

<!doctype html>
<html lang="en">
    

  <head>
    <meta charset="utf-8">
  
  
    <!-- Fallback for Font family below in noscript [*] -->
    <script type="text/javascript">
      WebFontConfig = {
        google: { families: [ 'Oswald:300,400,700',  'Open+Sans:400,700',  'Grand+Hotel' ] }
      };
      (function() {
        var wf = document.createElement('script');
        wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
        '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
        wf.type = 'text/javascript';
        wf.async = 'true';
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(wf, s);
      })(); </script>
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="Your Ethereum Swiss Army Knife">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="news_keywords" content="solidity, dapps, contracts, smart contracts" />
    <meta name="standout" content="http://truffleframework.com" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <meta property="og:site_name" content="Truffle Suite" />
    <meta property="og:description" content="Your Ethereum Swiss Army Knife" />
    <meta property="og:title" content="Documentation | Truffle Suite" />
    <meta property="og:url" content="http://truffleframework.com" />
    <meta property="og:type" content="article" />
    <meta property="og:image" content="https://github.com/trufflesuite/trufflesuite.github.io/raw/master/images/truffle-share.png" />

    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="Truffle Suite" />
    <meta name="twitter:title" content="Documentation | Truffle Suite" />
    <meta name="twitter:description" content="Your Ethereum Swiss Army Knife" />
    <meta name="twitter:creator" content="Truffle Suite" />
    <meta name="twitter:domain" content="truffleframework.com" />
    <meta name="twitter:image:src" content="https://github.com/trufflesuite/trufflesuite.github.io/raw/master/images/truffle-share.png" />

    
    

    <title>
    Documentation | 
    Truffle Suite
    
    </title>



    <link rel="author" href="/humans.txt" />

    <link rel="icon" href="/images/touch/favicon.ico">

    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Truffle Suite">
    <link rel="icon" sizes="192x192" href="/images/touch/chrome-touch-icon-192x192.png">

    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Web Starter Kit">
    <link rel="apple-touch-icon" href="/images/touch/apple-touch-icon.png">

    <!-- Tile icon for Win8 (144x144 + tile color) -->
    <meta name="msapplication-TileImage" content="images/touch/ms-touch-icon-144x144-precomposed.png">
    <meta name="msapplication-TileColor" content="#3372DF">

    <link rel="stylesheet" href="/styles/main.css">
    
      <noscript>
        <!-- [*] Web fonts for no-js -->
        <link href='http://fonts.googleapis.com/css?family=Oswald:300,400,700%7COpen+Sans:400,700%7CGrand+Hotel' rel='stylesheet' type='text/css'>
      </noscript>
    
  </head>

  <body class="
    body-docs
    
    
  ">
    <main>
      <section class="Documentation">
  <nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand hidden-xs" href="/">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 265.39 282.11"><defs><style>.cls-1{fill:#fff;}.cls-2{fill:#5e464d; mask:none;}.cls-3{mask:url(#mask);}.cls-4{mask:url(#mask-2);}.cls-5{fill:#3fe0c5;}</style><mask id="mask" x="0" y="23.1" width="265.39" height="259.02" maskUnits="userSpaceOnUse"><g id="mask-4"><polygon id="path-3" class="cls-1" points="0 23.1 265.39 23.1 265.39 282.11 0 282.11 0 23.1"/></g></mask><mask id="mask-2" x="-6.02" y="0" width="267.03" height="260.62" maskUnits="userSpaceOnUse"><g id="mask-2-2" data-name="mask-2"><polyline id="path-1" class="cls-1" points="-6.02 0 261.01 0 261.01 260.62 -6.02 260.62"/></g></mask></defs><title>truffle-logo</title><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><polygon id="Fill-12" class="cls-2" points="0 243.25 20.95 243.25 20.95 250.36 14.05 250.36 14.05 281.16 6.73 281.16 6.73 250.36 0 250.36 0 243.25"/><path id="Fill-14" class="cls-2" d="M46.31,258.06H50.6q3.44,0,4.74-.9a3.4,3.4,0,0,0,1.3-3A3.67,3.67,0,0,0,56,252a3.57,3.57,0,0,0-1.72-1.32,13.07,13.07,0,0,0-4-.4h-4Zm-7.22-14.82h9.68q6.28,0,8.95,1.12A9.18,9.18,0,0,1,62,248.09a11.4,11.4,0,0,1,1.62,6.16,10.49,10.49,0,0,1-1.79,6.25,10.84,10.84,0,0,1-5.4,3.8l9,16.86H57.53L49,265.1H46.31v16.06H39.09Z"/><g class="cls-3"><path id="Fill-16" class="cls-2" d="M83.77,243.24H91v24.52a12.7,12.7,0,0,0,.55,4.48,4.42,4.42,0,0,0,1.83,2.1,5.74,5.74,0,0,0,3.08.79,6,6,0,0,0,3.28-.88,4.59,4.59,0,0,0,1.91-2.22,16.54,16.54,0,0,0,.53-5.17V243.24h7.25v22.6a32.63,32.63,0,0,1-.65,7.94,11.23,11.23,0,0,1-2.46,4.28,11.39,11.39,0,0,1-4.19,3.05,14.21,14.21,0,0,1-5.52,1,13.37,13.37,0,0,1-7.18-1.9,11,11,0,0,1-4.37-4.74q-1.31-2.85-1.31-9.63Z"/></g><polygon id="Fill-19" class="cls-2" points="131.28 243.25 150.1 243.25 150.1 250.28 138.45 250.28 138.45 257.16 150.1 257.16 150.1 264.1 138.45 264.1 138.45 281.16 131.28 281.16 131.28 243.25"/><polygon id="Fill-21" class="cls-2" points="170.07 243.25 188.89 243.25 188.89 250.28 177.24 250.28 177.24 257.16 188.89 257.16 188.89 264.1 177.24 264.1 177.24 281.16 170.07 281.16 170.07 243.25"/><polygon id="Fill-23" class="cls-2" points="208.8 243.25 216.02 243.25 216.02 274.28 226.53 274.28 226.53 281.16 208.8 281.16 208.8 243.25"/><polygon id="Fill-25" class="cls-2" points="244.7 243.25 265.39 243.25 265.39 250.31 251.86 250.31 251.86 257.16 265.39 257.16 265.39 264.1 251.86 264.1 251.86 274.07 265.39 274.07 265.39 281.16 244.7 281.16 244.7 243.25"/><g id="Group-5"><g class="cls-4"><path id="Fill-3" class="cls-2" d="M234.59,102.14a102.15,102.15,0,0,1-185,59.71c-12.12-16.79-16.9-37.42-16.9-59.71,0-31,11.42-58.74,33.2-77.47a102.15,102.15,0,0,1,168.72,77.47"/></g></g><path id="Fill-6" class="cls-1" d="M104.07,192c4.17,1.3,18.16,5.45,18.63,1,.25-2.42-7.09-4.72-17.17-9.71a159,159,0,0,1-39-27.24A87.83,87.83,0,0,1,38.63,95.74C37,64.88,48.47,39.58,67.91,22.95A102.2,102.2,0,0,0,49.56,161.86a142.9,142.9,0,0,0,12.67,10.24c11.46,8.21,28.11,15.65,41.84,19.92"/><path id="Fill-8" class="cls-1" d="M236,78.73c-6.27-29.44-25.73-50.05-51.75-64.61,19.9,14.17,47.92,44.3,31.4,70.86-14,21.3-48,17.12-66.65,7-22.12-12-49.83-39-22.5-65.4,17.69-17.08,74,2.07,64.09,27.61-5.78,14.84-28.28,11.55-38.4,4.28-7.46-5.36-13.74-14.57-10.42-24.08,1.07-3,.91-7.78-3.39-4.3C135.15,32.72,133.54,37,133,41c-4.71,33.29,54.6,59.1,72.19,26.89,9.13-16.72-5.66-41-24.29-50.94-14-7.5-28.58-12.77-46.44-11.49-28.55,2-52.52,19.9-55.52,49.08-3,29,16.38,55.09,39.22,70.71,24,16.4,56.26,27.21,85.78,17.43,26.46-8.77,37.39-39.14,32.07-63.93"/><path id="Fill-10" class="cls-5" d="M198.74,56.18C201.58,37.1,184.33,24,168.41,18c-18.79-7-43.59-3.94-57.27,11.62-10,11.42-9.35,28-4.2,41.41,7.8,20.27,25.41,34.93,45.91,41.25,14.57,4.5,32.18,6.46,46.95,1.71,21.53-6.92,28.54-29.38,24.09-49.95a59.25,59.25,0,0,0-4.36-12.88c-2.72-5.71-11-17.26.43-3.19a50.44,50.44,0,0,1,3.31,4.91,54.87,54.87,0,0,1,5.59,12.41c6.26,19.2,1.35,41.6-16,53.19-13.31,8.88-30.23,9.93-45.68,7.71-20.7-3-40.21-13-53.76-29.09C101,82.48,92.55,61.41,97.65,42.16c3.72-14.09,15.17-24.61,28.86-29,17.33-5.61,36.41-3,52,6.11,7.81,4.56,15,10.86,18.94,19.11a28.27,28.27,0,0,1,2.85,11.93,24.44,24.44,0,0,1-.39,5c-.11.6-1.37,2.29-1.2.9"/></g></g></svg>

      </a>
      <a class="navbar-brand visible-xs" href="/">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 206.99 204.29"><defs><style>.cls-1{fill:#fff;}.cls-2{mask:url(#mask);}.cls-3{fill:#5e464d;}.cls-mint{fill:#3fe0c5;}</style><mask id="mask" x="-36.33" y="0" width="267.03" height="260.62" maskUnits="userSpaceOnUse"><g id="mask-2"><polyline id="path-1" class="cls-1" points="-36.33 0 230.71 0 230.71 260.62 -36.33 260.62"/></g></mask></defs><title>truffle-logomark</title><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><g id="Group-5"><g class="cls-2"><path id="Fill-3" class="cls-3" d="M204.29,102.14a102.15,102.15,0,0,1-185,59.71c-12.12-16.79-16.9-37.42-16.9-59.71,0-31,11.42-58.74,33.2-77.47a102.15,102.15,0,0,1,168.72,77.47"/></g></g><path id="Fill-6" class="cls-1" d="M73.77,192c4.17,1.3,18.16,5.45,18.63,1,.25-2.42-7.09-4.72-17.17-9.71a159,159,0,0,1-39-27.24A87.83,87.83,0,0,1,8.33,95.74C6.67,64.88,18.17,39.58,37.61,22.95A102.2,102.2,0,0,0,19.26,161.86a142.9,142.9,0,0,0,12.67,10.24C43.39,180.31,60,187.74,73.77,192"/><path id="Fill-8" class="cls-1" d="M205.68,78.73C199.42,49.29,180,28.68,153.93,14.12c19.9,14.17,47.92,44.3,31.4,70.86-14,21.3-48,17.12-66.65,7-22.12-12-49.83-39-22.5-65.4,17.69-17.08,74,2.07,64.09,27.61-5.78,14.84-28.28,11.55-38.4,4.28-7.46-5.36-13.74-14.57-10.42-24.08,1.07-3,.91-7.78-3.39-4.3-3.21,2.6-4.83,6.88-5.39,10.86-4.71,33.29,54.6,59.1,72.19,26.89,9.13-16.72-5.66-41-24.29-50.94-14-7.5-28.58-12.77-46.44-11.49-28.55,2-52.52,19.9-55.52,49.08-3,29,16.38,55.09,39.22,70.71,24,16.4,56.26,27.21,85.78,17.43,26.46-8.77,37.39-39.14,32.07-63.93"/><path id="Fill-10" class="cls-mint" d="M168.44,56.18C171.28,37.1,154,24,138.1,18c-18.79-7-43.59-3.94-57.27,11.62-10,11.42-9.35,28-4.2,41.41C84.44,91.35,102,106,122.55,112.33c14.57,4.5,32.18,6.46,46.95,1.71C191,107.11,198,84.66,193.58,64.09a59.25,59.25,0,0,0-4.36-12.88c-2.72-5.71-11-17.26.43-3.19A50.44,50.44,0,0,1,193,52.93a54.87,54.87,0,0,1,5.59,12.41c6.26,19.2,1.35,41.6-16,53.19-13.31,8.88-30.23,9.93-45.68,7.71-20.7-3-40.21-13-53.76-29.09-12.39-14.67-20.83-35.74-15.74-55,3.72-14.09,15.17-24.61,28.86-29,17.33-5.61,36.41-3,52,6.11,7.81,4.56,15,10.86,18.94,19.11A28.27,28.27,0,0,1,170,50.27a24.44,24.44,0,0,1-.39,5c-.11.6-1.37,2.29-1.2.9"/></g></g></svg>

      </a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav navbar-right">
        <li><a href="/docs">Docs</a></li>
        <li><a href="/tutorials">Tutorials</a></li>
        <li><a href="/boxes">Boxes</a></li>
        <li><a href="/blog">Blog</a></li>
        <li><a href="/support">Support</a></li>
        <li><a href="/ganache"><img class="ganache-navbar" src="/images/suite/ganache/ganache-logomark.svg" alt="Ganache" />&nbsp;&nbsp;Ganache</a></li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container-fluid -->
</nav>

  <section class="MainContent">
    <div class="container-fluid">
      <div class="row">
        <div class="col-xs-12 col-md-3 SubNav">
          <form class="DocSearchForm" action='/docs/search#results' method='get'>
            <label for="search-box" class="sr-only">Search</label>

            <div class="input-group">
              <input class="form-control" type="text" id="search-box" name="query" placeholder="Search the Docs">
              <span class="input-group-btn">
                <input class="btn btn-primary btn-sm" type="submit" value="search">
              </span>
            </div>
          </form>
          
          

          <ul class="list-unstyled">
                          <h2>Getting Started</h2>
                                    <li>
              <ul class="list-unstyled">
                                  
                <li class=""><a href="/docs/getting_started/installation">Installation</a></li>
                                
                <li class=""><a href="/docs/getting_started/project">Creating a project</a></li>
                                
                <li class=""><a href="/docs/getting_started/client">Choosing an Ethereum client</a></li>
                                
                <li class=""><a href="/docs/getting_started/compile">Compiling contracts</a></li>
                                
                <li class=""><a href="/docs/getting_started/migrations">Running migrations</a></li>
                                
                <li class=""><a href="/docs/getting_started/testing">Testing your contracts</a></li>
                                
                <li class=""><a href="/docs/getting_started/javascript-tests">Writing tests in JavaScript</a></li>
                                
                <li class=""><a href="/docs/getting_started/solidity-tests">Writing tests in Solidity</a></li>
                                
                <li class=""><a href="/docs/getting_started/contracts">Interacting with your contracts</a></li>
                                
                <li class=""><a href="/docs/getting_started/packages-ethpm">Package management via EthPM</a></li>
                                
                <li class=""><a href="/docs/getting_started/packages-npm">Package management via NPM</a></li>
                                
                <li class=""><a href="/docs/getting_started/debugging">Debugging your contracts</a></li>
                                
                <li class=""><a href="/docs/getting_started/console">Using Truffle Develop and the console</a></li>
                                
                <li class=""><a href="/docs/getting_started/scripts">Writing external scripts</a></li>
                                
                <li class=""><a href="/docs/getting_started/build">Using the build pipeline</a></li>
                                
                <li class=""><a href="/docs/getting_started/contact">Contact the developers</a></li>
                            </ul>
            </li>
                        <h2>Advanced</h2>
                                    <li>
              <ul class="list-unstyled">
                                  
                <li class=""><a href="/docs/advanced/configuration">Configuration</a></li>
                                
                <li class=""><a href="/docs/advanced/networks">Networks and app deployment</a></li>
                                
                <li class=""><a href="/docs/advanced/build_processes">Build processes</a></li>
                                
                <li class=""><a href="/docs/advanced/commands">Command reference</a></li>
                                
                <li class=""><a href="/docs/advanced/truffle-boxes">Truffle Boxes</a></li>
                                
                <li class=""><a href="/docs/advanced/truffle-with-metamask">Truffle with MetaMask</a></li>
                            </ul>
            </li>
                        <h2>Ganache</h2>
                                    <li>
              <ul class="list-unstyled">
                                  
                <li class=""><a href="/docs/ganache/using">Working with Ganache</a></li>
                            </ul>
            </li>
          
          </ul>
        </div>
        <div class="col-xs-12 col-md-9 col-md-offset-3 ContentPage">
          <a name="results">Search Results</a>
<p>Here are the following matches for: <span class="queryTerm"></span></p>
<ul id="search-results"></ul>



<script>
window.store = {"installation":{"id":"installation","title":"Installation","path":"getting_started/installation","content":"&nbsp;Installation npm install -g truffle\n&nbsp;Requirements\nNodeJS 5.0+ recommended.\nWindows, Linux or Mac OS X\n\nTruffle also requires that you have a running Ethereum client which supports the standard JSON RPC API (which is nearly all of them). There are many to choose from, and some better than others for development. We&#39;ll discuss them in detail in the Choosing an Ethereum client section.\n&nbsp;Recommendations for WindowsIf you&#39;re running Truffle on Windows, you may encounter some naming conflicts that could prevent Truffle from executing properly. Please see the section on resolving naming conflicts for solutions.\n"},"project":{"id":"project","title":"Creating a project","path":"getting_started/project","content":"&nbsp;Creating a project To use most Truffle commands, you need to run them against an existing Truffle project. This section will show you how to create a new project.\nFor those just getting started, we have many boilerplates and example applications available to you through Truffle Boxes. \nYou can start with our MetaCoin example by running the following on the command line:\nmkdir MetaCoin\ncd MetaCoin\ntruffle unbox metacoin\n\nSee the project structure as shown at the bottom of this page.\n\nNote: The MetaCoin Truffle project used to be created by running truffle init. Now it exists as a Truffle Box.\n\n\nYou can use the truffle unbox &lt;box-name&gt; command to download any of the other applications.\nIf you&#39;d prefer to start from scratch, create a project directory and move into it. You can do this through your favorite file explorer or by running the following on the command line:\nmkdir myproject\ncd myproject\n\nNext, initialize your Truffle project by running the following command:\ntruffle init\n\nOnce completed, you&#39;ll now have a project structure with the following items:\n\ncontracts/: Directory for Solidity contracts\nmigrations/: Directory for scriptable deployment files\ntest/: Directory for test files for testing your application and contracts\ntruffle.js: Truffle configuration file\n\n"},"client":{"id":"client","title":"Choosing an Ethereum client","path":"getting_started/client","content":"&nbsp;Choosing an Ethereum client There are many Ethereum clients to choose from. We recommend different clients depending on whether you are developing or deploying.\n&nbsp;When developing&nbsp;GanacheWe recommend Ganache, a personal blockchain for Ethereum development that runs on your desktop. Part of the Truffle Suite, Ganache simplifies dapp development by placing your contracts and transactions front and center. Using Ganache you can quickly see how your application affects the blockchain, and introspect details like your accounts, balances, contract creations and gas costs. You can also fine tune Ganache&#39;s advanced mining controls to better suit your needs. Ganache is available for Windows, Mac and Linux, and you can download it here.\nGanache, when launched, runs on http://127.0.0.1:7545. It will display the first 10 accounts and the mnemonic used to create those accounts. (Read more about account mnemonics.)\nBy default, Ganache will use the following mnemonic:\ncandy maple cake sugar pudding cream honey rich smooth crumble sweet treat\nThis mnemonic can be changed to be randomly generated, or you can input your own.\n\nWarning: Do not use this mnemonic on the main Ethereum network (mainnet). If you send ETH to any account generated from this mnemonic, you will lose it all!\n\n\n&nbsp;Truffle DevelopWe also recommend using Truffle Develop, a development blockchain built directly into Truffle. Truffle Develop helps you set up an integrated blockchain environment with a single command, no installation required. Run Truffle Develop by typing the following into a terminal:\ntruffle develop\n\nThis will run the client on http://127.0.0.1:9545. It will display the first 10 accounts and the mnemonic used to create those accounts. (Read more about account mnemonics.) Truffle Develop uses the same mnemonic every time to make developing your applications as easy as possible:\ncandy maple cake sugar pudding cream honey rich smooth crumble sweet treat\n\nWarning: Do not use this mnemonic on the main Ethereum network (mainnet). If you send ETH to any account generated from this mnemonic, you will lose it all!\n\n\nOnce launched, Truffle Develop will provide you with a console you can use to run all available Truffle commands. These commands are input by omitting the truffle prefix. So, for example, to compile your smart contracts, instead of typing truffle compile, you need to only type compile.\nTo read more about interacting with the console, please see the Using the Console section.\n&nbsp;Ganache CLIGanache also has a command-line interface for those who aren&#39;t working from a graphical environment. Great for automated testing and continuous integration environments, Ganache CLI runs headless and can be configured to serve all your development needs. Ganache CLI processes transactions instantly instead of waiting for the default block time, so you can test that your code works quickly. It also tells you immediately when your smart contracts run into errors, and integrates directly with Truffle to reduce test runtime up to 90% compared to other clients. Learn more about Ganache CLI.\n&nbsp;Deploying to live networksThere are many official and unofficial Ethereum clients available for you to use. The following is a short list:\n\nGeth (go-ethereum): https://github.com/ethereum/go-ethereum\nWebThree (cpp-ethereum): https://github.com/ethereum/cpp-ethereum\nParity: https://github.com/paritytech/parity\nMore: https://www.ethereum.org/cli\n\nThese are full client implementations that include mining, networking, blocks and transaction processing. You should use these clients after you&#39;ve sufficiently tested your dapp with Ganache or Truffle Develop and you&#39;re ready to deploy to your desired Ethereum network.\n&nbsp;Deploying to private networksPrivate networks utilize the same technology as with live networks, but with a different configuration. So you can configure any of the Ethereum clients mentioned above to run a private network, and deploy to it in exactly the same way.\n"},"compile":{"id":"compile","title":"Compiling contracts","path":"getting_started/compile","content":"&nbsp;Compiling contracts &nbsp;LocationAll of your contracts are located in your project&#39;s contracts/ directory. As contracts are written in Solidity, all files containing contracts will have a file extension of .sol. Associated Solidity libraries will also have a .sol extension.\nWith a bare Truffle project (created through truffle init), you&#39;re given a single Migrations.sol file that helps in the deployment process. If you&#39;re using a Truffle Box, you will have multiple files here.\n&nbsp;CommandTo compile a Truffle project, change to the root of the directory where the project is located and then type the following into a terminal:\ntruffle compile\n\nUpon first run, all contracts will be compiled. Upon subsequent runs, Truffle will compile only the contracts that have been changed since the last compile. If you&#39;d like to override this behavior, run the above command with the --all option.\n&nbsp;Build artifactsArtifacts of your compilation will be placed in the build/contracts/ directory, relative to your project root. (This directory will be created if it does not exist.)\nThese artifacts are integral to the inner workings of Truffle, and they play an important part in the successful deployment of your application. You should not edit these files as they&#39;ll be overwritten by contract compilation and deployment.\n&nbsp;DependenciesYou can declare contract dependencies using Solidity&#39;s import command. Truffle will compile contracts in the correct order and ensure all dependencies are sent to the compiler. Dependencies can be specified in two ways:\n&nbsp;Importing dependencies via file nameTo import contracts from a separate file, add the following code to your Solidity source file::\nimport &quot;./AnotherContract.sol&quot;;\nThis will make all contracts within AnotherContract.sol available. Here, AnotherContract.sol is relative to the path of the current contract being written.\nNote that Solidity allows other import syntaxes as well. See the Solidity import documentation for more information.\n&nbsp;Importing contracts from an external packageTruffle supports dependencies installed via both EthPM and NPM. To import contracts from a dependency, use the following syntax\nimport &quot;somepackage/SomeContract.sol&quot;;\nHere, somepackage represents a package installed via EthPM or NPM, and SomeContract.sol represents a Solidity source file provided by that package.\nNote that Truffle will search installed packages from EthPM first before searching for packages installed from NPM, so in the rare case of a naming conflict the package installed via EthPM will be used.\nFor more information on how to use Truffle&#39;s package management features, please see the Truffle EthPM and NPM documentation.\n"},"migrations":{"id":"migrations","title":"Running migrations","path":"getting_started/migrations","content":"&nbsp;Running migrations Migrations are JavaScript files that help you deploy contracts to the Ethereum network. These files are responsible for staging your deployment tasks, and they&#39;re written under the assumption that your deployment needs will change over time. As your project evolves, you&#39;ll create new migration scripts to further this evolution on the blockchain. A history of previously run migrations is recorded on-chain through a special Migrations contract, detailed below.\n&nbsp;CommandTo run your migrations, run the following:\n$ truffle migrate\n\nThis will run all migrations located within your project&#39;s migrations directory. At their simplest, migrations are simply a set of managed deployment scripts. If your migrations were previously run successfully, truffle migrate will start execution from the last migration that was ran, running only newly created migrations. If no new migrations exists, truffle migrate won&#39;t perform any action at all. You can use the --reset option to run all your migrations from the beginning. For local testing make sure to have a test blockchain such as Ganache installed and running before executing migrate.\n&nbsp;Migration filesA simple migration file looks like this:\nFilename: 4_example_migration.js\nvar MyContract = artifacts.require(&quot;MyContract&quot;);\n\nmodule.exports = function(deployer) {\n  // deployment steps\n  deployer.deploy(MyContract);\n};\n\nNote that the filename is prefixed with a number and is suffixed by a description. The numbered prefix is required in order to record whether the migration ran successfully. The suffix is purely for human readability and comprehension.\n&nbsp;artifacts.require()At the beginning of the migration, we tell Truffle which contracts we&#39;d like to interact with via the artifacts.require() method. This method is similar to Node&#39;s require, but in our case it specifically returns a contract abstraction that we can use within the rest of our deployment script. The name specified should match the name of the contract definition within that source file. Do not pass the name of the source file, as files can contain more than one contract.\nConsider this example where two contracts are specified within the same source file:\nFilename: ./contracts/Contracts.sol\n\ncontract ContractOne {\n  // ...\n}\n\ncontract ContractTwo {\n  // ...\n}\n\nTo use only ContractTwo, your artifacts.require() statement would look like this:\nvar ContractTwo = artifacts.require(&quot;ContractTwo&quot;);\nTo use both contracts, you will need two artifacts.require() statements:\nvar ContractOne = artifacts.require(&quot;ContractOne&quot;);\nvar ContractTwo = artifacts.require(&quot;ContractTwo&quot;);\n&nbsp;module.exportsAll migrations must export a function via the module.exports syntax. The function exported by each migration should accept a deployer object as its first parameter. This object aides in deployment by both providing a clear syntax for deploying smart contracts as well as performing some of deployment&#39;s more mundane duties, such as saving deployed artifacts for later use. The deployer object is your main interface for staging deployment tasks, and its API is described at the bottom of this page.\nYour migration function can accept other parameters as well. See the examples below.\n&nbsp;Initial migrationTruffle requires you to have a Migrations contract in order to use the Migrations feature. This contract must contain a specific interface, but you&#39;re free to edit this contract at will. For most projects, this contract will be deployed initially as the first migration and won&#39;t be updated again. You will also receive this contract by default when creating a new project with truffle init.\nFilename: contracts/Migrations.sol\npragma solidity ^0.4.8;\n\ncontract Migrations {\n  address public owner;\n\n  // A function with the signature `last_completed_migration()`, returning a uint, is required.\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function Migrations() {\n    owner = msg.sender;\n  }\n\n  // A function with the signature `setCompleted(uint)` is required.\n  function setCompleted(uint completed) restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\nYou must deploy this contract inside your first migration in order to take advantage of the Migrations feature. To do so, create the following migration:\nFilename: migrations/1_initial_migration.js\nvar Migrations = artifacts.require(&quot;Migrations&quot;);\n\nmodule.exports = function(deployer) {\n  // Deploy the Migrations contract as our only task\n  deployer.deploy(Migrations);\n};\n\nFrom here, you can create new migrations with increasing numbered prefixes to deploy other contracts and perform further deployment steps.\n&nbsp;DeployerYour migration files will use the deployer to stage deployment tasks. As such, you can write deployment tasks synchronously and they&#39;ll be executed in the correct order:\n// Stage deploying A before B\ndeployer.deploy(A);\ndeployer.deploy(B);\n\nAlternatively, each function on the deployer can be used as a Promise, to queue up deployment tasks that depend on the execution of the previous task:\n// Deploy A, then deploy B, passing in A&#39;s newly deployed address\ndeployer.deploy(A).then(function() {\n  return deployer.deploy(B, A.address);\n});\n\nIt is possible to write your deployment as a single promise chain if you find that syntax to be more clear. The deployer API is discussed at the bottom of this page.\n&nbsp;Network considerationsIt is possible to run deployment steps conditionally based on the network being deployed to. This is an advanced feature, so see the Networks section first before continuing.\nTo conditionally stage deployment steps, write your migrations so that they accept a second parameter, called network. Example:\nmodule.exports = function(deployer, network) {\n  if (network == &quot;live&quot;) {\n    // Do something specific to the network named &quot;live&quot;.\n  } else {\n    // Perform a different step otherwise.\n  }\n}\n\n&nbsp;Available accountsMigrations are also passed the list of accounts provided to you by your Ethereum client and web3 provider, for you to use during your deployments. This is the exact same list of accounts returned from web3.eth.getAccounts().\nmodule.exports = function(deployer, network, accounts) {\n  // Use the accounts within your migrations.\n}\n\n&nbsp;Deployer APIThe deployer contains many functions available to simplify your migrations.\n&nbsp;deployer.deploy(contract, args..., options)Deploy a specific contract, specified by the contract object, with optional constructor arguments. This is useful for singleton contracts, such that only one instance of this contract exists for your dapp. This will set the address of the contract after deployment (i.e., Contract.address will equal the newly deployed address), and it will override any previous address stored.\nYou can optionally pass an array of contracts, or an array of arrays, to speed up deployment of multiple contracts. Additionally, the last argument is an optional object that can include the key named overwrite as well as other transaction parameters such as gas and from. If overwrite is set to false, the deployer won&#39;t deploy this contract if one has already been deployed. This is useful for certain circumstances where a contract address is provided by an external dependency.\nNote that you will need to deploy and link any libraries your contracts depend on first before calling deploy. See the link function below for more details.\nFor more information, please see the truffle-contract documentation.\nExamples:\n// Deploy a single contract without constructor arguments\ndeployer.deploy(A);\n\n// Deploy a single contract with constructor arguments\ndeployer.deploy(A, arg1, arg2, ...);\n\n// Don&#39;t deploy this contract if it has already been deployed\ndeployer.deploy(A, {overwrite: false});\n\n// Set a gas price and from address for the deployment\ndeployer.deploy(A, {gas: 4612388, from: &quot;0x....&quot;});\n\n// Deploy multiple contracts, some with arguments and some without.\n// This is quicker than writing three `deployer.deploy()` statements as the deployer\n// can perform the deployment as a single batched request.\ndeployer.deploy([\n  [A, arg1, arg2, ...],\n  B,\n  [C, arg1]\n]);\n\n// External dependency example:\n//\n// For this example, our dependency provides an address when we&#39;re deploying to the\n// live network, but not for any other networks like testing and development.\n// When we&#39;re deploying to the live network we want it to use that address, but in\n// testing and development we need to deploy a version of our own. Instead of writing\n// a bunch of conditionals, we can simply use the `overwrite` key.\ndeployer.deploy(SomeDependency, {overwrite: false});\n\n&nbsp;deployer.link(library, destinations)Link an already-deployed library to a contract or multiple contracts. destinations can be a single contract or an array of multiple contracts. If any contract within the destination doesn&#39;t rely on the library being linked, the deployer will ignore that contract.\nExample:\n// Deploy library LibA, then link LibA to contract B, then deploy B.\ndeployer.deploy(LibA);\ndeployer.link(LibA, B);\ndeployer.deploy(B);\n\n// Link LibA to many contracts\ndeployer.link(LibA, [B, C, D]);\n\n&nbsp;deployer.then(function() {...})Just like a promise, run an arbitrary deployment step. Use this to call specific contract functions during your migration to add, edit and reorganize contract data.\nExample:\nvar a, b;\ndeployer.then(function() {\n  // Create a new version of A\n  return A.new();\n}).then(function(instance) {\n  a = instance;\n  // Get the deployed instance of B\n  return B.deployed():\n}).then(function(instance) {\n  b = instance;\n  // Set the new instance of A&#39;s address on B via B&#39;s setA() function.\n  return b.setA(a.address);\n});\n\n"},"testing":{"id":"testing","title":"Testing your contracts","path":"getting_started/testing","content":"&nbsp;Testing your contracts &nbsp;FrameworkTruffle comes standard with an automated testing framework to make testing your contracts a breeze. This framework lets you write simple and manageable tests in two different ways:\n\nIn Javascript, for exercising your contracts from the outside world, just like your application.\nIn Solidity, for exercising your contracts in advanced, bare-to-the-metal scenarios.\n\nBoth styles of tests have their advantages and drawbacks. See the next two sections for a discussion of each one.\n&nbsp;LocationAll test files should be located in the ./test directory. Truffle will only run test files with the following file extensions: .js, .es, .es6, and .jsx, and .sol. All other files are ignored.\n&nbsp;CommandTo run all tests, simply run:\n$ truffle test\nAlternatively, you can specify a path to a specific file you want to run, e.g.,\n$ truffle test ./path/to/test/file.js\n\n&nbsp;Clean-room environmentTruffle provides a clean room environment when running your test files. When running your tests against Ganache or Truffle Develop, Truffle will use advanced snapshotting features to ensure your test files don&#39;t share state with each other. When running against other Ethereum clients like go-ethereum, Truffle will re-deploy all of your migrations at the beginning of every test file to ensure you have a fresh set of contracts to test against.\n&nbsp;Speed and reliability considerationsBoth Ganache and Truffle Develop are significantly faster than other clients when running automated tests. Moreover, they contain special features which Truffle takes advantage of to speed up test runtime by almost 90%. As a general workflow, we recommend you use Ganache or Truffle Develop during normal development and testing, and then run your tests once against go-ethereum or another official Ethereum client when you&#39;re gearing up to deploy to live or production networks.\n"},"javascript-tests":{"id":"javascript-tests","title":"Writing tests in JavaScript","path":"getting_started/javascript-tests","content":"&nbsp;Writing Tests in Javascript Truffle uses the Mocha testing framework and Chai for assertions to provide you with a solid framework from which to write your Javascript tests. Let&#39;s dive in and see how Truffle builds on top of Mocha to make testing your contracts a breeze.\nNote: If you&#39;re unfamiliar with writing unit tests in Mocha, please see Mocha&#39;s documentation before continuing.\n&nbsp;Use contract() instead of describe()Structurally, your tests should remain largely unchanged from that of Mocha: Your tests should exist in the ./test directory, they should end with a .js extension, and they should contain code that Mocha will recognize as an automated test. What makes Truffle tests different from that of Mocha is the contract() function: This function works exactly like describe() except it enables Truffle&#39;s clean-room features. It works like this:\n\nBefore each contract() function is run, your contracts are redeployed to the running Ethereum client so the tests within it run with a clean contract state.\nThe contract() function provides a list of accounts made available by your Ethereum client which you can use to write tests.\n\nSince Truffle uses Mocha under the hood, you can still use describe() to run normal Mocha tests whenever Truffle clean-room features are unnecessary.\n&nbsp;Use contract abstractions within your testsContract abstractions are the basis for making contract interaction possible from Javascript (they&#39;re basically our flux capacitor). Because Truffle has no way of detecting which contracts you&#39;ll need to interact with within your tests, you&#39;ll need to ask for those contracts explicitly. You do this by using the artifacts.require() method, a method provided by Truffle that allows you to request a usable contract abstraction for a specific Solidity contract. As you&#39;ll see in the example below, you can then use this abstraction to make sure your contracts are working properly.\nFor more information on using contract abstractions, see the Interacting With Your Contracts section.\n&nbsp;Using artifacts.require()Using artifacts.require() within your tests works the same way as using it within your migrations; you just need to pass the name of the contract. See the artifacts.require() documentation in the Migrations section for detailed usage.\n&nbsp;Using web3A web3 instance is available in each test file, configured to the correct provider. So calling web3.eth.getBalance just works!\n&nbsp;ExampleHere&#39;s an example test provided to you by truffle init. Note the use of the contract() function, the accounts array for specifying available Ethereum accounts, and our use of artifacts.require() for interacting directly with our contracts.\nFile: ./test/metacoin.js\n// Specifically request an abstraction for MetaCoin\nvar MetaCoin = artifacts.require(&quot;MetaCoin&quot;);\n\ncontract(&#39;MetaCoin&#39;, function(accounts) {\n  it(&quot;should put 10000 MetaCoin in the first account&quot;, function() {\n    return MetaCoin.deployed().then(function(instance) {\n      return instance.getBalance.call(accounts[0]);\n    }).then(function(balance) {\n      assert.equal(balance.valueOf(), 10000, &quot;10000 wasn&#39;t in the first account&quot;);\n    });\n  });\n  it(&quot;should send coin correctly&quot;, function() {\n    var meta;\n\n    // Get initial balances of first and second account.\n    var account_one = accounts[0];\n    var account_two = accounts[1];\n\n    var account_one_starting_balance;\n    var account_two_starting_balance;\n    var account_one_ending_balance;\n    var account_two_ending_balance;\n\n    var amount = 10;\n\n    return MetaCoin.deployed().then(function(instance) {\n      meta = instance;\n      return meta.getBalance.call(account_one);\n    }).then(function(balance) {\n      account_one_starting_balance = balance.toNumber();\n      return meta.getBalance.call(account_two);\n    }).then(function(balance) {\n      account_two_starting_balance = balance.toNumber();\n      return meta.sendCoin(account_two, amount, {from: account_one});\n    }).then(function() {\n      return meta.getBalance.call(account_one);\n    }).then(function(balance) {\n      account_one_ending_balance = balance.toNumber();\n      return meta.getBalance.call(account_two);\n    }).then(function(balance) {\n      account_two_ending_balance = balance.toNumber();\n\n      assert.equal(account_one_ending_balance, account_one_starting_balance - amount, &quot;Amount wasn&#39;t correctly taken from the sender&quot;);\n      assert.equal(account_two_ending_balance, account_two_starting_balance + amount, &quot;Amount wasn&#39;t correctly sent to the receiver&quot;);\n    });\n  });\n});\n\nThis test will produce the following output:\nUsing network &#39;development&#39;.\n\n  Contract: MetaCoin\n    ✓ should put 10000 MetaCoin in the first account\n    ✓ should send coin correctly\n\n  2 passing (113ms)\nYou can limit the tests being executed to a specific file as follows:\ntruffle test ./test/metacoin.js\n&nbsp;AdvancedTruffle gives you access to Mocha&#39;s configuration so you can change how Mocha behaves. See the project configuration section for more details.\n"},"solidity-tests":{"id":"solidity-tests","title":"Writing tests in Solidity","path":"getting_started/solidity-tests","content":"&nbsp;Writing tests in Solidity Solidity test contracts live alongside Javascript tests as .sol files. When truffle test is run, they will be included as a separate test suite per test contract. These contracts maintain all the benefits of the Javascript tests: namely a clean-room environment per test suite, direct access to your deployed contracts and the ability to import any contract dependency. In addition to these features, Truffle&#39;s Solidity testing framework was built with the following issues in mind:\n\nSolidity tests shouldn&#39;t extend from any contract (like a Test contract). This makes your tests as minimal as possible and gives you complete control over the contracts you write.\nSolidity tests shouldn&#39;t be beholden to any assertion library. Truffle provides a default assertion library for you, but you can change this library at any time to fit your needs.\nYou should be able to run your Solidity tests against any Ethereum client.\n\n&nbsp;ExampleLet&#39;s take a look at an example Solidity test before diving too deeply. Here&#39;s the example Solidity test provided for you by truffle init:\nimport &quot;truffle/Assert.sol&quot;;\nimport &quot;truffle/DeployedAddresses.sol&quot;;\nimport &quot;../contracts/MetaCoin.sol&quot;;\n\ncontract TestMetacoin {\n  function testInitialBalanceUsingDeployedContract() {\n    MetaCoin meta = MetaCoin(DeployedAddresses.MetaCoin());\n\n    uint expected = 10000;\n\n    Assert.equal(meta.getBalance(tx.origin), expected, &quot;Owner should have 10000 MetaCoin initially&quot;);\n  }\n\n  function testInitialBalanceWithNewMetaCoin() {\n    MetaCoin meta = new MetaCoin();\n\n    uint expected = 10000;\n\n    Assert.equal(meta.getBalance(tx.origin), expected, &quot;Owner should have 10000 MetaCoin initially&quot;);\n  }\n}\n\nThis produces the following output:\n$ truffle test\nCompiling ConvertLib.sol...\nCompiling MetaCoin.sol...\nCompiling truffle/Assert.sol\nCompiling truffle/DeployedAddresses.sol\nCompiling ../test/TestMetacoin.sol...\n\n  TestMetacoin\n    ✓ testInitialBalanceUsingDeployedContract (61ms)\n    ✓ testInitialBalanceWithNewMetaCoin (69ms)\n\n  2 passing (3s)\n&nbsp;Test structureTo better understand whats happening, let&#39;s discuss things in more detail.\n&nbsp;AssertionsYour assertion functions like Assert.equal() are provided to you by the truffle/Assert.sol library. This is the default assertion library, however you can include your own assertion library so long as the library loosely integrates with Truffle&#39;s test runner by triggering the correct assertion events. You can find all available assertion functions in Assert.sol.\n&nbsp;Deployed addressesThe addresses of your deployed contracts (i.e., contracts that were deployed as part of your migrations) are available through the truffle/DeployedAddresses.sol library. This is provided by Truffle and is recompiled and relinked before each suite is run to provide your tests with Truffle&#39;s a clean room environment. This library provides functions for all of your deployed contracts, in the form of:\nDeployedAddresses.&lt;contract name&gt;();\n\nThis will return an address that you can then use to access that contract. See the example test above for usage.\nIn order to use the deployed contract, you&#39;ll have to import the contract code into your test suite. Notice import &quot;../contracts/MetaCoin.sol&quot;; in the example. This import is relative to the test contract, which exists in the ./test directory, and it goes outside of the test directory in order to find the MetaCoin contract. It then uses that contract to cast the address to the MetaCoin type.\n&nbsp;Test contract namesAll test contracts must start with Test, using an uppercase T. This distinguishes this contract apart from test helpers and project contracts (i.e., the contracts under test), letting the test runner know which contracts represent test suites.\n&nbsp;Test function namesLike test contract names, all test functions must start with test, lowercase. Each test function is executed as a single transaction, in order of appearance in the test file (like your Javascript tests). Assertion functions provided by truffle/Assert.sol trigger events that the test runner evaluates to determine the result of the test. Assertion functions return a boolean representing the outcome of the assertion which you can use to return from the test early to prevent execution errors (as in, errors that Ganache or Truffle Develop will expose).\n&nbsp;before / after hooksYou are provided many test hooks, shown in the example below. These hooks are beforeAll, beforeEach, afterAll and afterEach, which are the same hooks provided by Mocha in your Javascript tests. You can use these hooks to perform setup and teardown actions before and after each test, or before and after each suite is run. Like test functions, each hook is executed as a single transaction. Note that some complex tests will need to perform a significant amount of setup that might overflow the gas limit of a single transaction; you can get around this limitation by creating many hooks with different suffixes, like in the example below:\nimport &quot;truffle/Assert.sol&quot;;\n\ncontract TestHooks {\n  uint someValue;\n\n  function beforeEach() {\n    someValue = 5;\n  }\n\n  function beforeEachAgain() {\n    someValue += 1;\n  }\n\n  function testSomeValueIsSix() {\n    uint expected = 6;\n\n    Assert.equal(someValue, expected, &quot;someValue should have been 6&quot;);\n  }\n}\n\nThis test contract also shows that your test functions and hook functions all share the same contract state. You can setup contract data before the test, use that data during the test, and reset it afterward in preparation for the next one. Note that just like your Javascript tests, your next test function will continue from the state of the previous test function that ran.\n&nbsp;Advanced featuresSolidity tests come with a few advanced features to let you test specific use cases within Solidity.\n&nbsp;Testing for exceptionsYou can easily test if your contract should or shouldn&#39;t raise an exception (i.e., for require()/assert()/revert() statements; throw on previous versions of Solidity).\nThis topic was first written about by guest writer Simon de la Rouviere in his tutorial Testing for Throws in Truffle Solidity Tests.  N.B. that the tutorial makes heavy use of exceptions via the deprecated keyword throw, replaced by revert(), require(), and assert() starting in Solidity v0.4.13.\n&nbsp;Testing ether transactionsYou can also test how your contracts react to receiving Ether, and script that interaction within Solidity. To do so, your Solidity test should have a public function that returns a uint, called initialBalance. This can be written directly as a function or a public variable, as shown below. When your test contract is deployed to the network, Truffle will send that amount of Ether from your test account to your test contract. Your test contract can then use that Ether to script Ether interactions within your contract under test. Note that initialBalance is optional and not required.\nimport &quot;truffle/Assert.sol&quot;;\nimport &quot;truffle/DeployedAddresses.sol&quot;;\nimport &quot;../contracts/MyContract.sol&quot;;\n\ncontract TestContract {\n  // Truffle will send the TestContract one Ether after deploying the contract.\n  uint public initialBalance = 1 ether;\n\n  function testInitialBalanceUsingDeployedContract() {\n    MyContract myContract = MyContract(DeployedAddresses.MyContract());\n\n    // perform an action which sends value to myContract, then assert.\n    myContract.send(...);\n  }\n\n  function () {\n    // This will NOT be executed when Ether is sent. \\o/\n  }\n}\n\nNote that Truffle sends Ether to your test contract in a way that does not execute a fallback function, so you can still use the fallback function within your Solidity tests for advanced test cases.\n"},"contracts":{"id":"contracts","title":"Interacting with your contracts","path":"getting_started/contracts","content":"&nbsp;Interacting with your contracts &nbsp;IntroductionIf you were writing raw requests to the Ethereum network yourself in order to interact with your contracts, you&#39;d soon realize that writing these requests is clunky and cumbersome. As well, you might find that managing the state each request you&#39;ve made is complicated. Fortunately, Truffle takes care of this complexity for you, to make interacting with your contracts a breeze.\n&nbsp;Reading and writing dataThe Ethereum network makes a distinction between writing data to the network and reading data from it, and this distinction plays a significant part in how you write your application. In general, writing data is called a transaction whereas reading data is called a call. Transactions and calls are treated very differently, and have the following characteristics.\n&nbsp;TransactionsTransactions fundamentally change the state of the network. A transaction can be as simple as sending Ether to another account, or as complicated as executing a contract function or adding a new contract to the network. The defining characteristic of a transaction is that it writes (or changes) data. Transactions cost Ether to run, known as &quot;gas&quot;, and transactions take time to process. When you execute a contract&#39;s function via a transaction, you cannot receive that function&#39;s return value because the transaction isn&#39;t processed immediately. In general, functions meant to be executed via a transaction will not return a value; they will return a transaction id instead. So in summary, transactions:\n\nCost gas (Ether)\nChange the state of the network\nAren&#39;t processed immediately\nWon&#39;t expose a return value (only a transaction id).\n\n&nbsp;CallsCalls, on the other hand, are very different. Calls can be used to execute code on the network, though no data will be permanently changed. Calls are free to run, and their defining characteristic is that they read data. When you execute a contract function via a call you will receive the return value immediately. In summary, calls:\n\nAre free (do not cost gas)\nDo not change the state of the network\nAre processed immediately\nWill expose a return value (hooray!)\n\nChoosing between a transaction and a call is as simple as deciding whether you want to read data, or write it.\n&nbsp;Introducing abstractionsContract abstractions are the bread and butter of interacting with Ethereum contracts from Javascript. In short, contract abstractions are wrapper code that makes interaction with your contracts easy, in a way that lets you forget about the many engines and gears executing under the hood. Truffle uses its own contract abstraction via the truffle-contract module, and it is this contract abstraction that&#39;s described below.\nIn order to appreciate the usefulness of a contract abstraction, however, we first need a contract to talk about. We&#39;ll use the MetaCoin contract provided for you by default via truffle init.\npragma solidity ^0.4.2;\n\nimport &quot;./ConvertLib.sol&quot;;\n\n// This is just a simple example of a coin-like contract.\n// It is not standards compatible and cannot be expected to talk to other\n// coin/token contracts. If you want to create a standards-compliant\n// token, see: https://github.com/ConsenSys/Tokens. Cheers!\n\ncontract MetaCoin {\n    mapping (address =&gt; uint) balances;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    function MetaCoin() {\n        balances[tx.origin] = 10000;\n    }\n\n    function sendCoin(address receiver, uint amount) returns(bool sufficient) {\n        if (balances[msg.sender] &lt; amount) return false;\n        balances[msg.sender] -= amount;\n        balances[receiver] += amount;\n        Transfer(msg.sender, receiver, amount);\n        return true;\n    }\n\n    function getBalanceInEth(address addr) returns(uint){\n        return ConvertLib.convert(getBalance(addr),2);\n    }\n\n    function getBalance(address addr) returns(uint) {\n        return balances[addr];\n    }\n}\n\nThis contract has three methods aside from the constructor (sendCoin, getBalanceInEth, and getBalance). All three methods can be executed as either a transaction or a call.\nNow let&#39;s look at the Javascript object called MetaCoin provided for us by Truffle, as made available in the Truffle console:\n// Print the deployed version of MetaCoin.\n// Note that getting the deployed version requires a promise, hence the .then.\nMetaCoin.deployed().then(function(instance) {\n  console.log(instance);\n});\n\n// outputs:\n//\n// Contract\n// - address: &quot;0xa9f441a487754e6b27ba044a5a8eb2eec77f6b92&quot;\n// - allEvents: ()\n// - getBalance: ()\n// - getBalanceInEth: ()\n// - sendCoin: ()\n// ...\n\nNotice that the abstraction contains the exact same functions that exist within our contract. It also contains an address which points to the deployed version of the MetaCoin contract.\n&nbsp;Executing contract functionsUsing the abstraction you can easily execute contract functions on the Ethereum network.\n&nbsp;Making a transactionThere are three functions on the MetaCoin contract that we can execute. If you analyze each of them, you&#39;ll see that sendCoin is the only function that aims to make changes to the network. The goal of sendCoin is to &quot;send&quot; some Meta coins from one account to the next, and these changes should persist.\nWhen calling sendCoin, we&#39;ll execute it as a transaction. In the following example, we&#39;ll send 10 Meta coin from one account to another, in a way that persists changes on the network:\nvar account_one = &quot;0x1234...&quot;; // an address\nvar account_two = &quot;0xabcd...&quot;; // another address\n\nvar meta;\nMetaCoin.deployed().then(function(instance) {\n  meta = instance;\n  return meta.sendCoin(account_two, 10, {from: account_one});\n}).then(function(result) {\n  // If this callback is called, the transaction was successfully processed.\n  alert(&quot;Transaction successful!&quot;)\n}).catch(function(e) {\n  // There was an error! Handle it.\n})\n\nThere are a few things interesting about the above code:\n\nWe called the abstraction&#39;s sendCoin function directly. This will result in a transaction by default (i.e, writing data) instead of call.\nWhen the transaction is successful, the callback function isn&#39;t fired until the transaction is processed. This makes life easy and means you don&#39;t have to check the status of the transaction yourself.\nWe passed an object as the third parameter to sendCoin. Note that the sendCoin function in our Solidity contract doesn&#39;t have a third parameter. What you see above is a special object that can always be passed as the last parameter to a function that lets you edit specific details about the transaction. Here, we set the from address ensuring this transaction came from account_one.\n\n&nbsp;Making a callContinuing with MetaCoin, notice the getBalance function is a great candidate for reading data from the network. It doesn&#39;t need to make any changes, as it just returns the MetaCoin balance of the address passed to it. Let&#39;s give it a shot:\nvar account_one = &quot;0x1234...&quot;; // an address\n\nvar meta;\nMetaCoin.deployed().then(function(instance) {\n  meta = instance;\n  return meta.getBalance.call(account_one, {from: account_one});\n}).then(function(balance) {\n  // If this callback is called, the call was successfully executed.\n  // Note that this returns immediately without any waiting.\n  // Let&#39;s print the return value.\n  console.log(balance.toNumber());\n}).catch(function(e) {\n  // There was an error! Handle it.\n})\n\nWhat&#39;s interesting here:\n\nWe had to execute the .call() function explicitly to let the Ethereum network know we&#39;re not intending to persist any changes.\nWe received a return value instead of a transaction id on success. Note that since the Ethereum network can handle very large numbers, we&#39;re given a BigNumber object which we then convert to a number.\n\nWarning: We convert the return value to a number because in this example the numbers are small. However, if you try to convert a BigNumber that&#39;s larger than the largest integer supported by Javascript, you&#39;ll likely run into errors or unexpected behavior.\n&nbsp;Catching eventsYour contracts can fire events that you can catch to gain more insight into what your contracts are doing. The easiest way to handle events is by processing the result object of the transaction that triggered the event, like so:\nvar account_one = &quot;0x1234...&quot;; // an address\nvar account_two = &quot;0xabcd...&quot;; // another address\n\nvar meta;\nMetaCoin.deployed().then(function(instance) {\n  meta = instance;  \n  return meta.sendCoin(account_two, 10, {from: account_one});\n}).then(function(result) {\n  // result is an object with the following values:\n  //\n  // result.tx      =&gt; transaction hash, string\n  // result.logs    =&gt; array of decoded events that were triggered within this transaction\n  // result.receipt =&gt; transaction receipt object, which includes gas used\n\n  // We can loop through result.logs to see if we triggered the Transfer event.\n  for (var i = 0; i &lt; result.logs.length; i++) {\n    var log = result.logs[i];\n\n    if (log.event == &quot;Transfer&quot;) {\n      // We found the event!\n      break;\n    }\n  }\n}).catch(function(err) {\n  // There was an error! Handle it.\n});\n\n&nbsp;Processing transaction resultsWhen you make a transaction, you&#39;re given a result object that gives you a wealth of information about the transaction. Specifically, you get the following:\n\nresult.tx (string) - Transaction hash \nresult.logs (array) - Decoded events (logs)\nresult.receipt (object) - Transaction receipt\n\nFor more information, please see the README in the truffle-contract project.\n&nbsp;Add a new contract to the networkIn all of the above cases, we&#39;ve been using a contract abstraction that has already been deployed. We can deploy our own version to the network using the .new() function:\nMetaCoin.new().then(function(instance) {\n  // Print the new address\n  console.log(instance.address);\n}).catch(function(err) {\n  // There was an error! Handle it.\n});\n\n&nbsp;Use a contract at a specific addressIf you already have an address for a contract, you can create a new abstraction to represent the contract at that address.\nvar instance = MetaCoin.at(&quot;0x1234...&quot;);\n\n&nbsp;Sending ether to a contractYou may simply want to send Ether directly to a contract, or trigger a contract&#39;s fallback function. You can do so using one of the following two options.\nOption 1: Send a transaction directly to a contract via instance.sendTransaction(). This is promisified like all available contract instance functions, and has the same API as web3.eth.sendTransaction but without the callback. The to value will be automatically filled in for you if not specified.\ninstance.sendTransaction({...}).then(function(result) {\n  // Same transaction result object as above.\n});\n\nOption 2: There&#39;s also shorthand for just sending Ether directly:\ninstance.send(web3.toWei(1, &quot;ether&quot;)).then(function(result) {\n  // Same result object as above.\n});\n\n&nbsp;Further readingThe contract abstractions provided by Truffle contain a wealth of utilities for making interacting with your contracts easy. Check out the truffle-contract documentation for tips, tricks and insights.\n"},"packages-ethpm":{"id":"packages-ethpm","title":"Package management via EthPM","path":"getting_started/packages-ethpm","content":"&nbsp;Package management via EthPM EthPM is the new Package Registry for Ethereum. It follows the ERC190 spec for publishing and consuming smart contract packages, and has gained wide support from many diverse Ethereum development tools. To show our support, we&#39;ve integrated the Ethereum Package Registry directly into Truffle.\n&nbsp;Installing a packageInstalling a package from EthPM is nearly as easy as installing a package via NPM. You can simply run the following command:\n$ truffle install &lt;package name&gt;\nYou can also install a package at a specific version:\n$ truffle install &lt;package name&gt;@&lt;version&gt;\nLike NPM, EthPM versions follow semver. You can find a list of all available packages at the Ethereum Package Registry.\n&nbsp;Installing DependenciesYour project can define an ethpm.json file that among other things can pin your project to specific dependencies and versions. To install all dependencies listed in the ethpm.json file, run:\n$ truffle install\nFor more details on the ethpm.json file, see the package configuration below.\n&nbsp;Consuming installed contractsInstalled packages will be placed in the installed_contracts directory within your project folder. If no installed_contracts directory exists it&#39;ll be created for you. You should treat this folder like you treat the node_modules folder with NPM -- that is, you shouldn&#39;t edit the contents inside unless you know what you&#39;re doing. :)\nInstalled packages can be consumed within your tests, migrations and solidity contract files by import&#39;ing or require&#39;ing that package and contract by name. For example, the following Solidity contract would import the owned.sol file from the owned package:\npragma solidity ^0.4.2;\n\nimport &quot;owned/owned.sol&quot;;\n\ncontract MyContract is owned {\n  // ...\n}\n\nSimilarly, the following migration file would use the ENS.sol contract from the ens package:\nFile: ./migrations/2_deploy_contracts.js\nvar ENS = artifacts.require(&quot;ens/ENS&quot;);\nvar MyContract = artifacts.require(&quot;MyContract&quot;);\n\nmodule.exports = function(deployer) {\n  // Only deploy ENS if there&#39;s not already an address already.\n  // i.e., don&#39;t deploy if we&#39;re using the canonical ENS address,\n  // but do deploy it if we&#39;re on a test network and ENS doesn&#39;t exist.\n  deployer.deploy(ENS, {overwrite: false}).then(function() {\n    return deployer.deploy(MyContract, ENS.address);\n  });\n};\n\nNote that in the migration above, we consume the ens package and deploy the ENS contract conditionally based on whether or not ENS already has an address set. This is a fancy trick provided to you by the deployer that makes it much easier to write migrations dependent on the the existence of network artifacts. In this case, if we were running our migrations on the Ropsten network, this migration wouldn&#39;t deploy the ENS contract because (at the time of this writing) Ropsten is where the canonical ENS contract exists -- we wouldn&#39;t want to deploy our own. But if we were running our migrations against a different network, or a test network perhaps, then we&#39;d want to deploy the ENS contract so that we have a dependency contract to work with.\n&nbsp;Publishing your own packagePublishing your own package is as straightforward as installing, but like NPM, requires a bit more configuration.\n&nbsp;Ropsten, Ropsten, RopstenThe Ethereum Package Registry currently exists on the Ropsten test network. To publish to the registry, we need to set up our own Ropsten configuration because we&#39;ll be making transactions that need to be signed.\nIn this example, we&#39;ll use Infura for publishing packages along with the truffle-hdwallet-provider NPM module and a 12-word hd-wallet mnemonic that represents our Ethereum address on the Ropsten network. First, install the truffle-hdwallet-provider via NPM within your project directory:\n$ npm install truffle-hdwallet-provider --save\nThen edit your configuration to add the ropsten network using your 12-word mnemonic:\nFile: truffle.js\nvar HDWalletProvider = require(&quot;truffle-hdwallet-provider&quot;);\n\n// 12-word mnemonic\nvar mnemonic = &quot;opinion destroy betray ...&quot;;\n\nmodule.exports = {\n  networks: {\n    development: {\n      host: &quot;127.0.0.1&quot;,\n      port: 8545,\n      network_id: &quot;*&quot; // Match any network id\n    },\n    ropsten: {\n      provider: new HDWalletProvider(mnemonic, &quot;https://ropsten.infura.io/&quot;),\n      network_id: 3 // official id of the ropsten network\n    }\n  }\n};\n\n&nbsp;Package configurationLike NPM, configuration options for EthPM go in a separate JSON file called ethpm.json. This file sits alongside your Truffle configuration and gives Truffle all the information it needs to publish your package. You can see a full list of available options in the Configuration section.\nFile: ethpm.json\n{\n  &quot;package_name&quot;: &quot;adder&quot;,\n  &quot;version&quot;: &quot;0.0.3&quot;,\n  &quot;description&quot;: &quot;Simple contract to add two numbers&quot;,\n  &quot;authors&quot;: [\n    &quot;Tim Coulter &lt;tim.coulter@consensys.net&gt;&quot;\n  ],\n  &quot;keywords&quot;: [\n    &quot;ethereum&quot;,\n    &quot;addition&quot;\n  ],\n  &quot;dependencies&quot;: {\n    &quot;owned&quot;: &quot;^0.0.1&quot;\n  },\n  &quot;license&quot;: &quot;MIT&quot;\n}\n\n&nbsp;CommandAfter you have your configuration settled, publishing is a snap:\n$ truffle publish\nYou&#39;ll see output similar to that below, with confirmation that your package was published successfully.\n$ truffle publish\nGathering contracts...\nFinding publishable artifacts...\nUploading sources and publishing to registry...\n+ adder@0.0.3\n&nbsp;Before publishingWhen using a network like the default develop network that&#39;s configured to match any Ethereum client (like Ganache or Truffle Develop), you&#39;re bound to have network artifacts lying around that you don&#39;t want published. Before publishing your package, consider running the following command to remove any extraneous network artifacts:\n$ truffle networks --clean\nSee the command reference for more information.\n"},"packages-npm":{"id":"packages-npm","title":"Package management via NPM","path":"getting_started/packages-npm","content":"&nbsp;Package management via NPM Truffle comes standard with npm integration, and is aware of the node_modules directory in your project if it exists. This means you can use and distribute contracts, dapps and Ethereum-enabled libraries via npm, making your code available to others and other&#39;s code available to you.\n&nbsp;Package layoutProjects created with Truffle have a specific layout by default which enables them to be used as packages. This layout isn&#39;t required, but if used as a common convention -- or &quot;de-facto standard&quot; -- then distributing contracts and dapps through NPM will become much easier.\nThe most important directories in a Truffle package are the following:\n\n/contracts\n/build (which includes /build/contracts, created by Truffle)\n\nThe first directory is your contracts directory, which includes your raw Solidity contracts. The second directory is the build directory, and more specifically /build/contracts, which holds build artifacts in the form of .json files. Including raw contracts in your package will allow others to import those contracts within their own solidity code. Similarly, including your .json build artifacts in your package will allow others to seamlessly interact with your contracts from JavaScript, which can be used in dapps, scripts and migrations.\n&nbsp;Using a packageWhen using a package within your own project, it is important to note that there are two places where you might be interested in using other&#39;s contract code: within your contracts and within your Javascript code (migrations and tests). The following provides an example of each case, and discusses techniques for making the most of other&#39;s contracts and build artifacts.\n&nbsp;InstallingFor this example, we&#39;re going to use the Example Truffle Library, which provides a simple name registry that is deployed to the Morden test network. In order to use it as a dependency, we must first install it within our project through npm:\n$ cd my_project\n$ npm install example-truffle-library\nNote that the last command above downloads the package and places it in my_project/node_modules directory, which is important for the examples below. See the npm documentation for help using npm to install packages.\n&nbsp;Within your contractsTo use a package&#39;s contracts within your contracts, this can be as simple as Solidity&#39;s import statement. When your import path isn&#39;t explicitly relative or absolute, this signifies to Truffle that you&#39;re looking for a file from a specific named package. Consider this example using the Example Truffle Library mentioned above:\nimport &quot;example-truffle-library/contracts/SimpleNameRegistry.sol&quot;;\nSince the path didn&#39;t start with ./, Truffle knows to look in your project&#39;s node_modules directory for the example-truffle-library folder. From there, it resolves the path to provide you the contract you requested.\n&nbsp;Within JavaScript codeTo interact with package&#39;s contracts within JavaScript code, you simply need to require that package&#39;s .json files, and then use the truffle-contract module to turn those into usable abstractions:\nvar contract = require(&quot;truffle-contract&quot;);\nvar data = require(&quot;example-truffle-library/build/contracts/SimpleNameRegistry.json&quot;);\nvar SimpleNameRegistry = contract(data);\nTo use these abstractions, see the Interacting With Your Contracts section for more details.\n&nbsp;Package&#39;s deployed addressesSometimes you want your contracts to interact with the package&#39;s previously deployed contracts. Since the deployed addresses exist within the package&#39;s .json files, you must perform an extra step to get those addresses into your contracts. To do so, make your contract accept the address of the dependency contract, and then use migrations. The following is an example contract that exists within your project as well as an example migration:\nContract: MyContract.sol\npragma solidity ^0.4.13;\n\nimport &quot;example-truffle-library/contracts/SimpleNameRegistry.sol&quot;;\n\ncontract MyContract {\n  SimpleNameRegistry registry;\n  address public owner;\n\n  function MyContract {\n    owner = msg.sender;\n  }\n\n  // Simple example that uses the deployed registry from the package.\n  function getModule(bytes32 name) returns (address) {\n    return registry.names(name);\n  }\n\n  // Set the registry if you&#39;re the owner.\n  function setRegistry(address addr) {\n    require(msg.sender == owner);\n\n    registry = SimpleNameRegistry(addr);\n  }\n}\n\nMigration: 3_hook_up_example_library.js\n// Note that artifacts.require takes care of creating an abstraction for us.\nvar SimpleNameRegistry = artifacts.require(&quot;example-truffle-library/SimpleNameRegistry&quot;);\n\nmodule.exports = function(deployer) {\n  // Deploy our contract, then set the address of the registry.\n  deployer.deploy(MyContract).then(function() {\n    return MyContract.deployed();\n  }).then(function(deployed) {\n    return deployed.setRegistry(SimpleNameRegistry.address);\n  });\n};\n\n&nbsp;Before publishingWhen using a network like the default develop network that&#39;s configured to match any Ethereum client (like Ganache or Truffle Develop), you&#39;re bound to have network artifacts lying around that you don&#39;t want published. Before publishing your package, consider running the following command to remove any extraneous network artifacts:\n$ truffle networks --clean\nSee the command reference for more information.\n"},"debugging":{"id":"debugging","title":"Debugging your contracts","path":"getting_started/debugging","content":"&nbsp;Debugging your contracts Truffle includes an integrated debugger so that you can debug transactions made against your contracts. This debugger looks and feels like existing command line debuggers available for traditional development environments.\n&nbsp;OverviewDebugging a transaction on the blockchain is different than debugging traditional applications (for instance, applications written in C++ or Javascript). When debugging a transaction on the blockchain, you&#39;re not running the code in real-time; instead, you&#39;re stepping over the historical execution of that transaction, and mapping that execution onto its associated code. This gives us many liberties in debugging, in that we can debug any transaction, any time, so long as we have the code and artifacts for the contracts the transaction interacted with. Think of these code and artifacts as akin to the debugging symbols needed by traditional debuggers.\nIn order to debug transactions, you&#39;ll need the following:\n\nTruffle 4.0 or above.\nThe hash of a transaction on your desired blockchain.\nThe source code and artifacts the transaction encounters.\n\nNote that it&#39;s okay if your desired transaction resulted in an exception or if it ran out of gas. The transaction still exists on chain, and so you can still debug it!\n&nbsp;CommandTo use the debugger, gather the transaction you&#39;d like to debug then run the following:\n$ truffle debug &lt;transaction hash&gt;\nUsing a transaction starting with 0x8e5dadfb921dd... as an example, the command would look as follows:\n$ truffle debug 0x8e5dadfb921ddddfa8f53af1f9bd8beeac6838d52d7e0c2fe5085b42a4f3ca76\nThis will launch the debugging interface described below.\n&nbsp;Debugging interfaceStarting the debugger will open an interface familiar to those that have debugged other types of applications. When it starts, you&#39;ll see the following:\n\nA list of addresses either transacted against or created during the course of this transaction.\nA list of available commands for using the debugger.\nAnd the initial entry point for the transaction, including contract source file and code preview.\n\nThe enter key is set to perform the last command entered. When the debugger starts, the enter key is set to step to the next logical source code element encountered during execution (i.e., the next expression or statement evaluated by the Ethereum virtual machine). At this point you can press enter to step through the transaction, or enter one of the available commands to analyze the transaction in more detail. The list of commands is detailed below.\n&nbsp;(o) step overThis command steps over the current line, relative to the position of the statement or expression currently being evaluated in the Solidity source file. Use this command if you don&#39;t want to step into a function call or contract creation on the current line, or if you&#39;d like to quickly jump to a specific point in the source file.\n&nbsp;(i) step intoThis command steps into the function call or contract creation currently being evaluated. Use this command to jump into the function and quickly start debugging the code that exists there.\n&nbsp;(u) step outThis command steps out of the currently running function. Use this command to quickly get back to the calling function, or end execution of the transaction if this was the entry point of the transaction.\n&nbsp;(n) step nextThis command steps to the next logical statement or expression in the source code. For example, evaluating sub expressions will need to occur first before the virtual machine can evaluate the full expression. Use this command if you&#39;d like to analyze each logical item the virtual machine evaluates.\n&nbsp;(;) step instructionThis command allows you to step through each individual instruction evaluated by the virtual machine. This is useful if you&#39;re interested in understanding the low level bytecode created by the Solidity source code. When you use this command, the debugger will also print out the stack data at the time the instruction was evaluated.\n&nbsp;(p) print instructionThis commands prints the current instruction and stack data, but does not step to the next instruction. Use this when you&#39;d like to see the current instruction and stack data after navigating through the transaction with the logical commands described above.\n&nbsp;(h) print this helpPrint the list of available commands.\n&nbsp;(q) quitQuit the debugger.\n"},"console":{"id":"console","title":"Using Truffle Develop and the console","path":"getting_started/console","content":"&nbsp;Using Truffle Develop and the console Sometimes it&#39;s nice to work with your contracts interactively for testing and debugging purposes, or for executing transactions by hand. Truffle provides you two easy ways to do this via an interactive console, with your contracts available and ready to use.\n\nTruffle console: A basic interactive console connecting to any Ethereum client\nTruffle Develop: An interactive console that also spawns a development blockchain\n\n&nbsp;Why two different consoles?Having two different consoles allows you to choose the best tool for your needs.\nReasons to use Truffle console:\n\nYou have a client you&#39;re already using, such as Ganache or geth\nYou want to migrate to a testnet (or the main Ethereum network)\nYou want to use a specific mnemonic or account list\n\nReasons to use Truffle Develop:\n\nYou are testing your project with no intention of immediately deploying\nYou don&#39;t need to work with specific accounts (and you&#39;re fine with using default development accounts)\nYou don&#39;t want to install and manage a separate blockchain client\n\n&nbsp;CommandsAll commands require that you be in your project folder. You do not need to be at the root.\n&nbsp;ConsoleTo launch the console:\ntruffle console\n\nThis will look for a network definition called development in the configuration, and connect to it, if available. You can override this using the --network &lt;name&gt; option. See more details in the Networks section as well as the command reference.\nWhen you load the console, you&#39;ll immediately see the following prompt:\ntruffle(development)&gt;\n\nThis tells you you&#39;re running within a Truffle console using the development network.\n&nbsp;Truffle DevelopTo launch Truffle Develop:\ntruffle develop\n\nThis will spawn a development blockchain locally on port 9545, regardless of what your truffle.js configuration file calls for.\nWhen you load Truffle Develop, you will see the following:\nTruffle Develop started at http://localhost:9545/\n\nAccounts:\n(0) 0x627306090abab3a6e1400e9345bc60c78a8bef57\n(1) 0xf17f52151ebef6c7334fad080c5704d77216b732\n(2) 0xc5fdf4076b8f3a5357c5e395ab970b5b54098fef\n(3) 0x821aea9a577a9b44299b9c15c88cf3087f3b5544\n(4) 0x0d1d4e623d10f9fba5db95830f7d3839406c6af2\n(5) 0x2932b7a2355d6fecc4b5c0b6bd44cc31df247a2e\n(6) 0x2191ef87e392377ec08e7c08eb105ef5448eced5\n(7) 0x0f4f2ac550a1b4e2280d04c21cea7ebd822934b5\n(8) 0x6330a553fc93768f612722bb8c2ec78ac90b3bbc\n(9) 0x5aeda56215b167893e80b4fe645ba6d5bab767de\n\nPrivate Keys:\n(0) c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3\n(1) ae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f\n(2) 0dbbe8e4ae425a6d2687f1a7e3ba17bc98c673636790f1b8ad91193c05875ef1\n(3) c88b703fb08cbea894b6aeff5a544fb92e78a18e19814cd85da83b71f772aa6c\n(4) 388c684f0ba1ef5017716adb5d21a053ea8e90277d0868337519f97bede61418\n(5) 659cbb0e2411a44db63778987b1e22153c086a95eb6b18bdf89de078917abc63\n(6) 82d052c865f5763aad42add438569276c00d3d88a2d062d36b2bae914d58b8c8\n(7) aa3680d5d48a8283413f7a108367c7299ca73f553735860a87b08f39395618b7\n(8) 0f62d96d6675f32685bbdb8ac13cda7c23436f63efbb9d07700d8669ff12b7c4\n(9) 8d5366123cb560bb606379f90a0bfd4769eecc0557f1b362dcae9012b548b1e5\n\nMnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat\n\nThis shows you the addresses, private keys, and mnemonic for this particular blockchain.\n\nNote: The mnemonic and addresses cannot be changed. If you want to use a different mnemonic or set of addresses, we recommend using Ganache.\n\n\n\nWarning: Remember to never use any of these addresses or the mnemonic on the mainnet. This is for development only.\n\n\n\n&nbsp;FeaturesBoth Truffle Develop and the console provide most of the features available in the Truffle command line tool. For instance, you can type migrate --reset within the console, and it will be interpreted the same as if you ran truffle migrate --reset on the command line.\nAdditionally, both Truffle Develop and the console additionally have the following features:\n\nAll of your compiled contracts are available and ready for use.\nAfter each command (such as migrate --reset) your contracts are reprovisioned so you can start using the newly assigned addresses and binaries immediately.\nThe web3 library is made available and is set to connect to your Ethereum client.\nAll commands that return a promise will automatically be resolved, and the result printed, removing the need to use .then() for simple commands. For example, the following command:\nMyContract.at(&quot;0xabcd...&quot;).getValue.call();\n\nWill return something like:\n5\n\n\n\n&nbsp;Commands available\nbuild\ncompile\ncreate\ndebug\nexec\ninstall\nmigrate\nnetworks\nopcode\npublish\ntest\nversion\n\nIf a Truffle command is not available, it is because it is not relevant for an existing project (for example, init) or wouldn&#39;t make sense (for example, develop or console).\nSee full command reference for more information.\n"},"scripts":{"id":"scripts","title":"Writing external scripts","path":"getting_started/scripts","content":"&nbsp;Writing external scripts Often you may want to run external scripts that interact with your contracts. Truffle provides an easy way to do this, bootstrapping your contracts based on your desired network and connecting to your Ethereum client automatically per your project configuration.\n&nbsp;CommandTo run an external script, perform the following:\n$ truffle exec &lt;path/to/file.js&gt;\n&nbsp;File structureIn order for external scripts to be run correctly, Truffle expects them to export a function that takes a single parameter as a callback:\nmodule.exports = function(callback) {\n  // perform actions\n}\n\nYou can do anything you&#39;d like within this script, so long as the callback is called when the script finishes. The callback accepts an error as its first and only parameter. If an error is provided, execution will halt and the process will return a non-zero exit code.\n"},"build":{"id":"build","title":"Using the build pipeline","path":"getting_started/build","content":"&nbsp;Using the build pipeline Truffle 1.0 and 2.0 came standard with a default build system heavily geared toward web applications (here, the term &quot;build&quot; means turning code artifacts into HTML, Javascript and CSS). That build system has been pulled out into its own module to make Truffle usable and extensible for all kinds of applications.\nTruffle can be configured for tight integration with any build system. To configure a custom build system, see the Advanced Build Processes section for more details.\n&nbsp;CommandTo build your application when a build system is configured, run:\n$ truffle build\n\nNote you&#39;ll receive an error if you try to run the build command without first configuring a custom build process.\n"},"contact":{"id":"contact","title":"Contact the developers","path":"getting_started/contact","content":"&nbsp;Contact the developers &nbsp;GitterThe best way to contact us is through Gitter. This allows you to ask questions to both the Truffle developers as well as the community at large.\n\n\n\n  SIGN UP FOR THE TRUFFLE MAILING LIST\n\n  Get news, beta releases and new features straight to your inbox!\n\n  \n    \n      \n        \n          \n          First Name \n            \n          \n          \n            Your Email Address\n            \n          \n          \n          \n          \n        \n      \n    \n  \n  \n\n\n\n"},"configuration":{"id":"configuration","title":"Configuration","path":"advanced/configuration","content":"&nbsp;Configuration &nbsp;LocationYour configuration file is called truffle.js and is located at the root of your project directory. This file is a Javascript file and can execute any code necessary to create your configuration. It must export an object representing your project configuration like the example below.\nmodule.exports = {\n  networks: {\n    development: {\n      host: &quot;127.0.0.1&quot;,\n      port: 8545,\n      network_id: &quot;*&quot; // Match any network id\n    }\n  }\n};\n\nThe default configuration ships with configuration for a single development network, running on 127.0.0.1:8545. There are many other configuration options, detailed below.\n&nbsp;Resolving naming conflicts on WindowsWhen using the Command Prompt on Windows, the default configuration file name can cause a conflict with the truffle executable, and so you may not be able to run Truffle commands properly on existing projects.\nThis is because of the way that command precedence works on the Command Prompt. The truffle.cmd executable is on the path as part of the npm package, but the truffle.js configuration file is in the actual directory where the truffle command is run. Because .js is an acceptable executable extension by default, truffle.js takes precedence over truffle.cmd, causing unexpected results.\nAny of the following solutions will remedy this issue:\n\nCall the executable file explicitly using its .cmd extension (truffle.cmd compile)\nEdit the system PATHEXT environment variable and remove .JS; from the list of executable extensions\nRename truffle.js to something else (truffle-config.js)\nUse Windows PowerShell or Git BASH, as these shells do not have this conflict.\n\n&nbsp;General options&nbsp;buildBuild configuration of your application, if your application requires tight integration with Truffle. Most users likely will not need to configure this option. See the Advanced Build Processes section for more details.\n&nbsp;networksSpecifies which networks are available for deployment during migrations, as well as specific transaction parameters when interacting with each network (such as gas price, from address, etc.). When compiling and running migrations on a specific network, contract artifacts will be saved and recorded for later use. When your contract abstractions detect that your Ethereum client is connected to a specific network, they&#39;ll use the contract artifacts associated that network to simplify app deployment. Networks are identified through Ethereum&#39;s net_version RPC call, as well as blockchain URIs.\nThe networks object, shown below, is keyed by a network name and contains a corresponding object that defines the parameters of the network. The networks option is required, as if you have no network configuration, Truffle will not be able to deploy your contracts. The default network configuration provided by truffle init gives you a development network that matches any network it connects to -- this is useful during development, but not suitable for production deployments. To configure Truffle to connect to other networks, simply add more named networks and specify the corresponding network id.\nThe network name is used for user interface purposes, such as when running your migrations on a specific network:\n$ truffle migrate --network live\n\nExample:\nnetworks: {\n  development: {\n    host: &quot;127.0.0.1&quot;,\n    port: 8545,\n    network_id: &quot;*&quot; // match any network\n  },\n  live: {\n    host: &quot;178.25.19.88&quot;, // Random IP for example purposes (do not use)\n    port: 80,\n    network_id: 1,        // Ethereum public network\n    // optional config values:\n    // gas\n    // gasPrice\n    // from - default address to use for any transaction Truffle makes during migrations\n    // provider - web3 provider instance Truffle should use to talk to the Ethereum network.\n    //          - if specified, host and port are ignored.\n  }\n}\n\nFor each network, if unspecified, transaction options will default to the following values:\n\ngas: Gas limit used for deploys. Default is 4712388.\ngasPrice: Gas price used for deploys. Default is 100000000000 (100 Shannon).\nfrom: From address used during migrations. Defaults to the first available account provided by your Ethereum client.\nprovider: Default web3 provider using host and port options: new Web3.providers.HttpProvider(&quot;http://&lt;host&gt;:&lt;port&gt;&quot;)\n\nFor each network, you can specify either host / port or provider, but not both. If you need an HTTP provider, we recommend using host and port, while if you need a custom provider such as HDWalletProvider, you must use provider.\n&nbsp;Accessing only one of multiple network providersAs seen above, your truffle.js file can contain multiple network configurations, but in general you will only work with a single network at a time. While you can issue a command to migrate to a single network (truffle migrate --network live), a minimal network connection will nevertheless be opened to every network defined with a provider.\nAs a workaround to this, you can wrap your network&#39;s provider definition in a function call. This way, the network information is there, but Truffle will ignore it until specifically called.\nFor example, consider the following network list consisting of a local test network and a Infura-hosted Ropsten network, both provided by HDWalletProvider:\nnetworks: {\n  ropsten: {\n    provider: new HDWalletProvider(mnemonic, &quot;https://ropsten.infura.io/&quot;),\n    network_id: &#39;3&#39;,\n  },\n  test: {\n    provider: new HDWalletProvider(mnemonic, &quot;http://127.0.0.1:8545/&quot;),\n    network_id: &#39;*&#39;,\n  },\n}\n\nTo ensure that only one network is ever connected at a time, modify the provider keys as follows:\nnetworks: {\n  ropsten: {\n    provider: function() {\n      return new HDWalletProvider(mnemonic, &quot;https://ropsten.infura.io/&quot;);\n    },\n    network_id: &#39;3&#39;,\n  },\n  test: {\n    provider: function() {\n      return new HDWalletProvider(mnemonic, &quot;http://127.0.0.1:8545/&quot;);\n    },\n    network_id: &#39;*&#39;,\n  },\n}\n\nIf you specify host and port instead of provider, Truffle will create its own default HTTP provider using that host and port, and no minimal network connection will be opened, so there is no need to do the function wrapping workaround. That said, you wouldn&#39;t be able to use a custom provider in this case.\n&nbsp;contracts_build_directoryThe default output directory for compiled contracts is ./build/contracts relative to the project root. This can be changed with the contracts_build_directory key.\nExamples:\nTo place the built contract artifacts in ./output/contracts:\nmodule.exports = {\n  contracts_build_directory: &quot;./output&quot;,\n  networks: {\n    development: {\n      host: &quot;127.0.0.1&quot;,\n      port: 8545,\n      network_id: &quot;*&quot;,\n    }\n  }\n};\n\nThe built contract artifacts do not need to be inside the project root:\nmodule.exports = {\n  contracts_build_directory: &quot;../../../output&quot;,\n  networks: {\n    development: {\n      host: &quot;127.0.0.1&quot;,\n      port: 8545,\n      network_id: &quot;*&quot;,\n    }\n  }\n};\n\nAbsolute paths will also work. This is not recommended though, as an absolute path may not exist when compiled on another system. If you use absolute paths on Windows, make sure to use double backslashes for paths (example: C:\\\\Users\\\\Username\\\\output).\n&nbsp;mochaConfiguration options for the MochaJS testing framework. This configuration expects an object as detailed in Mocha&#39;s documentation.\nExample:\nmocha: {\n  useColors: true\n}\n\n&nbsp;Solidity compiler configurationSolidity compiler settings. Supports optimizer settings for solc.\n&nbsp;solcConfiguration options to pass to the Solidity compiler.\nExample:\nsolc: {\n  optimizer: {\n    enabled: true,\n    runs: 200\n  }\n}\n\nFor more information, please see the Solidity documentation on Compiler Input and Output JSON Description.\n&nbsp;EthPM configurationThis configuration applies to the optional ethpm.json file that exists alongside your truffle.js configuration file.\n&nbsp;package_nameName of the package you&#39;re publishing. Your package name must be unique to the EthPM registry.\nExample:\npackage_name: &quot;adder&quot;\n\n&nbsp;versionVersion of this package, using the semver specification.\nExample:\nversion: &quot;0.0.3&quot;\n\n&nbsp;descriptionA text description of your package for human readers.\nExample:\ndescription: &quot;Simple contract to add two numbers&quot;\n\n&nbsp;authorsAn array of authors. Can have any format, but we recommend the format below.\nExample:\nauthors: [\n  &quot;Tim Coulter &lt;tim.coulter@consensys.net&gt;&quot;\n]\n\n&nbsp;keywordsAn array of keywords that tag this package with helpful categories.\nExample:\nkeywords: [\n  &quot;ethereum&quot;,\n  &quot;addition&quot;\n],\n\n&nbsp;dependenciesA list of EthPM packages your package depends on, using semver version ranges, like npm.\nExample:\ndependencies: {\n  &quot;owned&quot;: &quot;^0.0.1&quot;,\n  &quot;erc20-token&quot;: &quot;1.0.0&quot;\n}\n\n&nbsp;licenseLicense to use for this package. Strictly informative.\nExample:\nlicense: &quot;MIT&quot;,\n\n"},"networks":{"id":"networks","title":"Networks and app deployment","path":"advanced/networks","content":"&nbsp;Networks and app deployment Even the smallest project will interact with at the very least two blockchains: One on the developer&#39;s machine, like Ganache or Truffle Develop, and the other representing the network where the developer will eventually deploy their application (such as the main public Ethereum network or a private consortium network, for instance). Truffle provides a system for managing the compilation and deployment artifacts for each network, and does so in a way that simplifies final application deployment.\n&nbsp;ConfigurationSee the Configuration section for more information.\n&nbsp;Specifying a networkMost Truffle commands will behave differently based on the network specified, and will use that network&#39;s contracts and configuration. You can specify a network using the --network option, like below:\n$ truffle migrate --network live\n\nIn this example, Truffle will run your migrations on the &quot;live&quot; network, which -- if configured like the example -- is associated with the public Ethereum blockchain.\n&nbsp;Build artifactsAs mentioned in the Compiling contracts section, build artifacts are stored in the ./build/contracts directory as .json files. When you compile your contracts or run your migrations using a specific network, Truffle will update those .json files so they contain the information related to that network. When those artifacts are used later -- such as within your frontend or application via truffle-contract -- they&#39;ll automatically detect which network the Ethereum client is connected to and use the correct contract artifacts accordingly.\n&nbsp;Application deploymentBecause the network is auto-detected by the contract artifacts at runtime, this means that you only need to deploy your application or frontend once. When your application is run, the running Ethereum client will determine which artifacts are used, and this will make your application very flexible. As an example, if you were to deploy a web application to http://mydapp.io, you could navigate to that address using your favorite wallet-browser (like MetaMask, or Mist) and your dapp would work correctly regardless of the Ethereum network the wallet-browser was connected to. If the wallet-browser was connected to the live network, your dapp would use the contracts you deployed on the live network. If on Ropsten, the contracts you deployed to Ropsten would be used.\n"},"build_processes":{"id":"build_processes","title":"Build processes","path":"advanced/build_processes","content":"&nbsp;Build processes In order to provide tight integration with Truffle for those that desire it, Truffle allows you to specify a custom build pipeline meant to bootstrap and configure your application. Truffle provides three methods of integration, described below.\n&nbsp;Running an external commandIf you&#39;d like Truffle to run an external command whenever it triggers a build, simply include that option as a string within your project configuration, like so:\nmodule.exports = {\n  // This will run the `webpack` command on each build.\n  //\n  // The following environment variables will be set when running the command:\n  // WORKING_DIRECTORY: root location of the project\n  // BUILD_DESTINATION_DIRECTORY: expected destination of built assets (important for `truffle serve`)\n  // BUILD_CONTRACTS_DIRECTORY: root location of your build contract files (.sol.js)\n  //\n  build: &quot;webpack&quot;\n}\n\nNote that you&#39;re given ample environment variables with which to integrate with Truffle, detailed above.\n&nbsp;Providing a custom functionYou can also provide a custom build function like the one below. Note you&#39;re given a plethora of information about your project which you can use to integrate tightly with Truffle.\nmodule.exports = {\n  build: function(options, callback) {\n     // Do something when a build is required. `options` contains these values:\n     //\n     // working_directory: root location of the project\n     // contracts_directory: root directory of .sol files\n     // destination_directory: directory where truffle expects the built assets (important for `truffle serve`)\n  }\n}\n\n&nbsp;Creating a custom moduleYou could also create a module or object that implements the builder interface (i.e., is an object which contains a build function like the one above). This is great for those who want to maintain tighter integration with Truffle and publish a package to make everyone else&#39;s lives easier.\nHere&#39;s an example using Truffle&#39;s default builder:\nvar DefaultBuilder = require(&quot;truffle-default-builder&quot;);\nmodule.exports = {\n  build: new DefaultBuilder(...) // specify the default builder configuration here.\n}\n\n&nbsp;Bootstrapping your applicationWhether you&#39;re building an application to run in the browser, or a command line tool, a Javascript library or a native mobile application, bootstrapping your contracts is the same, and using your deployed contract artifacts follows the same general process no matter the app you&#39;re building.\nWhen configuring your build tool or application, you&#39;ll need to perform the following steps:\n1) Get all your contract artifacts into your build pipeline / application. This includes all of the .json files within the ./build/contracts directory.\n2) Turn those .json contract artifacts into contract abstractions that are easy to use, via truffle-contract.\n3) Provision those contract abstractions with a Web3 provider. In the browser, this provider might come from Metamask or Mist, but it could also be a custom provider you&#39;ve configured to point to Infura or any other Ethereum client.\n4) Use your contracts!\nIn Node, this is very easy to do. Let&#39;s take a look at an example that shows off the &quot;purest&quot; way of performing the above steps, since it exists outside of any build process or tool.\n// Step 1: Get a contract into my application\nvar json = require(&quot;./build/contracts/MyContract.json&quot;);\n\n// Step 2: Turn that contract into an abstraction I can use\nvar contract = require(&quot;truffle-contract&quot;);\nvar MyContract = contract(json);\n\n// Step 3: Provision the contract with a web3 provider\nMyContract.setProvider(new Web3.providers.HttpProvider(&quot;http://127.0.0.1:8545&quot;));\n\n// Step 4: Use the contract!\nMyContract.deployed().then(function(deployed) {\n  return deployed.someFunction();\n});\n\nAll build processes and contract bootstrapping will follow this pattern. The key when setting up your own custom build process is to ensure you&#39;re consuming all of your contract artifacts and provisioning your abstractions correctly.\n"},"commands":{"id":"commands","title":"Command reference","path":"advanced/commands","content":"&nbsp;Command reference &nbsp;Usage$ truffle [command] [options]\n\n&nbsp;Available commands&nbsp;buildExecute build pipeline (if configuration present)\n$ truffle build\n\nSee the Building your application section for more details.\n&nbsp;consoleRun a console with contract abstractions and commands available.\n$ truffle console\n\nOnce the console starts, you can then use your contracts via the command line like you would in your code. Additionally, all truffle commands listed here are available within the console.\nOptional parameters:\n\n--network name: Specify the network to use.\n--verbose-rpc: Log communication between Truffle and the RPC.\n\nSee the Using the console section for more details.\n&nbsp;compileIntelligently compile your contracts. This will only compile contracts that have changed since the last compile, unless otherwise specified.\n$ truffle compile\n\nOptional parameter:\n\n--all: Compile all contracts instead of intelligently choosing.\n--network name: Specify the network to use, saving artifacts specific to that network.\n\n&nbsp;create contractHelper method to scaffold a new contract. Name must be camel-case.\n$ truffle create contract MyContract\n\n&nbsp;create migrationHelper method to scaffold a new migration. Name must be camel-case.\n$ truffle create migration MyContract\n\n&nbsp;create testHelper method to scaffold a new test for a contract. Name must be camel-case.\n$ truffle create test MyTest\n\n&nbsp;execExecute a Javascript file within the Truffle environment. This will include web3, set the default provider based on the network specified (if any), and include your contracts as global objects while executing the script. Your script must export a function that Truffle can run. See the Writing external scripts section for more details.\n$ truffle exec /path/to/my/script.js\n\nOptional parameter:\n\n--network name: Specify the network to use, using artifacts specific to that network.\n\n&nbsp;initCreate a completely new app within the current working directory. Will add default contracts, tests and frontend configuration.\n$ truffle init\n\n&nbsp;installInstall a package from the Ethereum Package Registry.\n$ truffle install &lt;package name&gt;@&lt;version&gt;\n\nThe @version parameter syntax is optional. See the Package Management with EthPM section for more details.\n&nbsp;migrateRun your project&#39;s migrations. See the Migrations section for more details.\n$ truffle migrate\n\nOptional parameters:\n\n--reset: Run all migrations from the beginning, instead of running from the last completed migration.\n-f number: Run contracts from a specific migration.\n--network name: Specify the network to use, saving artifacts specific to that network.\n--compile-all: Compile all contracts instead of intelligently choosing.\n--verbose-rpc: Log communication between Truffle and the RPC.\n\n&nbsp;networksShow the deployed addresses of all contracts on all networks, and optionally clean extraneous network artifacts.\n$ truffle networks\n\nUse this command before publishing your package to see if there are any extraneous network artifacts you don&#39;t want published. With no options specified, this package will simply output the current artifact state.\nOptional parameters:\n\n--clean: Remove all network artifacts that aren&#39;t associated with a named network.\n\n&nbsp;publishPublish a package to the Ethereum Package Registry.\n$ truffle publish\n\nAll parameters are pulled from your project&#39;s configuration file. See the Package Management with EthPM section for more details.\n&nbsp;serveServe the built app from http://127.0.0.1:8080, rebuilding and redeploying changes as needed. Like truffle watch, but with the web server component added.\n$ truffle serve\n\nOptional parameters:\n\n-p port: Specify the port to serve on. Default is 8080.\n--network name: Specify the network to use, using artifacts specific to that network.\n\n&nbsp;testRun all tests within the ./test directory, or optionally run a single test.\n$ truffle test [/path/to/test/file]\n\nOptional parameters:\n\n--compile-all: Compile all contracts instead of intelligently choosing.\n--verbose-rpc: Log communication between Truffle and the RPC.\n--network name: Specify the network to use, using artifacts specific to that network.\n\n&nbsp;versionShow version number and exit.\n$ truffle version\n\n&nbsp;watchWatch for changes to contracts, app and configuration files. When there&#39;s a change, rebuild the app if necessary.\n$ truffle watch\n\n"},"truffle-boxes":{"id":"truffle-boxes","title":"Truffle Boxes","path":"advanced/truffle-boxes","content":"&nbsp;Truffle Boxes &nbsp;Creating a boxTo create a Truffle Box you&#39;ll need a few things:\n\nA GitHub repository\nA configuration file\nOptionally, small and large images for the box&#39;s listing\n\nThe configuration file and images belong in the top-level directory of your repo. With these files in place, and your repo on GitHub, the unbox command will be: truffle unbox {USER_NAME || ORG_NAME}/{REPO_NAME}\nIf you&#39;re starting from scratch, we&#39;ve created a blueprint box containing a configuration file with common values, as well as template versions of the small and large images.\nIf you&#39;re using an existing project, download the files here and extract them into your project.\n&nbsp;Configuration fileAll truffle boxes include a configuration file, truffle-box.json. This file has three attributes: ignore, commands, and hooks.\n&nbsp;ignore (array)An array of files or relative paths you&#39;d like Truffle to ignore when unboxing. Common files include the readme.md or .gitignore.\n&quot;ignore&quot;: [\n  &quot;README.md&quot;,\n  &quot;.gitignore&quot;\n]\n\n&nbsp;commands (object)An object who&#39;s key/value pairs are a descriptor and console command respectively. These pairs will be shown to users once your box is successfully unboxed. Think of these as quick instructions.\nFor example, consider the object below. We&#39;ve given our users all they need to compile, migrate and test their smart contracts, along with commands for developing the front-end.\n&quot;commands&quot;: {\n  &quot;Compile&quot;: &quot;truffle compile&quot;,\n  &quot;Migrate&quot;: &quot;truffle migrate&quot;,\n  &quot;Test contracts&quot;: &quot;truffle test&quot;,\n  &quot;Test dapp&quot;: &quot;npm test&quot;,\n  &quot;Run dev server&quot;: &quot;npm run start&quot;,\n  &quot;Build for production&quot;: &quot;npm run build&quot;\n}\n\n&nbsp;hooks (object)An object containing console commands to execute once unboxed. Since we&#39;re working in Node.js, most commonly this will contain npm install.\n&quot;hooks&quot;: {\n  &quot;post-unpack&quot;: &quot;npm install&quot;\n}\n\n&nbsp;ImagesThe large box image is a 512px square with 32px of padding on each side.\n\nThe small box image is 735px x 100px. There is 32px of padding on the left side of the banner, and it&#39;s minimum size (described in the template as &quot;Min Banner Width&quot;) is 290px, including the left padding. The banners are fixed to the left side and crop off the right side as the window narrows.\n\nIf no images are provided in a box, we default to banners containing the Truffle logo:\n\n\n&nbsp;Truffle site listingBefore being listed on the Truffle website, all boxes undergo a screening process to ensure compatibility with Truffle. To start the pre-screening process, send us an email with your desired box name and brief description, along with a link to its GitHub repo to: info@trufflesuite.com.\n"},"truffle-with-metamask":{"id":"truffle-with-metamask","title":"Truffle with MetaMask","path":"advanced/truffle-with-metamask","content":"&nbsp;Truffle and MetaMask Before you can interact with smart contracts in a browser, make sure they&#39;re compiled, deployed, and that you&#39;re interacting with them via web3 in client-side JavaScript. We recommend using the truffle-contract library, as it makes interacting with contracts easier and more robust.\n\nNote: For more information on these topics, including using truffle-contract, check out our Pet Shop or TutorialToken tutorials.\n\n\nOnce you&#39;ve done the above, you&#39;re ready to use MetaMask.\n&nbsp;What is MetaMask?MetaMask is the easiest way to interact with dapps in a browser. It is an extension for Chrome or Firefox that connects to an Ethereum network without running a full node on the browser&#39;s machine. It can connect to the main Ethereum network, any of the testnets (Ropsten, Kovan, and Rinkeby), or a local blockchain such as the one created by Ganache or Truffle Develop.\n\nFor development with Truffle this means we can use our dapp the same way users will interact with it on a live network.\n&nbsp;Installing MetaMask\nTo install MetaMask for Chrome, go to the Chrome Web Store and click the Add to Chrome button.\n\nTo install MetaMask for FireFox, go to the Firefox Add-ons page and click the Add to Firefox button.\n\n\nWith our front-end ready to be used and MetaMask installed, we&#39;re ready to see our dapp in all its glory.\n&nbsp;Using MetaMask with GanacheGanache is a graphical application that runs a blockchain that can be used for testing purposes. It runs on 127.0.0.1:7545.\n\nNote: We recommend specifying 127.0.0.1 instead of localhost because the address does not require a network connection and so is more suitable for development.\n\n\n&nbsp;Detecting MetaMask&#39;s web3 injectionBefore diving in, we&#39;ll need to make sure the dapp is checking for MetaMask&#39;s web3 instance and that the extension itself is configured properly with Ganache.\nMetaMask injects its own web3 instance, so we&#39;ll want to make sure we&#39;re checking for that. After the window has loaded perform the following check:\n// Is there is an injected web3 instance?\nif (typeof web3 !== &#39;undefined&#39;) {\n  App.web3Provider = web3.currentProvider;\n  web3 = new Web3(web3.currentProvider);\n} else {\n  // If no injected web3 instance is detected, fallback to Ganache.\n  App.web3Provider = new web3.providers.HttpProvider(&#39;http://127.0.0.1:7545&#39;);\n  web3 = new Web3(App.web3Provider);\n}\n\n&nbsp;Setting up MetaMaskTo use Ganache with MetaMask, click the MetaMask icon in your browser and this screen will appear:\n\nMetaMask initial screen\nClick Import Existing DEN. In the box marked Wallet Seed, enter the mnemonic that was displayed when launching Ganache. While this can be changed in the Settings, the default is:\ncandy maple cake sugar pudding cream honey rich smooth crumble sweet treat\n\n\nWarning: Do not use this mnemonic on the main Ethereum network (mainnet). If you send ETH to any account generated from this mnemonic, you will lose it all!\n\n\nEnter a password below that and click OK.\n\nMetaMask seed phrase\nNow we need to connect MetaMask to the blockchain created by Ganache. Click the menu that shows &quot;Main Network&quot; and select Custom RPC.\n\nMetaMask network menu\nIn the box titled &quot;New RPC URL&quot; enter http://127.0.0.1:7545 and click Save.\n\nThe network name at the top will switch to say &quot;Private Network&quot;. Click the left-pointing arrow next to &quot;Settings&quot; to close out of the page and return to the Accounts page.\nNow that we&#39;ve connected MetaMask to Ganache, you&#39;ll be take to the accounts screen. Each account created by Ganache is given 100 ether. The first account should have less than the others because that account supplies the gas for smart contract deployment. Since you&#39;ve deployed your smart contract to the network, this account paid for it.\nClick the account icon in the upper-right to create new accounts, the first 10 of which will correspond to the 10 accounts displayed when you launched Ganache.\n\nMetaMask account\n&nbsp;Using MetaMask with Truffle DevelopTruffle Develop is a command-line application that runs a temporary blockchain that is also used for testing purposes. It runs on 127.0.0.1:9545.\n\nNote: We recommend specifying 127.0.0.1 instead of localhost because the address does not require a network connection and so is more suitable for development.\n\n\nUsing MetaMask with Truffle Develop is very similar to that of Ganache. There are only a few notable differences:\n\nThe mnemonic is always candy maple cake sugar pudding cream honey rich smooth crumble sweet treat and can&#39;t be changed.\nTruffle Develop runs by default on 127.0.0.1:9545, so you&#39;ll want to edit the above web3 code to say:\n// Is there is an injected web3 instance?\nif (typeof web3 !== &#39;undefined&#39;) {\n  App.web3Provider = web3.currentProvider;\n  web3 = new Web3(web3.currentProvider);\n} else {\n  // If no injected web3 instance is detected, fallback to Truffle Develop.\n  App.web3Provider = new web3.providers.HttpProvider(&#39;http://127.0.0.1:9545&#39;);\n  web3 = new Web3(App.web3Provider);\n}\n\n\nIn MetaMask, when entering the &quot;New RPC URL&quot;, enter http://127.0.0.1:9545.\n\n\n&nbsp;Using MetaMask with Ganache CLIUsing MetaMask with Ganache CLI is also very similar to that of Ganache. There are only a few notable differences:\n\nGanache CLI runs by default on http://127.0.0.1:8545 so you&#39;ll want to edit the above web3 code to say:\n// Is there is an injected web3 instance?\nif (typeof web3 !== &#39;undefined&#39;) {\n  App.web3Provider = web3.currentProvider;\n  web3 = new Web3(web3.currentProvider);\n} else {\n  // If no injected web3 instance is detected, fallback to Ganache CLI.\n  App.web3Provider = new web3.providers.HttpProvider(&#39;http://127.0.0.1:8545&#39;);\n  web3 = new Web3(App.web3Provider);\n}\n\n\nIn MetaMask, when entering the &quot;New RPC URL&quot;, enter http://127.0.0.1:8545.\n\n\n"},"using":{"id":"using","title":"Working with Ganache","path":"ganache/using","content":"&nbsp;Working with Ganache Ganache is a personal blockchain for Ethereum development you can use to deploy contracts, develop your applications, and run tests.\n\nIt is available as both a desktop application as well as a command-line tool (formerly known as the TestRPC). Ganache is available for Windows, Mac, and Linux.\n&nbsp;Installation&nbsp;GanacheDownload the appropriate version for your OS:\n\nWindows: Ganache-*.appx\nMac: Ganache-*.dmg\nLinux: Ganache-*.AppImage\n\nDouble-click on the downloaded file, follow the prompts, and you&#39;re up and running.\n&nbsp;Ganache CLIIf you are interested in the command-line version (formerly known as the TestRPC), you can get it through npm.\nnpm install -g ganache-cli\n\nThis page will focus only on the graphical interface. Please see the README for more information on Ganache CLI.\n&nbsp;Main interfaceWhen you launch Ganache, the screen will show some details about the server, and also list out a number of accounts. Each account is given 100 ether. Having ether automatically in all accounts allows you to focus on developing your application.\n\nNote: The first time you launch Ganache, you will be asked if you want to allow Google Analytics tracking. While optional, turning this on will help the development team gain more insight into how Ganache is used. This tracking is totally anonymous, and no account data or private keys will ever be shared.\n\n\n\nGanache Accounts\nThere are four pages available:\n\nThe Accounts page shows the accounts generated and their balances. This is the default view.\nThe Blocks page shows each block as mined on the blockchain, along with gas used and transactions.\nThe Transactions page lists all transactions run against the blockchain.\nThe Logs page shows the logs for the server, which is useful for debugging. \n\nAlso note that you can search for block numbers or transaction hashes from a search box at the top.\n&nbsp;SettingsYou can change some features of the generated blockchain through the Settings pages, accessed by the gear icon in the top right corner.\n\nGanache Settings\n\nThe Server page shows details about the network connection, including hostname, port, network ID, and whether to automatically mine each transaction into a block.\nThe Accounts &amp; Keys page sets details about the number of accounts created, and whether to use a specific mnemonic or let Ganache generate its own.\nThe Chain page sets details about the actual workings of the generated blockchain, including gas limit and gas price.\nThe Advanced page toggles Google Analytics, which is useful for the Ganache team to track usage of the application.\n\nAfter making changes, you will have to click Restart on the application for the changes to take effect.\n"}}
</script>
<script src="/deps/scripts/lunr.js"></script>
<script src="/scripts/search.js"></script>

          <footer class="container-fluid">
            <p class="text-center">See a way to make this page better? <br class="visible-xs" /><a href="https://github.com/trufflesuite/trufflesuite.com/edit/master/public/docs/search.md">Edit here &rarr;</a></p>
          </footer>
        </div>
      </div>
    </div>
  </section>
</section>

    </main>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
<script async defer src="https://buttons.github.io/buttons.js"></script>
<script src="/scripts/main.js"></script>
<script src="/deps/scripts/prism.js"></script>
<script src="/deps/scripts/collapse.js"></script>
<script src="/deps/scripts/dropdown.js"></script>
<script src="/deps/scripts/lunr.js"></script>
<script src="/scripts/navbar.js"></script>


    
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-83874933-3', 'auto');
    ga('send', 'pageview');
  </script>

  </body>
</html>
