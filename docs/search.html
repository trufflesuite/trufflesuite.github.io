

<!doctype html>
<html lang="en">
    

  <head>
    <meta charset="utf-8">
  
  
    <!-- Fallback for Font family below in noscript [*] -->
    <script type="text/javascript">
      WebFontConfig = {
        google: { families: [ 'Oswald:300,400,700',  'Open+Sans:400,700' ] }
      };
      (function() {
        var wf = document.createElement('script');
        wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
        '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
        wf.type = 'text/javascript';
        wf.async = 'true';
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(wf, s);
      })(); </script>
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="Your Ethereum Swiss Army Knife">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="news_keywords" content="solidity, dapps, contracts, smart contracts" />
    <meta name="standout" content="http://truffleframwork.com" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <meta property="og:site_name" content="Truffle Framework" />
    <meta property="og:description" content="Your Ethereum Swiss Army Knife" />
    <meta property="og:title" content="TruffleFramework.com - Truffle Framework" />
    <meta property="og:url" content="http://truffleframwork.com" />
    <meta property="og:type" content="article" />
    <meta property="og:image" content="https://github.com/trufflesuite/trufflesuite.github.io/raw/master/images/truffle-share.png" />

    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="Truffle Framework" />
    <meta name="twitter:title" content="TruffleFramework.com - Truffle Framework" />
    <meta name="twitter:description" content="Your Ethereum Swiss Army Knife" />
    <meta name="twitter:creator" content="Truffle Framework" />
    <meta name="twitter:domain" content="truffleframework.com" />
    <meta name="twitter:image:src" content="https://github.com/trufflesuite/trufflesuite.github.io/raw/master/images/truffle-share.png" />

    
    

    <title>TruffleFramework.com | Documentation</title>

    <link rel="author" href="humans.txt" />

    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">

    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Truffle Framework">
    <link rel="icon" sizes="192x192" href="images/touch/chrome-touch-icon-192x192.png">

    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Web Starter Kit">
    <link rel="apple-touch-icon" href="images/touch/apple-touch-icon.png">

    <!-- Tile icon for Win8 (144x144 + tile color) -->
    <meta name="msapplication-TileImage" content="images/touch/ms-touch-icon-144x144-precomposed.png">
    <meta name="msapplication-TileColor" content="#3372DF">

    <link rel="stylesheet" href="/styles/main.css">
    
      <noscript>
        <!-- [*] Web fonts for no-js -->
        <link href='http://fonts.googleapis.com/css?family=Oswald:300,400,700%7COpen+Sans:400,700' rel='stylesheet' type='text/css'>
      </noscript>
    
  </head>

  <body class="
    body-docs
    
  ">
    <main>
      <section class="Documentation">
  <nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">
        
<svg class="truffle-logo" width="100%" height="100%" viewBox="655 52 131 128" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <defs>
        <polyline id="path-1" points="0 0.426 130.715 0.426 130.715 128 0 128"></polyline>
        <polygon id="path-3" points="0 0.426 130.715 0.426 130.715 128 0 128"></polygon>
    </defs>
    <g id="Logo" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" transform="translate(655.000000, 52.000000)">
        <!-- Truffle Logo -->

        <path d="M100.8574,99.9258 C100.8574,102.0878 82.8804,103.8378 65.6344,103.8378 C48.3884,103.8378 30.4124,102.0878 30.4124,99.9258 C30.4124,97.7658 48.3884,96.0138 65.6344,96.0138 C82.8804,96.0138 100.8574,97.7658 100.8574,99.9258" id="Fill-1" fill="#E6E7E8"></path>
        <g id="Group-5">
            <mask id="mask-2" fill="white">
                <use xlink:href="#path-1"></use>
            </mask>
            <g id="Clip-4"></g>
            <path d="M117.7813,50.4258 C117.7813,78.0398 95.3943,100.4258 67.7813,100.4258 C51.0803,100.4258 36.2913,92.2378 27.2113,79.6558 C21.2773,71.4358 18.9393,61.3388 18.9403,50.4258 C18.9403,35.2618 24.5313,21.6738 35.1913,12.5048 C43.9433,4.9768 55.3313,0.4258 67.7813,0.4258 C95.3943,0.4258 117.7813,22.8118 117.7813,50.4258" id="Fill-3" fill="#5E464D" mask="url(#mask-2)"></path>
        </g>
        <path d="M53.8936,94.4175 C55.9346,95.0525 62.7846,97.0835 63.0116,94.9175 C63.1366,93.7305 59.5436,92.6085 54.6076,90.1675 C47.5826,86.6945 41.1946,82.2065 35.5246,76.8335 C29.1906,70.8335 22.6076,61.2925 21.8576,47.2925 C21.0476,32.1835 26.6756,19.8005 36.1896,11.6595 C24.9566,20.8285 17.7816,34.7795 17.7816,50.4105 C17.7816,61.3545 21.2466,71.4225 27.2106,79.6565 C29.1966,81.4595 31.3236,83.1725 33.4116,84.6675 C39.0236,88.6875 47.1746,92.3275 53.8936,94.4175" id="Fill-6" fill="#FFFFFF"></path>
        <path d="M118.4668,38.9644 C115.3988,24.5534 105.8718,14.4624 93.1328,7.3374 C102.8738,14.2754 116.5888,29.0214 108.5048,42.0234 C101.6488,52.4484 84.9838,50.4034 75.8768,45.4644 C65.0498,39.5924 51.4838,26.3724 64.8638,13.4504 C73.5248,5.0894 101.1068,14.4644 96.2358,26.9644 C93.4048,34.2294 82.3948,32.6164 77.4388,29.0604 C73.7848,26.4384 70.7128,21.9294 72.3408,17.2754 C72.8628,15.7824 72.7868,13.4654 70.6798,15.1704 C69.1068,16.4434 68.3158,18.5384 68.0398,20.4864 C65.7358,36.7834 94.7688,49.4154 103.3798,33.6494 C107.8508,25.4644 100.6068,13.5894 91.4888,8.7144 C84.6208,5.0424 77.4998,2.4644 68.7578,3.0894 C54.7818,4.0884 43.0478,12.8314 41.5788,27.1154 C40.1228,41.2914 49.5978,54.0844 60.7748,61.7264 C72.5128,69.7534 88.3168,75.0464 102.7678,70.2574 C115.7198,65.9644 121.0708,51.0974 118.4668,38.9644" id="Fill-8" fill="#FFFFFF"></path>
        <path d="M100.2344,27.9272 C101.6234,18.5872 93.1804,12.1762 85.3844,9.2612 C76.1884,5.8212 64.0464,7.3312 57.3504,14.9472 C52.4384,20.5352 52.7724,28.6592 55.2964,35.2182 C59.1144,45.1422 67.7354,52.3152 77.7704,55.4112 C84.9014,57.6132 93.5214,58.5732 100.7504,56.2472 C111.2874,52.8582 114.7194,41.8662 112.5424,31.7982 C112.0734,29.6302 111.3594,27.4952 110.4064,25.4932 C109.0764,22.6982 104.9984,17.0422 110.6194,23.9312 C111.2334,24.6842 111.7204,25.5142 112.2424,26.3332 C113.4294,28.2002 114.2954,30.3142 114.9784,32.4102 C118.0444,41.8102 115.6374,52.7752 107.1294,58.4472 C100.6124,62.7912 92.3294,63.3062 84.7694,62.2222 C74.6384,60.7702 65.0854,55.8372 58.4524,47.9822 C52.3874,40.8022 48.2554,30.4882 50.7474,21.0642 C52.5704,14.1662 58.1724,9.0192 64.8764,6.8492 C73.3604,4.1012 82.6984,5.3762 90.3444,9.8372 C94.1684,12.0682 97.6714,15.1532 99.6164,19.1932 C100.4904,21.0072 100.9934,23.0192 101.0114,25.0352 C101.0184,25.8482 100.9834,26.6872 100.8214,27.4862 C100.7684,27.7782 100.1484,28.6072 100.2344,27.9272" id="Fill-10" fill="#3FE0C5"></path>
    </g>
</svg>

<svg class="truffle-wordmark" width="100%" height="100%" viewBox="655 52 131 128" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <defs>
        <polyline id="path-1" points="0 0.426 130.715 0.426 130.715 128 0 128"></polyline>
        <polygon id="path-3" points="0 0.426 130.715 0.426 130.715 128 0 128"></polygon>
    </defs>
    <g id="Logo" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" transform="translate(655.000000, 52.000000)">
        <!-- Truffle Wordmark -->

        <polygon id="Fill-12" fill="#5F464D" points="0 108.8555 10.321 108.8555 10.321 112.3595 6.919 112.3595 6.919 127.5295 3.313 127.5295 3.313 112.3595 0 112.3595"></polygon>
        <path d="M22.8096,116.1543 L24.9236,116.1543 C26.0536,116.1543 26.8326,116.0063 27.2586,115.7093 C27.6846,115.4123 27.8976,114.9203 27.8976,114.2303 C27.8976,113.8243 27.7916,113.4683 27.5806,113.1683 C27.3706,112.8673 27.0876,112.6503 26.7336,112.5173 C26.3796,112.3863 25.7296,112.3203 24.7846,112.3203 L22.8096,112.3203 L22.8096,116.1543 Z M19.2546,108.8553 L24.0216,108.8553 C26.0836,108.8553 27.5536,109.0393 28.4286,109.4063 C29.3026,109.7753 30.0066,110.3863 30.5396,111.2423 C31.0716,112.0953 31.3386,113.1073 31.3386,114.2753 C31.3386,115.5043 31.0436,116.5293 30.4556,117.3533 C29.8686,118.1793 28.9816,118.8043 27.7966,119.2263 L32.2206,127.5293 L28.3346,127.5293 L24.1356,119.6213 L22.8096,119.6213 L22.8096,127.5293 L19.2546,127.5293 L19.2546,108.8553 Z" id="Fill-14" fill="#5F464D"></path>
        <g id="Group-18">
            <mask id="mask-4" fill="white">
                <use xlink:href="#path-3"></use>
            </mask>
            <g id="Clip-17"></g>
            <path d="M41.2588,108.8555 L44.8258,108.8555 L44.8258,120.9315 C44.8258,121.9705 44.9168,122.7075 45.0988,123.1385 C45.2808,123.5705 45.5808,123.9145 46.0008,124.1715 C46.4188,124.4295 46.9248,124.5585 47.5178,124.5585 C48.1438,124.5585 48.6838,124.4165 49.1358,124.1265 C49.5888,123.8395 49.9028,123.4745 50.0748,123.0315 C50.2488,122.5855 50.3358,121.7385 50.3358,120.4865 L50.3358,108.8555 L53.9038,108.8555 L53.9038,119.9885 C53.9038,121.8675 53.7978,123.1715 53.5858,123.8985 C53.3738,124.6265 52.9698,125.3305 52.3738,126.0055 C51.7768,126.6835 51.0888,127.1855 50.3108,127.5095 C49.5318,127.8355 48.6258,128.0005 47.5938,128.0005 C46.2388,128.0005 45.0618,127.6875 44.0578,127.0665 C43.0558,126.4435 42.3378,125.6665 41.9058,124.7305 C41.4748,123.7945 41.2588,122.2145 41.2588,119.9885 L41.2588,108.8555 Z" id="Fill-16" fill="#5F464D" mask="url(#mask-4)"></path>
        </g>
        <polygon id="Fill-19" fill="#5F464D" points="64.6611 108.8555 73.9281 108.8555 73.9281 112.3205 68.1891 112.3205 68.1891 115.7105 73.9281 115.7105 73.9281 119.1255 68.1891 119.1255 68.1891 127.5295 64.6611 127.5295"></polygon>
        <polygon id="Fill-21" fill="#5F464D" points="83.7676 108.8555 93.0356 108.8555 93.0356 112.3205 87.2966 112.3205 87.2966 115.7105 93.0356 115.7105 93.0356 119.1255 87.2966 119.1255 87.2966 127.5295 83.7676 127.5295"></polygon>
        <polygon id="Fill-23" fill="#5F464D" points="102.8398 108.8555 106.3948 108.8555 106.3948 124.1405 111.5738 124.1405 111.5738 127.5295 102.8398 127.5295"></polygon>
        <polygon id="Fill-25" fill="#5F464D" points="120.5205 108.8555 130.7145 108.8555 130.7145 112.3345 124.0495 112.3345 124.0495 115.7105 130.7145 115.7105 130.7145 119.1255 124.0495 119.1255 124.0495 124.0395 130.7145 124.0395 130.7145 127.5295 120.5205 127.5295"></polygon>
    </g>
</svg>

      </a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav navbar-right">
        <li><a href="/">Home</a></li>
        <li><a href="/docs">Documentation</a></li>
        <li><a href="/boxes">Boxes</a></li>
        <li><a href="/blog">Blog</a></li>
        <li><a href="/tutorials">Tutorials</a></li>
        <li><a href="/support">Support</a></li>
        <li><a href="/community">Community</a></li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container-fluid -->
</nav>

  <section class="MainContent">
    <div class="container-fluid">
      <div class="row">
        <div class="col-xs-12 col-md-3 SubNav">
          <form class="DocSearchForm" action='/docs/search#results' method='get'>
            <label for="search-box" class="sr-only">Search</label>

            <div class="input-group">
              <input class="form-control" type="text" id="search-box" name="query" placeholder="Search the Docs">
              <span class="input-group-btn">
                <input class="btn btn-primary btn-sm" type="submit" value="search">
              </span>
            </div>
          </form>
          
          

          <ul class="list-unstyled">
                          <h2>Getting Started</h2>
                                    <li>
              <ul class="list-unstyled">
                                  
                <li class=""><a href="/docs/getting_started/installation">Installation</a></li>
                                
                <li class=""><a href="/docs/getting_started/client">Choosing an Ethereum client</a></li>
                                
                <li class=""><a href="/docs/getting_started/project">Creating a project</a></li>
                                
                <li class=""><a href="/docs/getting_started/compile">Compiling contracts</a></li>
                                
                <li class=""><a href="/docs/getting_started/migrations">Running migrations</a></li>
                                
                <li class=""><a href="/docs/getting_started/testing">Testing your contracts</a></li>
                                
                <li class=""><a href="/docs/getting_started/javascript-tests">Writing tests in Javascript</a></li>
                                
                <li class=""><a href="/docs/getting_started/solidity-tests">Writing tests in Solidity</a></li>
                                
                <li class=""><a href="/docs/getting_started/contracts">Interacting with your contracts</a></li>
                                
                <li class=""><a href="/docs/getting_started/packages-ethpm">Package management via EthPM</a></li>
                                
                <li class=""><a href="/docs/getting_started/packages-npm">Package management via NPM</a></li>
                                
                <li class=""><a href="/docs/getting_started/console">Using the console</a></li>
                                
                <li class=""><a href="/docs/getting_started/scripts">Writing external scripts</a></li>
                                
                <li class=""><a href="/docs/getting_started/build">Using the build pipeline</a></li>
                                
                <li class=""><a href="/docs/getting_started/contact">Contact the developers</a></li>
                            </ul>
            </li>
                        <h2>Advanced</h2>
                                    <li>
              <ul class="list-unstyled">
                                  
                <li class=""><a href="/docs/advanced/configuration">Configuration</a></li>
                                
                <li class=""><a href="/docs/advanced/networks">Networks &amp; App Deployment</a></li>
                                
                <li class=""><a href="/docs/advanced/build_processes">Build Processes</a></li>
                                
                <li class=""><a href="/docs/advanced/commands">Command Reference</a></li>
                                
                <li class=""><a href="/docs/advanced/truffle-boxes">Truffle Boxes</a></li>
                                
                <li class=""><a href="/docs/advanced/truffle-with-metamask">Truffle with MetaMask</a></li>
                            </ul>
            </li>
          
          </ul>
        </div>
        <div class="col-xs-12 col-md-9 col-md-offset-3 ContentPage">
          <a name="results">Search Results</a>
<p>Here are the following matches for: <span class="queryTerm"></span></p>
<ul id="search-results"></ul>



<script>
window.store = {"installation":{"id":"installation","title":"Installation","path":"getting_started/installation","content":"&nbsp;Installation $ npm install -g truffle\n&nbsp;Requirements\nNodeJS 5.0+ recommended.\nWindows, Linux or Mac OS X\n\nTruffle also requires that you have a running Ethereum client which supports the standard JSON RPC API (which is nearly all of them). There are many to choose from, and some better than others for development. We&#39;ll discuss them in detail in the next section.\n&nbsp;Recommendations for WindowsIf you&#39;re running Truffle on Windows, you may encounter some naming conflicts that could prevent Truffle from executing properly. Please see the section on resolving naming conflicts for solutions.\n"},"client":{"id":"client","title":"Choosing an Ethereum client","path":"getting_started/client","content":"There are many Ethereum clients to choose from. We recommend using different clients when developing and deploying.\n&nbsp;When Developing \nEthereumJS TestRPC: https://github.com/ethereumjs/testrpc\n\nWhen developing your Truffle-based application, we recommend using the EthereumJS TestRPC. It&#39;s a complete blockchain-in-memory that runs only on your development machine. It processes transactions instantly instead of waiting for the default block time -- so you can test that your code works quickly -- and it tells you immediately when your smart contracts run into errors. It also makes a great client for automated testing, and Truffle knows how to use its special features to speed up test runtime by almost 90%.\n&nbsp;When Deploying to Live Networks\nGeth (go-ethereum): https://github.com/ethereum/go-ethereum\nWebThree (cpp-ethereum): https://github.com/ethereum/cpp-ethereum\nParity: https://github.com/paritytech/parity\nMore: https://www.ethereum.org/cli\n\nThere are many official and unofficial Ethereum clients available for you to use. You should use these clients after you&#39;ve sufficiently tested your dapp with the EthereumJS TestRPC and you&#39;re ready to deploy to your desired Ethereum network. These are full client implementations that include mining, networking, blocks and transaction processing, and Truffle can deploy to these clients without any extra configuration.\n&nbsp;When Deploying to Private NetworksPrivate networks utilize the same technology but with a different configuration. So you can configure any of the Ethereum clients mentioned above to run a private network, and deploy to it in exactly the same way.\n"},"project":{"id":"project","title":"Creating a project","path":"getting_started/project","content":"&nbsp;Create a Project Folder First create a project folder. You can do this through your favorite file explorer or by running the following on the command line:\n$ mkdir myproject\n\n&nbsp;Initialize Your ProjectNext, initialize your Truffle project by performing the following in the command line:\n$ cd myproject\n$ truffle init\n\nOnce completed, you&#39;ll now have a project structure with the following items:\n\ncontracts/ - directory where Truffle expects to find solidity contracts.\nmigrations/ - directory to place scriptable deployment files.\ntest/ - location of test files for testing your application and contracts.\ntruffle.js - your main Truffle configuration file.\n\n&nbsp;Default Contracts: MetaCoinBy default, truffle init gives you a set of example contracts (MetaCoin and ConvertLib) which act like a simple alt-coin built on top of Ethereum. You can use these contracts to learn quickly while navigating through the Getting Started guide, or delete these files and build a project of your own.\n&nbsp;Truffle BoxesBy default, truffle init creates a simple project for you so you can get familiar with writing, compiling and deploying Solidity-based smart contracts. However, we have many boilerplates and example applications available to you via the truffle unbox command that help you build complex applications quickly. Check all of our Truffle Boxes to get started.\n"},"compile":{"id":"compile","title":"Compiling contracts","path":"getting_started/compile","content":"&nbsp;Location All of your contracts are located in the ./contracts directory. By default you&#39;re given an example Solidity contract file and an example Solidity library file, both with filenames ending in .sol. Although a Solidity library is different than a contract, for documentation purposes we&#39;re going to lump these into the same word, &quot;contracts&quot;.\n&nbsp;CommandTo compile your contracts, simply run:\n$ truffle compile\n\nTruffle will compile only the contracts that have been changed since the last compile, to reduce any unnecessary compilation. If you&#39;d like to override this behavior, run the above command with the --all option.\n&nbsp;ArtifactsArtifacts of your compilation will be placed in the ./build/contracts directory, relative to your project. This directory will be created if it does not exist. These artifacts are integral to the inner workings of Truffle, and they play an important part in the successful deployment of your application. You should not edit these files by hand as they&#39;ll be overwritten by contract compilation and deployment.\n&nbsp;DependenciesYou can declare contract dependencies using Solidity&#39;s import command. Truffle will compile contracts in the correct order and ensure all dependencies are sent to the compiler. Dependencies can be specified in two ways:\n&nbsp;Importing dependencies via their file name:To import contracts from a separate file, simply write the following command, where AnotherContract.sol is relative to the current contract being written. This will make all contracts within AnotherContract.sol available to the current source file.\nimport &quot;./AnotherContract.sol&quot;;\nNote that Solidity allows other import syntaxes as well. See their import documentation for more information.\n&nbsp;Importing contracts from an external packageTruffle supports dependencies installed via NPM as well as EthPM. To import contracts from a dependency, use the following syntax, where somepackage represents a package installed via NPM or EthPM, and /SomeContract.sol represents a path to a Solidity source file provided by that package.\nimport &quot;somepackage/SomeContract.sol&quot;;\nNote that Truffle will search installed packages from EthPM first before searching for packages installed from NPM, so in the rare case of a naming conflict the package installed via EthPM will be used.\nFor more information on how to use Truffle&#39;s package management features, please see Truffle&#39;s NPM and EthPM documentation, respectively.\n"},"migrations":{"id":"migrations","title":"Running migrations","path":"getting_started/migrations","content":"Migrations are Javascript files that help you deploy contracts to the Ethereum network. These files are responsible for staging your deployment tasks, and they&#39;re written under the assumption that your deployment needs will change over time. As your project evolves, you&#39;ll create new migration scripts to further this evolution on the blockchain. A history of previously run migrations is recorded on-chain through a special Migrations contract, detailed below.\n&nbsp;Command To run your migrations, run the following:\n$ truffle migrate\n\nThis will run all migrations located within your project&#39;s migrations directory. At their simplest, migrations are simply a set of managed deployment scripts. If your migrations were previously run successfully, truffle migrate will start execution from the last migration that was ran, running only newly created migrations. If no new migrations exists, truffle migrate won&#39;t perform any action at all. You can use the --reset option to run all your migrations from the beginning. For local testing make sure to have TestRPC installed and running before running migrate.\n&nbsp;Migration FilesA simple migration file looks like this:\nFilename: 4_example_migration.js\nvar MyContract = artifacts.require(&quot;MyContract&quot;);\n\nmodule.exports = function(deployer) {\n  // deployment steps\n  deployer.deploy(MyContract);\n};\n\nNote that the filename is prefixed with a number and is suffixed by a description. The numbered prefix is required in order to record whether the migration ran successfully. The suffix is purely for human readability and comprehension.\n&nbsp;artifacts.require()At the beginning of the migration, we tell Truffle which contracts we&#39;d like to interact with via the artifacts.require() method. This method is similar to Node&#39;s require, but in our case it specifically returns a contract abstraction that we can use within the rest of our deployment script. The name specified does not have to match the filename of your contract source files. Instead, it should match the name of the contract definition within that source file. Consider this example where two contracts are specified within the same source file:\nFilename: ./contracts/Contracts.sol\n\ncontract ContractOne {\n  // ...\n}\n\ncontract ContractTwo {\n  // ...\n}\n\nTo use only ContractTwo, your artifacts.require() statement would look like this:\nvar ContractTwo = artifacts.require(&quot;ContractTwo&quot;);\n&nbsp;module.exportsAll migrations must export a function via the module.exports syntax. The function exported by each migration should accept a deployer object as its first parameter. This object aides in deployment by both providing a clear syntax for deploying smart contracts as well as performing some of deployment&#39;s more mundane duties, such as saving deployed artifacts for later use. The deployer object is your main interface for staging deployment tasks, and its API is described at the bottom of this page.\nYour migration function can accept other parameters as well. See the examples below.\n&nbsp;Initial MigrationTruffle requires you to have a Migrations contract in order to use the Migrations feature. This contract must contain a specific interface, but you&#39;re free to edit this contract at will. For most projects, this contract will be deployed initially as the first migration and won&#39;t be updated again. You will also receive this contract by default when creating a new project with truffle init.\nFilename: contracts/Migrations.sol\npragma solidity ^0.4.8;\n\ncontract Migrations {\n  address public owner;\n\n  // A function with the signature `last_completed_migration()`, returning a uint, is required.\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function Migrations() {\n    owner = msg.sender;\n  }\n\n  // A function with the signature `setCompleted(uint)` is required.\n  function setCompleted(uint completed) restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\nYou must deploy this contract inside your first migration in order to take advantage of the Migrations feature. To do so, create the following migration:\nFilename: migrations/1_initial_migration.js\nvar Migrations = artifacts.require(&quot;Migrations&quot;);\n\nmodule.exports = function(deployer) {\n  // Deploy the Migrations contract as our only task\n  deployer.deploy(Migrations);\n};\n\nFrom here, you can create new migrations with increasing numbered prefixes to deploy other contracts and perform further deployment steps.\n&nbsp;DeployerYour migration files will use the deployer to stage deployment tasks. As such, you can write deployment tasks synchronously and they&#39;ll be executed in the correct order:\n// Stage deploying A before B\ndeployer.deploy(A);\ndeployer.deploy(B);\n\nAlternatively, each function on the deployer can be used as a Promise, to queue up deployment tasks that depend on the execution of the previous task:\n// Deploy A, then deploy B, passing in A&#39;s newly deployed address\ndeployer.deploy(A).then(function() {\n  return deployer.deploy(B, A.address);\n});\n\nIt is possible to write your deployment as a single promise chain if you find that syntax to be more clear. The deployer API is discussed at the bottom of this page.\n&nbsp;Network ConsiderationsIt is possible to run deployment steps conditionally based on the network being deployed to. This is an advanced feature, so see the Networks section first before continuing.\nTo conditionally stage deployment steps, write your migrations so that they accept a second parameter, called network. Example:\nmodule.exports = function(deployer, network) {\n  if (network == &quot;live&quot;) {\n    // Do something specific to the network named &quot;live&quot;.\n  } else {\n    // Perform a different step otherwise.\n  }\n}\n\n&nbsp;Available AccountsMigrations are also passed the list of accounts provided to you by your Ethereum client and web3 provider, for you to use during your deployments. This is the exact same list of accounts returned from web3.eth.getAccounts().\nmodule.exports = function(deployer, network, accounts) {\n  // Use the accounts within your migrations.\n}\n\n&nbsp;Deployer APIThe deployer contains many functions available to simplify your migrations.\n&nbsp;deployer.deploy(contract, args..., options)Deploy a specific contract, specified by the contract object, with optional constructor arguments. This is useful for singleton contracts, such that only one instance of this contract exists for your dapp. This will set the address of the contract after deployment (i.e., Contract.address will equal the newly deployed address), and it will override any previous address stored.\nYou can optionally pass an array of contracts, or an array of arrays, to speed up deployment of multiple contracts. Additionally, the last argument is an optional object that observes a single key, overwrite. If overwrite is set to false, the deployer won&#39;t deploy this contract if one has already been deployed. This is useful for certain circumstances where a contract address is provided by an external dependency.\nNote that you will need to deploy and link any libraries your contracts depend on first before calling deploy. See the link function below for more details.\nExamples:\n// Deploy a single contract without constructor arguments\ndeployer.deploy(A);\n\n// Deploy a single contract with constructor arguments\ndeployer.deploy(A, arg1, arg2, ...);\n\n// Deploy multiple contracts, some with arguments and some without.\n// This is quicker than writing three `deployer.deploy()` statements as the deployer\n// can perform the deployment as a single batched request.\ndeployer.deploy([\n  [A, arg1, arg2, ...],\n  B,\n  [C, arg1]\n]);\n\n// External dependency example:\n//\n// For this example, our dependency provides an address when we&#39;re deploying to the\n// live network, but not for any other networks like testing and development.\n// When we&#39;re deploying to the live network we want it to use that address, but in\n// testing and development we need to deploy a version of our own. Instead of writing\n// a bunch of conditionals, we can simply use the `overwrite` key.\ndeployer.deploy(SomeDependency, {overwrite: false});\n\n&nbsp;deployer.link(library, destinations)Link an already-deployed library to a contract or multiple contracts. destinations can be a single contract or an array of multiple contracts. If any contract within the destination doesn&#39;t rely on the library being linked, the deployer will ignore that contract.\nExample:\n// Deploy library LibA, then link LibA to contract B, then deploy B.\ndeployer.deploy(LibA);\ndeployer.link(LibA, B);\ndeployer.deploy(B);\n\n// Link LibA to many contracts\ndeployer.link(LibA, [B, C, D]);\n\n&nbsp;deployer.then(function() {...})Just like a promise, run an arbitrary deployment step. Use this to call specific contract functions during your migration to add, edit and reorganize contract data.\nExample:\nvar a, b;\ndeployer.then(function() {\n  // Create a new version of A\n  return A.new();\n}).then(function(instance) {\n  a = instance;\n  // Get the deployed instance of B\n  return B.deployed():\n}).then(function(instance) {\n  b = instance;\n  // Set the new instance of A&#39;s address on B via B&#39;s setA() function.\n  return b.setA(a.address);\n});\n\n"},"testing":{"id":"testing","title":"Testing your contracts","path":"getting_started/testing","content":"&nbsp;Framework Truffle comes standard with an automated testing framework to make testing your contracts a breeze. This framework lets you write simple and manageable tests in two different ways:\n\nIn Javascript, for exercising your contracts from the outside world, just like your application.\nIn Solidity, for exercising your contracts in advanced, bare-to-the-metal scenarios.\n\nBoth styles of tests have their advantages and drawbacks. See the next two sections for a discussion of each one.\n&nbsp;LocationAll test files should be located in the ./test directory. Truffle will only run test files with the following file extensions: .js, .es, .es6, and .jsx, and .sol. All other files are ignored.\n&nbsp;CommandTo run all tests, simply run:\n$ truffle test\nAlternatively, you can specify a path to a specific file you want to run, e.g.,\n$ truffle test ./path/to/test/file.js\n\n&nbsp;Clean-room EnvironmentTruffle provides a clean room environment when running your test files. When running your tests against the TestRPC, Truffle will use the TestRPC&#39;s advanced snapshotting features to ensure your test files don&#39;t share state with each other. When running against other Ethereum clients like go-ethereum, Truffle will re-deploy all of your migrations at the beginning of every test file to ensure you have a fresh set of contracts to test against.\n&nbsp;Speed &amp; Reliability ConsiderationsThe EthereumJS TestRPC is significantly faster than other clients when running automated tests. Moreover, the TestRPC contains special features which Truffle takes advantage of to speed up test runtime by almost 90%. As a general workflow, we recommend you use the TestRPC during normal development and testing, and then run your tests once against go-ethereum or another official Ethereum client when you&#39;re gearing up to deploy to live or production networks.\n"},"javascript-tests":{"id":"javascript-tests","title":"Writing tests in Javascript","path":"getting_started/javascript-tests","content":"&nbsp;Writing Tests in Javascript Truffle uses the Mocha testing framework and Chai for assertions to provide you with a solid framework from which to write your Javascript tests. Let&#39;s dive in and see how Truffle builds on top of Mocha to make testing your contracts a breeze.\nNote: If you&#39;re unfamiliar with writing unit tests in Mocha, please see Mocha&#39;s documentation before continuing.\n&nbsp;Use contract() instead of describe()Structurally, your tests should remain largely unchanged from that of Mocha: Your tests should exist in the ./test directory, they should end with a .js extension, and they should contain code that Mocha will recognize as an automated test. What makes Truffle tests different from that of Mocha is the contract() function: This function works exactly like describe() except it enables Truffle&#39;s clean-room features. It works like this:\n\nBefore each contract() function is run, your contracts are redeployed to the running Ethereum client so the tests within it run with a clean contract state.\nThe contract() function provides a list of accounts made available by your Ethereum client which you can use to write tests.\n\nSince Truffle uses Mocha under the hood, you can still use describe() to run normal Mocha tests whenever Truffle clean-room features are unnecessary.\n&nbsp;Use contract abstractions within your testsContract abstractions are the basis for making contract interaction possible from Javascript (they&#39;re basically our flux capacitor). Because Truffle has no way of detecting which contracts you&#39;ll need to interact with within your tests, you&#39;ll need to ask for those contracts explicitly. You do this by using the artifacts.require() method, a method provided by Truffle that allows you to request a usable contract abstraction for a specific Solidity contract. As you&#39;ll see in the example below, you can then use this abstraction to make sure your contracts are working properly.\nFor more information on using contract abstractions, see the Interacting With Your Contracts section.\n&nbsp;Using artifacts.require()Using artifacts.require() within your tests is the exact same as using it within your migrations. See the artifacts.require() documentation within the Migrations section for detailed usage.\n&nbsp;Using web3A web3 instance is available in each test file, configured to the correct provider. So calling web3.eth.getBalance just works!\n&nbsp;ExampleHere&#39;s an example test provided to you by truffle init. Note the use of the contract() function, the accounts array for specifying available Ethereum accounts, and our use of artifacts.require() for interacting directly with our contracts.\nFile: ./test/metacoin.js\n// Specifically request an abstraction for MetaCoin\nvar MetaCoin = artifacts.require(&quot;MetaCoin&quot;);\n\ncontract(&#39;MetaCoin&#39;, function(accounts) {\n  it(&quot;should put 10000 MetaCoin in the first account&quot;, function() {\n    return MetaCoin.deployed().then(function(instance) {\n      return instance.getBalance.call(accounts[0]);\n    }).then(function(balance) {\n      assert.equal(balance.valueOf(), 10000, &quot;10000 wasn&#39;t in the first account&quot;);\n    });\n  });\n  it(&quot;should send coin correctly&quot;, function() {\n    var meta;\n\n    // Get initial balances of first and second account.\n    var account_one = accounts[0];\n    var account_two = accounts[1];\n\n    var account_one_starting_balance;\n    var account_two_starting_balance;\n    var account_one_ending_balance;\n    var account_two_ending_balance;\n\n    var amount = 10;\n\n    return MetaCoin.deployed().then(function(instance) {\n      meta = instance;\n      return meta.getBalance.call(account_one);\n    }).then(function(balance) {\n      account_one_starting_balance = balance.toNumber();\n      return meta.getBalance.call(account_two);\n    }).then(function(balance) {\n      account_two_starting_balance = balance.toNumber();\n      return meta.sendCoin(account_two, amount, {from: account_one});\n    }).then(function() {\n      return meta.getBalance.call(account_one);\n    }).then(function(balance) {\n      account_one_ending_balance = balance.toNumber();\n      return meta.getBalance.call(account_two);\n    }).then(function(balance) {\n      account_two_ending_balance = balance.toNumber();\n\n      assert.equal(account_one_ending_balance, account_one_starting_balance - amount, &quot;Amount wasn&#39;t correctly taken from the sender&quot;);\n      assert.equal(account_two_ending_balance, account_two_starting_balance + amount, &quot;Amount wasn&#39;t correctly sent to the receiver&quot;);\n    });\n  });\n});\n\nThis test will produce the following output:\nUsing network &#39;development&#39;.\n\n  Contract: MetaCoin\n    ✓ should put 10000 MetaCoin in the first account\n    ✓ should send coin correctly\n\n  2 passing (113ms)\nYou can limit the tests being executed to a specific file as follows:\ntruffle test ./test/metacoin.js\n&nbsp;AdvancedTruffle gives you access to Mocha&#39;s configuration so you can change how Mocha behaves. See the project configuration section for more details.\n"},"solidity-tests":{"id":"solidity-tests","title":"Writing tests in Solidity","path":"getting_started/solidity-tests","content":"&nbsp;Writing Tests in Solidity Solidity test contracts live alongside Javascript tests as .sol files. When truffle test is run, they will be included as a separate test suite per test contract. These contracts maintain all the benefits of the Javascript tests: namely a clean-room environment per test suite, direct access to your deployed contracts and the ability to import any contract dependency. In addition to these features, Truffle&#39;s Solidity testing framework was built with the following issues in mind:\n\nSolidity tests shouldn&#39;t extend from any contract (like a Test contract). This makes your tests as minimal as possible and gives you complete control over the contracts you write.\nSolidity tests shouldn&#39;t be beholden to any assertion library. Truffle provides a default assertion library for you, but you can change this library at any time to fit your needs.\nYou should be able to run your Solidity tests against any Ethereum client.\n\n&nbsp;ExampleLet&#39;s take a look at an example Solidity test before diving too deeply. Here&#39;s the example Solidity test provided for you by truffle init:\nimport &quot;truffle/Assert.sol&quot;;\nimport &quot;truffle/DeployedAddresses.sol&quot;;\nimport &quot;../contracts/MetaCoin.sol&quot;;\n\ncontract TestMetacoin {\n  function testInitialBalanceUsingDeployedContract() {\n    MetaCoin meta = MetaCoin(DeployedAddresses.MetaCoin());\n\n    uint expected = 10000;\n\n    Assert.equal(meta.getBalance(tx.origin), expected, &quot;Owner should have 10000 MetaCoin initially&quot;);\n  }\n\n  function testInitialBalanceWithNewMetaCoin() {\n    MetaCoin meta = new MetaCoin();\n\n    uint expected = 10000;\n\n    Assert.equal(meta.getBalance(tx.origin), expected, &quot;Owner should have 10000 MetaCoin initially&quot;);\n  }\n}\n\nThis produces the following output:\n$ truffle test\nCompiling ConvertLib.sol...\nCompiling MetaCoin.sol...\nCompiling truffle/Assert.sol\nCompiling truffle/DeployedAddresses.sol\nCompiling ../test/TestMetacoin.sol...\n\n  TestMetacoin\n    ✓ testInitialBalanceUsingDeployedContract (61ms)\n    ✓ testInitialBalanceWithNewMetaCoin (69ms)\n\n  2 passing (3s)\n&nbsp;Test StructureTo better understand whats happening, let&#39;s discuss things in more detail.\n&nbsp;AssertionsYour assertion functions like Assert.equal() are provided to you by the truffle/Assert.sol library. This is the default assertion library, however you can include your own assertion library so long as the library loosely integrates with Truffle&#39;s test runner by triggering the correct assertion events. You can find all available assertion functions in Assert.sol.\n&nbsp;Deployed AddressesThe addresses of your deployed contracts (i.e., contracts that were deployed as part of your migrations) are available through the truffle/DeployedAddresses.sol library. This is provided by Truffle and is recompiled and relinked before each suite is run to provide your tests with Truffle&#39;s a clean room environment. This library provides functions for all of your deployed contracts, in the form of:\nDeployedAddresses.&lt;contract name&gt;();\n\nThis will return an address that you can then use to access that contract. See the example test above for usage.\nIn order to use the deployed contract, you&#39;ll have to import the contract code into your test suite. Notice import &quot;../contracts/MetaCoin.sol&quot;; in the example. This import is relative to the test contract, which exists in the ./test directory, and it goes outside of the test directory in order to find the MetaCoin contract. It then uses that contract to cast the address to the MetaCoin type.\n&nbsp;Test Contract NamesAll test contracts must start with Test, using an uppercase T. This distinguishes this contract apart from test helpers and project contracts (i.e., the contracts under test), letting the test runner know which contracts represent test suites.\n&nbsp;Test Function NamesLike test contract names, all test functions must start with test, lowercase. Each test function is executed as a single transaction, in order of appearance in the test file (like your Javascript tests). Assertion functions provided by truffle/Assert.sol trigger events that the test runner evaluates to determine the result of the test. Assertion functions return a boolean representing the outcome of the assertion which you can use to return from the test early to prevent execution errors (i.e, errors that the TestRPC will expose).\n&nbsp;before / after hooksYou are provided many test hooks, shown in the example below. These hooks are beforeAll, beforeEach, afterAll and afterEach, which are the same hooks provided by Mocha in your Javascript tests. You can use these hooks to perform setup and teardown actions before and after each test, or before and after each suite is run. Like test functions, each hook is executed as a single transaction. Note that some complex tests will need to perform a significant amount of setup that might overflow the gas limit of a single transaction; you can get around this limitation by creating many hooks with different suffixes, like in the example below:\nimport &quot;truffle/Assert.sol&quot;;\n\ncontract TestHooks {\n  uint someValue;\n\n  function beforeEach() {\n    someValue = 5;\n  }\n\n  function beforeEachAgain() {\n    someValue += 1;\n  }\n\n  function testSomeValueIsSix() {\n    uint expected = 6;\n\n    Assert.equal(someValue, expected, &quot;someValue should have been 6&quot;);\n  }\n}\n\nThis test contract also shows that your test functions and hook functions all share the same contract state. You can setup contract data before the test, use that data during the test, and reset it afterward in preparation for the next one. Note that just like your Javascript tests, your next test function will continue from the state of the previous test function that ran.\n&nbsp;Advanced FeaturesSolidity tests come with a few advanced features to let you test specific use cases within Solidity.\n&nbsp;Testing for exceptionsYou can easily test if your contract should or shouldn&#39;t raise an exception (i.e., for require()/assert()/revert() statements; throw on previous versions of Solidity).\nThis topic was first written about by guest writer Simon de la Rouviere in his tutorial Testing for Throws in Truffle Solidity Tests.  N.B. that the tutorial makes heavy use of exceptions via the deprecated keyword throw, replaced by revert(), require(), and assert() starting in Solidity v0.4.13.\n&nbsp;Testing Ether transactionsYou can also test how your contracts react to receiving Ether, and script that interaction within Solidity. To do so, your Solidity test should have a public function that returns a uint, called initialBalance. This can be written directly as a function or a public variable, as shown below. When your test contract is deployed to the network, Truffle will send that amount of Ether from your test account to your test contract. Your test contract can then use that Ether to script Ether interactions within your contract under test. Note that initialBalance is optional and not required.\nimport &quot;truffle/Assert.sol&quot;;\nimport &quot;truffle/DeployedAddresses.sol&quot;;\nimport &quot;../contracts/MyContract.sol&quot;;\n\ncontract TestContract {\n  // Truffle will send the TestContract one Ether after deploying the contract.\n  uint public initialBalance = 1 ether;\n\n  function testInitialBalanceUsingDeployedContract() {\n    MyContract myContract = MyContract(DeployedAddresses.MyContract());\n\n    // perform an action which sends value to myContract, then assert.\n    myContract.send(...);\n  }\n\n  function () {\n    // This will NOT be executed when Ether is sent. \\o/\n  }\n}\n\nNote that Truffle sends Ether to your test contract in a way that does not execute a fallback function, so you can still use the fallback function within your Solidity tests for advanced test cases.\n"},"contracts":{"id":"contracts","title":"Interacting with your contracts","path":"getting_started/contracts","content":"&nbsp;Introduction If you were writing raw requests to the Ethereum network yourself in order to interact with your contracts, you&#39;d soon realize that writing these requests is clunky and cumbersome. As well, you might find that managing the state each request you&#39;ve made is complicated. Fortunately, Truffle takes care of this complexity for you, to make interacting with your contracts a breeze.\n&nbsp;Reading &amp; Writing DataThe Ethereum network makes a distinction between writing data to the network and reading data from it, and this distinction plays a significant part in how you write your application. In general, writing data is called a transaction whereas reading data is called a call. Transactions and calls are treated very differently, and have the following characteristics.\n&nbsp;TransactionsTransactions fundamentally change the state of the network. A transaction can be as simple as sending Ether to another account, or as complicated as executing a contract function or adding a new contract to the network. The defining characteristic of a transaction is that it writes (or changes) data. Transactions cost Ether to run, known as &quot;gas&quot;, and transactions take time to process. When you execute a contract&#39;s function via a transaction, you cannot receive that function&#39;s return value because the transaction isn&#39;t processed immediately. In general, functions meant to be executed via a transaction will not return a value; they will return a transaction id instead. So in summary, transactions:\n\nCost gas (Ether)\nChange the state of the network\nAren&#39;t processed immediately\nWon&#39;t expose a return value (only a transaction id).\n\n&nbsp;CallsCalls, on the other hand, are very different. Calls can be used to execute code on the network, though no data will be permanently changed. Calls are free to run, and their defining characteristic is that they read data. When you execute a contract function via a call you will receive the return value immediately. In summary, calls:\n\nAre free (do not cost gas)\nDo not change the state of the network\nAre processed immediately\nWill expose a return value (hooray!)\n\nChoosing between a transaction and a call is as simple as deciding whether you want to read data, or write it.\n&nbsp;Introducing AbstractionsContract abstractions are the bread and butter of interacting with Ethereum contracts from Javascript. In short, contract abstractions are wrapper code that makes interaction with your contracts easy, in a way that lets you forget about the many engines and gears executing under the hood. Truffle uses its own contract abstraction via the truffle-contract module, and it is this contract abstraction that&#39;s described below.\nIn order to appreciate the usefulness of a contract abstraction, however, we first need a contract to talk about. We&#39;ll use the MetaCoin contract provided for you by default via truffle init.\npragma solidity ^0.4.2;\n\nimport &quot;./ConvertLib.sol&quot;;\n\n// This is just a simple example of a coin-like contract.\n// It is not standards compatible and cannot be expected to talk to other\n// coin/token contracts. If you want to create a standards-compliant\n// token, see: https://github.com/ConsenSys/Tokens. Cheers!\n\ncontract MetaCoin {\n    mapping (address =&gt; uint) balances;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    function MetaCoin() {\n        balances[tx.origin] = 10000;\n    }\n\n    function sendCoin(address receiver, uint amount) returns(bool sufficient) {\n        if (balances[msg.sender] &lt; amount) return false;\n        balances[msg.sender] -= amount;\n        balances[receiver] += amount;\n        Transfer(msg.sender, receiver, amount);\n        return true;\n    }\n\n    function getBalanceInEth(address addr) returns(uint){\n        return ConvertLib.convert(getBalance(addr),2);\n    }\n\n    function getBalance(address addr) returns(uint) {\n        return balances[addr];\n    }\n}\n\nThis contract has three methods aside from the constructor (sendCoin, getBalanceInEth, and getBalance). All three methods can be executed as either a transaction or a call.\nNow let&#39;s look at the Javascript object called MetaCoin provided for us by Truffle, as made available in the Truffle console:\n// Print the deployed version of MetaCoin.\n// Note that getting the deployed version requires a promise, hence the .then.\nMetaCoin.deployed().then(function(instance) {\n  console.log(instance);\n});\n\n// outputs:\n//\n// Contract\n// - address: &quot;0xa9f441a487754e6b27ba044a5a8eb2eec77f6b92&quot;\n// - allEvents: ()\n// - getBalance: ()\n// - getBalanceInEth: ()\n// - sendCoin: ()\n// ...\n\nNotice that the abstraction contains the exact same functions that exist within our contract. It also contains an address which points to the deployed version of the MetaCoin contract.\n&nbsp;Executing Contract FunctionsUsing the abstraction you can easily execute contract functions on the Ethereum network.\n&nbsp;Making a TransactionThere are three functions on the MetaCoin contract that we can execute. If you analyze each of them, you&#39;ll see that sendCoin is the only function that aims to make changes to the network. The goal of sendCoin is to &quot;send&quot; some Meta coins from one account to the next, and these changes should persist.\nWhen calling sendCoin, we&#39;ll execute it as a transaction. In the following example, we&#39;ll send 10 Meta coin from one account to another, in a way that persists changes on the network:\nvar account_one = &quot;0x1234...&quot;; // an address\nvar account_two = &quot;0xabcd...&quot;; // another address\n\nvar meta;\nMetaCoin.deployed().then(function(instance) {\n  meta = instance;\n  return meta.sendCoin(account_two, 10, {from: account_one});\n}).then(function(result) {\n  // If this callback is called, the transaction was successfully processed.\n  alert(&quot;Transaction successful!&quot;)\n}).catch(function(e) {\n  // There was an error! Handle it.\n})\n\nThere are a few things interesting about the above code:\n\nWe called the abstraction&#39;s sendCoin function directly. This will result in a transaction by default (i.e, writing data) instead of call.\nWhen the transaction is successful, the callback function isn&#39;t fired until the transaction is processed. This makes life easy and means you don&#39;t have to check the status of the transaction yourself.\nWe passed an object as the third parameter to sendCoin. Note that the sendCoin function in our Solidity contract doesn&#39;t have a third parameter. What you see above is a special object that can always be passed as the last parameter to a function that lets you edit specific details about the transaction. Here, we set the from address ensuring this transaction came from account_one.\n\n&nbsp;Making a CallContinuing with MetaCoin, notice the getBalance function is a great candidate for reading data from the network. It doesn&#39;t need to make any changes, as it just returns the MetaCoin balance of the address passed to it. Let&#39;s give it a shot:\nvar account_one = &quot;0x1234...&quot;; // an address\n\nvar meta;\nMetaCoin.deployed().then(function(instance) {\n  meta = instance;\n  return meta.getBalance.call(account_one, {from: account_one});\n}).then(function(balance) {\n  // If this callback is called, the call was successfully executed.\n  // Note that this returns immediately without any waiting.\n  // Let&#39;s print the return value.\n  console.log(balance.toNumber());\n}).catch(function(e) {\n  // There was an error! Handle it.\n})\n\nWhat&#39;s interesting here:\n\nWe had to execute the .call() function explicitly to let the Ethereum network know we&#39;re not intending to persist any changes.\nWe received a return value instead of a transaction id on success. Note that since the Ethereum network can handle very large numbers, we&#39;re given a BigNumber object which we then convert to a number.\n\nWarning: We convert the return value to a number because in this example the numbers are small. However, if you try to convert a BigNumber that&#39;s larger than the largest integer supported by Javascript, you&#39;ll likely run into errors or unexpected behavior.\n&nbsp;Catching EventsYour contracts can fire events that you can catch to gain more insight into what your contracts are doing. The easiest way to handle events is by processing the result object of the transaction that triggered the event, like so:\nvar account_one = &quot;0x1234...&quot;; // an address\nvar account_two = &quot;0xabcd...&quot;; // another address\n\nvar meta;\nMetaCoin.deployed().then(function(instance) {\n  meta = instance;  \n  return meta.sendCoin(account_two, 10, {from: account_one});\n}).then(function(result) {\n  // result is an object with the following values:\n  //\n  // result.tx      =&gt; transaction hash, string\n  // result.logs    =&gt; array of decoded events that were triggered within this transaction\n  // result.receipt =&gt; transaction receipt object, which includes gas used\n\n  // We can loop through result.logs to see if we triggered the Transfer event.\n  for (var i = 0; i &lt; result.logs.length; i++) {\n    var log = result.logs[i];\n\n    if (log.event == &quot;Transfer&quot;) {\n      // We found the event!\n      break;\n    }\n  }\n}).catch(function(err) {\n  // There was an error! Handle it.\n});\n\n&nbsp;Add a new contract to the networkIn all of the above cases, we&#39;ve been using a contract abstraction that has already been deployed. We can deploy our own version to the network using the .new() function:\nMetaCoin.new().then(function(instance) {\n  // Print the new address\n  console.log(instance.address);\n}).catch(function(err) {\n  // There was an error! Handle it.\n});\n\n&nbsp;Use a contract at a specific addressIf you already have an address for a contract, you can create a new abstraction to represent the contract at that address.\nvar instance = MetaCoin.at(&quot;0x1234...&quot;);\n\n&nbsp;Sending Ether to a contractYou may simply want to send Ether directly to a contract, or trigger a contract&#39;s fallback function. You can do so using one of the following two options.\nOption 1: Send a transaction directly to a contract via instance.sendTransaction(). This is promisified like all available contract instance functions, and has the same API as web3.eth.sendTransaction but without the callback. The to value will be automatically filled in for you if not specified.\ninstance.sendTransaction({...}).then(function(result) {\n  // Same transaction result object as above.\n});\n\nOption 2: There&#39;s also shorthand for just sending Ether directly:\ninstance.send(web3.toWei(1, &quot;ether&quot;)).then(function(result) {\n  // Same result object as above.\n});\n\n&nbsp;Further ReadingThe contract abstractions provided by Truffle contain a wealth of utilities for making interacting with your contracts easy. Check out the truffle-contract documentation for tips, tricks and insights.\n"},"packages-ethpm":{"id":"packages-ethpm","title":"Package management via EthPM","path":"getting_started/packages-ethpm","content":"&nbsp;EthPM EthPM is the new Package Registry for Ethereum. It follows the ERC190 spec for publishing and consuming smart contract packages, and has gained wide support from many diverse Ethereum development tools. To show our support, we&#39;ve integrated the Ethereum Package Registry directly into Truffle.\n&nbsp;Installing a PackageInstalling a package from EthPM is nearly as easy as installing a package via NPM. You can simply run the following command:\n$ truffle install &lt;package name&gt;\nYou can also install a package at a specific version:\n$ truffle install &lt;package name&gt;@&lt;version&gt;\nLike NPM, EthPM versions follow semver. You can find a list of all available packages at the Ethereum Package Registry.\n&nbsp;Installing DependenciesYour project can define an ethpm.json file that among other things can pin your project to specific dependencies and versions. To install all dependencies listed in the ethpm.json file, run:\n$ truffle install\nFor more details on the ethpm.json file, see the package configuration below.\n&nbsp;Consuming Installed ContractsInstalled packages will be placed in the installed_contracts directory within your project folder. If no installed_contracts directory exists it&#39;ll be created for you. You should treat this folder like you treat the node_modules folder with NPM -- that is, you shouldn&#39;t edit the contents inside unless you know what you&#39;re doing. :)\nInstalled packages can be consumed within your tests, migrations and solidity contract files by import&#39;ing or require&#39;ing that package and contract by name. For example, the following Solidity contract would import the owned.sol file from the owned package:\npragma solidity ^0.4.2;\n\nimport &quot;owned/owned.sol&quot;;\n\ncontract MyContract is owned {\n  // ...\n}\n\nSimilarly, the following migration file would use the ENS.sol contract from the ens package:\nFile: ./migrations/2_deploy_contracts.js\nvar ENS = artifacts.require(&quot;ens/ENS.sol&quot;);\nvar MyContract = artifacts.require(&quot;MyContract.sol&quot;);\n\nmodule.exports = function(deployer) {\n  // Only deploy ENS if there&#39;s not already an address already.\n  // i.e., don&#39;t deploy if we&#39;re using the canonical ENS address,\n  // but do deploy it if we&#39;re on a test network and ENS doesn&#39;t exist.\n  deployer.deploy(ENS, {overwrite: false}).then(function() {\n    return deployer.deploy(MyContract, ENS.address);\n  });\n};\n\nNote that in the migration above, we consume the ens package and deploy the ENS contract conditionally based on whether or not ENS already has an address set. This is a fancy trick provided to you by the deployer that makes it much easier to write migrations dependent on the the existence of network artifacts. In this case, if we were running our migrations on the ropsten network, this migration wouldn&#39;t deploy the ENS contract because (at the time of this writing) roptsen is where the canonical ENS contract exists -- we wouldn&#39;t want to deploy our own. But if we were running our migrations against a different network, or a test network perhaps, then we&#39;d want to deploy the ENS contract so that we have a dependency contract to work with.\n&nbsp;Publishing Your Own PackagePublishing your own package is as straightforward as installing, but like NPM, requires a bit more configuration.\n&nbsp;Ropsten, Ropsten, RopstenThe Ethereum Package Registry currently exists on the Ropsten test network. To publish to the registry, we need to set up our own Ropsten configuration because we&#39;ll be making transactions that need to be signed.\nIn this example, we&#39;ll use Infura for publishing packages along with the truffle-hdwallet-provider NPM module and a 12-word hd-wallet mnemonic that represents our Ethereum address on the Ropsten network. First, install the truffle-hdwallet-provider via NPM within your project directory:\n$ npm install truffle-hdwallet-provider --save\nThen edit your configuration to add the ropsten network using your 12-word mnemonic:\nFile: truffle.js\nvar HDWalletProvider = require(&quot;truffle-hdwallet-provider&quot;);\n\n// 12-word mnemonic\nvar mnemonic = &quot;opinion destroy betray ...&quot;;\n\nmodule.exports = {\n  networks: {\n    development: {\n      host: &quot;localhost&quot;,\n      port: 8545,\n      network_id: &quot;*&quot; // Match any network id\n    },\n    ropsten: {\n      provider: new HDWalletProvider(mnemonic, &quot;https://ropsten.infura.io/&quot;),\n      network_id: 3 // official id of the ropsten network\n    }\n  }\n};\n\n&nbsp;Package configurationLike NPM, configuration options for EthPM go in a separate JSON file called ethpm.json. This file sits alongside your Truffle configuration and gives Truffle all the information it needs to publish your package. You can see a full list of available options in the Configuration section.\nFile: ethpm.json\n{\n  &quot;package_name&quot;: &quot;adder&quot;,\n  &quot;version&quot;: &quot;0.0.3&quot;,\n  &quot;description&quot;: &quot;Simple contract to add two numbers&quot;,\n  &quot;authors&quot;: [\n    &quot;Tim Coulter &lt;tim.coulter@consensys.net&gt;&quot;\n  ],\n  &quot;keywords&quot;: [\n    &quot;ethereum&quot;,\n    &quot;addition&quot;\n  ],\n  &quot;dependencies&quot;: {\n    &quot;owned&quot;: &quot;^0.0.1&quot;\n  },\n  &quot;license&quot;: &quot;MIT&quot;\n}\n\n&nbsp;CommandAfter you have your configuration settled, publishing is a snap:\n$ truffle publish\nYou&#39;ll see output similar to that below, with confirmation that your package was published successfully.\n$ truffle publish\nGathering contracts...\nFinding publishable artifacts...\nUploading sources and publishing to registry...\n+ adder@0.0.3\n&nbsp;Before publishingWhen using a network like the default development network that&#39;s configured to match any Ethereum client (i.e., the TestRPC), you&#39;re bound to have network artifacts laying around that you don&#39;t want published. Before publishing your package, consider running the following command to remove any extraneous network artifacts:\n$ truffle networks --clean\nSee the command reference for more information.\n"},"packages-npm":{"id":"packages-npm","title":"Package management via NPM","path":"getting_started/packages-npm","content":"&nbsp;Package Management Truffle comes standard with npm integration, and is aware of the node_modules directory in your project if it exists. This means you can use and distribute contracts, dapps and Ethereum-enabled libraries via npm, making your code available to others and other&#39;s code available to you.\n&nbsp;Package LayoutProjects created with Truffle have a specific layout by default which enables them to be used as packages. This layout isn&#39;t required, but if used as a common convention -- or &quot;de-facto standard&quot; -- then distributing contracts and dapps through NPM will become much easier.\nThe most important directories in a Truffle package are the following:\n\n/contracts\n/build (which includes /build/contracts, created by Truffle)\n\nThe first directory is your contracts directory, which includes your raw Solidity contracts. The second directory is the build directory, and more specifically /build/contracts, which holds build artifacts in the form of .json files. Including raw contracts in your package will allow others to import those contracts within their own solidity code. Similarly, including your .json build artifacts in your package will allow others to seamlessly interact with your contracts from Javascript, which can be used in dapps, scripts and migrations.\n&nbsp;Using a PackageWhen using a package within your own project, it is important to note that there are two places where you might be interested in using other&#39;s contract code: within your contracts and within your Javascript code (migrations and tests). The following provides an example of each case, and discusses techniques for making the most of other&#39;s contracts and build artifacts.\n&nbsp;InstallingFor this example, we&#39;re going to use the Example Truffle Library, which provides a simple name registry that is deployed to the Morden test network. In order to use it as a dependency, we must first install it within our project through npm:\n$ cd my_project\n$ npm install example-truffle-library\nNote that the last command above downloads the package and places it in my_project/node_modules directory, which is important for the examples below. See the npm documentation for help using npm to install packages.\n&nbsp;Within Your ContractsTo use a package&#39;s contracts within your contracts, this can be as simple as Solidity&#39;s import statement. When your import path isn&#39;t explicitly relative or absolute, this signifies to Truffle that you&#39;re looking for a file from a specific named package. Consider this example using the Example Truffle Library mentioned above:\nimport &quot;example-truffle-library/contracts/SimpleNameRegistry.sol&quot;;\nSince the path didn&#39;t start with ./, Truffle knows to look in your project&#39;s node_modules directory for the example-truffle-library folder. From there, it resolves the path to provide you the contract you requested.\n&nbsp;Within Javascript CodeTo interact with package&#39;s contracts within Javascript code, you simply need to require that package&#39;s .json files, and then use the truffle-contract module to turn those into usable abstractions:\nvar contract = require(&quot;truffle-contract&quot;);\nvar data = require(&quot;example-truffle-library/build/contracts/SimpleNameRegistry.json&quot;);\nvar SimpleNameRegistry = contract(data);\nTo use these abstractions, see the Interacting With Your Contracts section for more details.\n&nbsp;Package&#39;s Deployed AddressesSometimes you want your contracts to interact with the package&#39;s previously deployed contracts. Since the deployed addresses exist within the package&#39;s .json files, you must perform an extra step to get those addresses into your contracts. To do so, make your contract accept the address of the dependency contract, and then use migrations. The following is an example contract that exists within your project as well as an example migration:\nContract: MyContract.sol\npragma solidity ^0.4.13;\n\nimport &quot;example-truffle-library/contracts/SimpleNameRegistry.sol&quot;;\n\ncontract MyContract {\n  SimpleNameRegistry registry;\n  address public owner;\n\n  function MyContract {\n    owner = msg.sender;\n  }\n\n  // Simple example that uses the deployed registry from the package.\n  function getModule(bytes32 name) returns (address) {\n    return registry.names(name);\n  }\n\n  // Set the registry if you&#39;re the owner.\n  function setRegistry(address addr) {\n    require(msg.sender == owner);\n\n    registry = SimpleNameRegistry(addr);\n  }\n}\n\nMigration: 3_hook_up_example_library.js\n// Note that artifacts.require takes care of creating an abstraction for us.\nvar SimpleNameRegistry = artifacts.require(&quot;example-truffle-library/contracts/SimpleNameRegistry.sol&quot;);\n\nmodule.exports = function(deployer) {\n  // Deploy our contract, then set the address of the registry.\n  deployer.deploy(MyContract).then(function() {\n    return MyContract.deployed();\n  }).then(function(deployed) {\n    return deployed.setRegistry(SimpleNameRegistry.address);\n  });\n};\n\n&nbsp;Before publishingWhen using a network like the default development network that&#39;s configured to match any Ethereum client (i.e., the TestRPC), you&#39;re bound to have network artifacts laying around that you don&#39;t want published. Before publishing your package, consider running the following command to remove any extraneous network artifacts:\n$ truffle networks --clean\nSee the command reference for more information.\n\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\n\n  ga('create', 'UA-83874933-1', 'auto');\n  ga('send', 'pageview');\n\n"},"console":{"id":"console","title":"Using the console","path":"getting_started/console","content":"&nbsp;Background Sometimes it&#39;s nice to work with your contracts interactively for testing and debugging purposes, or for executing transactions by hand. Truffle provides you an easy way to do this via an interactive console, with your contracts available and ready to use.\n&nbsp;CommandTo fire up the console, simply run:\n$ truffle console\n\nThis will load up a console using the development network, if specified. You can override this using the --network option. See more details in the Networks section as well as the command reference.\nWhen you load the console, you&#39;ll immediately see output like this:\n$ truffle console\ntruffle(development)&gt;\nThis tells you you&#39;re running within a Truffle console using the development network.\n&nbsp;FeaturesThe console provides all the features available in the Truffle command line tool. For instance, you can type migrate --reset within the console, and it will be interpreted the same as if you ran truffle migrate --reset from outside the console. Truffle&#39;s console additionally has the following features:\n\nAll of your compiled contracts are available and ready for use.\nAfter each command (such as migrate --reset) your contracts are reprovisioned so you can start using the newly assigned addresses and binaries immediately.\nThe web3 library is made available and is set to connect to your Ethereum client.\nAll commands that return a promise will automatically be resolved, and the result printed, removing the need to use .then() for simple commands. e.g.,\n\ntruffle(default)&gt; MyContract.at(&quot;0xabcd...&quot;).getValue.call(); \n5\n"},"scripts":{"id":"scripts","title":"Writing external scripts","path":"getting_started/scripts","content":"&nbsp;Background Often you may want to run external scripts that interact with your contracts. Truffle provides an easy way to do this, bootstrapping your contracts based on your desired network and connecting to your Ethereum client automatically per your project configuration.\n&nbsp;CommandTo run an external script, perform the following:\n$ truffle exec &lt;path/to/file.js&gt;\n&nbsp;File StructureIn order for external scripts to be run correctly, Truffle expects them to export a function that takes a single parameter as a callback:\nmodule.exports = function(callback) {\n  // perform actions\n}\n\nYou can do anything you&#39;d like within this script, so long as the callback is called when the script finishes. The callback accepts an error as its first and only parameter. If an error is provided, execution will halt and the process will return a non-zero exit code.\n"},"build":{"id":"build","title":"Using the build pipeline","path":"getting_started/build","content":"&nbsp;Build Pipeline Truffle 1.0 and 2.0 came standard with a default build system heavily geared toward web applications (here, the term &quot;build&quot; means turning code artifacts into HTML, Javascript and CSS). That build system has been pulled out into its own module to make Truffle usable and extensible for all kinds of applications.\nTruffle can be configured for tight integration with any build system. To configure a custom build system, see the Advanced Build Processes section for more details.\n&nbsp;CommandTo build your application when a build system is configured, run:\n$ truffle build\n\nNote you&#39;ll receive an error if you try to run the build command without first configuring a custom build process.\n\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\n\n  ga('create', 'UA-83874933-1', 'auto');\n  ga('send', 'pageview');\n\n"},"contact":{"id":"contact","title":"Contact the developers","path":"getting_started/contact","content":"&nbsp;Contact Us &nbsp;GitterThe best way to contact us is through Gitter. This allows you to ask questions to both the Truffle developers as well as the community at large.\n\n\n\n  SIGN UP FOR THE TRUFFLE MAILING LIST\n\n  Get news, beta releases and new features straight to your inbox!\n\n  \n    \n      \n        \n          \n          First Name \n            \n          \n          \n            Your Email Address\n            \n          \n          \n          \n          \n        \n      \n    \n  \n  \n\n\n\n"},"configuration":{"id":"configuration","title":"Configuration","path":"advanced/configuration","content":"&nbsp;Location Your configuration file is called truffle.js and is located at the root of your project directory. This file is a Javascript file and can execute any code necessary to create your configuration. It must export an object representing your project configuration like the example below.\nmodule.exports = {\n  networks: {\n    development: {\n      host: &quot;localhost&quot;,\n      port: 8545,\n      network_id: &quot;*&quot; // Match any network id\n    }\n  }\n};\n\nThe default configuration ships with configuration for a single development network, running on localhost:8545. There are many other configuration options, detailed below.\n&nbsp;Resolving naming conflicts on WindowsWhen using the Command Prompt on Windows, the default configuration file name can cause a conflict with the truffle executable, and so you may not be able to run Truffle commands properly on existing projects.\nThis is because of the way that command precedence works on the Command Prompt. The truffle.cmd executable is on the path as part of the npm package, but the truffle.js configuration file is in the actual directory where the truffle command is run. Because .js is an acceptable executable extension by default, truffle.js takes precedence over truffle.cmd, causing unexpected results.\nAny of the following solutions will remedy this issue:\n\nCall the executable file explicitly using its .cmd extension (truffle.cmd compile)\nEdit the system PATHEXT environment variable and remove .JS; from the list of executable extensions\nRename truffle.js to something else (truffle-config.js)\nUse Windows PowerShell or Git BASH, as these shells do not have this conflict.\n\n&nbsp;General Options&nbsp;buildBuild configuration of your application, if your application requires tight integration with Truffle. Most users likely will not need to configure this option. See the Advanced Build Processes section for more details.\n&nbsp;networksSpecifies which networks are available for deployment during migrations, as well as specific transaction parameters when interacting with each network (such as gas price, from address, etc.). When compiling and running migrations on a specific network, contract artifacts will be saved and recorded for later use. When your contract abstractions detect that your Ethereum client is connected to a specific network, they&#39;ll use the contract artifacts associated that network to simplify app deployment. Networks are identified through Ethereum&#39;s net_version RPC call, as well as blockchain URIs.\nThe networks object, shown below, is keyed by a network name and contains a corresponding object that defines the parameters of the network. The networks option is required, as if you have no network configuration, Truffle will not be able to deploy your contracts. The default network configuration provided by truffle init gives you a development network that matches any network it connects to -- this is useful during development, but not suitable for production deployments. To configure Truffle to connect to other networks, simply add more named networks and specify the corresponding network id.\nThe network name is used for user interface purposes, such as when running your migrations on a specific network:\n$ truffle migrate --network live\n\nExample:\nnetworks: {\n  development: {\n    host: &quot;localhost&quot;,\n    port: 8545,\n    network_id: &quot;*&quot; // match any network\n  },\n  live: {\n    host: &quot;178.25.19.88&quot;, // Random IP for example purposes (do not use)\n    port: 80,\n    network_id: 1,        // Ethereum public network\n    // optional config values:\n    // gas\n    // gasPrice\n    // from - default address to use for any transaction Truffle makes during migrations\n    // provider - web3 provider instance Truffle should use to talk to the Ethereum network.\n    //          - if specified, host and port are ignored.\n  }\n}\n\nFor each network, if unspecified, transaction options will default to the following values:\n\ngas: Gas limit used for deploys. Default is 4712388.\ngasPrice: Gas price used for deploys. Default is 100000000000 (100 Shannon).\nfrom: From address used during migrations. Defaults to the first available account provided by your Ethereum client.\nprovider: Default web3 provider using host and port options: new Web3.providers.HttpProvider(&quot;http://&lt;host&gt;:&lt;port&gt;&quot;)\n\n&nbsp;mochaConfiguration options for the MochaJS testing framework. This configuration expects an object as detailed in Mocha&#39;s documentation.\nExample:\nmocha: {\n  useColors: true\n}\n\n&nbsp;Solidity Compiler ConfigurationSolidity compiler settings. Supports optimizer settings for solc.\n&nbsp;solcExample:\nsolc: {\n  optimizer: {\n    enabled: true,\n    runs: 200\n  }\n}\n\n&nbsp;EthPM ConfigurationThis configuration applies to the optional ethpm.json file that exists alongside your truffle.js configuration file.\n&nbsp;package_nameName of the package you&#39;re publishing. Your package name must be unique to the EthPM registry.\nExample:\npackage_name: &quot;adder&quot;\n\n&nbsp;versionVersion of this package, using the semver specification.\nExample:\nversion: &quot;0.0.3&quot;\n\n&nbsp;descriptionA text description of your package for human readers.\nExample:\ndescription: &quot;Simple contract to add two numbers&quot;\n\n&nbsp;authorsAn array of authors. Can have any format, but we recommend the format below.\nExample:\nauthors: [\n  &quot;Tim Coulter &lt;tim.coulter@consensys.net&gt;&quot;\n]\n\n&nbsp;keywordsAn array of keywords that tag this package with helpful categories.\nExample:\nkeywords: [\n  &quot;ethereum&quot;,\n  &quot;addition&quot;\n],\n\n&nbsp;dependenciesA list of EthPM packages your package depends on, using semver version ranges, like npm.\nExample:\ndependencies: {\n  &quot;owned&quot;: &quot;^0.0.1&quot;,\n  &quot;erc20-token&quot;: &quot;1.0.0&quot;\n}\n\n&nbsp;licenseLicense to use for this package. Strictly informative.\nExample:\nlicense: &quot;MIT&quot;,\n\n"},"networks":{"id":"networks","title":"Networks &amp; App Deployment","path":"advanced/networks","content":"&nbsp;Background Even the smallest project will interact with at the very least two blockchains: One on the developer&#39;s machine, like the EthereumJS TestRPC, and the other representing the network where the developer will eventually deploy their application (this could be the public Ethereum network, or a private consortium network, for instance). Truffle provides a system for managing the compilation and deployment artifacts for each network, and does so in a way that simplifies final application deployment.\n&nbsp;ConfigurationSee the Configuration section for more information.\n&nbsp;Specifying a NetworkMost Truffle commands will behave differently based on the network specified, and will use that network&#39;s contracts and configuration. You can specify a network using the --network option, like below:\n$ truffle migrate --network live\n\nIn this example, Truffle will run your migrations on the &quot;live&quot; network, which -- if configured like the example -- is associated with the public Ethereum blockchain.\n&nbsp;Build ArtifactsAs mentioned in the Compiling contracts section, build artifacts are stored in the ./build/contracts directory as .json files. When you compile your contracts or run your migrations using a specific network, Truffle will update those .json files so they contain the information related to that network. When those artifacts are used later -- such as within your frontend or application via truffle-contract -- they&#39;ll automatically detect which network the Ethereum client is connected to and use the correct contract artifacts accordingly.\n&nbsp;Application DeploymentBecause the network is auto-detected by the contract artifacts at runtime, this means that you only need to deploy your application or frontend once. When your application is run, the running Ethereum client will determine which artifacts are used, and this will make your application very flexible. As an example, if you were to deploy a web application to http://mydapp.io, you could navigate to that address using your favorite wallet-browser (like MetaMask, or Mist) and your dapp would work correctly regardless of the Ethereum network the wallet-browser was connected to. If the wallet-browser was connected to the live network, your dapp would use the contracts you deployed on the live network. If on Ropsten, the contracts you deployed to Ropsten would be used.\n"},"build_processes":{"id":"build_processes","title":"Build Processes","path":"advanced/build_processes","content":"&nbsp;Custom Build Processes In order to provide tight integration with Truffle for those that desire it, Truffle allows you to specify a custom build pipeline meant to bootstrap and configure your application. Truffle provides three methods of integration, described below.\n&nbsp;Running an External CommandIf you&#39;d like Truffle to run an external command whenever it triggers a build, simply include that option as a string within your project configuration, like so:\nmodule.exports = {\n  // This will run the `webpack` command on each build.\n  //\n  // The following environment variables will be set when running the command:\n  // WORKING_DIRECTORY: root location of the project\n  // BUILD_DESTINATION_DIRECTORY: expected destination of built assets (important for `truffle serve`)\n  // BUILD_CONTRACTS_DIRECTORY: root location of your build contract files (.sol.js)\n  //\n  build: &quot;webpack&quot;\n}\n\nNote that you&#39;re given ample environment variables with which to integrate with Truffle, detailed above.\n&nbsp;Providing a Custom FunctionYou can also provide a custom build function like the one below. Note you&#39;re given a plethora of information about your project which you can use to integrate tightly with Truffle.\nmodule.exports = {\n  build: function(options, callback) {\n     // Do something when a build is required. `options` contains these values:\n     //\n     // working_directory: root location of the project\n     // contracts_directory: root directory of .sol files\n     // destination_directory: directory where truffle expects the built assets (important for `truffle serve`)\n  }\n}\n\n&nbsp;Creating a Custom ModuleYou could also create a module or object that implements the builder interface (i.e., is an object which contains a build function like the one above). This is great for those who want to maintain tighter integration with Truffle and publish a package to make everyone else&#39;s lives easier.\nHere&#39;s an example using Truffle&#39;s default builder:\nvar DefaultBuilder = require(&quot;truffle-default-builder&quot;);\nmodule.exports = {\n  build: new DefaultBuilder(...) // specify the default builder configuration here.\n}\n\n&nbsp;Bootstrapping Your ApplicationWhether you&#39;re building an application to run in the browser, or a command line tool, a Javascript library or a native mobile application, bootstrapping your contracts is the same, and using your deployed contract artifacts follows the same general process no matter the app you&#39;re building.\nWhen configuring your build tool or application, you&#39;ll need to perform the following steps:\n1) Get all your contract artifacts into your build pipeline / application. This includes all of the .json files within the ./build/contracts directory.\n2) Turn those .json contract artifacts into contract abstractions that are easy to use, via truffle-contract.\n3) Provision those contract abstractions with a Web3 provider. In the browser, this provider might come from Metamask or Mist, but it could also be a custom provider you&#39;ve configured to point to Infura or any other Ethereum client.\n4) Use your contracts!\nIn Node, this is very easy to do. Let&#39;s take a look at an example that shows off the &quot;purest&quot; way of performing the above steps, since it exists outside of any build process or tool.\n// Step 1: Get a contract into my application\nvar json = require(&quot;./build/contracts/MyContract.json&quot;);\n\n// Step 2: Turn that contract into an abstraction I can use\nvar contract = require(&quot;truffle-contract&quot;);\nvar MyContract = contract(json);\n\n// Step 3: Provision the contract with a web3 provider\nMyContract.setProvider(new Web3.providers.HttpProvider(&quot;http://localhost:8545&quot;));\n\n// Step 4: Use the contract!\nMyContract.deployed().then(function(deployed) {\n  return deployed.someFunction();\n});\n\nAll build processes and contract bootstrapping will follow this pattern. The key when setting up your own custom build process is to ensure you&#39;re consuming all of your contract artifacts and provisioning your abstractions correctly.\n"},"commands":{"id":"commands","title":"Command Reference","path":"advanced/commands","content":"&nbsp;Usage $ truffle [command] [options]\n\n&nbsp;Available Commands&nbsp;buildExecute build pipeline (if configuration present)\n$ truffle build\n\nSee the Building your application section for more details.\n&nbsp;consoleRun a console with contract abstractions and commands available.\n$ truffle console\n\nOnce the console starts, you can then use your contracts via the command line like you would in your code. Additionally, all truffle commands listed here are available within the console.\nOptional parameters:\n\n--network name: Specify the network to use.\n--verbose-rpc: Log communication between Truffle and the RPC.\n\nSee the Using the console section for more details.\n&nbsp;compileIntelligently compile your contracts. This will only compile contracts that have changed since the last compile, unless otherwise specified.\n$ truffle compile\n\nOptional parameter:\n\n--all: Compile all contracts instead of intelligently choosing.\n--network name: Specify the network to use, saving artifacts specific to that network.\n\n&nbsp;create contractHelper method to scaffold a new contract. Name must be camel-case.\n$ truffle create contract MyContract\n\n&nbsp;create migrationHelper method to scaffold a new migration. Name must be camel-case.\n$ truffle create migration MyContract\n\n&nbsp;create testHelper method to scaffold a new test for a contract. Name must be camel-case.\n$ truffle create test MyTest\n\n&nbsp;execExecute a Javascript file within the Truffle environment. This will include web3, set the default provider based on the network specified (if any), and include your contracts as global objects while executing the script. Your script must export a function that Truffle can run. See the Writing external scripts section for more details.\n$ truffle exec /path/to/my/script.js\n\nOptional parameter:\n\n--network name: Specify the network to use, using artifacts specific to that network.\n\n&nbsp;initCreate a completely new app within the current working directory. Will add default contracts, tests and frontend configuration.\n$ truffle init\n\n&nbsp;installInstall a package from the Ethereum Package Registry.\n$ truffle install &lt;package name&gt;@&lt;version&gt;\n\nThe @version parameter syntax is optional. See the Package Management with EthPM section for more details.\n&nbsp;migrateRun your project&#39;s migrations. See the Migrations section for more details.\n$ truffle migrate\n\nOptional parameters:\n\n--reset: Run all migrations from the beginning, instead of running from the last completed migration.\n-f number: Run contracts from a specific migration.\n--network name: Specify the network to use, saving artifacts specific to that network.\n--compile-all: Compile all contracts instead of intelligently choosing.\n--verbose-rpc: Log communication between Truffle and the RPC.\n\n&nbsp;networksShow the deployed addresses of all contracts on all networks, and optionally clean extraneous network artifacts.\n$ truffle networks\n\nUse this command before publishing your package to see if there are any extraneous network artifacts you don&#39;t want published. With no options specified, this package will simply output the current artifact state.\nOptional parameters:\n\n--clean: Remove all network artifacts that aren&#39;t associated with a named network.\n\n&nbsp;publishPublish a package to the Ethereum Package Registry.\n$ truffle publish\n\nAll parameters are pulled from your project&#39;s configuration file. See the Package Management with EthPM section for more details.\n&nbsp;serveServe the built app from http://localhost:8080, rebuilding and redeploying changes as needed. Like truffle watch, but with the web server component added.\n$ truffle serve\n\nOptional parameters:\n\n-p port: Specify the port to serve on. Default is 8080.\n--network name: Specify the network to use, using artifacts specific to that network.\n\n&nbsp;testRun all tests within the ./test directory, or optionally run a single test.\n$ truffle test [/path/to/test/file]\n\nOptional parameters:\n\n--compile-all: Compile all contracts instead of intelligently choosing.\n--verbose-rpc: Log communication between Truffle and the RPC.\n--network name: Specify the network to use, using artifacts specific to that network.\n\n&nbsp;versionShow version number and exit.\n$ truffle version\n\n&nbsp;watchWatch for changes to contracts, app and configuration files. When there&#39;s a change, rebuild the app if necessary.\n$ truffle watch\n\n"},"truffle-boxes":{"id":"truffle-boxes","title":"Truffle Boxes","path":"advanced/truffle-boxes","content":"&nbsp;Creating a Box To create a Truffle Box you&#39;ll need a few things:\n\nA GitHub repository\nA configuration file\nOptionally, small and large images for the box&#39;s listing\n\nThe configuration file and images belong in the top-level directory of your repo. With these files in place, and your repo on GitHub, the unbox command will be: truffle unbox {USER_NAME || ORG_NAME}/{REPO_NAME}\nIf you&#39;re starting from scratch, we&#39;ve created a blueprint box containing a configuration file with common values, as well as template versions of the small and large images.\nIf you&#39;re using an existing project, download the files here and extract them into your project.\n&nbsp;Configuration FileAll truffle boxes include a configuration file, truffle-box.json. This file has three attributes: ignore, commands, and hooks.\n&nbsp;ignore (array)An array of files or relative paths you&#39;d like Truffle to ignore when unboxing. Common files include the readme.md or .gitignore.\n&quot;ignore&quot;: [\n  &quot;README.md&quot;,\n  &quot;.gitignore&quot;\n]\n\n&nbsp;commands (object)An object who&#39;s key/value pairs are a descriptor and console command respectively. These pairs will be shown to users once your box is successfully unboxed. Think of these as quick instructions.\nFor example, consider the object below. We&#39;ve given our users all they need to compile, migrate and test their smart contracts, along with commands for developing the front-end.\n&quot;commands&quot;: {\n  &quot;Compile&quot;: &quot;truffle compile&quot;,\n  &quot;Migrate&quot;: &quot;truffle migrate&quot;,\n  &quot;Test contracts&quot;: &quot;truffle test&quot;,\n  &quot;Test dapp&quot;: &quot;npm test&quot;,\n  &quot;Run dev server&quot;: &quot;npm run start&quot;,\n  &quot;Build for production&quot;: &quot;npm run build&quot;\n}\n\n&nbsp;hooks (object)An object containing console commands to execute once unboxed. Since we&#39;re working in Node.js, most commonly this will contain npm install.\n&quot;hooks&quot;: {\n  &quot;post-unpack&quot;: &quot;npm install&quot;\n}\n\n&nbsp;ImagesThe large box image is a 512px square with 32px of padding on each side.\n\nThe small box image is 735px x 100px. There is 32px of padding on the left side of the banner, and it&#39;s minimum size (described in the template as &quot;Min Banner Width&quot;) is 290px, including the left padding. The banners are fixed to the left side and crop off the right side as the window narrows.\n\nIf no images are provided in a box, we default to banners containing the Truffle logo:\n\n\n&nbsp;Truffle Site ListingBefore being listed on the Truffle website, all boxes undergo a screening process to ensure compatibility with Truffle. To start the pre-screening process, send us an email with your desired box name and brief description, along with a link to its GitHub repo to: info@trufflesuite.com.\n"},"truffle-with-metamask":{"id":"truffle-with-metamask","title":"Truffle with MetaMask","path":"advanced/truffle-with-metamask","content":"&nbsp;Accessing Smart Contracts in a Browser To begin interacting with our smart contracts in a browser, first make sure they&#39;re compiled, deployed and that we&#39;re interacting with them via web3 in our client-side JavaScript. We recommend using the truffle-contract library, as it makes interacting with contracts easier and more robust.\nFor more information on these topics, including using truffle-contract, check out our Pet Shop or TutorialToken Tutorials.\n&nbsp;What is MetaMask?MetaMask is the easiest way to start using Dapps in a browser. It is a Chrome extension that connects to the Ethereum network without running a full node on the browser&#39;s machine. It can connect to the Ethereum Main Network; Ropsten, Kovan and Rinkeby testnets; or a local chain such as the TestRPC. For development with Truffle this means we can use our Dapp the same way users will interact with it on a live network.\n&nbsp;Installing MetamaskCurrently, MetaMask only supports Google&#39;s Chrome browser, but support for Firefox and others is planned for the future.\nTo install MetaMask, go to the Chrome Web Store and click the + ADD TO CHROME button.\n&nbsp;Using MetaMask with the TestRPCWith our front-end ready to be used and MetaMask installed, we&#39;re ready to see our Dapp in all its glory. Before diving in though, we&#39;ll need to make sure we&#39;re checking for MetaMask&#39;s web3 instance and the extension itself is configured properly with the TestRPC.\n&nbsp;Detecting MetaMask&#39;s Web3 InjectionMetaMask injects its own web3 instance, so we&#39;ll want to make sure we&#39;re checking for that. After the window as loaded perform the following check:\n// Is there is an injected web3 instance?\nif (typeof web3 !== &#39;undefined&#39;) {\n  App.web3Provider = web3.currentProvider;\n  web3 = new Web3(web3.currentProvider);\n} else {\n  // If no injected web3 instance is detected, fallback to the TestRPC.\n  App.web3Provider = new web3.providers.HttpProvider(&#39;http://localhost:8545&#39;);\n  web3 = new Web3(App.web3Provider);\n}\n\n&nbsp;Using the Browser ExtensionTo use the TestRPC with MetaMask, you&#39;ll need to copy the mnemonic phrase given to you when the TestRPC first starts. From there, click the MetaMask icon in your browser and this screen will appear:\n\n  \n  \n\n\nIf the network in the upper-left is something other than &quot;Private Network&quot;, click it and you&#39;ll see a dropdown of possible networks. Select Localhost 8545 to use the TestRPC. If you&#39;ve set the TestRPC to use a custom port, instead choose Custom RPC and input the full TestRPC URL with port number (for example: localhost:1234).\n\n  \n  \n\n\nNow, you&#39;ll need to get the Mnemonic the TestRPC generated when we first started it up. If you don&#39;t have it, go to the console window running the TestRPC and scroll to the top. You&#39;ll see a heading called HD Wallet and below it Mnemonic. Copy this phrase, then click I forgot my password and paste it in the first field. Now choose a password and click OK.\n\n  \n  \n\n\nNow that we&#39;ve connected MetaMask to the TestRPC, you&#39;ll be take to the accounts screen. Each account created by the TestRPC is given 100 Ether. The first account may have less than the others because that account supplies the gas for smart contract deployment.\nThe plus button below Account 1 will create new accounts, the first 10 of which will correspond to the 10 accounts made by the TestRPC.\n\n  \n  \n\n\nNow that MetaMask is configured, we can start our web server and actually use the Dapp.\n"}}
</script>
<script src="/deps/scripts/lunr.js"></script>
<script src="/scripts/search.js"></script>

          <footer class="container-fluid">
            <p class="text-center">See a way to make this page better? <br class="visible-xs" /><a href="https://github.com/trufflesuite/trufflesuite.github.io/edit/master/_site/public/docs/search.md">Edit here &rarr;</a></p>
          </footer>
        </div>
      </div>
    </div>
  </section>
</section>

    </main>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
<script async defer src="https://buttons.github.io/buttons.js"></script>
<script src="/scripts/main.js"></script>
<script src="/deps/scripts/prism.js"></script>
<script src="/deps/scripts/collapse.js"></script>
<script src="/deps/scripts/dropdown.js"></script>
<script src="/deps/scripts/lunr.js"></script>
<script src="/scripts/navbar.js"></script>

    
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-83874933-3', 'auto');
    ga('send', 'pageview');
  </script>

  </body>
</html>
